// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImGui.Backends
{
	public unsafe partial class ImGuiBackends
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCurrentContextNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[0])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[0])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentContext(ImGuiContext* ctx)
		{
			SetCurrentContextNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetCurrentContextNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiContext* GetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*>)funcTable[1])();
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContext* GetCurrentContext()
		{
			ImGuiContext* ret = GetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplWin32InitNative(void* hwnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, byte>)funcTable[2])(hwnd);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[2])((nint)hwnd);
			#endif
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplWin32Init(void* hwnd)
		{
			byte ret = ImplWin32InitNative(hwnd);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplWin32InitForOpenGLNative(void* hwnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, byte>)funcTable[3])(hwnd);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[3])((nint)hwnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplWin32InitForOpenGL(void* hwnd)
		{
			byte ret = ImplWin32InitForOpenGLNative(hwnd);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplWin32ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[4])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[4])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplWin32Shutdown()
		{
			ImplWin32ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplWin32NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[5])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[5])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplWin32NewFrame()
		{
			ImplWin32NewFrameNative();
		}

		/// <summary>
		/// DPI-related helpers (optional)<br/>
		/// - Use to enable DPI awareness without having to create an application manifest.<br/>
		/// - Your own app may already do this via a manifest or explicit calls. This is mostly useful for our examples/ apps.<br/>
		/// - In theory we could call simple functions from Windows SDK such as SetProcessDPIAware(), SetProcessDpiAwareness(), etc.<br/>
		/// but most of the functions provided by Microsoft require Windows 8.1/10+ SDK at compile time and Windows 8/10+ at runtime,<br/>
		/// neither we want to require the user to have. So we dynamically select and load those functions to avoid dependencies.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplWin32EnableDpiAwarenessNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[6])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[6])();
			#endif
		}

		/// <summary>
		/// DPI-related helpers (optional)<br/>
		/// - Use to enable DPI awareness without having to create an application manifest.<br/>
		/// - Your own app may already do this via a manifest or explicit calls. This is mostly useful for our examples/ apps.<br/>
		/// - In theory we could call simple functions from Windows SDK such as SetProcessDPIAware(), SetProcessDpiAwareness(), etc.<br/>
		/// but most of the functions provided by Microsoft require Windows 8.1/10+ SDK at compile time and Windows 8/10+ at runtime,<br/>
		/// neither we want to require the user to have. So we dynamically select and load those functions to avoid dependencies.<br/>
		/// </summary>
		public static void ImplWin32EnableDpiAwareness()
		{
			ImplWin32EnableDpiAwarenessNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImplWin32GetDpiScaleForHwndNative(void* hwnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, float>)funcTable[7])(hwnd);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[7])((nint)hwnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImplWin32GetDpiScaleForHwnd(void* hwnd)
		{
			float ret = ImplWin32GetDpiScaleForHwndNative(hwnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImplWin32GetDpiScaleForMonitorNative(void* monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, float>)funcTable[8])(monitor);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[8])((nint)monitor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImplWin32GetDpiScaleForMonitor(void* monitor)
		{
			float ret = ImplWin32GetDpiScaleForMonitorNative(monitor);
			return ret;
		}

		/// <summary>
		/// Transparency related helpers (optional) [experimental]<br/>
		/// - Use to enable alpha compositing transparency with the desktop.<br/>
		/// - Use together with e.g. clearing your framebuffer with zero-alpha.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplWin32EnableAlphaCompositingNative(void* hwnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[9])(hwnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[9])((nint)hwnd);
			#endif
		}

		/// <summary>
		/// Transparency related helpers (optional) [experimental]<br/>
		/// - Use to enable alpha compositing transparency with the desktop.<br/>
		/// - Use together with e.g. clearing your framebuffer with zero-alpha.<br/>
		/// </summary>
		public static void ImplWin32EnableAlphaCompositing(void* hwnd)
		{
			ImplWin32EnableAlphaCompositingNative(hwnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplGlfwInitForOpenGLNative(GLFWwindow* window, byte installCallbacks)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, byte, byte>)funcTable[10])(window, installCallbacks);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[10])((nint)window, installCallbacks);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplGlfwInitForOpenGL(GLFWwindowPtr window, bool installCallbacks)
		{
			byte ret = ImplGlfwInitForOpenGLNative(window, installCallbacks ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplGlfwInitForOpenGL(ref GLFWwindow window, bool installCallbacks)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				byte ret = ImplGlfwInitForOpenGLNative((GLFWwindow*)pwindow, installCallbacks ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplGlfwInitForVulkanNative(GLFWwindow* window, byte installCallbacks)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, byte, byte>)funcTable[11])(window, installCallbacks);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[11])((nint)window, installCallbacks);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplGlfwInitForVulkan(GLFWwindowPtr window, bool installCallbacks)
		{
			byte ret = ImplGlfwInitForVulkanNative(window, installCallbacks ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplGlfwInitForVulkan(ref GLFWwindow window, bool installCallbacks)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				byte ret = ImplGlfwInitForVulkanNative((GLFWwindow*)pwindow, installCallbacks ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplGlfwInitForOtherNative(GLFWwindow* window, byte installCallbacks)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, byte, byte>)funcTable[12])(window, installCallbacks);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[12])((nint)window, installCallbacks);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplGlfwInitForOther(GLFWwindowPtr window, bool installCallbacks)
		{
			byte ret = ImplGlfwInitForOtherNative(window, installCallbacks ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplGlfwInitForOther(ref GLFWwindow window, bool installCallbacks)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				byte ret = ImplGlfwInitForOtherNative((GLFWwindow*)pwindow, installCallbacks ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[13])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[13])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwShutdown()
		{
			ImplGlfwShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwNewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[14])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[14])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwNewFrame()
		{
			ImplGlfwNewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwInstallCallbacksNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, void>)funcTable[15])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[15])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwInstallCallbacks(GLFWwindowPtr window)
		{
			ImplGlfwInstallCallbacksNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwInstallCallbacks(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwInstallCallbacksNative((GLFWwindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwRestoreCallbacksNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, void>)funcTable[16])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[16])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwRestoreCallbacks(GLFWwindowPtr window)
		{
			ImplGlfwRestoreCallbacksNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwRestoreCallbacks(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwRestoreCallbacksNative((GLFWwindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwSetCallbacksChainForAllWindowsNative(byte chainForAllWindows)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[17])(chainForAllWindows);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[17])(chainForAllWindows);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwSetCallbacksChainForAllWindows(bool chainForAllWindows)
		{
			ImplGlfwSetCallbacksChainForAllWindowsNative(chainForAllWindows ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwWindowFocusCallbackNative(GLFWwindow* window, int focused)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, int, void>)funcTable[18])(window, focused);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[18])((nint)window, focused);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwWindowFocusCallback(GLFWwindowPtr window, int focused)
		{
			ImplGlfwWindowFocusCallbackNative(window, focused);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwWindowFocusCallback(ref GLFWwindow window, int focused)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwWindowFocusCallbackNative((GLFWwindow*)pwindow, focused);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwCursorEnterCallbackNative(GLFWwindow* window, int entered)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, int, void>)funcTable[19])(window, entered);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[19])((nint)window, entered);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwCursorEnterCallback(GLFWwindowPtr window, int entered)
		{
			ImplGlfwCursorEnterCallbackNative(window, entered);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwCursorEnterCallback(ref GLFWwindow window, int entered)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwCursorEnterCallbackNative((GLFWwindow*)pwindow, entered);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwCursorPosCallbackNative(GLFWwindow* window, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, double, double, void>)funcTable[20])(window, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, double, double, void>)funcTable[20])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwCursorPosCallback(GLFWwindowPtr window, double x, double y)
		{
			ImplGlfwCursorPosCallbackNative(window, x, y);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwCursorPosCallback(ref GLFWwindow window, double x, double y)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwCursorPosCallbackNative((GLFWwindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwMouseButtonCallbackNative(GLFWwindow* window, int button, int action, int mods)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, int, int, int, void>)funcTable[21])(window, button, action, mods);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, int, void>)funcTable[21])((nint)window, button, action, mods);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwMouseButtonCallback(GLFWwindowPtr window, int button, int action, int mods)
		{
			ImplGlfwMouseButtonCallbackNative(window, button, action, mods);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwMouseButtonCallback(ref GLFWwindow window, int button, int action, int mods)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwMouseButtonCallbackNative((GLFWwindow*)pwindow, button, action, mods);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwScrollCallbackNative(GLFWwindow* window, double xoffset, double yoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, double, double, void>)funcTable[22])(window, xoffset, yoffset);
			#else
			((delegate* unmanaged[Cdecl]<nint, double, double, void>)funcTable[22])((nint)window, xoffset, yoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwScrollCallback(GLFWwindowPtr window, double xoffset, double yoffset)
		{
			ImplGlfwScrollCallbackNative(window, xoffset, yoffset);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwScrollCallback(ref GLFWwindow window, double xoffset, double yoffset)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwScrollCallbackNative((GLFWwindow*)pwindow, xoffset, yoffset);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwKeyCallbackNative(GLFWwindow* window, int key, int scancode, int action, int mods)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, int, int, int, int, void>)funcTable[23])(window, key, scancode, action, mods);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, int, int, void>)funcTable[23])((nint)window, key, scancode, action, mods);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwKeyCallback(GLFWwindowPtr window, int key, int scancode, int action, int mods)
		{
			ImplGlfwKeyCallbackNative(window, key, scancode, action, mods);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwKeyCallback(ref GLFWwindow window, int key, int scancode, int action, int mods)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwKeyCallbackNative((GLFWwindow*)pwindow, key, scancode, action, mods);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwCharCallbackNative(GLFWwindow* window, uint c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, uint, void>)funcTable[24])(window, c);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[24])((nint)window, c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwCharCallback(GLFWwindowPtr window, uint c)
		{
			ImplGlfwCharCallbackNative(window, c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwCharCallback(ref GLFWwindow window, uint c)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				ImplGlfwCharCallbackNative((GLFWwindow*)pwindow, c);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwMonitorCallbackNative(GLFWmonitor* monitor, int evnt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWmonitor*, int, void>)funcTable[25])(monitor, evnt);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[25])((nint)monitor, evnt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwMonitorCallback(GLFWmonitorPtr monitor, int evnt)
		{
			ImplGlfwMonitorCallbackNative(monitor, evnt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwMonitorCallback(ref GLFWmonitor monitor, int evnt)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				ImplGlfwMonitorCallbackNative((GLFWmonitor*)pmonitor, evnt);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplGlfwSleepNative(int milliseconds)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[26])(milliseconds);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[26])(milliseconds);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplGlfwSleep(int milliseconds)
		{
			ImplGlfwSleepNative(milliseconds);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDL2InitForOpenGLNative(SDLWindow* window, void* sdlGlContext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, void*, byte>)funcTable[27])(window, sdlGlContext);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[27])((nint)window, (nint)sdlGlContext);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForOpenGL(SDLWindowPtr window, void* sdlGlContext)
		{
			byte ret = ImplSDL2InitForOpenGLNative(window, sdlGlContext);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForOpenGL(ref SDLWindow window, void* sdlGlContext)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ImplSDL2InitForOpenGLNative((SDLWindow*)pwindow, sdlGlContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDL2InitForVulkanNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[28])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[28])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForVulkan(SDLWindowPtr window)
		{
			byte ret = ImplSDL2InitForVulkanNative(window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForVulkan(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ImplSDL2InitForVulkanNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDL2InitForD3DNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[29])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[29])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForD3D(SDLWindowPtr window)
		{
			byte ret = ImplSDL2InitForD3DNative(window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForD3D(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ImplSDL2InitForD3DNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDL2InitForMetalNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[30])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[30])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForMetal(SDLWindowPtr window)
		{
			byte ret = ImplSDL2InitForMetalNative(window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForMetal(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ImplSDL2InitForMetalNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDL2InitForSDLRendererNative(SDLWindow* window, SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRenderer*, byte>)funcTable[31])(window, renderer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[31])((nint)window, (nint)renderer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForSDLRenderer(SDLWindowPtr window, SDLRendererPtr renderer)
		{
			byte ret = ImplSDL2InitForSDLRendererNative(window, renderer);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForSDLRenderer(ref SDLWindow window, SDLRendererPtr renderer)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ImplSDL2InitForSDLRendererNative((SDLWindow*)pwindow, renderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForSDLRenderer(SDLWindowPtr window, ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = ImplSDL2InitForSDLRendererNative(window, (SDLRenderer*)prenderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForSDLRenderer(ref SDLWindow window, ref SDLRenderer renderer)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRenderer* prenderer = &renderer)
				{
					byte ret = ImplSDL2InitForSDLRendererNative((SDLWindow*)pwindow, (SDLRenderer*)prenderer);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDL2InitForOtherNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[32])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[32])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForOther(SDLWindowPtr window)
		{
			byte ret = ImplSDL2InitForOtherNative(window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2InitForOther(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ImplSDL2InitForOtherNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplSDL2ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[33])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[33])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDL2Shutdown()
		{
			ImplSDL2ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplSDL2NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[34])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[34])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDL2NewFrame()
		{
			ImplSDL2NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDL2ProcessEventNative(SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, byte>)funcTable[35])(evnt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[35])((nint)evnt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2ProcessEvent(SDLEventPtr evnt)
		{
			byte ret = ImplSDL2ProcessEventNative(evnt);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDL2ProcessEvent(ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				byte ret = ImplSDL2ProcessEventNative((SDLEvent*)pevnt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplSDL2SetGamepadModeNative(ImGuiImplSDL2GamepadMode mode, SDLGameController** manualGamepadsArray, int manualGamepadsCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiImplSDL2GamepadMode, SDLGameController**, int, void>)funcTable[36])(mode, manualGamepadsArray, manualGamepadsCount);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiImplSDL2GamepadMode, nint, int, void>)funcTable[36])(mode, (nint)manualGamepadsArray, manualGamepadsCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDL2SetGamepadMode(ImGuiImplSDL2GamepadMode mode, SDLGameControllerPtrPtr manualGamepadsArray, int manualGamepadsCount)
		{
			ImplSDL2SetGamepadModeNative(mode, manualGamepadsArray, manualGamepadsCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDL2SetGamepadMode(ImGuiImplSDL2GamepadMode mode, ref SDLGameController* manualGamepadsArray, int manualGamepadsCount)
		{
			fixed (SDLGameController** pmanualGamepadsArray = &manualGamepadsArray)
			{
				ImplSDL2SetGamepadModeNative(mode, (SDLGameController**)pmanualGamepadsArray, manualGamepadsCount);
			}
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDLRenderer2InitNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte>)funcTable[37])(renderer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[37])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplSDLRenderer2Init(SDLRendererPtr renderer)
		{
			byte ret = ImplSDLRenderer2InitNative(renderer);
			return ret != 0;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplSDLRenderer2Init(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = ImplSDLRenderer2InitNative((SDLRenderer*)prenderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplSDLRenderer2ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[38])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[38])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDLRenderer2Shutdown()
		{
			ImplSDLRenderer2ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplSDLRenderer2NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[39])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[39])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDLRenderer2NewFrame()
		{
			ImplSDLRenderer2NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplSDLRenderer2RenderDrawDataNative(ImDrawData* drawData, SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, SDLRenderer*, void>)funcTable[40])(drawData, renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[40])((nint)drawData, (nint)renderer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDLRenderer2RenderDrawData(ImDrawData* drawData, SDLRendererPtr renderer)
		{
			ImplSDLRenderer2RenderDrawDataNative(drawData, renderer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDLRenderer2RenderDrawData(ref ImDrawData drawData, SDLRendererPtr renderer)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				ImplSDLRenderer2RenderDrawDataNative((ImDrawData*)pdrawData, renderer);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDLRenderer2RenderDrawData(ImDrawData* drawData, ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				ImplSDLRenderer2RenderDrawDataNative(drawData, (SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDLRenderer2RenderDrawData(ref ImDrawData drawData, ref SDLRenderer renderer)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (SDLRenderer* prenderer = &renderer)
				{
					ImplSDLRenderer2RenderDrawDataNative((ImDrawData*)pdrawData, (SDLRenderer*)prenderer);
				}
			}
		}

		/// <summary>
		/// Called by Init/NewFrame/Shutdown<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDLRenderer2CreateFontsTextureNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[41])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[41])();
			#endif
		}

		/// <summary>
		/// Called by Init/NewFrame/Shutdown<br/>
		/// </summary>
		public static bool ImplSDLRenderer2CreateFontsTexture()
		{
			byte ret = ImplSDLRenderer2CreateFontsTextureNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplSDLRenderer2DestroyFontsTextureNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[42])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[42])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDLRenderer2DestroyFontsTexture()
		{
			ImplSDLRenderer2DestroyFontsTextureNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplSDLRenderer2CreateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[43])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[43])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplSDLRenderer2CreateDeviceObjects()
		{
			byte ret = ImplSDLRenderer2CreateDeviceObjectsNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplSDLRenderer2DestroyDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[44])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[44])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplSDLRenderer2DestroyDeviceObjects()
		{
			ImplSDLRenderer2DestroyDeviceObjectsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplOpenGL3InitNative(byte* glslVersion)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[45])(glslVersion);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[45])((nint)glslVersion);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL3Init(byte* glslVersion)
		{
			byte ret = ImplOpenGL3InitNative(glslVersion);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL3Init(ref byte glslVersion)
		{
			fixed (byte* pglslVersion = &glslVersion)
			{
				byte ret = ImplOpenGL3InitNative((byte*)pglslVersion);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL3Init(ReadOnlySpan<byte> glslVersion)
		{
			fixed (byte* pglslVersion = glslVersion)
			{
				byte ret = ImplOpenGL3InitNative((byte*)pglslVersion);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL3Init(string glslVersion)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (glslVersion != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(glslVersion);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(glslVersion, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImplOpenGL3InitNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL3ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[46])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[46])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL3Shutdown()
		{
			ImplOpenGL3ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL3NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[47])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[47])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL3NewFrame()
		{
			ImplOpenGL3NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL3RenderDrawDataNative(ImDrawData* drawData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, void>)funcTable[48])(drawData);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[48])((nint)drawData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL3RenderDrawData(ImDrawData* drawData)
		{
			ImplOpenGL3RenderDrawDataNative(drawData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL3RenderDrawData(ref ImDrawData drawData)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				ImplOpenGL3RenderDrawDataNative((ImDrawData*)pdrawData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplOpenGL3CreateFontsTextureNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[49])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[49])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL3CreateFontsTexture()
		{
			byte ret = ImplOpenGL3CreateFontsTextureNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL3DestroyFontsTextureNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[50])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[50])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL3DestroyFontsTexture()
		{
			ImplOpenGL3DestroyFontsTextureNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplOpenGL3CreateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[51])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[51])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL3CreateDeviceObjects()
		{
			byte ret = ImplOpenGL3CreateDeviceObjectsNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL3DestroyDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[52])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[52])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL3DestroyDeviceObjects()
		{
			ImplOpenGL3DestroyDeviceObjectsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplOpenGL2InitNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[53])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[53])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL2Init()
		{
			byte ret = ImplOpenGL2InitNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL2ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[54])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[54])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL2Shutdown()
		{
			ImplOpenGL2ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL2NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[55])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[55])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL2NewFrame()
		{
			ImplOpenGL2NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL2RenderDrawDataNative(ImDrawData* drawData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, void>)funcTable[56])(drawData);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[56])((nint)drawData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL2RenderDrawData(ImDrawData* drawData)
		{
			ImplOpenGL2RenderDrawDataNative(drawData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL2RenderDrawData(ref ImDrawData drawData)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				ImplOpenGL2RenderDrawDataNative((ImDrawData*)pdrawData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplOpenGL2CreateFontsTextureNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[57])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[57])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL2CreateFontsTexture()
		{
			byte ret = ImplOpenGL2CreateFontsTextureNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL2DestroyFontsTextureNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[58])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[58])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL2DestroyFontsTexture()
		{
			ImplOpenGL2DestroyFontsTextureNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplOpenGL2CreateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[59])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[59])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplOpenGL2CreateDeviceObjects()
		{
			byte ret = ImplOpenGL2CreateDeviceObjectsNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplOpenGL2DestroyDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[60])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[60])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplOpenGL2DestroyDeviceObjects()
		{
			ImplOpenGL2DestroyDeviceObjectsNative();
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplDX11InitNative(ID3D11Device* device, ID3D11DeviceContext* deviceContext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ID3D11Device*, ID3D11DeviceContext*, byte>)funcTable[61])(device, deviceContext);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[61])((nint)device, (nint)deviceContext);
			#endif
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplDX11Init(ID3D11DevicePtr device, ID3D11DeviceContextPtr deviceContext)
		{
			byte ret = ImplDX11InitNative(device, deviceContext);
			return ret != 0;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplDX11Init(ref ID3D11Device device, ID3D11DeviceContextPtr deviceContext)
		{
			fixed (ID3D11Device* pdevice = &device)
			{
				byte ret = ImplDX11InitNative((ID3D11Device*)pdevice, deviceContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplDX11Init(ID3D11DevicePtr device, ref ID3D11DeviceContext deviceContext)
		{
			fixed (ID3D11DeviceContext* pdeviceContext = &deviceContext)
			{
				byte ret = ImplDX11InitNative(device, (ID3D11DeviceContext*)pdeviceContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplDX11Init(ref ID3D11Device device, ref ID3D11DeviceContext deviceContext)
		{
			fixed (ID3D11Device* pdevice = &device)
			{
				fixed (ID3D11DeviceContext* pdeviceContext = &deviceContext)
				{
					byte ret = ImplDX11InitNative((ID3D11Device*)pdevice, (ID3D11DeviceContext*)pdeviceContext);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplDX11ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[62])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[62])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX11Shutdown()
		{
			ImplDX11ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplDX11NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[63])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[63])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX11NewFrame()
		{
			ImplDX11NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplDX11RenderDrawDataNative(ImDrawData* drawData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, void>)funcTable[64])(drawData);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[64])((nint)drawData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX11RenderDrawData(ImDrawData* drawData)
		{
			ImplDX11RenderDrawDataNative(drawData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX11RenderDrawData(ref ImDrawData drawData)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				ImplDX11RenderDrawDataNative((ImDrawData*)pdrawData);
			}
		}

		/// <summary>
		/// Use if you want to reset your rendering device without losing Dear ImGui state.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplDX11InvalidateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[65])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[65])();
			#endif
		}

		/// <summary>
		/// Use if you want to reset your rendering device without losing Dear ImGui state.<br/>
		/// </summary>
		public static void ImplDX11InvalidateDeviceObjects()
		{
			ImplDX11InvalidateDeviceObjectsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplDX11CreateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[66])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[66])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplDX11CreateDeviceObjects()
		{
			byte ret = ImplDX11CreateDeviceObjectsNative();
			return ret != 0;
		}

		/// <summary>
		/// cmd_list is the command list that the implementation will use to render imgui draw lists.<br/>
		/// Before calling the render function, caller must prepare cmd_list by resetting it and setting the appropriate<br/>
		/// render target and descriptor heap that contains font_srv_cpu_desc_handle/font_srv_gpu_desc_handle.<br/>
		/// font_srv_cpu_desc_handle and font_srv_gpu_desc_handle are handles to a single SRV descriptor to use for the internal font texture.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplDX12InitNative(ID3D12Device* device, int numFramesInFlight, uint rtvFormat, ID3D12DescriptorHeap* cbvSrvHeap, D3D12CpuDescriptorHandle fontSrvCpuDescHandle, D3D12GpuDescriptorHandle fontSrvGpuDescHandle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ID3D12Device*, int, uint, ID3D12DescriptorHeap*, D3D12CpuDescriptorHandle, D3D12GpuDescriptorHandle, byte>)funcTable[67])(device, numFramesInFlight, rtvFormat, cbvSrvHeap, fontSrvCpuDescHandle, fontSrvGpuDescHandle);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, uint, nint, D3D12CpuDescriptorHandle, D3D12GpuDescriptorHandle, byte>)funcTable[67])((nint)device, numFramesInFlight, rtvFormat, (nint)cbvSrvHeap, fontSrvCpuDescHandle, fontSrvGpuDescHandle);
			#endif
		}

		/// <summary>
		/// cmd_list is the command list that the implementation will use to render imgui draw lists.<br/>
		/// Before calling the render function, caller must prepare cmd_list by resetting it and setting the appropriate<br/>
		/// render target and descriptor heap that contains font_srv_cpu_desc_handle/font_srv_gpu_desc_handle.<br/>
		/// font_srv_cpu_desc_handle and font_srv_gpu_desc_handle are handles to a single SRV descriptor to use for the internal font texture.<br/>
		/// </summary>
		public static bool ImplDX12Init(ID3D12DevicePtr device, int numFramesInFlight, uint rtvFormat, ID3D12DescriptorHeapPtr cbvSrvHeap, D3D12CpuDescriptorHandle fontSrvCpuDescHandle, D3D12GpuDescriptorHandle fontSrvGpuDescHandle)
		{
			byte ret = ImplDX12InitNative(device, numFramesInFlight, rtvFormat, cbvSrvHeap, fontSrvCpuDescHandle, fontSrvGpuDescHandle);
			return ret != 0;
		}

		/// <summary>
		/// cmd_list is the command list that the implementation will use to render imgui draw lists.<br/>
		/// Before calling the render function, caller must prepare cmd_list by resetting it and setting the appropriate<br/>
		/// render target and descriptor heap that contains font_srv_cpu_desc_handle/font_srv_gpu_desc_handle.<br/>
		/// font_srv_cpu_desc_handle and font_srv_gpu_desc_handle are handles to a single SRV descriptor to use for the internal font texture.<br/>
		/// </summary>
		public static bool ImplDX12Init(ref ID3D12Device device, int numFramesInFlight, uint rtvFormat, ID3D12DescriptorHeapPtr cbvSrvHeap, D3D12CpuDescriptorHandle fontSrvCpuDescHandle, D3D12GpuDescriptorHandle fontSrvGpuDescHandle)
		{
			fixed (ID3D12Device* pdevice = &device)
			{
				byte ret = ImplDX12InitNative((ID3D12Device*)pdevice, numFramesInFlight, rtvFormat, cbvSrvHeap, fontSrvCpuDescHandle, fontSrvGpuDescHandle);
				return ret != 0;
			}
		}

		/// <summary>
		/// cmd_list is the command list that the implementation will use to render imgui draw lists.<br/>
		/// Before calling the render function, caller must prepare cmd_list by resetting it and setting the appropriate<br/>
		/// render target and descriptor heap that contains font_srv_cpu_desc_handle/font_srv_gpu_desc_handle.<br/>
		/// font_srv_cpu_desc_handle and font_srv_gpu_desc_handle are handles to a single SRV descriptor to use for the internal font texture.<br/>
		/// </summary>
		public static bool ImplDX12Init(ID3D12DevicePtr device, int numFramesInFlight, uint rtvFormat, ref ID3D12DescriptorHeap cbvSrvHeap, D3D12CpuDescriptorHandle fontSrvCpuDescHandle, D3D12GpuDescriptorHandle fontSrvGpuDescHandle)
		{
			fixed (ID3D12DescriptorHeap* pcbvSrvHeap = &cbvSrvHeap)
			{
				byte ret = ImplDX12InitNative(device, numFramesInFlight, rtvFormat, (ID3D12DescriptorHeap*)pcbvSrvHeap, fontSrvCpuDescHandle, fontSrvGpuDescHandle);
				return ret != 0;
			}
		}

		/// <summary>
		/// cmd_list is the command list that the implementation will use to render imgui draw lists.<br/>
		/// Before calling the render function, caller must prepare cmd_list by resetting it and setting the appropriate<br/>
		/// render target and descriptor heap that contains font_srv_cpu_desc_handle/font_srv_gpu_desc_handle.<br/>
		/// font_srv_cpu_desc_handle and font_srv_gpu_desc_handle are handles to a single SRV descriptor to use for the internal font texture.<br/>
		/// </summary>
		public static bool ImplDX12Init(ref ID3D12Device device, int numFramesInFlight, uint rtvFormat, ref ID3D12DescriptorHeap cbvSrvHeap, D3D12CpuDescriptorHandle fontSrvCpuDescHandle, D3D12GpuDescriptorHandle fontSrvGpuDescHandle)
		{
			fixed (ID3D12Device* pdevice = &device)
			{
				fixed (ID3D12DescriptorHeap* pcbvSrvHeap = &cbvSrvHeap)
				{
					byte ret = ImplDX12InitNative((ID3D12Device*)pdevice, numFramesInFlight, rtvFormat, (ID3D12DescriptorHeap*)pcbvSrvHeap, fontSrvCpuDescHandle, fontSrvGpuDescHandle);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplDX12ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[68])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[68])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX12Shutdown()
		{
			ImplDX12ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplDX12NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[69])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[69])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX12NewFrame()
		{
			ImplDX12NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplDX12RenderDrawDataNative(ImDrawData* drawData, ID3D12GraphicsCommandList* graphicsCommandList)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, ID3D12GraphicsCommandList*, void>)funcTable[70])(drawData, graphicsCommandList);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[70])((nint)drawData, (nint)graphicsCommandList);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX12RenderDrawData(ImDrawData* drawData, ID3D12GraphicsCommandListPtr graphicsCommandList)
		{
			ImplDX12RenderDrawDataNative(drawData, graphicsCommandList);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX12RenderDrawData(ref ImDrawData drawData, ID3D12GraphicsCommandListPtr graphicsCommandList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				ImplDX12RenderDrawDataNative((ImDrawData*)pdrawData, graphicsCommandList);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX12RenderDrawData(ImDrawData* drawData, ref ID3D12GraphicsCommandList graphicsCommandList)
		{
			fixed (ID3D12GraphicsCommandList* pgraphicsCommandList = &graphicsCommandList)
			{
				ImplDX12RenderDrawDataNative(drawData, (ID3D12GraphicsCommandList*)pgraphicsCommandList);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplDX12RenderDrawData(ref ImDrawData drawData, ref ID3D12GraphicsCommandList graphicsCommandList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (ID3D12GraphicsCommandList* pgraphicsCommandList = &graphicsCommandList)
				{
					ImplDX12RenderDrawDataNative((ImDrawData*)pdrawData, (ID3D12GraphicsCommandList*)pgraphicsCommandList);
				}
			}
		}

		/// <summary>
		/// Use if you want to reset your rendering device without losing Dear ImGui state.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplDX12InvalidateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[71])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[71])();
			#endif
		}

		/// <summary>
		/// Use if you want to reset your rendering device without losing Dear ImGui state.<br/>
		/// </summary>
		public static void ImplDX12InvalidateDeviceObjects()
		{
			ImplDX12InvalidateDeviceObjectsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplDX12CreateDeviceObjectsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[72])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[72])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplDX12CreateDeviceObjects()
		{
			byte ret = ImplDX12CreateDeviceObjectsNative();
			return ret != 0;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplVulkanInitNative(ImGuiImplVulkanInitInfo* info)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiImplVulkanInitInfo*, byte>)funcTable[73])(info);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[73])((nint)info);
			#endif
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplVulkanInit(ImGuiImplVulkanInitInfoPtr info)
		{
			byte ret = ImplVulkanInitNative(info);
			return ret != 0;
		}

		/// <summary>
		/// Follow "Getting Started" link and check examples/ folder to learn about using backends!<br/>
		/// </summary>
		public static bool ImplVulkanInit(ref ImGuiImplVulkanInitInfo info)
		{
			fixed (ImGuiImplVulkanInitInfo* pinfo = &info)
			{
				byte ret = ImplVulkanInitNative((ImGuiImplVulkanInitInfo*)pinfo);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplVulkanShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[74])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[74])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanShutdown()
		{
			ImplVulkanShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplVulkanNewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[75])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[75])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanNewFrame()
		{
			ImplVulkanNewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplVulkanRenderDrawDataNative(ImDrawData* drawData, VkCommandBuffer commandBuffer, VkPipeline pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, VkCommandBuffer, VkPipeline, void>)funcTable[76])(drawData, commandBuffer, pipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, VkCommandBuffer, VkPipeline, void>)funcTable[76])((nint)drawData, commandBuffer, pipeline);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanRenderDrawData(ImDrawData* drawData, VkCommandBuffer commandBuffer, VkPipeline pipeline)
		{
			ImplVulkanRenderDrawDataNative(drawData, commandBuffer, pipeline);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanRenderDrawData(ref ImDrawData drawData, VkCommandBuffer commandBuffer, VkPipeline pipeline)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				ImplVulkanRenderDrawDataNative((ImDrawData*)pdrawData, commandBuffer, pipeline);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplVulkanCreateFontsTextureNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[77])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[77])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImplVulkanCreateFontsTexture()
		{
			byte ret = ImplVulkanCreateFontsTextureNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplVulkanDestroyFontsTextureNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[78])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[78])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanDestroyFontsTexture()
		{
			ImplVulkanDestroyFontsTextureNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplVulkanSetMinImageCountNative(uint minImageCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[79])(minImageCount);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[79])(minImageCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanSetMinImageCount(uint minImageCount)
		{
			ImplVulkanSetMinImageCountNative(minImageCount);
		}

		/// <summary>
		/// Register a texture (VkDescriptorSet == ImTextureID)<br/>
		/// FIXME: This is experimental in the sense that we are unsure how to best design/tackle this problem<br/>
		/// Please post to https://github.com/ocornut/imgui/pull/914 if you have suggestions.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static VkDescriptorSet ImplVulkanAddTextureNative(VkSampler sampler, VkImageView imageView, VkImageLayout imageLayout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<VkSampler, VkImageView, VkImageLayout, VkDescriptorSet>)funcTable[80])(sampler, imageView, imageLayout);
			#else
			return (VkDescriptorSet)((delegate* unmanaged[Cdecl]<VkSampler, VkImageView, VkImageLayout, VkDescriptorSet>)funcTable[80])(sampler, imageView, imageLayout);
			#endif
		}

		/// <summary>
		/// Register a texture (VkDescriptorSet == ImTextureID)<br/>
		/// FIXME: This is experimental in the sense that we are unsure how to best design/tackle this problem<br/>
		/// Please post to https://github.com/ocornut/imgui/pull/914 if you have suggestions.<br/>
		/// </summary>
		public static VkDescriptorSet ImplVulkanAddTexture(VkSampler sampler, VkImageView imageView, VkImageLayout imageLayout)
		{
			VkDescriptorSet ret = ImplVulkanAddTextureNative(sampler, imageView, imageLayout);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplVulkanRemoveTextureNative(VkDescriptorSet descriptorSet)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<VkDescriptorSet, void>)funcTable[81])(descriptorSet);
			#else
			((delegate* unmanaged[Cdecl]<VkDescriptorSet, void>)funcTable[81])(descriptorSet);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanRemoveTexture(VkDescriptorSet descriptorSet)
		{
			ImplVulkanRemoveTextureNative(descriptorSet);
		}

		/// <summary>
		/// Optional: load Vulkan functions with a custom function loader<br/>
		/// This is only useful with IMGUI_IMPL_VULKAN_NO_PROTOTYPES / VK_NO_PROTOTYPES<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImplVulkanLoadFunctionsNative(PFNVkVoidFunction loaderFunc, void* userData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<byte*, void*, void*>, void*, byte>)funcTable[82])((delegate*<byte*, void*, void*>)Utils.GetFunctionPointerForDelegate(loaderFunc), userData);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[82])((nint)Utils.GetFunctionPointerForDelegate(loaderFunc), (nint)userData);
			#endif
		}

		/// <summary>
		/// Optional: load Vulkan functions with a custom function loader<br/>
		/// This is only useful with IMGUI_IMPL_VULKAN_NO_PROTOTYPES / VK_NO_PROTOTYPES<br/>
		/// </summary>
		public static bool ImplVulkanLoadFunctions(PFNVkVoidFunction loaderFunc, void* userData)
		{
			byte ret = ImplVulkanLoadFunctionsNative(loaderFunc, userData);
			return ret != 0;
		}

		/// <summary>
		/// Helpers<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplVulkanHCreateOrResizeWindowNative(VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice device, ImGuiImplVulkanHWindow* wd, uint queueFamily, VkAllocationCallbacks* allocator, int w, int h, uint minImageCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<VkInstance, VkPhysicalDevice, VkDevice, ImGuiImplVulkanHWindow*, uint, VkAllocationCallbacks*, int, int, uint, void>)funcTable[83])(instance, physicalDevice, device, wd, queueFamily, allocator, w, h, minImageCount);
			#else
			((delegate* unmanaged[Cdecl]<VkInstance, VkPhysicalDevice, VkDevice, nint, uint, nint, int, int, uint, void>)funcTable[83])(instance, physicalDevice, device, (nint)wd, queueFamily, (nint)allocator, w, h, minImageCount);
			#endif
		}

		/// <summary>
		/// Helpers<br/>
		/// </summary>
		public static void ImplVulkanHCreateOrResizeWindow(VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice device, ImGuiImplVulkanHWindowPtr wd, uint queueFamily, VkAllocationCallbacks* allocator, int w, int h, uint minImageCount)
		{
			ImplVulkanHCreateOrResizeWindowNative(instance, physicalDevice, device, wd, queueFamily, allocator, w, h, minImageCount);
		}

		/// <summary>
		/// Helpers<br/>
		/// </summary>
		public static void ImplVulkanHCreateOrResizeWindow(VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice device, ref ImGuiImplVulkanHWindow wd, uint queueFamily, VkAllocationCallbacks* allocator, int w, int h, uint minImageCount)
		{
			fixed (ImGuiImplVulkanHWindow* pwd = &wd)
			{
				ImplVulkanHCreateOrResizeWindowNative(instance, physicalDevice, device, (ImGuiImplVulkanHWindow*)pwd, queueFamily, allocator, w, h, minImageCount);
			}
		}

		/// <summary>
		/// Helpers<br/>
		/// </summary>
		public static void ImplVulkanHCreateOrResizeWindow(VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice device, ImGuiImplVulkanHWindowPtr wd, uint queueFamily, ref VkAllocationCallbacks allocator, int w, int h, uint minImageCount)
		{
			fixed (VkAllocationCallbacks* pallocator = &allocator)
			{
				ImplVulkanHCreateOrResizeWindowNative(instance, physicalDevice, device, wd, queueFamily, (VkAllocationCallbacks*)pallocator, w, h, minImageCount);
			}
		}

		/// <summary>
		/// Helpers<br/>
		/// </summary>
		public static void ImplVulkanHCreateOrResizeWindow(VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice device, ref ImGuiImplVulkanHWindow wd, uint queueFamily, ref VkAllocationCallbacks allocator, int w, int h, uint minImageCount)
		{
			fixed (ImGuiImplVulkanHWindow* pwd = &wd)
			{
				fixed (VkAllocationCallbacks* pallocator = &allocator)
				{
					ImplVulkanHCreateOrResizeWindowNative(instance, physicalDevice, device, (ImGuiImplVulkanHWindow*)pwd, queueFamily, (VkAllocationCallbacks*)pallocator, w, h, minImageCount);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImplVulkanHDestroyWindowNative(VkInstance instance, VkDevice device, ImGuiImplVulkanHWindow* wd, VkAllocationCallbacks* allocator)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<VkInstance, VkDevice, ImGuiImplVulkanHWindow*, VkAllocationCallbacks*, void>)funcTable[84])(instance, device, wd, allocator);
			#else
			((delegate* unmanaged[Cdecl]<VkInstance, VkDevice, nint, nint, void>)funcTable[84])(instance, device, (nint)wd, (nint)allocator);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanHDestroyWindow(VkInstance instance, VkDevice device, ImGuiImplVulkanHWindowPtr wd, VkAllocationCallbacks* allocator)
		{
			ImplVulkanHDestroyWindowNative(instance, device, wd, allocator);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanHDestroyWindow(VkInstance instance, VkDevice device, ref ImGuiImplVulkanHWindow wd, VkAllocationCallbacks* allocator)
		{
			fixed (ImGuiImplVulkanHWindow* pwd = &wd)
			{
				ImplVulkanHDestroyWindowNative(instance, device, (ImGuiImplVulkanHWindow*)pwd, allocator);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanHDestroyWindow(VkInstance instance, VkDevice device, ImGuiImplVulkanHWindowPtr wd, ref VkAllocationCallbacks allocator)
		{
			fixed (VkAllocationCallbacks* pallocator = &allocator)
			{
				ImplVulkanHDestroyWindowNative(instance, device, wd, (VkAllocationCallbacks*)pallocator);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImplVulkanHDestroyWindow(VkInstance instance, VkDevice device, ref ImGuiImplVulkanHWindow wd, ref VkAllocationCallbacks allocator)
		{
			fixed (ImGuiImplVulkanHWindow* pwd = &wd)
			{
				fixed (VkAllocationCallbacks* pallocator = &allocator)
				{
					ImplVulkanHDestroyWindowNative(instance, device, (ImGuiImplVulkanHWindow*)pwd, (VkAllocationCallbacks*)pallocator);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static VkSurfaceFormatKHR ImplVulkanHSelectSurfaceFormatNative(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint* requestFormats, int requestFormatsCount, uint requestColorSpace)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<VkPhysicalDevice, VkSurfaceKHR, uint*, int, uint, VkSurfaceFormatKHR>)funcTable[85])(physicalDevice, surface, requestFormats, requestFormatsCount, requestColorSpace);
			#else
			return (VkSurfaceFormatKHR)((delegate* unmanaged[Cdecl]<VkPhysicalDevice, VkSurfaceKHR, nint, int, uint, VkSurfaceFormatKHR>)funcTable[85])(physicalDevice, surface, (nint)requestFormats, requestFormatsCount, requestColorSpace);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static VkSurfaceFormatKHR ImplVulkanHSelectSurfaceFormat(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint* requestFormats, int requestFormatsCount, uint requestColorSpace)
		{
			VkSurfaceFormatKHR ret = ImplVulkanHSelectSurfaceFormatNative(physicalDevice, surface, requestFormats, requestFormatsCount, requestColorSpace);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static VkSurfaceFormatKHR ImplVulkanHSelectSurfaceFormat(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, ref uint requestFormats, int requestFormatsCount, uint requestColorSpace)
		{
			fixed (uint* prequestFormats = &requestFormats)
			{
				VkSurfaceFormatKHR ret = ImplVulkanHSelectSurfaceFormatNative(physicalDevice, surface, (uint*)prequestFormats, requestFormatsCount, requestColorSpace);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static VkPresentModeKHR ImplVulkanHSelectPresentModeNative(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkPresentModeKHR* requestModes, int requestModesCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<VkPhysicalDevice, VkSurfaceKHR, VkPresentModeKHR*, int, VkPresentModeKHR>)funcTable[86])(physicalDevice, surface, requestModes, requestModesCount);
			#else
			return (VkPresentModeKHR)((delegate* unmanaged[Cdecl]<VkPhysicalDevice, VkSurfaceKHR, nint, int, VkPresentModeKHR>)funcTable[86])(physicalDevice, surface, (nint)requestModes, requestModesCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static VkPresentModeKHR ImplVulkanHSelectPresentMode(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkPresentModeKHR* requestModes, int requestModesCount)
		{
			VkPresentModeKHR ret = ImplVulkanHSelectPresentModeNative(physicalDevice, surface, requestModes, requestModesCount);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static VkPresentModeKHR ImplVulkanHSelectPresentMode(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, ref VkPresentModeKHR requestModes, int requestModesCount)
		{
			fixed (VkPresentModeKHR* prequestModes = &requestModes)
			{
				VkPresentModeKHR ret = ImplVulkanHSelectPresentModeNative(physicalDevice, surface, (VkPresentModeKHR*)prequestModes, requestModesCount);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImplVulkanHGetMinImageCountFromPresentModeNative(VkPresentModeKHR presentMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<VkPresentModeKHR, int>)funcTable[87])(presentMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<VkPresentModeKHR, int>)funcTable[87])(presentMode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImplVulkanHGetMinImageCountFromPresentMode(VkPresentModeKHR presentMode)
		{
			int ret = ImplVulkanHGetMinImageCountFromPresentModeNative(presentMode);
			return ret;
		}

	}
}
