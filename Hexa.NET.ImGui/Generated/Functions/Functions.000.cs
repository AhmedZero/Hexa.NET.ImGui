// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{
		internal const string LibName = "cimgui";

		[LibraryImport(LibName, EntryPoint = "ImVec2_ImVec2_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector2* ImVec2Native();

		public static Vector2* ImVec2()
		{
			Vector2* ret = ImVec2Native();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImVec2_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(Vector2* self);

		public static void Destroy(Vector2* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref Vector2 self)
		{
			fixed (Vector2* pself = &self)
			{
				DestroyNative((Vector2*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImVec2_ImVec2_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector2* ImVec2Native(float x, float y);

		public static Vector2* ImVec2(float x, float y)
		{
			Vector2* ret = ImVec2Native(x, y);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImVec4_ImVec4_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector4* ImVec4Native();

		public static Vector4* ImVec4()
		{
			Vector4* ret = ImVec4Native();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImVec4_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(Vector4* self);

		public static void Destroy(Vector4* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref Vector4 self)
		{
			fixed (Vector4* pself = &self)
			{
				DestroyNative((Vector4*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImVec4_ImVec4_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector4* ImVec4Native(float x, float y, float z, float w);

		public static Vector4* ImVec4(float x, float y, float z, float w)
		{
			Vector4* ret = ImVec4Native(x, y, z, w);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igCreateContext")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiContext* CreateContextNative(ImFontAtlas* sharedFontAtlas);

		public static ImGuiContextPtr CreateContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = CreateContextNative(sharedFontAtlas);
			return ret;
		}

		public static ImGuiContextPtr CreateContext()
		{
			ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)(default));
			return ret;
		}

		public static ImGuiContextPtr CreateContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDestroyContext")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyContextNative(ImGuiContext* ctx);

		public static void DestroyContext(ImGuiContextPtr ctx)
		{
			DestroyContextNative(ctx);
		}

		public static void DestroyContext()
		{
			DestroyContextNative((ImGuiContext*)(default));
		}

		public static void DestroyContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DestroyContextNative((ImGuiContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetCurrentContext")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiContext* GetCurrentContextNative();

		public static ImGuiContextPtr GetCurrentContext()
		{
			ImGuiContextPtr ret = GetCurrentContextNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetCurrentContext")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCurrentContextNative(ImGuiContext* ctx);

		public static void SetCurrentContext(ImGuiContextPtr ctx)
		{
			SetCurrentContextNative(ctx);
		}

		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetCurrentContextNative((ImGuiContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetIO")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiIO* GetIONative();

		public static ImGuiIOPtr GetIO()
		{
			ImGuiIOPtr ret = GetIONative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetStyle")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStyle* GetStyleNative();

		public static ImGuiStylePtr GetStyle()
		{
			ImGuiStylePtr ret = GetStyleNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igNewFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NewFrameNative();

		public static void NewFrame()
		{
			NewFrameNative();
		}

		[LibraryImport(LibName, EntryPoint = "igEndFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndFrameNative();

		public static void EndFrame()
		{
			EndFrameNative();
		}

		[LibraryImport(LibName, EntryPoint = "igRender")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderNative();

		public static void Render()
		{
			RenderNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetDrawData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawData* GetDrawDataNative();

		public static ImDrawDataPtr GetDrawData()
		{
			ImDrawDataPtr ret = GetDrawDataNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igShowDemoWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowDemoWindowNative(bool* pOpen);

		public static void ShowDemoWindow(bool* pOpen)
		{
			ShowDemoWindowNative(pOpen);
		}

		public static void ShowDemoWindow()
		{
			ShowDemoWindowNative((bool*)(default));
		}

		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDemoWindowNative((bool*)ppOpen);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igShowMetricsWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowMetricsWindowNative(bool* pOpen);

		public static void ShowMetricsWindow(bool* pOpen)
		{
			ShowMetricsWindowNative(pOpen);
		}

		public static void ShowMetricsWindow()
		{
			ShowMetricsWindowNative((bool*)(default));
		}

		public static void ShowMetricsWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowMetricsWindowNative((bool*)ppOpen);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igShowDebugLogWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowDebugLogWindowNative(bool* pOpen);

		public static void ShowDebugLogWindow(bool* pOpen)
		{
			ShowDebugLogWindowNative(pOpen);
		}

		public static void ShowDebugLogWindow()
		{
			ShowDebugLogWindowNative((bool*)(default));
		}

		public static void ShowDebugLogWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDebugLogWindowNative((bool*)ppOpen);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igShowIDStackToolWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowIDStackToolWindowNative(bool* pOpen);

		public static void ShowIDStackToolWindow(bool* pOpen)
		{
			ShowIDStackToolWindowNative(pOpen);
		}

		public static void ShowIDStackToolWindow()
		{
			ShowIDStackToolWindowNative((bool*)(default));
		}

		public static void ShowIDStackToolWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowIDStackToolWindowNative((bool*)ppOpen);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igShowAboutWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowAboutWindowNative(bool* pOpen);

		public static void ShowAboutWindow(bool* pOpen)
		{
			ShowAboutWindowNative(pOpen);
		}

		public static void ShowAboutWindow()
		{
			ShowAboutWindowNative((bool*)(default));
		}

		public static void ShowAboutWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowAboutWindowNative((bool*)ppOpen);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igShowStyleEditor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowStyleEditorNative(ImGuiStyle* reference);

		public static void ShowStyleEditor(ImGuiStylePtr reference)
		{
			ShowStyleEditorNative(reference);
		}

		public static void ShowStyleEditor()
		{
			ShowStyleEditorNative((ImGuiStyle*)(default));
		}

		public static void ShowStyleEditor(ref ImGuiStyle reference)
		{
			fixed (ImGuiStyle* preference = &reference)
			{
				ShowStyleEditorNative((ImGuiStyle*)preference);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igShowStyleSelector")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ShowStyleSelectorNative(byte* label);

		public static bool ShowStyleSelector(byte* label)
		{
			byte ret = ShowStyleSelectorNative(label);
			return ret != 0;
		}

		public static bool ShowStyleSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowStyleSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igShowFontSelector")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowFontSelectorNative(byte* label);

		public static void ShowFontSelector(byte* label)
		{
			ShowFontSelectorNative(label);
		}

		public static void ShowFontSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ShowFontSelectorNative((byte*)plabel);
			}
		}

		public static void ShowFontSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowFontSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igShowUserGuide")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowUserGuideNative();

		public static void ShowUserGuide()
		{
			ShowUserGuideNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetVersion")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* GetVersionNative();

		public static byte* GetVersion()
		{
			byte* ret = GetVersionNative();
			return ret;
		}

		public static string GetVersionS()
		{
			string ret = Utils.DecodeStringUTF8(GetVersionNative());
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igStyleColorsDark")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void StyleColorsDarkNative(ImGuiStyle* dst);

		public static void StyleColorsDark(ImGuiStylePtr dst)
		{
			StyleColorsDarkNative(dst);
		}

		public static void StyleColorsDark()
		{
			StyleColorsDarkNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsDark(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsDarkNative((ImGuiStyle*)pdst);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igStyleColorsLight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void StyleColorsLightNative(ImGuiStyle* dst);

		public static void StyleColorsLight(ImGuiStylePtr dst)
		{
			StyleColorsLightNative(dst);
		}

		public static void StyleColorsLight()
		{
			StyleColorsLightNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsLight(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsLightNative((ImGuiStyle*)pdst);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igStyleColorsClassic")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void StyleColorsClassicNative(ImGuiStyle* dst);

		public static void StyleColorsClassic(ImGuiStylePtr dst)
		{
			StyleColorsClassicNative(dst);
		}

		public static void StyleColorsClassic()
		{
			StyleColorsClassicNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsClassic(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsClassicNative((ImGuiStyle*)pdst);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBegin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginNative(byte* name, bool* pOpen, ImGuiWindowFlags flags);

		public static bool Begin(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, pOpen, flags);
			return ret != 0;
		}

		public static bool Begin(byte* name, bool* pOpen)
		{
			byte ret = BeginNative(name, pOpen, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool Begin(byte* name)
		{
			byte ret = BeginNative(name, (bool*)(default), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool Begin(byte* name, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, (bool*)(default), flags);
			return ret != 0;
		}

		public static bool Begin(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}

		public static bool Begin(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(string name, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}

		public static bool Begin(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		public static bool Begin(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool Begin(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Begin(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igEnd")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndNative();

		public static void End()
		{
			EndNative();
		}

		[LibraryImport(LibName, EntryPoint = "igBeginChild_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginChildNative(byte* strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags);

		public static bool BeginChild(byte* strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, size, childFlags, windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(strId, size, childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, Vector2 size)
		{
			byte ret = BeginChildNative(strId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, size, (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(string strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, childFlags, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, ImGuiChildFlags childFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (ImGuiChildFlags)(0), windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginChild_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginChildNative(int id, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags);

		public static bool BeginChild(int id, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, size, childFlags, windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(int id, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(id, size, childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id, Vector2 size)
		{
			byte ret = BeginChildNative(id, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, size, (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(int id, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(int id, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igEndChild")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndChildNative();

		public static void EndChild()
		{
			EndChildNative();
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowAppearing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowAppearingNative();

		public static bool IsWindowAppearing()
		{
			byte ret = IsWindowAppearingNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowCollapsed")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowCollapsedNative();

		public static bool IsWindowCollapsed()
		{
			byte ret = IsWindowCollapsedNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowFocused")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowFocusedNative(ImGuiFocusedFlags flags);

		public static bool IsWindowFocused(ImGuiFocusedFlags flags)
		{
			byte ret = IsWindowFocusedNative(flags);
			return ret != 0;
		}

		public static bool IsWindowFocused()
		{
			byte ret = IsWindowFocusedNative((ImGuiFocusedFlags)(0));
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowHovered")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowHoveredNative(ImGuiHoveredFlags flags);

		public static bool IsWindowHovered(ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowHoveredNative(flags);
			return ret != 0;
		}

		public static bool IsWindowHovered()
		{
			byte ret = IsWindowHoveredNative((ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowDrawList")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawList* GetWindowDrawListNative();

		public static ImDrawListPtr GetWindowDrawList()
		{
			ImDrawListPtr ret = GetWindowDrawListNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowDpiScale")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetWindowDpiScaleNative();

		public static float GetWindowDpiScale()
		{
			float ret = GetWindowDpiScaleNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWindowPosNative(Vector2* output);

		public static Vector2 GetWindowPos()
		{
			Vector2 ret;
			GetWindowPosNative(&ret);
			return ret;
		}

		public static void GetWindowPos(Vector2* output)
		{
			GetWindowPosNative(output);
		}

		public static void GetWindowPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowPosNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWindowSizeNative(Vector2* output);

		public static Vector2 GetWindowSize()
		{
			Vector2 ret;
			GetWindowSizeNative(&ret);
			return ret;
		}

		public static void GetWindowSize(Vector2* output)
		{
			GetWindowSizeNative(output);
		}

		public static void GetWindowSize(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowSizeNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetWindowWidthNative();

		public static float GetWindowWidth()
		{
			float ret = GetWindowWidthNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowHeight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetWindowHeightNative();

		public static float GetWindowHeight()
		{
			float ret = GetWindowHeightNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiViewport* GetWindowViewportNative();

		public static ImGuiViewportPtr GetWindowViewport()
		{
			ImGuiViewportPtr ret = GetWindowViewportNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowPosNative(Vector2 pos, ImGuiCond cond, Vector2 pivot);

		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, cond, pivot);
		}

		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetNextWindowPosNative(pos, cond, (Vector2)(new Vector2(0,0)));
		}

		public static void SetNextWindowPos(Vector2 pos)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), (Vector2)(new Vector2(0,0)));
		}

		public static void SetNextWindowPos(Vector2 pos, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), pivot);
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowSizeNative(Vector2 size, ImGuiCond cond);

		public static void SetNextWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetNextWindowSizeNative(size, cond);
		}

		public static void SetNextWindowSize(Vector2 size)
		{
			SetNextWindowSizeNative(size, (ImGuiCond)(0));
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowSizeConstraints")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowSizeConstraintsNative(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData);

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, customCallbackData);
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, (void*)(default));
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), (void*)(default));
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), customCallbackData);
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowContentSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowContentSizeNative(Vector2 size);

		public static void SetNextWindowContentSize(Vector2 size)
		{
			SetNextWindowContentSizeNative(size);
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowCollapsed")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowCollapsedNative(byte collapsed, ImGuiCond cond);

		public static void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetNextWindowCollapsed(bool collapsed)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowFocus")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowFocusNative();

		public static void SetNextWindowFocus()
		{
			SetNextWindowFocusNative();
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowScroll")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowScrollNative(Vector2 scroll);

		public static void SetNextWindowScroll(Vector2 scroll)
		{
			SetNextWindowScrollNative(scroll);
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowBgAlpha")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowBgAlphaNative(float alpha);

		public static void SetNextWindowBgAlpha(float alpha)
		{
			SetNextWindowBgAlphaNative(alpha);
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextWindowViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowViewportNative(int viewportId);

		public static void SetNextWindowViewport(int viewportId)
		{
			SetNextWindowViewportNative(viewportId);
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowPos_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowPosNative(Vector2 pos, ImGuiCond cond);

		public static void SetWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(pos, cond);
		}

		public static void SetWindowPos(Vector2 pos)
		{
			SetWindowPosNative(pos, (ImGuiCond)(0));
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowSize_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowSizeNative(Vector2 size, ImGuiCond cond);

		public static void SetWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(size, cond);
		}

		public static void SetWindowSize(Vector2 size)
		{
			SetWindowSizeNative(size, (ImGuiCond)(0));
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowCollapsed_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowCollapsedNative(byte collapsed, ImGuiCond cond);

		public static void SetWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsed(bool collapsed)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowFocus_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowFocusNative();

		public static void SetWindowFocus()
		{
			SetWindowFocusNative();
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowFontScale")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowFontScaleNative(float scale);

		public static void SetWindowFontScale(float scale)
		{
			SetWindowFontScaleNative(scale);
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowPos_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowPosNative(byte* name, Vector2 pos, ImGuiCond cond);

		public static void SetWindowPos(byte* name, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(name, pos, cond);
		}

		public static void SetWindowPos(byte* name, Vector2 pos)
		{
			SetWindowPosNative(name, pos, (ImGuiCond)(0));
		}

		public static void SetWindowPos(ref byte name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, cond);
			}
		}

		public static void SetWindowPos(ref byte name, Vector2 pos)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		public static void SetWindowPos(string name, Vector2 pos, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowPos(string name, Vector2 pos)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowSize_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowSizeNative(byte* name, Vector2 size, ImGuiCond cond);

		public static void SetWindowSize(byte* name, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(name, size, cond);
		}

		public static void SetWindowSize(byte* name, Vector2 size)
		{
			SetWindowSizeNative(name, size, (ImGuiCond)(0));
		}

		public static void SetWindowSize(ref byte name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, cond);
			}
		}

		public static void SetWindowSize(ref byte name, Vector2 size)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		public static void SetWindowSize(string name, Vector2 size, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowSize(string name, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowCollapsed_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowCollapsedNative(byte* name, byte collapsed, ImGuiCond cond);

		public static void SetWindowCollapsed(byte* name, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsed(byte* name, bool collapsed)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		public static void SetWindowCollapsed(ref byte name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		public static void SetWindowCollapsed(ref byte name, bool collapsed)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		public static void SetWindowCollapsed(string name, bool collapsed, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowCollapsed(string name, bool collapsed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowFocus_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowFocusNative(byte* name);

		public static void SetWindowFocus(byte* name)
		{
			SetWindowFocusNative(name);
		}

		public static void SetWindowFocus(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SetWindowFocusNative((byte*)pname);
			}
		}

		public static void SetWindowFocus(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowFocusNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetContentRegionAvail")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetContentRegionAvailNative(Vector2* output);

		public static Vector2 GetContentRegionAvail()
		{
			Vector2 ret;
			GetContentRegionAvailNative(&ret);
			return ret;
		}

		public static void GetContentRegionAvail(Vector2* output)
		{
			GetContentRegionAvailNative(output);
		}

		public static void GetContentRegionAvail(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionAvailNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetContentRegionMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetContentRegionMaxNative(Vector2* output);

		public static Vector2 GetContentRegionMax()
		{
			Vector2 ret;
			GetContentRegionMaxNative(&ret);
			return ret;
		}

		public static void GetContentRegionMax(Vector2* output)
		{
			GetContentRegionMaxNative(output);
		}

		public static void GetContentRegionMax(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionMaxNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowContentRegionMin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWindowContentRegionMinNative(Vector2* output);

		public static Vector2 GetWindowContentRegionMin()
		{
			Vector2 ret;
			GetWindowContentRegionMinNative(&ret);
			return ret;
		}

		public static void GetWindowContentRegionMin(Vector2* output)
		{
			GetWindowContentRegionMinNative(output);
		}

		public static void GetWindowContentRegionMin(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowContentRegionMinNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowContentRegionMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWindowContentRegionMaxNative(Vector2* output);

		public static Vector2 GetWindowContentRegionMax()
		{
			Vector2 ret;
			GetWindowContentRegionMaxNative(&ret);
			return ret;
		}

		public static void GetWindowContentRegionMax(Vector2* output)
		{
			GetWindowContentRegionMaxNative(output);
		}

		public static void GetWindowContentRegionMax(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowContentRegionMaxNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetScrollX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetScrollXNative();

		public static float GetScrollX()
		{
			float ret = GetScrollXNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetScrollY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetScrollYNative();

		public static float GetScrollY()
		{
			float ret = GetScrollYNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollX_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollXNative(float scrollX);

		public static void SetScrollX(float scrollX)
		{
			SetScrollXNative(scrollX);
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollY_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollYNative(float scrollY);

		public static void SetScrollY(float scrollY)
		{
			SetScrollYNative(scrollY);
		}

		[LibraryImport(LibName, EntryPoint = "igGetScrollMaxX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetScrollMaxXNative();

		public static float GetScrollMaxX()
		{
			float ret = GetScrollMaxXNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetScrollMaxY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetScrollMaxYNative();

		public static float GetScrollMaxY()
		{
			float ret = GetScrollMaxYNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollHereX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollHereXNative(float centerXRatio);

		public static void SetScrollHereX(float centerXRatio)
		{
			SetScrollHereXNative(centerXRatio);
		}

		public static void SetScrollHereX()
		{
			SetScrollHereXNative((float)(0.5f));
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollHereY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollHereYNative(float centerYRatio);

		public static void SetScrollHereY(float centerYRatio)
		{
			SetScrollHereYNative(centerYRatio);
		}

		public static void SetScrollHereY()
		{
			SetScrollHereYNative((float)(0.5f));
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollFromPosX_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollFromPosXNative(float localX, float centerXRatio);

		public static void SetScrollFromPosX(float localX, float centerXRatio)
		{
			SetScrollFromPosXNative(localX, centerXRatio);
		}

		public static void SetScrollFromPosX(float localX)
		{
			SetScrollFromPosXNative(localX, (float)(0.5f));
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollFromPosY_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollFromPosYNative(float localY, float centerYRatio);

		public static void SetScrollFromPosY(float localY, float centerYRatio)
		{
			SetScrollFromPosYNative(localY, centerYRatio);
		}

		public static void SetScrollFromPosY(float localY)
		{
			SetScrollFromPosYNative(localY, (float)(0.5f));
		}

		[LibraryImport(LibName, EntryPoint = "igPushFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushFontNative(ImFont* font);

		public static void PushFont(ImFontPtr font)
		{
			PushFontNative(font);
		}

		public static void PushFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				PushFontNative((ImFont*)pfont);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igPopFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopFontNative();

		public static void PopFont()
		{
			PopFontNative();
		}

		[LibraryImport(LibName, EntryPoint = "igPushStyleColor_U32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushStyleColorNative(ImGuiCol idx, uint col);

		public static void PushStyleColor(ImGuiCol idx, uint col)
		{
			PushStyleColorNative(idx, col);
		}

		[LibraryImport(LibName, EntryPoint = "igPushStyleColor_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushStyleColorNative(ImGuiCol idx, Vector4 col);

		public static void PushStyleColor(ImGuiCol idx, Vector4 col)
		{
			PushStyleColorNative(idx, col);
		}

		[LibraryImport(LibName, EntryPoint = "igPopStyleColor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopStyleColorNative(int count);

		public static void PopStyleColor(int count)
		{
			PopStyleColorNative(count);
		}

		public static void PopStyleColor()
		{
			PopStyleColorNative((int)(1));
		}

		[LibraryImport(LibName, EntryPoint = "igPushStyleVar_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushStyleVarNative(ImGuiStyleVar idx, float val);

		public static void PushStyleVar(ImGuiStyleVar idx, float val)
		{
			PushStyleVarNative(idx, val);
		}

		[LibraryImport(LibName, EntryPoint = "igPushStyleVar_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushStyleVarNative(ImGuiStyleVar idx, Vector2 val);

		public static void PushStyleVar(ImGuiStyleVar idx, Vector2 val)
		{
			PushStyleVarNative(idx, val);
		}

		[LibraryImport(LibName, EntryPoint = "igPopStyleVar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopStyleVarNative(int count);

		public static void PopStyleVar(int count)
		{
			PopStyleVarNative(count);
		}

		public static void PopStyleVar()
		{
			PopStyleVarNative((int)(1));
		}

		[LibraryImport(LibName, EntryPoint = "igPushTabStop")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushTabStopNative(byte tabStop);

		public static void PushTabStop(bool tabStop)
		{
			PushTabStopNative(tabStop ? (byte)1 : (byte)0);
		}

		[LibraryImport(LibName, EntryPoint = "igPopTabStop")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopTabStopNative();

		public static void PopTabStop()
		{
			PopTabStopNative();
		}

		[LibraryImport(LibName, EntryPoint = "igPushButtonRepeat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushButtonRepeatNative(byte repeat);

		public static void PushButtonRepeat(bool repeat)
		{
			PushButtonRepeatNative(repeat ? (byte)1 : (byte)0);
		}

		[LibraryImport(LibName, EntryPoint = "igPopButtonRepeat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopButtonRepeatNative();

		public static void PopButtonRepeat()
		{
			PopButtonRepeatNative();
		}

		[LibraryImport(LibName, EntryPoint = "igPushItemWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushItemWidthNative(float itemWidth);

		public static void PushItemWidth(float itemWidth)
		{
			PushItemWidthNative(itemWidth);
		}

		[LibraryImport(LibName, EntryPoint = "igPopItemWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopItemWidthNative();

		public static void PopItemWidth()
		{
			PopItemWidthNative();
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextItemWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextItemWidthNative(float itemWidth);

		public static void SetNextItemWidth(float itemWidth)
		{
			SetNextItemWidthNative(itemWidth);
		}

		[LibraryImport(LibName, EntryPoint = "igCalcItemWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float CalcItemWidthNative();

		public static float CalcItemWidth()
		{
			float ret = CalcItemWidthNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igPushTextWrapPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushTextWrapPosNative(float wrapLocalPosX);

		public static void PushTextWrapPos(float wrapLocalPosX)
		{
			PushTextWrapPosNative(wrapLocalPosX);
		}

		public static void PushTextWrapPos()
		{
			PushTextWrapPosNative((float)(0.0f));
		}

		[LibraryImport(LibName, EntryPoint = "igPopTextWrapPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopTextWrapPosNative();

		public static void PopTextWrapPos()
		{
			PopTextWrapPosNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImFont* GetFontNative();

		public static ImFontPtr GetFont()
		{
			ImFontPtr ret = GetFontNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetFontSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetFontSizeNative();

		public static float GetFontSize()
		{
			float ret = GetFontSizeNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetFontTexUvWhitePixel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetFontTexUvWhitePixelNative(Vector2* output);

		public static Vector2 GetFontTexUvWhitePixel()
		{
			Vector2 ret;
			GetFontTexUvWhitePixelNative(&ret);
			return ret;
		}

		public static void GetFontTexUvWhitePixel(Vector2* output)
		{
			GetFontTexUvWhitePixelNative(output);
		}

		public static void GetFontTexUvWhitePixel(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetFontTexUvWhitePixelNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetColorU32_Col")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetColorU32Native(ImGuiCol idx, float alphaMul);

		public static uint GetColorU32(ImGuiCol idx, float alphaMul)
		{
			uint ret = GetColorU32Native(idx, alphaMul);
			return ret;
		}

		public static uint GetColorU32(ImGuiCol idx)
		{
			uint ret = GetColorU32Native(idx, (float)(1.0f));
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetColorU32_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetColorU32Native(Vector4 col);

		public static uint GetColorU32(Vector4 col)
		{
			uint ret = GetColorU32Native(col);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetColorU32_U32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetColorU32Native(uint col, float alphaMul);

		public static uint GetColorU32(uint col, float alphaMul)
		{
			uint ret = GetColorU32Native(col, alphaMul);
			return ret;
		}

		public static uint GetColorU32(uint col)
		{
			uint ret = GetColorU32Native(col, (float)(1.0f));
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetStyleColorVec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector4* GetStyleColorVec4Native(ImGuiCol idx);

		public static Vector4* GetStyleColorVec4(ImGuiCol idx)
		{
			Vector4* ret = GetStyleColorVec4Native(idx);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetCursorScreenPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetCursorScreenPosNative(Vector2* output);

		public static Vector2 GetCursorScreenPos()
		{
			Vector2 ret;
			GetCursorScreenPosNative(&ret);
			return ret;
		}

		public static void GetCursorScreenPos(Vector2* output)
		{
			GetCursorScreenPosNative(output);
		}

		public static void GetCursorScreenPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorScreenPosNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetCursorScreenPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCursorScreenPosNative(Vector2 pos);

		public static void SetCursorScreenPos(Vector2 pos)
		{
			SetCursorScreenPosNative(pos);
		}

		[LibraryImport(LibName, EntryPoint = "igGetCursorPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetCursorPosNative(Vector2* output);

		public static Vector2 GetCursorPos()
		{
			Vector2 ret;
			GetCursorPosNative(&ret);
			return ret;
		}

		public static void GetCursorPos(Vector2* output)
		{
			GetCursorPosNative(output);
		}

		public static void GetCursorPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorPosNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetCursorPosX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetCursorPosXNative();

		public static float GetCursorPosX()
		{
			float ret = GetCursorPosXNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetCursorPosY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetCursorPosYNative();

		public static float GetCursorPosY()
		{
			float ret = GetCursorPosYNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetCursorPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCursorPosNative(Vector2 localPos);

		public static void SetCursorPos(Vector2 localPos)
		{
			SetCursorPosNative(localPos);
		}

		[LibraryImport(LibName, EntryPoint = "igSetCursorPosX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCursorPosXNative(float localX);

		public static void SetCursorPosX(float localX)
		{
			SetCursorPosXNative(localX);
		}

		[LibraryImport(LibName, EntryPoint = "igSetCursorPosY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCursorPosYNative(float localY);

		public static void SetCursorPosY(float localY)
		{
			SetCursorPosYNative(localY);
		}

		[LibraryImport(LibName, EntryPoint = "igGetCursorStartPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetCursorStartPosNative(Vector2* output);

		public static Vector2 GetCursorStartPos()
		{
			Vector2 ret;
			GetCursorStartPosNative(&ret);
			return ret;
		}

		public static void GetCursorStartPos(Vector2* output)
		{
			GetCursorStartPosNative(output);
		}

		public static void GetCursorStartPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorStartPosNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSeparator")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SeparatorNative();

		public static void Separator()
		{
			SeparatorNative();
		}

		[LibraryImport(LibName, EntryPoint = "igSameLine")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SameLineNative(float offsetFromStartX, float spacing);

		public static void SameLine(float offsetFromStartX, float spacing)
		{
			SameLineNative(offsetFromStartX, spacing);
		}

		public static void SameLine(float offsetFromStartX)
		{
			SameLineNative(offsetFromStartX, (float)(-1.0f));
		}

		public static void SameLine()
		{
			SameLineNative((float)(0.0f), (float)(-1.0f));
		}

		[LibraryImport(LibName, EntryPoint = "igNewLine")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NewLineNative();

		public static void NewLine()
		{
			NewLineNative();
		}

		[LibraryImport(LibName, EntryPoint = "igSpacing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SpacingNative();

		public static void Spacing()
		{
			SpacingNative();
		}

		[LibraryImport(LibName, EntryPoint = "igDummy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DummyNative(Vector2 size);

		public static void Dummy(Vector2 size)
		{
			DummyNative(size);
		}

		[LibraryImport(LibName, EntryPoint = "igIndent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void IndentNative(float indentW);

		public static void Indent(float indentW)
		{
			IndentNative(indentW);
		}

		public static void Indent()
		{
			IndentNative((float)(0.0f));
		}

		[LibraryImport(LibName, EntryPoint = "igUnindent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void UnindentNative(float indentW);

		public static void Unindent(float indentW)
		{
			UnindentNative(indentW);
		}

		public static void Unindent()
		{
			UnindentNative((float)(0.0f));
		}

		[LibraryImport(LibName, EntryPoint = "igBeginGroup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BeginGroupNative();

		public static void BeginGroup()
		{
			BeginGroupNative();
		}

		[LibraryImport(LibName, EntryPoint = "igEndGroup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndGroupNative();

		public static void EndGroup()
		{
			EndGroupNative();
		}

		[LibraryImport(LibName, EntryPoint = "igAlignTextToFramePadding")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AlignTextToFramePaddingNative();

		public static void AlignTextToFramePadding()
		{
			AlignTextToFramePaddingNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetTextLineHeight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetTextLineHeightNative();

		public static float GetTextLineHeight()
		{
			float ret = GetTextLineHeightNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetTextLineHeightWithSpacing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetTextLineHeightWithSpacingNative();

		public static float GetTextLineHeightWithSpacing()
		{
			float ret = GetTextLineHeightWithSpacingNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetFrameHeight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetFrameHeightNative();

		public static float GetFrameHeight()
		{
			float ret = GetFrameHeightNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetFrameHeightWithSpacing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetFrameHeightWithSpacingNative();

		public static float GetFrameHeightWithSpacing()
		{
			float ret = GetFrameHeightWithSpacingNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igPushID_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushIDNative(byte* strId);

		public static void PushID(byte* strId)
		{
			PushIDNative(strId);
		}

		public static void PushID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		public static void PushID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igPushID_StrStr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushIDNative(byte* strIdBegin, byte* strIdEnd);

		public static void PushID(byte* strIdBegin, byte* strIdEnd)
		{
			PushIDNative(strIdBegin, strIdEnd);
		}

		public static void PushID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		public static void PushID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		public static void PushID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		public static void PushID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PushIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igPushID_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushIDNative(void* ptrId);

		public static void PushID(void* ptrId)
		{
			PushIDNative(ptrId);
		}

		[LibraryImport(LibName, EntryPoint = "igPushID_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushIDNative(int intId);

		public static void PushID(int intId)
		{
			PushIDNative(intId);
		}

		[LibraryImport(LibName, EntryPoint = "igPopID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopIDNative();

		public static void PopID()
		{
			PopIDNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetID_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetIDNative(byte* strId);

		public static int GetID(byte* strId)
		{
			int ret = GetIDNative(strId);
			return ret;
		}

		public static int GetID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				int ret = GetIDNative((byte*)pstrId);
				return ret;
			}
		}

		public static int GetID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetID_StrStr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetIDNative(byte* strIdBegin, byte* strIdEnd);

		public static int GetID(byte* strIdBegin, byte* strIdEnd)
		{
			int ret = GetIDNative(strIdBegin, strIdEnd);
			return ret;
		}

		public static int GetID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				int ret = GetIDNative((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		public static int GetID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				int ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		public static int GetID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					int ret = GetIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		public static int GetID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = GetIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetID_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetIDNative(void* ptrId);

		public static int GetID(void* ptrId)
		{
			int ret = GetIDNative(ptrId);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igTextUnformatted")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextUnformattedNative(byte* text, byte* textEnd);

		public static void TextUnformatted(byte* text, byte* textEnd)
		{
			TextUnformattedNative(text, textEnd);
		}

		public static void TextUnformatted(byte* text)
		{
			TextUnformattedNative(text, (byte*)(default));
		}

		public static void TextUnformatted(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				TextUnformattedNative((byte*)ptext, textEnd);
			}
		}

		public static void TextUnformatted(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				TextUnformattedNative((byte*)ptext, (byte*)(default));
			}
		}

		public static void TextUnformatted(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				TextUnformattedNative(text, (byte*)ptextEnd);
			}
		}

		public static void TextUnformatted(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					TextUnformattedNative((byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void TextUnformatted(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			TextUnformattedNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextNative(byte* fmt);

		public static void Text(byte* fmt)
		{
			TextNative(fmt);
		}

		public static void Text(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextNative((byte*)pfmt);
			}
		}

		public static void Text(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTextV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextVNative(byte* fmt, nuint args);

		public static void TextV(byte* fmt, nuint args)
		{
			TextVNative(fmt, args);
		}

		public static void TextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextVNative((byte*)pfmt, args);
			}
		}

		public static void TextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTextColored")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextColoredNative(Vector4 col, byte* fmt);

		public static void TextColored(Vector4 col, byte* fmt)
		{
			TextColoredNative(col, fmt);
		}

		public static void TextColored(Vector4 col, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredNative(col, (byte*)pfmt);
			}
		}

		public static void TextColored(Vector4 col, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredNative(col, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTextColoredV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextColoredVNative(Vector4 col, byte* fmt, nuint args);

		public static void TextColoredV(Vector4 col, byte* fmt, nuint args)
		{
			TextColoredVNative(col, fmt, args);
		}

		public static void TextColoredV(Vector4 col, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredVNative(col, (byte*)pfmt, args);
			}
		}

		public static void TextColoredV(Vector4 col, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredVNative(col, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTextDisabled")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextDisabledNative(byte* fmt);

		public static void TextDisabled(byte* fmt)
		{
			TextDisabledNative(fmt);
		}

		public static void TextDisabled(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextDisabledNative((byte*)pfmt);
			}
		}

		public static void TextDisabled(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextDisabledNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTextDisabledV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextDisabledVNative(byte* fmt, nuint args);

		public static void TextDisabledV(byte* fmt, nuint args)
		{
			TextDisabledVNative(fmt, args);
		}

		public static void TextDisabledV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextDisabledVNative((byte*)pfmt, args);
			}
		}

		public static void TextDisabledV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextDisabledVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTextWrapped")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextWrappedNative(byte* fmt);

		public static void TextWrapped(byte* fmt)
		{
			TextWrappedNative(fmt);
		}

		public static void TextWrapped(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextWrappedNative((byte*)pfmt);
			}
		}

		public static void TextWrapped(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextWrappedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTextWrappedV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextWrappedVNative(byte* fmt, nuint args);

		public static void TextWrappedV(byte* fmt, nuint args)
		{
			TextWrappedVNative(fmt, args);
		}

		public static void TextWrappedV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextWrappedVNative((byte*)pfmt, args);
			}
		}

		public static void TextWrappedV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextWrappedVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igLabelText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LabelTextNative(byte* label, byte* fmt);

		public static void LabelText(byte* label, byte* fmt)
		{
			LabelTextNative(label, fmt);
		}

		public static void LabelText(ref byte label, byte* fmt)
		{
			fixed (byte* plabel = &label)
			{
				LabelTextNative((byte*)plabel, fmt);
			}
		}

		public static void LabelText(string label, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextNative(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(byte* label, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextNative(label, (byte*)pfmt);
			}
		}

		public static void LabelText(byte* label, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextNative(label, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(ref byte label, ref byte fmt)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pfmt = &fmt)
				{
					LabelTextNative((byte*)plabel, (byte*)pfmt);
				}
			}
		}

		public static void LabelText(string label, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LabelTextNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igLabelTextV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LabelTextVNative(byte* label, byte* fmt, nuint args);

		public static void LabelTextV(byte* label, byte* fmt, nuint args)
		{
			LabelTextVNative(label, fmt, args);
		}

		public static void LabelTextV(ref byte label, byte* fmt, nuint args)
		{
			fixed (byte* plabel = &label)
			{
				LabelTextVNative((byte*)plabel, fmt, args);
			}
		}

		public static void LabelTextV(string label, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextVNative(pStr0, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(byte* label, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextVNative(label, (byte*)pfmt, args);
			}
		}

		public static void LabelTextV(byte* label, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextVNative(label, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(ref byte label, ref byte fmt, nuint args)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pfmt = &fmt)
				{
					LabelTextVNative((byte*)plabel, (byte*)pfmt, args);
				}
			}
		}

		public static void LabelTextV(string label, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LabelTextVNative(pStr0, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBulletText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BulletTextNative(byte* fmt);

		public static void BulletText(byte* fmt)
		{
			BulletTextNative(fmt);
		}

		public static void BulletText(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				BulletTextNative((byte*)pfmt);
			}
		}

		public static void BulletText(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BulletTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBulletTextV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BulletTextVNative(byte* fmt, nuint args);

		public static void BulletTextV(byte* fmt, nuint args)
		{
			BulletTextVNative(fmt, args);
		}

		public static void BulletTextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				BulletTextVNative((byte*)pfmt, args);
			}
		}

		public static void BulletTextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BulletTextVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSeparatorText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SeparatorTextNative(byte* label);

		public static void SeparatorText(byte* label)
		{
			SeparatorTextNative(label);
		}

		public static void SeparatorText(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				SeparatorTextNative((byte*)plabel);
			}
		}

		public static void SeparatorText(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SeparatorTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ButtonNative(byte* label, Vector2 size);

		public static bool Button(byte* label, Vector2 size)
		{
			byte ret = ButtonNative(label, size);
			return ret != 0;
		}

		public static bool Button(byte* label)
		{
			byte ret = ButtonNative(label, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Button(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ButtonNative((byte*)plabel, size);
				return ret != 0;
			}
		}

		public static bool Button(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Button(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ButtonNative(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Button(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ButtonNative(pStr0, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igSmallButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte SmallButtonNative(byte* label);

		public static bool SmallButton(byte* label)
		{
			byte ret = SmallButtonNative(label);
			return ret != 0;
		}

		public static bool SmallButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SmallButtonNative((byte*)plabel);
				return ret != 0;
			}
		}

		public static bool SmallButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SmallButtonNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igInvisibleButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InvisibleButtonNative(byte* strId, Vector2 size, ImGuiButtonFlags flags);

		public static bool InvisibleButton(byte* strId, Vector2 size, ImGuiButtonFlags flags)
		{
			byte ret = InvisibleButtonNative(strId, size, flags);
			return ret != 0;
		}

		public static bool InvisibleButton(byte* strId, Vector2 size)
		{
			byte ret = InvisibleButtonNative(strId, size, (ImGuiButtonFlags)(0));
			return ret != 0;
		}

		public static bool InvisibleButton(ref byte strId, Vector2 size, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = InvisibleButtonNative((byte*)pstrId, size, flags);
				return ret != 0;
			}
		}

		public static bool InvisibleButton(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = InvisibleButtonNative((byte*)pstrId, size, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}

		public static bool InvisibleButton(string strId, Vector2 size, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InvisibleButtonNative(pStr0, size, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InvisibleButton(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InvisibleButtonNative(pStr0, size, (ImGuiButtonFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igArrowButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ArrowButtonNative(byte* strId, ImGuiDir dir);

		public static bool ArrowButton(byte* strId, ImGuiDir dir)
		{
			byte ret = ArrowButtonNative(strId, dir);
			return ret != 0;
		}

		public static bool ArrowButton(ref byte strId, ImGuiDir dir)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ArrowButtonNative((byte*)pstrId, dir);
				return ret != 0;
			}
		}

		public static bool ArrowButton(string strId, ImGuiDir dir)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ArrowButtonNative(pStr0, dir);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igCheckbox")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte CheckboxNative(byte* label, bool* v);

		public static bool Checkbox(byte* label, bool* v)
		{
			byte ret = CheckboxNative(label, v);
			return ret != 0;
		}

		public static bool Checkbox(ref byte label, bool* v)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CheckboxNative((byte*)plabel, v);
				return ret != 0;
			}
		}

		public static bool Checkbox(string label, bool* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CheckboxNative(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Checkbox(byte* label, ref bool v)
		{
			fixed (bool* pv = &v)
			{
				byte ret = CheckboxNative(label, (bool*)pv);
				return ret != 0;
			}
		}

		public static bool Checkbox(ref byte label, ref bool v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* pv = &v)
				{
					byte ret = CheckboxNative((byte*)plabel, (bool*)pv);
					return ret != 0;
				}
			}
		}

		public static bool Checkbox(string label, ref bool v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* pv = &v)
			{
				byte ret = CheckboxNative(pStr0, (bool*)pv);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igCheckboxFlags_IntPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte CheckboxFlagsNative(byte* label, int* flags, int flagsValue);

		public static bool CheckboxFlags(byte* label, int* flags, int flagsValue)
		{
			byte ret = CheckboxFlagsNative(label, flags, flagsValue);
			return ret != 0;
		}

		public static bool CheckboxFlags(ref byte label, int* flags, int flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CheckboxFlagsNative((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlags(string label, int* flags, int flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CheckboxFlagsNative(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CheckboxFlags(byte* label, ref int flags, int flagsValue)
		{
			fixed (int* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(label, (int*)pflags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlags(ref byte label, ref int flags, int flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pflags = &flags)
				{
					byte ret = CheckboxFlagsNative((byte*)plabel, (int*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}

		public static bool CheckboxFlags(string label, ref int flags, int flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(pStr0, (int*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igCheckboxFlags_UintPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte CheckboxFlagsNative(byte* label, uint* flags, uint flagsValue);

		public static bool CheckboxFlags(byte* label, uint* flags, uint flagsValue)
		{
			byte ret = CheckboxFlagsNative(label, flags, flagsValue);
			return ret != 0;
		}

		public static bool CheckboxFlags(ref byte label, uint* flags, uint flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CheckboxFlagsNative((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlags(string label, uint* flags, uint flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CheckboxFlagsNative(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CheckboxFlags(byte* label, ref uint flags, uint flagsValue)
		{
			fixed (uint* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(label, (uint*)pflags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlags(ref byte label, ref uint flags, uint flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (uint* pflags = &flags)
				{
					byte ret = CheckboxFlagsNative((byte*)plabel, (uint*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}

		public static bool CheckboxFlags(string label, ref uint flags, uint flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(pStr0, (uint*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igRadioButton_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte RadioButtonNative(byte* label, byte active);

		public static bool RadioButton(byte* label, bool active)
		{
			byte ret = RadioButtonNative(label, active ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool RadioButton(ref byte label, bool active)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = RadioButtonNative((byte*)plabel, active ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool RadioButton(string label, bool active)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RadioButtonNative(pStr0, active ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igRadioButton_IntPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte RadioButtonNative(byte* label, int* v, int vButton);

		public static bool RadioButton(byte* label, int* v, int vButton)
		{
			byte ret = RadioButtonNative(label, v, vButton);
			return ret != 0;
		}

		public static bool RadioButton(ref byte label, int* v, int vButton)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = RadioButtonNative((byte*)plabel, v, vButton);
				return ret != 0;
			}
		}

		public static bool RadioButton(string label, int* v, int vButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RadioButtonNative(pStr0, v, vButton);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool RadioButton(byte* label, ref int v, int vButton)
		{
			fixed (int* pv = &v)
			{
				byte ret = RadioButtonNative(label, (int*)pv, vButton);
				return ret != 0;
			}
		}

		public static bool RadioButton(ref byte label, ref int v, int vButton)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = RadioButtonNative((byte*)plabel, (int*)pv, vButton);
					return ret != 0;
				}
			}
		}

		public static bool RadioButton(string label, ref int v, int vButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = RadioButtonNative(pStr0, (int*)pv, vButton);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igProgressBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ProgressBarNative(float fraction, Vector2 sizeArg, byte* overlay);

		public static void ProgressBar(float fraction, Vector2 sizeArg, byte* overlay)
		{
			ProgressBarNative(fraction, sizeArg, overlay);
		}

		public static void ProgressBar(float fraction, Vector2 sizeArg)
		{
			ProgressBarNative(fraction, sizeArg, (byte*)(default));
		}

		public static void ProgressBar(float fraction)
		{
			ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), (byte*)(default));
		}

		public static void ProgressBar(float fraction, byte* overlay)
		{
			ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), overlay);
		}

		public static void ProgressBar(float fraction, Vector2 sizeArg, ref byte overlay)
		{
			fixed (byte* poverlay = &overlay)
			{
				ProgressBarNative(fraction, sizeArg, (byte*)poverlay);
			}
		}

		public static void ProgressBar(float fraction, ref byte overlay)
		{
			fixed (byte* poverlay = &overlay)
			{
				ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), (byte*)poverlay);
			}
		}

		public static void ProgressBar(float fraction, Vector2 sizeArg, string overlay)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlay != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlay);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlay, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgressBarNative(fraction, sizeArg, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ProgressBar(float fraction, string overlay)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlay != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlay);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlay, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBullet")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BulletNative();

		public static void Bullet()
		{
			BulletNative();
		}

		[LibraryImport(LibName, EntryPoint = "igImage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImageNative(ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 tintCol, Vector4 borderCol);

		public static void Image(ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 tintCol, Vector4 borderCol)
		{
			ImageNative(userTextureId, imageSize, uv0, uv1, tintCol, borderCol);
		}

		public static void Image(ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 tintCol)
		{
			ImageNative(userTextureId, imageSize, uv0, uv1, tintCol, (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1)
		{
			ImageNative(userTextureId, imageSize, uv0, uv1, (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0)
		{
			ImageNative(userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 imageSize)
		{
			ImageNative(userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector4 tintCol)
		{
			ImageNative(userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), tintCol, (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 imageSize, Vector4 tintCol)
		{
			ImageNative(userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), tintCol, (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector4 tintCol, Vector4 borderCol)
		{
			ImageNative(userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), tintCol, borderCol);
		}

		public static void Image(ImTextureID userTextureId, Vector2 imageSize, Vector4 tintCol, Vector4 borderCol)
		{
			ImageNative(userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), tintCol, borderCol);
		}

		[LibraryImport(LibName, EntryPoint = "igImageButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImageButtonNative(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol);

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, uv1, bgCol, tintCol);
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, uv1, bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, uv1, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector4 bgCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector4 bgCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), bgCol, tintCol);
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), bgCol, tintCol);
			return ret != 0;
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, uv0, uv1, bgCol, tintCol);
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, uv0, uv1, bgCol, (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, uv0, uv1, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector4 bgCol)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), bgCol, (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize, Vector4 bgCol)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), bgCol, (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector4 bgCol, Vector4 tintCol)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), bgCol, tintCol);
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 imageSize, Vector4 bgCol, Vector4 tintCol)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), bgCol, tintCol);
				return ret != 0;
			}
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, imageSize, uv0, uv1, bgCol, tintCol);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, imageSize, uv0, uv1, bgCol, (Vector4)(new Vector4(1,1,1,1)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, imageSize, uv0, uv1, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
	}
}
