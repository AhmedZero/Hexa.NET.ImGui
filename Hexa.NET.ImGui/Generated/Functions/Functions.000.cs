// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{
		internal const string LibName = "cimgui";

		internal static Vector2* ImVec2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*>)vt[0])();
			#else
			return (Vector2*)((delegate* unmanaged[Cdecl]<nint>)vt[0])();
			#endif
		}

		public static Vector2* ImVec2()
		{
			Vector2* ret = ImVec2Native();
			return ret;
		}

		internal static void DestroyNative(Vector2* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[1])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1])((nint)self);
			#endif
		}

		public static void Destroy(Vector2* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref Vector2 self)
		{
			fixed (Vector2* pself = &self)
			{
				DestroyNative((Vector2*)pself);
			}
		}

		internal static Vector2* ImVec2Native(float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, Vector2*>)vt[2])(x, y);
			#else
			return (Vector2*)((delegate* unmanaged[Cdecl]<float, float, nint>)vt[2])(x, y);
			#endif
		}

		public static Vector2* ImVec2(float x, float y)
		{
			Vector2* ret = ImVec2Native(x, y);
			return ret;
		}

		internal static Vector4* ImVec4Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4*>)vt[3])();
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<nint>)vt[3])();
			#endif
		}

		public static Vector4* ImVec4()
		{
			Vector4* ret = ImVec4Native();
			return ret;
		}

		internal static void DestroyNative(Vector4* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, void>)vt[4])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[4])((nint)self);
			#endif
		}

		public static void Destroy(Vector4* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref Vector4 self)
		{
			fixed (Vector4* pself = &self)
			{
				DestroyNative((Vector4*)pself);
			}
		}

		internal static Vector4* ImVec4Native(float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, Vector4*>)vt[5])(x, y, z, w);
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<float, float, float, float, nint>)vt[5])(x, y, z, w);
			#endif
		}

		public static Vector4* ImVec4(float x, float y, float z, float w)
		{
			Vector4* ret = ImVec4Native(x, y, z, w);
			return ret;
		}

		internal static ImGuiContext* CreateContextNative(ImFontAtlas* sharedFontAtlas)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFontAtlas*, ImGuiContext*>)vt[6])(sharedFontAtlas);
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[6])((nint)sharedFontAtlas);
			#endif
		}

		public static ImGuiContextPtr CreateContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = CreateContextNative(sharedFontAtlas);
			return ret;
		}

		public static ImGuiContextPtr CreateContext()
		{
			ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)(default));
			return ret;
		}

		public static ImGuiContextPtr CreateContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		internal static void DestroyContextNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[7])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[7])((nint)ctx);
			#endif
		}

		public static void DestroyContext(ImGuiContextPtr ctx)
		{
			DestroyContextNative(ctx);
		}

		public static void DestroyContext()
		{
			DestroyContextNative((ImGuiContext*)(default));
		}

		public static void DestroyContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DestroyContextNative((ImGuiContext*)pctx);
			}
		}

		internal static ImGuiContext* GetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*>)vt[8])();
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint>)vt[8])();
			#endif
		}

		public static ImGuiContextPtr GetCurrentContext()
		{
			ImGuiContextPtr ret = GetCurrentContextNative();
			return ret;
		}

		internal static void SetCurrentContextNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[9])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[9])((nint)ctx);
			#endif
		}

		public static void SetCurrentContext(ImGuiContextPtr ctx)
		{
			SetCurrentContextNative(ctx);
		}

		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetCurrentContextNative((ImGuiContext*)pctx);
			}
		}

		internal static ImGuiIO* GetIONative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiIO*>)vt[10])();
			#else
			return (ImGuiIO*)((delegate* unmanaged[Cdecl]<nint>)vt[10])();
			#endif
		}

		public static ImGuiIOPtr GetIO()
		{
			ImGuiIOPtr ret = GetIONative();
			return ret;
		}

		internal static ImGuiStyle* GetStyleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyle*>)vt[11])();
			#else
			return (ImGuiStyle*)((delegate* unmanaged[Cdecl]<nint>)vt[11])();
			#endif
		}

		public static ImGuiStylePtr GetStyle()
		{
			ImGuiStylePtr ret = GetStyleNative();
			return ret;
		}

		internal static void NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[12])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[12])();
			#endif
		}

		public static void NewFrame()
		{
			NewFrameNative();
		}

		internal static void EndFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[13])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[13])();
			#endif
		}

		public static void EndFrame()
		{
			EndFrameNative();
		}

		internal static void RenderNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[14])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[14])();
			#endif
		}

		public static void Render()
		{
			RenderNative();
		}

		internal static ImDrawData* GetDrawDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawData*>)vt[15])();
			#else
			return (ImDrawData*)((delegate* unmanaged[Cdecl]<nint>)vt[15])();
			#endif
		}

		public static ImDrawDataPtr GetDrawData()
		{
			ImDrawDataPtr ret = GetDrawDataNative();
			return ret;
		}

		internal static void ShowDemoWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[16])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[16])((nint)pOpen);
			#endif
		}

		public static void ShowDemoWindow(bool* pOpen)
		{
			ShowDemoWindowNative(pOpen);
		}

		public static void ShowDemoWindow()
		{
			ShowDemoWindowNative((bool*)(default));
		}

		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDemoWindowNative((bool*)ppOpen);
			}
		}

		internal static void ShowMetricsWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[17])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[17])((nint)pOpen);
			#endif
		}

		public static void ShowMetricsWindow(bool* pOpen)
		{
			ShowMetricsWindowNative(pOpen);
		}

		public static void ShowMetricsWindow()
		{
			ShowMetricsWindowNative((bool*)(default));
		}

		public static void ShowMetricsWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowMetricsWindowNative((bool*)ppOpen);
			}
		}

		internal static void ShowDebugLogWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[18])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[18])((nint)pOpen);
			#endif
		}

		public static void ShowDebugLogWindow(bool* pOpen)
		{
			ShowDebugLogWindowNative(pOpen);
		}

		public static void ShowDebugLogWindow()
		{
			ShowDebugLogWindowNative((bool*)(default));
		}

		public static void ShowDebugLogWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDebugLogWindowNative((bool*)ppOpen);
			}
		}

		internal static void ShowIDStackToolWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[19])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[19])((nint)pOpen);
			#endif
		}

		public static void ShowIDStackToolWindow(bool* pOpen)
		{
			ShowIDStackToolWindowNative(pOpen);
		}

		public static void ShowIDStackToolWindow()
		{
			ShowIDStackToolWindowNative((bool*)(default));
		}

		public static void ShowIDStackToolWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowIDStackToolWindowNative((bool*)ppOpen);
			}
		}

		internal static void ShowAboutWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[20])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[20])((nint)pOpen);
			#endif
		}

		public static void ShowAboutWindow(bool* pOpen)
		{
			ShowAboutWindowNative(pOpen);
		}

		public static void ShowAboutWindow()
		{
			ShowAboutWindowNative((bool*)(default));
		}

		public static void ShowAboutWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowAboutWindowNative((bool*)ppOpen);
			}
		}

		internal static void ShowStyleEditorNative(ImGuiStyle* reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)vt[21])(reference);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[21])((nint)reference);
			#endif
		}

		public static void ShowStyleEditor(ImGuiStylePtr reference)
		{
			ShowStyleEditorNative(reference);
		}

		public static void ShowStyleEditor()
		{
			ShowStyleEditorNative((ImGuiStyle*)(default));
		}

		public static void ShowStyleEditor(ref ImGuiStyle reference)
		{
			fixed (ImGuiStyle* preference = &reference)
			{
				ShowStyleEditorNative((ImGuiStyle*)preference);
			}
		}

		internal static byte ShowStyleSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)vt[22])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[22])((nint)label);
			#endif
		}

		public static bool ShowStyleSelector(byte* label)
		{
			byte ret = ShowStyleSelectorNative(label);
			return ret != 0;
		}

		public static bool ShowStyleSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowStyleSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ShowStyleSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		internal static void ShowFontSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[23])(label);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[23])((nint)label);
			#endif
		}

		public static void ShowFontSelector(byte* label)
		{
			ShowFontSelectorNative(label);
		}

		public static void ShowFontSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ShowFontSelectorNative((byte*)plabel);
			}
		}

		public static void ShowFontSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowFontSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ShowFontSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ShowFontSelectorNative((byte*)plabel);
			}
		}

		internal static void ShowUserGuideNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[24])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[24])();
			#endif
		}

		public static void ShowUserGuide()
		{
			ShowUserGuideNative();
		}

		internal static byte* GetVersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)vt[25])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)vt[25])();
			#endif
		}

		public static byte* GetVersion()
		{
			byte* ret = GetVersionNative();
			return ret;
		}

		public static string GetVersionS()
		{
			string ret = Utils.DecodeStringUTF8(GetVersionNative());
			return ret;
		}

		internal static void StyleColorsDarkNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)vt[26])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[26])((nint)dst);
			#endif
		}

		public static void StyleColorsDark(ImGuiStylePtr dst)
		{
			StyleColorsDarkNative(dst);
		}

		public static void StyleColorsDark()
		{
			StyleColorsDarkNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsDark(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsDarkNative((ImGuiStyle*)pdst);
			}
		}

		internal static void StyleColorsLightNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)vt[27])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[27])((nint)dst);
			#endif
		}

		public static void StyleColorsLight(ImGuiStylePtr dst)
		{
			StyleColorsLightNative(dst);
		}

		public static void StyleColorsLight()
		{
			StyleColorsLightNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsLight(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsLightNative((ImGuiStyle*)pdst);
			}
		}

		internal static void StyleColorsClassicNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)vt[28])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[28])((nint)dst);
			#endif
		}

		public static void StyleColorsClassic(ImGuiStylePtr dst)
		{
			StyleColorsClassicNative(dst);
		}

		public static void StyleColorsClassic()
		{
			StyleColorsClassicNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsClassic(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsClassicNative((ImGuiStyle*)pdst);
			}
		}

		internal static byte BeginNative(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, bool*, ImGuiWindowFlags, byte>)vt[29])(name, pOpen, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ImGuiWindowFlags, byte>)vt[29])((nint)name, (nint)pOpen, flags);
			#endif
		}

		public static bool Begin(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, pOpen, flags);
			return ret != 0;
		}

		public static bool Begin(byte* name, bool* pOpen)
		{
			byte ret = BeginNative(name, pOpen, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool Begin(byte* name)
		{
			byte ret = BeginNative(name, (bool*)(default), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool Begin(byte* name, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, (bool*)(default), flags);
			return ret != 0;
		}

		public static bool Begin(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}

		public static bool Begin(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(string name, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(ReadOnlySpan<byte> name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		public static bool Begin(ReadOnlySpan<byte> name, bool* pOpen)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ReadOnlySpan<byte> name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}

		public static bool Begin(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}

		public static bool Begin(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		public static bool Begin(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool Begin(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Begin(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Begin(ReadOnlySpan<byte> name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		public static bool Begin(ReadOnlySpan<byte> name, ref bool pOpen)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		internal static void EndNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[30])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[30])();
			#endif
		}

		public static void End()
		{
			EndNative();
		}

		internal static byte BeginChildNative(byte* strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)vt[31])(strId, size, childFlags, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)vt[31])((nint)strId, size, childFlags, windowFlags);
			#endif
		}

		public static bool BeginChild(byte* strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, size, childFlags, windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(strId, size, childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, Vector2 size)
		{
			byte ret = BeginChildNative(strId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, size, (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(string strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, childFlags, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, ImGuiChildFlags childFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (ImGuiChildFlags)(0), windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
				return ret != 0;
			}
		}

		internal static byte BeginChildNative(int id, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)vt[32])(id, size, childFlags, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)vt[32])(id, size, childFlags, windowFlags);
			#endif
		}

		public static bool BeginChild(int id, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, size, childFlags, windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(int id, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(id, size, childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id, Vector2 size)
		{
			byte ret = BeginChildNative(id, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, size, (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(int id, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild(int id, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			return ret != 0;
		}

		internal static void EndChildNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[33])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[33])();
			#endif
		}

		public static void EndChild()
		{
			EndChildNative();
		}

		internal static byte IsWindowAppearingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[34])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[34])();
			#endif
		}

		public static bool IsWindowAppearing()
		{
			byte ret = IsWindowAppearingNative();
			return ret != 0;
		}

		internal static byte IsWindowCollapsedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[35])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[35])();
			#endif
		}

		public static bool IsWindowCollapsed()
		{
			byte ret = IsWindowCollapsedNative();
			return ret != 0;
		}

		internal static byte IsWindowFocusedNative(ImGuiFocusedFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiFocusedFlags, byte>)vt[36])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiFocusedFlags, byte>)vt[36])(flags);
			#endif
		}

		public static bool IsWindowFocused(ImGuiFocusedFlags flags)
		{
			byte ret = IsWindowFocusedNative(flags);
			return ret != 0;
		}

		public static bool IsWindowFocused()
		{
			byte ret = IsWindowFocusedNative((ImGuiFocusedFlags)(0));
			return ret != 0;
		}

		internal static byte IsWindowHoveredNative(ImGuiHoveredFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)vt[37])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)vt[37])(flags);
			#endif
		}

		public static bool IsWindowHovered(ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowHoveredNative(flags);
			return ret != 0;
		}

		public static bool IsWindowHovered()
		{
			byte ret = IsWindowHoveredNative((ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		internal static ImDrawList* GetWindowDrawListNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawList*>)vt[38])();
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint>)vt[38])();
			#endif
		}

		public static ImDrawListPtr GetWindowDrawList()
		{
			ImDrawListPtr ret = GetWindowDrawListNative();
			return ret;
		}

		internal static float GetWindowDpiScaleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[39])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[39])();
			#endif
		}

		public static float GetWindowDpiScale()
		{
			float ret = GetWindowDpiScaleNative();
			return ret;
		}

		internal static void GetWindowPosNative(Vector2* output)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[40])(output);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[40])((nint)output);
			#endif
		}

		public static Vector2 GetWindowPos()
		{
			Vector2 ret;
			GetWindowPosNative(&ret);
			return ret;
		}

		public static void GetWindowPos(Vector2* output)
		{
			GetWindowPosNative(output);
		}

		public static void GetWindowPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowPosNative((Vector2*)poutput);
			}
		}

		internal static void GetWindowSizeNative(Vector2* output)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[41])(output);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[41])((nint)output);
			#endif
		}

		public static Vector2 GetWindowSize()
		{
			Vector2 ret;
			GetWindowSizeNative(&ret);
			return ret;
		}

		public static void GetWindowSize(Vector2* output)
		{
			GetWindowSizeNative(output);
		}

		public static void GetWindowSize(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowSizeNative((Vector2*)poutput);
			}
		}

		internal static float GetWindowWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[42])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[42])();
			#endif
		}

		public static float GetWindowWidth()
		{
			float ret = GetWindowWidthNative();
			return ret;
		}

		internal static float GetWindowHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[43])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[43])();
			#endif
		}

		public static float GetWindowHeight()
		{
			float ret = GetWindowHeightNative();
			return ret;
		}

		internal static ImGuiViewport* GetWindowViewportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*>)vt[44])();
			#else
			return (ImGuiViewport*)((delegate* unmanaged[Cdecl]<nint>)vt[44])();
			#endif
		}

		public static ImGuiViewportPtr GetWindowViewport()
		{
			ImGuiViewportPtr ret = GetWindowViewportNative();
			return ret;
		}

		internal static void SetNextWindowPosNative(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, Vector2, void>)vt[45])(pos, cond, pivot);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, Vector2, void>)vt[45])(pos, cond, pivot);
			#endif
		}

		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, cond, pivot);
		}

		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetNextWindowPosNative(pos, cond, (Vector2)(new Vector2(0,0)));
		}

		public static void SetNextWindowPos(Vector2 pos)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), (Vector2)(new Vector2(0,0)));
		}

		public static void SetNextWindowPos(Vector2 pos, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), pivot);
		}

		internal static void SetNextWindowSizeNative(Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[46])(size, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[46])(size, cond);
			#endif
		}

		public static void SetNextWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetNextWindowSizeNative(size, cond);
		}

		public static void SetNextWindowSize(Vector2 size)
		{
			SetNextWindowSizeNative(size, (ImGuiCond)(0));
		}

		internal static void SetNextWindowSizeConstraintsNative(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, delegate*<ImGuiSizeCallbackData*, void>, void*, void>)vt[47])(sizeMin, sizeMax, (delegate*<ImGuiSizeCallbackData*, void>)Utils.GetFunctionPointerForDelegate(customCallback), customCallbackData);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, nint, nint, void>)vt[47])(sizeMin, sizeMax, (nint)Utils.GetFunctionPointerForDelegate(customCallback), (nint)customCallbackData);
			#endif
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, customCallbackData);
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, (void*)(default));
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), (void*)(default));
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), customCallbackData);
		}

		internal static void SetNextWindowContentSizeNative(Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[48])(size);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[48])(size);
			#endif
		}

		public static void SetNextWindowContentSize(Vector2 size)
		{
			SetNextWindowContentSizeNative(size);
		}

		internal static void SetNextWindowCollapsedNative(byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[49])(collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[49])(collapsed, cond);
			#endif
		}

		public static void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetNextWindowCollapsed(bool collapsed)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		internal static void SetNextWindowFocusNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[50])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[50])();
			#endif
		}

		public static void SetNextWindowFocus()
		{
			SetNextWindowFocusNative();
		}

		internal static void SetNextWindowScrollNative(Vector2 scroll)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[51])(scroll);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[51])(scroll);
			#endif
		}

		public static void SetNextWindowScroll(Vector2 scroll)
		{
			SetNextWindowScrollNative(scroll);
		}

		internal static void SetNextWindowBgAlphaNative(float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[52])(alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[52])(alpha);
			#endif
		}

		public static void SetNextWindowBgAlpha(float alpha)
		{
			SetNextWindowBgAlphaNative(alpha);
		}

		internal static void SetNextWindowViewportNative(int viewportId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[53])(viewportId);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[53])(viewportId);
			#endif
		}

		public static void SetNextWindowViewport(int viewportId)
		{
			SetNextWindowViewportNative(viewportId);
		}

		internal static void SetWindowPosNative(Vector2 pos, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[54])(pos, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[54])(pos, cond);
			#endif
		}

		public static void SetWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(pos, cond);
		}

		public static void SetWindowPos(Vector2 pos)
		{
			SetWindowPosNative(pos, (ImGuiCond)(0));
		}

		internal static void SetWindowSizeNative(Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[55])(size, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[55])(size, cond);
			#endif
		}

		public static void SetWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(size, cond);
		}

		public static void SetWindowSize(Vector2 size)
		{
			SetWindowSizeNative(size, (ImGuiCond)(0));
		}

		internal static void SetWindowCollapsedNative(byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[56])(collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[56])(collapsed, cond);
			#endif
		}

		public static void SetWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsed(bool collapsed)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		internal static void SetWindowFocusNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[57])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[57])();
			#endif
		}

		public static void SetWindowFocus()
		{
			SetWindowFocusNative();
		}

		internal static void SetWindowFontScaleNative(float scale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[58])(scale);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[58])(scale);
			#endif
		}

		public static void SetWindowFontScale(float scale)
		{
			SetWindowFontScaleNative(scale);
		}

		internal static void SetWindowPosNative(byte* name, Vector2 pos, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiCond, void>)vt[59])(name, pos, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)vt[59])((nint)name, pos, cond);
			#endif
		}

		public static void SetWindowPos(byte* name, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(name, pos, cond);
		}

		public static void SetWindowPos(byte* name, Vector2 pos)
		{
			SetWindowPosNative(name, pos, (ImGuiCond)(0));
		}

		public static void SetWindowPos(ref byte name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, cond);
			}
		}

		public static void SetWindowPos(ref byte name, Vector2 pos)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		public static void SetWindowPos(string name, Vector2 pos, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowPos(string name, Vector2 pos)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowPos(ReadOnlySpan<byte> name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowPosNative((byte*)pname, pos, cond);
			}
		}

		public static void SetWindowPos(ReadOnlySpan<byte> name, Vector2 pos)
		{
			fixed (byte* pname = name)
			{
				SetWindowPosNative((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		internal static void SetWindowSizeNative(byte* name, Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiCond, void>)vt[60])(name, size, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)vt[60])((nint)name, size, cond);
			#endif
		}

		public static void SetWindowSize(byte* name, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(name, size, cond);
		}

		public static void SetWindowSize(byte* name, Vector2 size)
		{
			SetWindowSizeNative(name, size, (ImGuiCond)(0));
		}

		public static void SetWindowSize(ref byte name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, cond);
			}
		}

		public static void SetWindowSize(ref byte name, Vector2 size)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		public static void SetWindowSize(string name, Vector2 size, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowSize(string name, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowSize(ReadOnlySpan<byte> name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowSizeNative((byte*)pname, size, cond);
			}
		}

		public static void SetWindowSize(ReadOnlySpan<byte> name, Vector2 size)
		{
			fixed (byte* pname = name)
			{
				SetWindowSizeNative((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		internal static void SetWindowCollapsedNative(byte* name, byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte, ImGuiCond, void>)vt[61])(name, collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, ImGuiCond, void>)vt[61])((nint)name, collapsed, cond);
			#endif
		}

		public static void SetWindowCollapsed(byte* name, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsed(byte* name, bool collapsed)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		public static void SetWindowCollapsed(ref byte name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		public static void SetWindowCollapsed(ref byte name, bool collapsed)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		public static void SetWindowCollapsed(string name, bool collapsed, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowCollapsed(string name, bool collapsed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowCollapsed(ReadOnlySpan<byte> name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		public static void SetWindowCollapsed(ReadOnlySpan<byte> name, bool collapsed)
		{
			fixed (byte* pname = name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		internal static void SetWindowFocusNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[62])(name);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[62])((nint)name);
			#endif
		}

		public static void SetWindowFocus(byte* name)
		{
			SetWindowFocusNative(name);
		}

		public static void SetWindowFocus(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SetWindowFocusNative((byte*)pname);
			}
		}

		public static void SetWindowFocus(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowFocusNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowFocus(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SetWindowFocusNative((byte*)pname);
			}
		}

		internal static float GetScrollXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[63])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[63])();
			#endif
		}

		public static float GetScrollX()
		{
			float ret = GetScrollXNative();
			return ret;
		}

		internal static float GetScrollYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[64])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[64])();
			#endif
		}

		public static float GetScrollY()
		{
			float ret = GetScrollYNative();
			return ret;
		}

		internal static void SetScrollXNative(float scrollX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[65])(scrollX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[65])(scrollX);
			#endif
		}

		public static void SetScrollX(float scrollX)
		{
			SetScrollXNative(scrollX);
		}

		internal static void SetScrollYNative(float scrollY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[66])(scrollY);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[66])(scrollY);
			#endif
		}

		public static void SetScrollY(float scrollY)
		{
			SetScrollYNative(scrollY);
		}

		internal static float GetScrollMaxXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[67])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[67])();
			#endif
		}

		public static float GetScrollMaxX()
		{
			float ret = GetScrollMaxXNative();
			return ret;
		}

		internal static float GetScrollMaxYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[68])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[68])();
			#endif
		}

		public static float GetScrollMaxY()
		{
			float ret = GetScrollMaxYNative();
			return ret;
		}

		internal static void SetScrollHereXNative(float centerXRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[69])(centerXRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[69])(centerXRatio);
			#endif
		}

		public static void SetScrollHereX(float centerXRatio)
		{
			SetScrollHereXNative(centerXRatio);
		}

		public static void SetScrollHereX()
		{
			SetScrollHereXNative((float)(0.5f));
		}

		internal static void SetScrollHereYNative(float centerYRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[70])(centerYRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[70])(centerYRatio);
			#endif
		}

		public static void SetScrollHereY(float centerYRatio)
		{
			SetScrollHereYNative(centerYRatio);
		}

		public static void SetScrollHereY()
		{
			SetScrollHereYNative((float)(0.5f));
		}

		internal static void SetScrollFromPosXNative(float localX, float centerXRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[71])(localX, centerXRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[71])(localX, centerXRatio);
			#endif
		}

		public static void SetScrollFromPosX(float localX, float centerXRatio)
		{
			SetScrollFromPosXNative(localX, centerXRatio);
		}

		public static void SetScrollFromPosX(float localX)
		{
			SetScrollFromPosXNative(localX, (float)(0.5f));
		}

		internal static void SetScrollFromPosYNative(float localY, float centerYRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[72])(localY, centerYRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[72])(localY, centerYRatio);
			#endif
		}

		public static void SetScrollFromPosY(float localY, float centerYRatio)
		{
			SetScrollFromPosYNative(localY, centerYRatio);
		}

		public static void SetScrollFromPosY(float localY)
		{
			SetScrollFromPosYNative(localY, (float)(0.5f));
		}

		internal static void PushFontNative(ImFont* font)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImFont*, void>)vt[73])(font);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[73])((nint)font);
			#endif
		}

		public static void PushFont(ImFontPtr font)
		{
			PushFontNative(font);
		}

		public static void PushFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				PushFontNative((ImFont*)pfont);
			}
		}

		internal static void PopFontNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[74])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[74])();
			#endif
		}

		public static void PopFont()
		{
			PopFontNative();
		}

		internal static void PushStyleColorNative(ImGuiCol idx, uint col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiCol, uint, void>)vt[75])(idx, col);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiCol, uint, void>)vt[75])(idx, col);
			#endif
		}

		public static void PushStyleColor(ImGuiCol idx, uint col)
		{
			PushStyleColorNative(idx, col);
		}

		internal static void PushStyleColorNative(ImGuiCol idx, Vector4 col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4, void>)vt[76])(idx, col);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4, void>)vt[76])(idx, col);
			#endif
		}

		public static void PushStyleColor(ImGuiCol idx, Vector4 col)
		{
			PushStyleColorNative(idx, col);
		}

		internal static void PopStyleColorNative(int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[77])(count);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[77])(count);
			#endif
		}

		public static void PopStyleColor(int count)
		{
			PopStyleColorNative(count);
		}

		public static void PopStyleColor()
		{
			PopStyleColorNative((int)(1));
		}

		internal static void PushStyleVarNative(ImGuiStyleVar idx, float val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)vt[78])(idx, val);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)vt[78])(idx, val);
			#endif
		}

		public static void PushStyleVar(ImGuiStyleVar idx, float val)
		{
			PushStyleVarNative(idx, val);
		}

		internal static void PushStyleVarNative(ImGuiStyleVar idx, Vector2 val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, void>)vt[79])(idx, val);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, void>)vt[79])(idx, val);
			#endif
		}

		public static void PushStyleVar(ImGuiStyleVar idx, Vector2 val)
		{
			PushStyleVarNative(idx, val);
		}

		internal static void PopStyleVarNative(int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[80])(count);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[80])(count);
			#endif
		}

		public static void PopStyleVar(int count)
		{
			PopStyleVarNative(count);
		}

		public static void PopStyleVar()
		{
			PopStyleVarNative((int)(1));
		}

		internal static void PushItemFlagNative(ImGuiItemFlags option, byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiItemFlags, byte, void>)vt[81])(option, enabled);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiItemFlags, byte, void>)vt[81])(option, enabled);
			#endif
		}

		public static void PushItemFlag(ImGuiItemFlags option, bool enabled)
		{
			PushItemFlagNative(option, enabled ? (byte)1 : (byte)0);
		}

		internal static void PopItemFlagNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[82])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[82])();
			#endif
		}

		public static void PopItemFlag()
		{
			PopItemFlagNative();
		}

		internal static void PushItemWidthNative(float itemWidth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[83])(itemWidth);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[83])(itemWidth);
			#endif
		}

		public static void PushItemWidth(float itemWidth)
		{
			PushItemWidthNative(itemWidth);
		}

		internal static void PopItemWidthNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[84])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[84])();
			#endif
		}

		public static void PopItemWidth()
		{
			PopItemWidthNative();
		}

		internal static void SetNextItemWidthNative(float itemWidth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[85])(itemWidth);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[85])(itemWidth);
			#endif
		}

		public static void SetNextItemWidth(float itemWidth)
		{
			SetNextItemWidthNative(itemWidth);
		}

		internal static float CalcItemWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[86])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[86])();
			#endif
		}

		public static float CalcItemWidth()
		{
			float ret = CalcItemWidthNative();
			return ret;
		}

		internal static void PushTextWrapPosNative(float wrapLocalPosX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[87])(wrapLocalPosX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[87])(wrapLocalPosX);
			#endif
		}

		public static void PushTextWrapPos(float wrapLocalPosX)
		{
			PushTextWrapPosNative(wrapLocalPosX);
		}

		public static void PushTextWrapPos()
		{
			PushTextWrapPosNative((float)(0.0f));
		}

		internal static void PopTextWrapPosNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[88])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[88])();
			#endif
		}

		public static void PopTextWrapPos()
		{
			PopTextWrapPosNative();
		}

		internal static ImFont* GetFontNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFont*>)vt[89])();
			#else
			return (ImFont*)((delegate* unmanaged[Cdecl]<nint>)vt[89])();
			#endif
		}

		public static ImFontPtr GetFont()
		{
			ImFontPtr ret = GetFontNative();
			return ret;
		}

		internal static float GetFontSizeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[90])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[90])();
			#endif
		}

		public static float GetFontSize()
		{
			float ret = GetFontSizeNative();
			return ret;
		}

		internal static void GetFontTexUvWhitePixelNative(Vector2* output)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[91])(output);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[91])((nint)output);
			#endif
		}

		public static Vector2 GetFontTexUvWhitePixel()
		{
			Vector2 ret;
			GetFontTexUvWhitePixelNative(&ret);
			return ret;
		}

		public static void GetFontTexUvWhitePixel(Vector2* output)
		{
			GetFontTexUvWhitePixelNative(output);
		}

		public static void GetFontTexUvWhitePixel(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetFontTexUvWhitePixelNative((Vector2*)poutput);
			}
		}

		internal static uint GetColorU32Native(ImGuiCol idx, float alphaMul)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiCol, float, uint>)vt[92])(idx, alphaMul);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<ImGuiCol, float, uint>)vt[92])(idx, alphaMul);
			#endif
		}

		public static uint GetColorU32(ImGuiCol idx, float alphaMul)
		{
			uint ret = GetColorU32Native(idx, alphaMul);
			return ret;
		}

		public static uint GetColorU32(ImGuiCol idx)
		{
			uint ret = GetColorU32Native(idx, (float)(1.0f));
			return ret;
		}

		internal static uint GetColorU32Native(Vector4 col)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, uint>)vt[93])(col);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<Vector4, uint>)vt[93])(col);
			#endif
		}

		public static uint GetColorU32(Vector4 col)
		{
			uint ret = GetColorU32Native(col);
			return ret;
		}

		internal static uint GetColorU32Native(uint col, float alphaMul)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, float, uint>)vt[94])(col, alphaMul);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, float, uint>)vt[94])(col, alphaMul);
			#endif
		}

		public static uint GetColorU32(uint col, float alphaMul)
		{
			uint ret = GetColorU32Native(col, alphaMul);
			return ret;
		}

		public static uint GetColorU32(uint col)
		{
			uint ret = GetColorU32Native(col, (float)(1.0f));
			return ret;
		}

		internal static Vector4* GetStyleColorVec4Native(ImGuiCol idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4*>)vt[95])(idx);
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<ImGuiCol, nint>)vt[95])(idx);
			#endif
		}

		public static Vector4* GetStyleColorVec4(ImGuiCol idx)
		{
			Vector4* ret = GetStyleColorVec4Native(idx);
			return ret;
		}

		internal static void GetCursorScreenPosNative(Vector2* output)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[96])(output);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[96])((nint)output);
			#endif
		}

		public static Vector2 GetCursorScreenPos()
		{
			Vector2 ret;
			GetCursorScreenPosNative(&ret);
			return ret;
		}

		public static void GetCursorScreenPos(Vector2* output)
		{
			GetCursorScreenPosNative(output);
		}

		public static void GetCursorScreenPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorScreenPosNative((Vector2*)poutput);
			}
		}

		internal static void SetCursorScreenPosNative(Vector2 pos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[97])(pos);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[97])(pos);
			#endif
		}

		public static void SetCursorScreenPos(Vector2 pos)
		{
			SetCursorScreenPosNative(pos);
		}

		internal static void GetContentRegionAvailNative(Vector2* output)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[98])(output);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[98])((nint)output);
			#endif
		}

		public static Vector2 GetContentRegionAvail()
		{
			Vector2 ret;
			GetContentRegionAvailNative(&ret);
			return ret;
		}

		public static void GetContentRegionAvail(Vector2* output)
		{
			GetContentRegionAvailNative(output);
		}

		public static void GetContentRegionAvail(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionAvailNative((Vector2*)poutput);
			}
		}

		internal static void GetCursorPosNative(Vector2* output)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[99])(output);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[99])((nint)output);
			#endif
		}

		public static Vector2 GetCursorPos()
		{
			Vector2 ret;
			GetCursorPosNative(&ret);
			return ret;
		}

		public static void GetCursorPos(Vector2* output)
		{
			GetCursorPosNative(output);
		}

		public static void GetCursorPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorPosNative((Vector2*)poutput);
			}
		}

		internal static float GetCursorPosXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[100])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[100])();
			#endif
		}

		public static float GetCursorPosX()
		{
			float ret = GetCursorPosXNative();
			return ret;
		}

		internal static float GetCursorPosYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[101])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[101])();
			#endif
		}

		public static float GetCursorPosY()
		{
			float ret = GetCursorPosYNative();
			return ret;
		}

		internal static void SetCursorPosNative(Vector2 localPos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[102])(localPos);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[102])(localPos);
			#endif
		}

		public static void SetCursorPos(Vector2 localPos)
		{
			SetCursorPosNative(localPos);
		}

		internal static void SetCursorPosXNative(float localX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[103])(localX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[103])(localX);
			#endif
		}

		public static void SetCursorPosX(float localX)
		{
			SetCursorPosXNative(localX);
		}

		internal static void SetCursorPosYNative(float localY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[104])(localY);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[104])(localY);
			#endif
		}

		public static void SetCursorPosY(float localY)
		{
			SetCursorPosYNative(localY);
		}

		internal static void GetCursorStartPosNative(Vector2* output)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[105])(output);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[105])((nint)output);
			#endif
		}

		public static Vector2 GetCursorStartPos()
		{
			Vector2 ret;
			GetCursorStartPosNative(&ret);
			return ret;
		}

		public static void GetCursorStartPos(Vector2* output)
		{
			GetCursorStartPosNative(output);
		}

		public static void GetCursorStartPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorStartPosNative((Vector2*)poutput);
			}
		}

		internal static void SeparatorNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[106])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[106])();
			#endif
		}

		public static void Separator()
		{
			SeparatorNative();
		}

		internal static void SameLineNative(float offsetFromStartX, float spacing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[107])(offsetFromStartX, spacing);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[107])(offsetFromStartX, spacing);
			#endif
		}

		public static void SameLine(float offsetFromStartX, float spacing)
		{
			SameLineNative(offsetFromStartX, spacing);
		}

		public static void SameLine(float offsetFromStartX)
		{
			SameLineNative(offsetFromStartX, (float)(-1.0f));
		}

		public static void SameLine()
		{
			SameLineNative((float)(0.0f), (float)(-1.0f));
		}

		internal static void NewLineNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[108])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[108])();
			#endif
		}

		public static void NewLine()
		{
			NewLineNative();
		}

		internal static void SpacingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[109])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[109])();
			#endif
		}

		public static void Spacing()
		{
			SpacingNative();
		}

		internal static void DummyNative(Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[110])(size);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[110])(size);
			#endif
		}

		public static void Dummy(Vector2 size)
		{
			DummyNative(size);
		}

		internal static void IndentNative(float indentW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[111])(indentW);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[111])(indentW);
			#endif
		}

		public static void Indent(float indentW)
		{
			IndentNative(indentW);
		}

		public static void Indent()
		{
			IndentNative((float)(0.0f));
		}

		internal static void UnindentNative(float indentW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[112])(indentW);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[112])(indentW);
			#endif
		}

		public static void Unindent(float indentW)
		{
			UnindentNative(indentW);
		}

		public static void Unindent()
		{
			UnindentNative((float)(0.0f));
		}

		internal static void BeginGroupNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[113])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[113])();
			#endif
		}

		public static void BeginGroup()
		{
			BeginGroupNative();
		}

		internal static void EndGroupNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[114])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[114])();
			#endif
		}

		public static void EndGroup()
		{
			EndGroupNative();
		}

		internal static void AlignTextToFramePaddingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[115])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[115])();
			#endif
		}

		public static void AlignTextToFramePadding()
		{
			AlignTextToFramePaddingNative();
		}

		internal static float GetTextLineHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[116])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[116])();
			#endif
		}

		public static float GetTextLineHeight()
		{
			float ret = GetTextLineHeightNative();
			return ret;
		}

		internal static float GetTextLineHeightWithSpacingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[117])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[117])();
			#endif
		}

		public static float GetTextLineHeightWithSpacing()
		{
			float ret = GetTextLineHeightWithSpacingNative();
			return ret;
		}

		internal static float GetFrameHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[118])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[118])();
			#endif
		}

		public static float GetFrameHeight()
		{
			float ret = GetFrameHeightNative();
			return ret;
		}

		internal static float GetFrameHeightWithSpacingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[119])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[119])();
			#endif
		}

		public static float GetFrameHeightWithSpacing()
		{
			float ret = GetFrameHeightWithSpacingNative();
			return ret;
		}

		internal static void PushIDNative(byte* strId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[120])(strId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[120])((nint)strId);
			#endif
		}

		public static void PushID(byte* strId)
		{
			PushIDNative(strId);
		}

		public static void PushID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		public static void PushID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		internal static void PushIDNative(byte* strIdBegin, byte* strIdEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)vt[121])(strIdBegin, strIdEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[121])((nint)strIdBegin, (nint)strIdEnd);
			#endif
		}

		public static void PushID(byte* strIdBegin, byte* strIdEnd)
		{
			PushIDNative(strIdBegin, strIdEnd);
		}

		public static void PushID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		public static void PushID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		public static void PushID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		public static void PushID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		public static void PushID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		public static void PushID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PushIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(ReadOnlySpan<byte> strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		internal static void PushIDNative(void* ptrId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)vt[122])(ptrId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[122])((nint)ptrId);
			#endif
		}

		public static void PushID(void* ptrId)
		{
			PushIDNative(ptrId);
		}

		internal static void PushIDNative(int intId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[123])(intId);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[123])(intId);
			#endif
		}

		public static void PushID(int intId)
		{
			PushIDNative(intId);
		}

		internal static void PopIDNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[124])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[124])();
			#endif
		}

		public static void PopID()
		{
			PopIDNative();
		}

		internal static int GetIDNative(byte* strId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)vt[125])(strId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[125])((nint)strId);
			#endif
		}

		public static int GetID(byte* strId)
		{
			int ret = GetIDNative(strId);
			return ret;
		}

		public static int GetID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				int ret = GetIDNative((byte*)pstrId);
				return ret;
			}
		}

		public static int GetID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				int ret = GetIDNative((byte*)pstrId);
				return ret;
			}
		}

		internal static int GetIDNative(byte* strIdBegin, byte* strIdEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)vt[126])(strIdBegin, strIdEnd);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[126])((nint)strIdBegin, (nint)strIdEnd);
			#endif
		}

		public static int GetID(byte* strIdBegin, byte* strIdEnd)
		{
			int ret = GetIDNative(strIdBegin, strIdEnd);
			return ret;
		}

		public static int GetID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				int ret = GetIDNative((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		public static int GetID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				int ret = GetIDNative((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		public static int GetID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				int ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		public static int GetID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				int ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		public static int GetID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					int ret = GetIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		public static int GetID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = GetIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(ReadOnlySpan<byte> strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					int ret = GetIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		internal static int GetIDNative(void* ptrId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, int>)vt[127])(ptrId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[127])((nint)ptrId);
			#endif
		}

		public static int GetID(void* ptrId)
		{
			int ret = GetIDNative(ptrId);
			return ret;
		}

		internal static int GetIDNative(int intId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[128])(intId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)vt[128])(intId);
			#endif
		}

		public static int GetID(int intId)
		{
			int ret = GetIDNative(intId);
			return ret;
		}

		internal static void TextUnformattedNative(byte* text, byte* textEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)vt[129])(text, textEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[129])((nint)text, (nint)textEnd);
			#endif
		}

		public static void TextUnformatted(byte* text, byte* textEnd)
		{
			TextUnformattedNative(text, textEnd);
		}

		public static void TextUnformatted(byte* text)
		{
			TextUnformattedNative(text, (byte*)(default));
		}

		public static void TextUnformatted(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				TextUnformattedNative((byte*)ptext, textEnd);
			}
		}

		public static void TextUnformatted(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				TextUnformattedNative((byte*)ptext, (byte*)(default));
			}
		}

		public static void TextUnformatted(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (byte* ptext = text)
			{
				TextUnformattedNative((byte*)ptext, textEnd);
			}
		}

		public static void TextUnformatted(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				TextUnformattedNative((byte*)ptext, (byte*)(default));
			}
		}

		public static void TextUnformatted(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				TextUnformattedNative(text, (byte*)ptextEnd);
			}
		}

		public static void TextUnformatted(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				TextUnformattedNative(text, (byte*)ptextEnd);
			}
		}

		public static void TextUnformatted(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					TextUnformattedNative((byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void TextUnformatted(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			TextUnformattedNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					TextUnformattedNative((byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		internal static void TextNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[130])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[130])((nint)fmt);
			#endif
		}

		public static void Text(byte* fmt)
		{
			TextNative(fmt);
		}

		public static void Text(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextNative((byte*)pfmt);
			}
		}

		public static void Text(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Text(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TextNative((byte*)pfmt);
			}
		}

		internal static void TextVNative(byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, nuint, void>)vt[131])(fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)vt[131])((nint)fmt, args);
			#endif
		}

		public static void TextV(byte* fmt, nuint args)
		{
			TextVNative(fmt, args);
		}

		public static void TextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextVNative((byte*)pfmt, args);
			}
		}

		public static void TextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextV(ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				TextVNative((byte*)pfmt, args);
			}
		}

		internal static void TextColoredNative(Vector4 col, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4, byte*, void>)vt[132])(col, fmt);
			#else
			((delegate* unmanaged[Cdecl]<Vector4, nint, void>)vt[132])(col, (nint)fmt);
			#endif
		}

		public static void TextColored(Vector4 col, byte* fmt)
		{
			TextColoredNative(col, fmt);
		}

		public static void TextColored(Vector4 col, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredNative(col, (byte*)pfmt);
			}
		}

		public static void TextColored(Vector4 col, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredNative(col, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextColored(Vector4 col, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TextColoredNative(col, (byte*)pfmt);
			}
		}

		internal static void TextColoredVNative(Vector4 col, byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4, byte*, nuint, void>)vt[133])(col, fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<Vector4, nint, nuint, void>)vt[133])(col, (nint)fmt, args);
			#endif
		}

		public static void TextColoredV(Vector4 col, byte* fmt, nuint args)
		{
			TextColoredVNative(col, fmt, args);
		}

		public static void TextColoredV(Vector4 col, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredVNative(col, (byte*)pfmt, args);
			}
		}

		public static void TextColoredV(Vector4 col, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredVNative(col, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextColoredV(Vector4 col, ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				TextColoredVNative(col, (byte*)pfmt, args);
			}
		}

		internal static void TextDisabledNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[134])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[134])((nint)fmt);
			#endif
		}

		public static void TextDisabled(byte* fmt)
		{
			TextDisabledNative(fmt);
		}

		public static void TextDisabled(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextDisabledNative((byte*)pfmt);
			}
		}

		public static void TextDisabled(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextDisabledNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextDisabled(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TextDisabledNative((byte*)pfmt);
			}
		}

		internal static void TextDisabledVNative(byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, nuint, void>)vt[135])(fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)vt[135])((nint)fmt, args);
			#endif
		}

		public static void TextDisabledV(byte* fmt, nuint args)
		{
			TextDisabledVNative(fmt, args);
		}

		public static void TextDisabledV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextDisabledVNative((byte*)pfmt, args);
			}
		}

		public static void TextDisabledV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextDisabledVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextDisabledV(ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				TextDisabledVNative((byte*)pfmt, args);
			}
		}

		internal static void TextWrappedNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[136])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[136])((nint)fmt);
			#endif
		}

		public static void TextWrapped(byte* fmt)
		{
			TextWrappedNative(fmt);
		}

		public static void TextWrapped(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextWrappedNative((byte*)pfmt);
			}
		}

		public static void TextWrapped(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextWrappedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextWrapped(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TextWrappedNative((byte*)pfmt);
			}
		}

		internal static void TextWrappedVNative(byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, nuint, void>)vt[137])(fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)vt[137])((nint)fmt, args);
			#endif
		}

		public static void TextWrappedV(byte* fmt, nuint args)
		{
			TextWrappedVNative(fmt, args);
		}

		public static void TextWrappedV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextWrappedVNative((byte*)pfmt, args);
			}
		}

		public static void TextWrappedV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextWrappedVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextWrappedV(ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				TextWrappedVNative((byte*)pfmt, args);
			}
		}

		internal static void LabelTextNative(byte* label, byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)vt[138])(label, fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[138])((nint)label, (nint)fmt);
			#endif
		}

		public static void LabelText(byte* label, byte* fmt)
		{
			LabelTextNative(label, fmt);
		}

		public static void LabelText(ref byte label, byte* fmt)
		{
			fixed (byte* plabel = &label)
			{
				LabelTextNative((byte*)plabel, fmt);
			}
		}

		public static void LabelText(string label, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextNative(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(ReadOnlySpan<byte> label, byte* fmt)
		{
			fixed (byte* plabel = label)
			{
				LabelTextNative((byte*)plabel, fmt);
			}
		}

		public static void LabelText(byte* label, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextNative(label, (byte*)pfmt);
			}
		}

		public static void LabelText(byte* label, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextNative(label, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(byte* label, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				LabelTextNative(label, (byte*)pfmt);
			}
		}

		public static void LabelText(ref byte label, ref byte fmt)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pfmt = &fmt)
				{
					LabelTextNative((byte*)plabel, (byte*)pfmt);
				}
			}
		}

		public static void LabelText(string label, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LabelTextNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(ReadOnlySpan<byte> label, ReadOnlySpan<byte> fmt)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pfmt = fmt)
				{
					LabelTextNative((byte*)plabel, (byte*)pfmt);
				}
			}
		}

		internal static void LabelTextVNative(byte* label, byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, nuint, void>)vt[139])(label, fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)vt[139])((nint)label, (nint)fmt, args);
			#endif
		}

		public static void LabelTextV(byte* label, byte* fmt, nuint args)
		{
			LabelTextVNative(label, fmt, args);
		}

		public static void LabelTextV(ref byte label, byte* fmt, nuint args)
		{
			fixed (byte* plabel = &label)
			{
				LabelTextVNative((byte*)plabel, fmt, args);
			}
		}

		public static void LabelTextV(string label, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextVNative(pStr0, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(ReadOnlySpan<byte> label, byte* fmt, nuint args)
		{
			fixed (byte* plabel = label)
			{
				LabelTextVNative((byte*)plabel, fmt, args);
			}
		}

		public static void LabelTextV(byte* label, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextVNative(label, (byte*)pfmt, args);
			}
		}

		public static void LabelTextV(byte* label, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextVNative(label, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(byte* label, ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				LabelTextVNative(label, (byte*)pfmt, args);
			}
		}

		public static void LabelTextV(ref byte label, ref byte fmt, nuint args)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pfmt = &fmt)
				{
					LabelTextVNative((byte*)plabel, (byte*)pfmt, args);
				}
			}
		}

		public static void LabelTextV(string label, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LabelTextVNative(pStr0, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(ReadOnlySpan<byte> label, ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pfmt = fmt)
				{
					LabelTextVNative((byte*)plabel, (byte*)pfmt, args);
				}
			}
		}

		internal static void BulletTextNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[140])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[140])((nint)fmt);
			#endif
		}

		public static void BulletText(byte* fmt)
		{
			BulletTextNative(fmt);
		}

		public static void BulletText(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				BulletTextNative((byte*)pfmt);
			}
		}

		public static void BulletText(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BulletTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BulletText(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				BulletTextNative((byte*)pfmt);
			}
		}

		internal static void BulletTextVNative(byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, nuint, void>)vt[141])(fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)vt[141])((nint)fmt, args);
			#endif
		}

		public static void BulletTextV(byte* fmt, nuint args)
		{
			BulletTextVNative(fmt, args);
		}

		public static void BulletTextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				BulletTextVNative((byte*)pfmt, args);
			}
		}

		public static void BulletTextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BulletTextVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BulletTextV(ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				BulletTextVNative((byte*)pfmt, args);
			}
		}

		internal static void SeparatorTextNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[142])(label);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[142])((nint)label);
			#endif
		}

		public static void SeparatorText(byte* label)
		{
			SeparatorTextNative(label);
		}

		public static void SeparatorText(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				SeparatorTextNative((byte*)plabel);
			}
		}

		public static void SeparatorText(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SeparatorTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SeparatorText(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				SeparatorTextNative((byte*)plabel);
			}
		}
	}
}
