// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		public static void FindBestWindowPosForPopupEx(ref Vector2 output, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* poutput = &output)
			{
				FindBestWindowPosForPopupExNative((Vector2*)poutput, refPos, size, lastDir, rOuter, rAvoid, policy);
			}
		}

		public static Vector2 FindBestWindowPosForPopupEx(Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (ImGuiDir* plastDir = &lastDir)
			{
				Vector2 ret;
				FindBestWindowPosForPopupExNative(&ret, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				return ret;
			}
		}

		public static void FindBestWindowPosForPopupEx(Vector2* output, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (ImGuiDir* plastDir = &lastDir)
			{
				FindBestWindowPosForPopupExNative(output, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
			}
		}

		public static void FindBestWindowPosForPopupEx(ref Vector2 output, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiDir* plastDir = &lastDir)
				{
					FindBestWindowPosForPopupExNative((Vector2*)poutput, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				}
			}
		}

		internal static byte BeginTooltipExNative(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTooltipFlags, ImGuiWindowFlags, byte>)vt[1090])(tooltipFlags, extraWindowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiTooltipFlags, ImGuiWindowFlags, byte>)vt[1090])(tooltipFlags, extraWindowFlags);
			#endif
		}

		public static bool BeginTooltipEx(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags)
		{
			byte ret = BeginTooltipExNative(tooltipFlags, extraWindowFlags);
			return ret != 0;
		}

		internal static byte BeginTooltipHiddenNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[1091])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[1091])();
			#endif
		}

		public static bool BeginTooltipHidden()
		{
			byte ret = BeginTooltipHiddenNative();
			return ret != 0;
		}

		internal static byte BeginViewportSideBarNative(byte* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiViewport*, ImGuiDir, float, ImGuiWindowFlags, byte>)vt[1092])(name, viewport, dir, size, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ImGuiDir, float, ImGuiWindowFlags, byte>)vt[1092])((nint)name, (nint)viewport, dir, size, windowFlags);
			#endif
		}

		public static bool BeginViewportSideBar(byte* name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginViewportSideBarNative(name, viewport, dir, size, windowFlags);
			return ret != 0;
		}

		public static bool BeginViewportSideBar(ref byte name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginViewportSideBarNative((byte*)pname, viewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginViewportSideBar(string name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginViewportSideBarNative(pStr0, viewport, dir, size, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginViewportSideBar(ReadOnlySpan<byte> name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginViewportSideBarNative((byte*)pname, viewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginViewportSideBar(byte* name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = BeginViewportSideBarNative(name, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginViewportSideBar(ref byte name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					byte ret = BeginViewportSideBarNative((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret != 0;
				}
			}
		}

		public static bool BeginViewportSideBar(string name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = BeginViewportSideBarNative(pStr0, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool BeginViewportSideBar(ReadOnlySpan<byte> name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					byte ret = BeginViewportSideBarNative((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret != 0;
				}
			}
		}

		internal static byte BeginMenuExNative(byte* label, byte* icon, byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte, byte>)vt[1093])(label, icon, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte>)vt[1093])((nint)label, (nint)icon, enabled);
			#endif
		}

		public static bool BeginMenuEx(byte* label, byte* icon, bool enabled)
		{
			byte ret = BeginMenuExNative(label, icon, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool BeginMenuEx(ref byte label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginMenuExNative((byte*)plabel, icon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenuEx(string label, byte* icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, icon, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginMenuEx(ReadOnlySpan<byte> label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginMenuExNative((byte*)plabel, icon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenuEx(byte* label, ref byte icon, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = BeginMenuExNative(label, (byte*)picon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenuEx(byte* label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(label, pStr0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginMenuEx(byte* label, ReadOnlySpan<byte> icon, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte ret = BeginMenuExNative(label, (byte*)picon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenuEx(ref byte label, ref byte icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = BeginMenuExNative((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool BeginMenuEx(string label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, pStr1, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginMenuEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = BeginMenuExNative((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		internal static byte MenuItemExNative(byte* label, byte* icon, byte* shortcut, byte selected, byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, byte, byte, byte>)vt[1094])(label, icon, shortcut, selected, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, byte, byte>)vt[1094])((nint)label, (nint)icon, (nint)shortcut, selected, enabled);
			#endif
		}

		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte ret = MenuItemExNative(label, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(string label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(byte* label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(string label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(byte* label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, icon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(string label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(byte* label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		public static bool MenuItemEx(string label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, pStr2, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		internal static byte BeginComboPopupNative(int popupId, ImRect bb, ImGuiComboFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImRect, ImGuiComboFlags, byte>)vt[1095])(popupId, bb, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, ImRect, ImGuiComboFlags, byte>)vt[1095])(popupId, bb, flags);
			#endif
		}

		public static bool BeginComboPopup(int popupId, ImRect bb, ImGuiComboFlags flags)
		{
			byte ret = BeginComboPopupNative(popupId, bb, flags);
			return ret != 0;
		}

		internal static byte BeginComboPreviewNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[1096])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[1096])();
			#endif
		}

		public static bool BeginComboPreview()
		{
			byte ret = BeginComboPreviewNative();
			return ret != 0;
		}

		internal static void EndComboPreviewNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1097])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1097])();
			#endif
		}

		public static void EndComboPreview()
		{
			EndComboPreviewNative();
		}

		internal static void NavInitWindowNative(ImGuiWindow* window, byte forceReinit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte, void>)vt[1098])(window, forceReinit);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)vt[1098])((nint)window, forceReinit);
			#endif
		}

		public static void NavInitWindow(ImGuiWindowPtr window, bool forceReinit)
		{
			NavInitWindowNative(window, forceReinit ? (byte)1 : (byte)0);
		}

		public static void NavInitWindow(ref ImGuiWindow window, bool forceReinit)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavInitWindowNative((ImGuiWindow*)pwindow, forceReinit ? (byte)1 : (byte)0);
			}
		}

		internal static void NavInitRequestApplyResultNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1099])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1099])();
			#endif
		}

		public static void NavInitRequestApplyResult()
		{
			NavInitRequestApplyResultNative();
		}

		internal static byte NavMoveRequestButNoResultYetNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[1100])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[1100])();
			#endif
		}

		public static bool NavMoveRequestButNoResultYet()
		{
			byte ret = NavMoveRequestButNoResultYetNative();
			return ret != 0;
		}

		internal static void NavMoveRequestSubmitNative(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDir, ImGuiDir, ImGuiNavMoveFlags, ImGuiScrollFlags, void>)vt[1101])(moveDir, clipDir, moveFlags, scrollFlags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiDir, ImGuiDir, ImGuiNavMoveFlags, ImGuiScrollFlags, void>)vt[1101])(moveDir, clipDir, moveFlags, scrollFlags);
			#endif
		}

		public static void NavMoveRequestSubmit(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			NavMoveRequestSubmitNative(moveDir, clipDir, moveFlags, scrollFlags);
		}

		internal static void NavMoveRequestForwardNative(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDir, ImGuiDir, ImGuiNavMoveFlags, ImGuiScrollFlags, void>)vt[1102])(moveDir, clipDir, moveFlags, scrollFlags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiDir, ImGuiDir, ImGuiNavMoveFlags, ImGuiScrollFlags, void>)vt[1102])(moveDir, clipDir, moveFlags, scrollFlags);
			#endif
		}

		public static void NavMoveRequestForward(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			NavMoveRequestForwardNative(moveDir, clipDir, moveFlags, scrollFlags);
		}

		internal static void NavMoveRequestResolveWithLastItemNative(ImGuiNavItemData* result)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNavItemData*, void>)vt[1103])(result);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1103])((nint)result);
			#endif
		}

		public static void NavMoveRequestResolveWithLastItem(ImGuiNavItemDataPtr result)
		{
			NavMoveRequestResolveWithLastItemNative(result);
		}

		public static void NavMoveRequestResolveWithLastItem(ref ImGuiNavItemData result)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				NavMoveRequestResolveWithLastItemNative((ImGuiNavItemData*)presult);
			}
		}

		internal static void NavMoveRequestResolveWithPastTreeNodeNative(ImGuiNavItemData* result, ImGuiTreeNodeStackData* treeNodeData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNavItemData*, ImGuiTreeNodeStackData*, void>)vt[1104])(result, treeNodeData);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1104])((nint)result, (nint)treeNodeData);
			#endif
		}

		public static void NavMoveRequestResolveWithPastTreeNode(ImGuiNavItemDataPtr result, ImGuiTreeNodeStackDataPtr treeNodeData)
		{
			NavMoveRequestResolveWithPastTreeNodeNative(result, treeNodeData);
		}

		public static void NavMoveRequestResolveWithPastTreeNode(ref ImGuiNavItemData result, ImGuiTreeNodeStackDataPtr treeNodeData)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				NavMoveRequestResolveWithPastTreeNodeNative((ImGuiNavItemData*)presult, treeNodeData);
			}
		}

		public static void NavMoveRequestResolveWithPastTreeNode(ImGuiNavItemDataPtr result, ref ImGuiTreeNodeStackData treeNodeData)
		{
			fixed (ImGuiTreeNodeStackData* ptreeNodeData = &treeNodeData)
			{
				NavMoveRequestResolveWithPastTreeNodeNative(result, (ImGuiTreeNodeStackData*)ptreeNodeData);
			}
		}

		public static void NavMoveRequestResolveWithPastTreeNode(ref ImGuiNavItemData result, ref ImGuiTreeNodeStackData treeNodeData)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				fixed (ImGuiTreeNodeStackData* ptreeNodeData = &treeNodeData)
				{
					NavMoveRequestResolveWithPastTreeNodeNative((ImGuiNavItemData*)presult, (ImGuiTreeNodeStackData*)ptreeNodeData);
				}
			}
		}

		internal static void NavMoveRequestCancelNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1105])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1105])();
			#endif
		}

		public static void NavMoveRequestCancel()
		{
			NavMoveRequestCancelNative();
		}

		internal static void NavMoveRequestApplyResultNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1106])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1106])();
			#endif
		}

		public static void NavMoveRequestApplyResult()
		{
			NavMoveRequestApplyResultNative();
		}

		internal static void NavMoveRequestTryWrappingNative(ImGuiWindow* window, ImGuiNavMoveFlags moveFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiNavMoveFlags, void>)vt[1107])(window, moveFlags);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiNavMoveFlags, void>)vt[1107])((nint)window, moveFlags);
			#endif
		}

		public static void NavMoveRequestTryWrapping(ImGuiWindowPtr window, ImGuiNavMoveFlags moveFlags)
		{
			NavMoveRequestTryWrappingNative(window, moveFlags);
		}

		public static void NavMoveRequestTryWrapping(ref ImGuiWindow window, ImGuiNavMoveFlags moveFlags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavMoveRequestTryWrappingNative((ImGuiWindow*)pwindow, moveFlags);
			}
		}

		internal static void NavHighlightActivatedNative(int id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1108])(id);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1108])(id);
			#endif
		}

		public static void NavHighlightActivated(int id)
		{
			NavHighlightActivatedNative(id);
		}

		internal static void NavClearPreferredPosForAxisNative(ImGuiAxis axis)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiAxis, void>)vt[1109])(axis);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiAxis, void>)vt[1109])(axis);
			#endif
		}

		public static void NavClearPreferredPosForAxis(ImGuiAxis axis)
		{
			NavClearPreferredPosForAxisNative(axis);
		}

		internal static void NavRestoreHighlightAfterMoveNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1110])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1110])();
			#endif
		}

		public static void NavRestoreHighlightAfterMove()
		{
			NavRestoreHighlightAfterMoveNative();
		}

		internal static void NavUpdateCurrentWindowIsScrollPushableXNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1111])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1111])();
			#endif
		}

		public static void NavUpdateCurrentWindowIsScrollPushableX()
		{
			NavUpdateCurrentWindowIsScrollPushableXNative();
		}

		internal static void SetNavWindowNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)vt[1112])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1112])((nint)window);
			#endif
		}

		public static void SetNavWindow(ImGuiWindowPtr window)
		{
			SetNavWindowNative(window);
		}

		public static void SetNavWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetNavWindowNative((ImGuiWindow*)pwindow);
			}
		}

		internal static void SetNavIDNative(int id, ImGuiNavLayer navLayer, int focusScopeId, ImRect rectRel)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ImGuiNavLayer, int, ImRect, void>)vt[1113])(id, navLayer, focusScopeId, rectRel);
			#else
			((delegate* unmanaged[Cdecl]<int, ImGuiNavLayer, int, ImRect, void>)vt[1113])(id, navLayer, focusScopeId, rectRel);
			#endif
		}

		public static void SetNavID(int id, ImGuiNavLayer navLayer, int focusScopeId, ImRect rectRel)
		{
			SetNavIDNative(id, navLayer, focusScopeId, rectRel);
		}

		internal static void SetNavFocusScopeNative(int focusScopeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1114])(focusScopeId);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1114])(focusScopeId);
			#endif
		}

		public static void SetNavFocusScope(int focusScopeId)
		{
			SetNavFocusScopeNative(focusScopeId);
		}

		internal static void FocusItemNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1115])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1115])();
			#endif
		}

		public static void FocusItem()
		{
			FocusItemNative();
		}

		internal static void ActivateItemByIDNative(int id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1116])(id);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1116])(id);
			#endif
		}

		public static void ActivateItemByID(int id)
		{
			ActivateItemByIDNative(id);
		}

		internal static byte IsNamedKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1117])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1117])(key);
			#endif
		}

		public static bool IsNamedKey(ImGuiKey key)
		{
			byte ret = IsNamedKeyNative(key);
			return ret != 0;
		}

		internal static byte IsNamedKeyOrModNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1118])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1118])(key);
			#endif
		}

		public static bool IsNamedKeyOrMod(ImGuiKey key)
		{
			byte ret = IsNamedKeyOrModNative(key);
			return ret != 0;
		}

		internal static byte IsLegacyKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1119])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1119])(key);
			#endif
		}

		public static bool IsLegacyKey(ImGuiKey key)
		{
			byte ret = IsLegacyKeyNative(key);
			return ret != 0;
		}

		internal static byte IsKeyboardKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1120])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1120])(key);
			#endif
		}

		public static bool IsKeyboardKey(ImGuiKey key)
		{
			byte ret = IsKeyboardKeyNative(key);
			return ret != 0;
		}

		internal static byte IsGamepadKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1121])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1121])(key);
			#endif
		}

		public static bool IsGamepadKey(ImGuiKey key)
		{
			byte ret = IsGamepadKeyNative(key);
			return ret != 0;
		}

		internal static byte IsMouseKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1122])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1122])(key);
			#endif
		}

		public static bool IsMouseKey(ImGuiKey key)
		{
			byte ret = IsMouseKeyNative(key);
			return ret != 0;
		}

		internal static byte IsAliasKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1123])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1123])(key);
			#endif
		}

		public static bool IsAliasKey(ImGuiKey key)
		{
			byte ret = IsAliasKeyNative(key);
			return ret != 0;
		}

		internal static byte IsModKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1124])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[1124])(key);
			#endif
		}

		public static bool IsModKey(ImGuiKey key)
		{
			byte ret = IsModKeyNative(key);
			return ret != 0;
		}

		internal static int FixupKeyChordNative(int keyChord)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[1125])(keyChord);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)vt[1125])(keyChord);
			#endif
		}

		public static int FixupKeyChord(int keyChord)
		{
			int ret = FixupKeyChordNative(keyChord);
			return ret;
		}

		internal static ImGuiKey ConvertSingleModFlagToKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, ImGuiKey>)vt[1126])(key);
			#else
			return (ImGuiKey)((delegate* unmanaged[Cdecl]<ImGuiKey, ImGuiKey>)vt[1126])(key);
			#endif
		}

		public static ImGuiKey ConvertSingleModFlagToKey(ImGuiKey key)
		{
			ImGuiKey ret = ConvertSingleModFlagToKeyNative(key);
			return ret;
		}

		internal static ImGuiKeyData* GetKeyDataContextPtrNative(ImGuiContext* ctx, ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiKey, ImGuiKeyData*>)vt[1127])(ctx, key);
			#else
			return (ImGuiKeyData*)((delegate* unmanaged[Cdecl]<nint, ImGuiKey, nint>)vt[1127])((nint)ctx, key);
			#endif
		}

		public static ImGuiKeyDataPtr GetKeyDataContextPtr(ImGuiContextPtr ctx, ImGuiKey key)
		{
			ImGuiKeyDataPtr ret = GetKeyDataContextPtrNative(ctx, key);
			return ret;
		}

		public static ImGuiKeyDataPtr GetKeyDataContextPtr(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKeyDataPtr ret = GetKeyDataContextPtrNative((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		internal static ImGuiKeyData* GetKeyDataKeyNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, ImGuiKeyData*>)vt[1128])(key);
			#else
			return (ImGuiKeyData*)((delegate* unmanaged[Cdecl]<ImGuiKey, nint>)vt[1128])(key);
			#endif
		}

		public static ImGuiKeyDataPtr GetKeyDataKey(ImGuiKey key)
		{
			ImGuiKeyDataPtr ret = GetKeyDataKeyNative(key);
			return ret;
		}

		internal static ImGuiKey MouseButtonToKeyNative(ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, ImGuiKey>)vt[1129])(button);
			#else
			return (ImGuiKey)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, ImGuiKey>)vt[1129])(button);
			#endif
		}

		public static ImGuiKey MouseButtonToKey(ImGuiMouseButton button)
		{
			ImGuiKey ret = MouseButtonToKeyNative(button);
			return ret;
		}

		internal static byte IsMouseDragPastThresholdNative(ImGuiMouseButton button, float lockThreshold)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, float, byte>)vt[1130])(button, lockThreshold);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, float, byte>)vt[1130])(button, lockThreshold);
			#endif
		}

		public static bool IsMouseDragPastThreshold(ImGuiMouseButton button, float lockThreshold)
		{
			byte ret = IsMouseDragPastThresholdNative(button, lockThreshold);
			return ret != 0;
		}

		internal static void GetKeyMagnitude2dNative(Vector2* output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiKey, ImGuiKey, ImGuiKey, ImGuiKey, void>)vt[1131])(output, keyLeft, keyRight, keyUp, keyDown);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiKey, ImGuiKey, ImGuiKey, ImGuiKey, void>)vt[1131])((nint)output, keyLeft, keyRight, keyUp, keyDown);
			#endif
		}

		public static Vector2 GetKeyMagnitude2d(ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			Vector2 ret;
			GetKeyMagnitude2dNative(&ret, keyLeft, keyRight, keyUp, keyDown);
			return ret;
		}

		public static void GetKeyMagnitude2d(Vector2* output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			GetKeyMagnitude2dNative(output, keyLeft, keyRight, keyUp, keyDown);
		}

		public static void GetKeyMagnitude2d(ref Vector2 output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			fixed (Vector2* poutput = &output)
			{
				GetKeyMagnitude2dNative((Vector2*)poutput, keyLeft, keyRight, keyUp, keyDown);
			}
		}

		internal static float GetNavTweakPressedAmountNative(ImGuiAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiAxis, float>)vt[1132])(axis);
			#else
			return (float)((delegate* unmanaged[Cdecl]<ImGuiAxis, float>)vt[1132])(axis);
			#endif
		}

		public static float GetNavTweakPressedAmount(ImGuiAxis axis)
		{
			float ret = GetNavTweakPressedAmountNative(axis);
			return ret;
		}

		internal static int CalcTypematicRepeatAmountNative(float t0, float t1, float repeatDelay, float repeatRate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, int>)vt[1133])(t0, t1, repeatDelay, repeatRate);
			#else
			return (int)((delegate* unmanaged[Cdecl]<float, float, float, float, int>)vt[1133])(t0, t1, repeatDelay, repeatRate);
			#endif
		}

		public static int CalcTypematicRepeatAmount(float t0, float t1, float repeatDelay, float repeatRate)
		{
			int ret = CalcTypematicRepeatAmountNative(t0, t1, repeatDelay, repeatRate);
			return ret;
		}

		internal static void GetTypematicRepeatRateNative(ImGuiInputFlags flags, float* repeatDelay, float* repeatRate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputFlags, float*, float*, void>)vt[1134])(flags, repeatDelay, repeatRate);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiInputFlags, nint, nint, void>)vt[1134])(flags, (nint)repeatDelay, (nint)repeatRate);
			#endif
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeatDelay, float* repeatRate)
		{
			GetTypematicRepeatRateNative(flags, repeatDelay, repeatRate);
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, ref float repeatDelay, float* repeatRate)
		{
			fixed (float* prepeatDelay = &repeatDelay)
			{
				GetTypematicRepeatRateNative(flags, (float*)prepeatDelay, repeatRate);
			}
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeatDelay, ref float repeatRate)
		{
			fixed (float* prepeatRate = &repeatRate)
			{
				GetTypematicRepeatRateNative(flags, repeatDelay, (float*)prepeatRate);
			}
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, ref float repeatDelay, ref float repeatRate)
		{
			fixed (float* prepeatDelay = &repeatDelay)
			{
				fixed (float* prepeatRate = &repeatRate)
				{
					GetTypematicRepeatRateNative(flags, (float*)prepeatDelay, (float*)prepeatRate);
				}
			}
		}

		internal static void TeleportMousePosNative(Vector2 pos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[1135])(pos);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[1135])(pos);
			#endif
		}

		public static void TeleportMousePos(Vector2 pos)
		{
			TeleportMousePosNative(pos);
		}

		internal static void SetActiveIdUsingAllKeyboardKeysNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1136])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1136])();
			#endif
		}

		public static void SetActiveIdUsingAllKeyboardKeys()
		{
			SetActiveIdUsingAllKeyboardKeysNative();
		}

		internal static byte IsActiveIdUsingNavDirNative(ImGuiDir dir)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDir, byte>)vt[1137])(dir);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiDir, byte>)vt[1137])(dir);
			#endif
		}

		public static bool IsActiveIdUsingNavDir(ImGuiDir dir)
		{
			byte ret = IsActiveIdUsingNavDirNative(dir);
			return ret != 0;
		}

		internal static int GetKeyOwnerNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, int>)vt[1138])(key);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImGuiKey, int>)vt[1138])(key);
			#endif
		}

		public static int GetKeyOwner(ImGuiKey key)
		{
			int ret = GetKeyOwnerNative(key);
			return ret;
		}

		internal static void SetKeyOwnerNative(ImGuiKey key, int ownerId, ImGuiInputFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKey, int, ImGuiInputFlags, void>)vt[1139])(key, ownerId, flags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiKey, int, ImGuiInputFlags, void>)vt[1139])(key, ownerId, flags);
			#endif
		}

		public static void SetKeyOwner(ImGuiKey key, int ownerId, ImGuiInputFlags flags)
		{
			SetKeyOwnerNative(key, ownerId, flags);
		}

		internal static void SetKeyOwnersForKeyChordNative(int key, int ownerId, ImGuiInputFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ImGuiInputFlags, void>)vt[1140])(key, ownerId, flags);
			#else
			((delegate* unmanaged[Cdecl]<int, int, ImGuiInputFlags, void>)vt[1140])(key, ownerId, flags);
			#endif
		}

		public static void SetKeyOwnersForKeyChord(int key, int ownerId, ImGuiInputFlags flags)
		{
			SetKeyOwnersForKeyChordNative(key, ownerId, flags);
		}

		internal static void SetItemKeyOwnerInputFlagsNative(ImGuiKey key, ImGuiInputFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKey, ImGuiInputFlags, void>)vt[1141])(key, flags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiKey, ImGuiInputFlags, void>)vt[1141])(key, flags);
			#endif
		}

		public static void SetItemKeyOwnerInputFlags(ImGuiKey key, ImGuiInputFlags flags)
		{
			SetItemKeyOwnerInputFlagsNative(key, flags);
		}

		internal static byte TestKeyOwnerNative(ImGuiKey key, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, int, byte>)vt[1142])(key, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, int, byte>)vt[1142])(key, ownerId);
			#endif
		}

		public static bool TestKeyOwner(ImGuiKey key, int ownerId)
		{
			byte ret = TestKeyOwnerNative(key, ownerId);
			return ret != 0;
		}

		internal static ImGuiKeyOwnerData* GetKeyOwnerDataNative(ImGuiContext* ctx, ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiKey, ImGuiKeyOwnerData*>)vt[1143])(ctx, key);
			#else
			return (ImGuiKeyOwnerData*)((delegate* unmanaged[Cdecl]<nint, ImGuiKey, nint>)vt[1143])((nint)ctx, key);
			#endif
		}

		public static ImGuiKeyOwnerDataPtr GetKeyOwnerData(ImGuiContextPtr ctx, ImGuiKey key)
		{
			ImGuiKeyOwnerDataPtr ret = GetKeyOwnerDataNative(ctx, key);
			return ret;
		}

		public static ImGuiKeyOwnerDataPtr GetKeyOwnerData(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKeyOwnerDataPtr ret = GetKeyOwnerDataNative((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		internal static byte IsKeyDownIDNative(ImGuiKey key, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, int, byte>)vt[1144])(key, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, int, byte>)vt[1144])(key, ownerId);
			#endif
		}

		public static bool IsKeyDownID(ImGuiKey key, int ownerId)
		{
			byte ret = IsKeyDownIDNative(key, ownerId);
			return ret != 0;
		}

		internal static byte IsKeyPressedInputFlagsNative(ImGuiKey key, ImGuiInputFlags flags, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, ImGuiInputFlags, int, byte>)vt[1145])(key, flags, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, ImGuiInputFlags, int, byte>)vt[1145])(key, flags, ownerId);
			#endif
		}

		public static bool IsKeyPressedInputFlags(ImGuiKey key, ImGuiInputFlags flags, int ownerId)
		{
			byte ret = IsKeyPressedInputFlagsNative(key, flags, ownerId);
			return ret != 0;
		}

		internal static byte IsKeyReleasedIDNative(ImGuiKey key, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, int, byte>)vt[1146])(key, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, int, byte>)vt[1146])(key, ownerId);
			#endif
		}

		public static bool IsKeyReleasedID(ImGuiKey key, int ownerId)
		{
			byte ret = IsKeyReleasedIDNative(key, ownerId);
			return ret != 0;
		}

		internal static byte IsKeyChordPressedInputFlagsNative(int keyChord, ImGuiInputFlags flags, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, int, byte>)vt[1147])(keyChord, flags, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, int, byte>)vt[1147])(keyChord, flags, ownerId);
			#endif
		}

		public static bool IsKeyChordPressedInputFlags(int keyChord, ImGuiInputFlags flags, int ownerId)
		{
			byte ret = IsKeyChordPressedInputFlagsNative(keyChord, flags, ownerId);
			return ret != 0;
		}

		internal static byte IsMouseDownIDNative(ImGuiMouseButton button, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int, byte>)vt[1148])(button, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int, byte>)vt[1148])(button, ownerId);
			#endif
		}

		public static bool IsMouseDownID(ImGuiMouseButton button, int ownerId)
		{
			byte ret = IsMouseDownIDNative(button, ownerId);
			return ret != 0;
		}

		internal static byte IsMouseClickedInputFlagsNative(ImGuiMouseButton button, ImGuiInputFlags flags, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, ImGuiInputFlags, int, byte>)vt[1149])(button, flags, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, ImGuiInputFlags, int, byte>)vt[1149])(button, flags, ownerId);
			#endif
		}

		public static bool IsMouseClickedInputFlags(ImGuiMouseButton button, ImGuiInputFlags flags, int ownerId)
		{
			byte ret = IsMouseClickedInputFlagsNative(button, flags, ownerId);
			return ret != 0;
		}

		internal static byte IsMouseReleasedIDNative(ImGuiMouseButton button, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int, byte>)vt[1150])(button, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int, byte>)vt[1150])(button, ownerId);
			#endif
		}

		public static bool IsMouseReleasedID(ImGuiMouseButton button, int ownerId)
		{
			byte ret = IsMouseReleasedIDNative(button, ownerId);
			return ret != 0;
		}

		internal static byte IsMouseDoubleClickedIDNative(ImGuiMouseButton button, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int, byte>)vt[1151])(button, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int, byte>)vt[1151])(button, ownerId);
			#endif
		}

		public static bool IsMouseDoubleClickedID(ImGuiMouseButton button, int ownerId)
		{
			byte ret = IsMouseDoubleClickedIDNative(button, ownerId);
			return ret != 0;
		}

		internal static byte ShortcutIDNative(int keyChord, ImGuiInputFlags flags, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, int, byte>)vt[1152])(keyChord, flags, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, int, byte>)vt[1152])(keyChord, flags, ownerId);
			#endif
		}

		public static bool ShortcutID(int keyChord, ImGuiInputFlags flags, int ownerId)
		{
			byte ret = ShortcutIDNative(keyChord, flags, ownerId);
			return ret != 0;
		}

		internal static byte SetShortcutRoutingNative(int keyChord, ImGuiInputFlags flags, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, int, byte>)vt[1153])(keyChord, flags, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, int, byte>)vt[1153])(keyChord, flags, ownerId);
			#endif
		}

		public static bool SetShortcutRouting(int keyChord, ImGuiInputFlags flags, int ownerId)
		{
			byte ret = SetShortcutRoutingNative(keyChord, flags, ownerId);
			return ret != 0;
		}

		internal static byte TestShortcutRoutingNative(int keyChord, int ownerId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte>)vt[1154])(keyChord, ownerId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, byte>)vt[1154])(keyChord, ownerId);
			#endif
		}

		public static bool TestShortcutRouting(int keyChord, int ownerId)
		{
			byte ret = TestShortcutRoutingNative(keyChord, ownerId);
			return ret != 0;
		}

		internal static ImGuiKeyRoutingData* GetShortcutRoutingDataNative(int keyChord)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiKeyRoutingData*>)vt[1155])(keyChord);
			#else
			return (ImGuiKeyRoutingData*)((delegate* unmanaged[Cdecl]<int, nint>)vt[1155])(keyChord);
			#endif
		}

		public static ImGuiKeyRoutingDataPtr GetShortcutRoutingData(int keyChord)
		{
			ImGuiKeyRoutingDataPtr ret = GetShortcutRoutingDataNative(keyChord);
			return ret;
		}

		internal static void DockContextInitializeNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[1156])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1156])((nint)ctx);
			#endif
		}

		public static void DockContextInitialize(ImGuiContextPtr ctx)
		{
			DockContextInitializeNative(ctx);
		}

		public static void DockContextInitialize(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextInitializeNative((ImGuiContext*)pctx);
			}
		}

		internal static void DockContextShutdownNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[1157])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1157])((nint)ctx);
			#endif
		}

		public static void DockContextShutdown(ImGuiContextPtr ctx)
		{
			DockContextShutdownNative(ctx);
		}

		public static void DockContextShutdown(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextShutdownNative((ImGuiContext*)pctx);
			}
		}

		internal static void DockContextClearNodesNative(ImGuiContext* ctx, int rootId, byte clearSettingsRefs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, int, byte, void>)vt[1158])(ctx, rootId, clearSettingsRefs);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, byte, void>)vt[1158])((nint)ctx, rootId, clearSettingsRefs);
			#endif
		}

		public static void DockContextClearNodes(ImGuiContextPtr ctx, int rootId, bool clearSettingsRefs)
		{
			DockContextClearNodesNative(ctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
		}

		public static void DockContextClearNodes(ref ImGuiContext ctx, int rootId, bool clearSettingsRefs)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextClearNodesNative((ImGuiContext*)pctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
			}
		}

		internal static void DockContextRebuildNodesNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[1159])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1159])((nint)ctx);
			#endif
		}

		public static void DockContextRebuildNodes(ImGuiContextPtr ctx)
		{
			DockContextRebuildNodesNative(ctx);
		}

		public static void DockContextRebuildNodes(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextRebuildNodesNative((ImGuiContext*)pctx);
			}
		}

		internal static void DockContextNewFrameUpdateUndockingNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[1160])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1160])((nint)ctx);
			#endif
		}

		public static void DockContextNewFrameUpdateUndocking(ImGuiContextPtr ctx)
		{
			DockContextNewFrameUpdateUndockingNative(ctx);
		}

		public static void DockContextNewFrameUpdateUndocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateUndockingNative((ImGuiContext*)pctx);
			}
		}

		internal static void DockContextNewFrameUpdateDockingNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[1161])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1161])((nint)ctx);
			#endif
		}

		public static void DockContextNewFrameUpdateDocking(ImGuiContextPtr ctx)
		{
			DockContextNewFrameUpdateDockingNative(ctx);
		}

		public static void DockContextNewFrameUpdateDocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateDockingNative((ImGuiContext*)pctx);
			}
		}

		internal static void DockContextEndFrameNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[1162])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1162])((nint)ctx);
			#endif
		}

		public static void DockContextEndFrame(ImGuiContextPtr ctx)
		{
			DockContextEndFrameNative(ctx);
		}

		public static void DockContextEndFrame(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextEndFrameNative((ImGuiContext*)pctx);
			}
		}

		internal static int DockContextGenNodeIDNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, int>)vt[1163])(ctx);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[1163])((nint)ctx);
			#endif
		}

		public static int DockContextGenNodeID(ImGuiContextPtr ctx)
		{
			int ret = DockContextGenNodeIDNative(ctx);
			return ret;
		}

		public static int DockContextGenNodeID(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				int ret = DockContextGenNodeIDNative((ImGuiContext*)pctx);
				return ret;
			}
		}

		internal static void DockContextQueueDockNative(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, byte splitOuter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiWindow*, ImGuiDockNode*, ImGuiWindow*, ImGuiDir, float, byte, void>)vt[1164])(ctx, target, targetNode, payload, splitDir, splitRatio, splitOuter);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, ImGuiDir, float, byte, void>)vt[1164])((nint)ctx, (nint)target, (nint)targetNode, (nint)payload, splitDir, splitRatio, splitOuter);
			#endif
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			DockContextQueueDockNative(ctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueDockNative((ImGuiContext*)pctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				DockContextQueueDockNative(ctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ppayload = &payload)
			{
				DockContextQueueDockNative(ctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative(ctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						fixed (ImGuiWindow* ppayload = &payload)
						{
							DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		internal static void DockContextQueueUndockWindowNative(ImGuiContext* ctx, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiWindow*, void>)vt[1165])(ctx, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1165])((nint)ctx, (nint)window);
			#endif
		}

		public static void DockContextQueueUndockWindow(ImGuiContextPtr ctx, ImGuiWindowPtr window)
		{
			DockContextQueueUndockWindowNative(ctx, window);
		}

		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ImGuiWindowPtr window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockWindowNative((ImGuiContext*)pctx, window);
			}
		}

		public static void DockContextQueueUndockWindow(ImGuiContextPtr ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextQueueUndockWindowNative(ctx, (ImGuiWindow*)pwindow);
			}
		}

		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextQueueUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow);
				}
			}
		}

		internal static void DockContextQueueUndockNodeNative(ImGuiContext* ctx, ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiDockNode*, void>)vt[1166])(ctx, node);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1166])((nint)ctx, (nint)node);
			#endif
		}

		public static void DockContextQueueUndockNode(ImGuiContextPtr ctx, ImGuiDockNodePtr node)
		{
			DockContextQueueUndockNodeNative(ctx, node);
		}

		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ImGuiDockNodePtr node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockNodeNative((ImGuiContext*)pctx, node);
			}
		}

		public static void DockContextQueueUndockNode(ImGuiContextPtr ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextQueueUndockNodeNative(ctx, (ImGuiDockNode*)pnode);
			}
		}

		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextQueueUndockNodeNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		internal static void DockContextProcessUndockWindowNative(ImGuiContext* ctx, ImGuiWindow* window, byte clearPersistentDockingRef)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiWindow*, byte, void>)vt[1167])(ctx, window, clearPersistentDockingRef);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, byte, void>)vt[1167])((nint)ctx, (nint)window, clearPersistentDockingRef);
			#endif
		}

		public static void DockContextProcessUndockWindow(ImGuiContextPtr ctx, ImGuiWindowPtr window, bool clearPersistentDockingRef)
		{
			DockContextProcessUndockWindowNative(ctx, window, clearPersistentDockingRef ? (byte)1 : (byte)0);
		}

		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ImGuiWindowPtr window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockWindowNative((ImGuiContext*)pctx, window, clearPersistentDockingRef ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextProcessUndockWindow(ImGuiContextPtr ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextProcessUndockWindowNative(ctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextProcessUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef ? (byte)1 : (byte)0);
				}
			}
		}

		internal static void DockContextProcessUndockNodeNative(ImGuiContext* ctx, ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiDockNode*, void>)vt[1168])(ctx, node);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1168])((nint)ctx, (nint)node);
			#endif
		}

		public static void DockContextProcessUndockNode(ImGuiContextPtr ctx, ImGuiDockNodePtr node)
		{
			DockContextProcessUndockNodeNative(ctx, node);
		}

		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ImGuiDockNodePtr node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockNodeNative((ImGuiContext*)pctx, node);
			}
		}

		public static void DockContextProcessUndockNode(ImGuiContextPtr ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextProcessUndockNodeNative(ctx, (ImGuiDockNode*)pnode);
			}
		}

		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextProcessUndockNodeNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		internal static byte DockContextCalcDropPosForDockingNative(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, byte splitOuter, Vector2* outPos)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiDockNode*, ImGuiWindow*, ImGuiDockNode*, ImGuiDir, byte, Vector2*, byte>)vt[1169])(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter, outPos);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, ImGuiDir, byte, nint, byte>)vt[1169])((nint)target, (nint)targetNode, (nint)payloadWindow, (nint)payloadNode, splitDir, splitOuter, (nint)outPos);
			#endif
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
			return ret != 0;
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (Vector2* poutPos = &outPos)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							fixed (Vector2* poutPos = &outPos)
							{
								byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		internal static ImGuiDockNode* DockContextFindNodeByIDNative(ImGuiContext* ctx, int id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, int, ImGuiDockNode*>)vt[1170])(ctx, id);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<nint, int, nint>)vt[1170])((nint)ctx, id);
			#endif
		}

		public static ImGuiDockNodePtr DockContextFindNodeByID(ImGuiContextPtr ctx, int id)
		{
			ImGuiDockNodePtr ret = DockContextFindNodeByIDNative(ctx, id);
			return ret;
		}

		public static ImGuiDockNodePtr DockContextFindNodeByID(ref ImGuiContext ctx, int id)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiDockNodePtr ret = DockContextFindNodeByIDNative((ImGuiContext*)pctx, id);
				return ret;
			}
		}

		internal static void DockNodeWindowMenuHandlerDefaultNative(ImGuiContext* ctx, ImGuiDockNode* node, ImGuiTabBar* tabBar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiDockNode*, ImGuiTabBar*, void>)vt[1171])(ctx, node, tabBar);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)vt[1171])((nint)ctx, (nint)node, (nint)tabBar);
			#endif
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContextPtr ctx, ImGuiDockNodePtr node, ImGuiTabBarPtr tabBar)
		{
			DockNodeWindowMenuHandlerDefaultNative(ctx, node, tabBar);
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ImGuiDockNodePtr node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, node, tabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContextPtr ctx, ref ImGuiDockNode node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockNodeWindowMenuHandlerDefaultNative(ctx, (ImGuiDockNode*)pnode, tabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ref ImGuiDockNode node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, tabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContextPtr ctx, ImGuiDockNodePtr node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				DockNodeWindowMenuHandlerDefaultNative(ctx, node, (ImGuiTabBar*)ptabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ImGuiDockNodePtr node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, node, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContextPtr ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandlerDefaultNative(ctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					fixed (ImGuiTabBar* ptabBar = &tabBar)
					{
						DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
					}
				}
			}
		}

		internal static byte DockNodeBeginAmendTabBarNative(ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[1172])(node);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[1172])((nint)node);
			#endif
		}

		public static bool DockNodeBeginAmendTabBar(ImGuiDockNodePtr node)
		{
			byte ret = DockNodeBeginAmendTabBarNative(node);
			return ret != 0;
		}

		public static bool DockNodeBeginAmendTabBar(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = DockNodeBeginAmendTabBarNative((ImGuiDockNode*)pnode);
				return ret != 0;
			}
		}

		internal static void DockNodeEndAmendTabBarNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1173])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1173])();
			#endif
		}

		public static void DockNodeEndAmendTabBar()
		{
			DockNodeEndAmendTabBarNative();
		}

		internal static ImGuiDockNode* DockNodeGetRootNodeNative(ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, ImGuiDockNode*>)vt[1174])(node);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[1174])((nint)node);
			#endif
		}

		public static ImGuiDockNodePtr DockNodeGetRootNode(ImGuiDockNodePtr node)
		{
			ImGuiDockNodePtr ret = DockNodeGetRootNodeNative(node);
			return ret;
		}

		public static ImGuiDockNodePtr DockNodeGetRootNode(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiDockNodePtr ret = DockNodeGetRootNodeNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		internal static byte DockNodeIsInHierarchyOfNative(ImGuiDockNode* node, ImGuiDockNode* parent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, ImGuiDockNode*, byte>)vt[1175])(node, parent);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)vt[1175])((nint)node, (nint)parent);
			#endif
		}

		public static bool DockNodeIsInHierarchyOf(ImGuiDockNodePtr node, ImGuiDockNodePtr parent)
		{
			byte ret = DockNodeIsInHierarchyOfNative(node, parent);
			return ret != 0;
		}

		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ImGuiDockNodePtr parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = DockNodeIsInHierarchyOfNative((ImGuiDockNode*)pnode, parent);
				return ret != 0;
			}
		}

		public static bool DockNodeIsInHierarchyOf(ImGuiDockNodePtr node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pparent = &parent)
			{
				byte ret = DockNodeIsInHierarchyOfNative(node, (ImGuiDockNode*)pparent);
				return ret != 0;
			}
		}

		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiDockNode* pparent = &parent)
				{
					byte ret = DockNodeIsInHierarchyOfNative((ImGuiDockNode*)pnode, (ImGuiDockNode*)pparent);
					return ret != 0;
				}
			}
		}

		internal static int DockNodeGetDepthNative(ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, int>)vt[1176])(node);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[1176])((nint)node);
			#endif
		}

		public static int DockNodeGetDepth(ImGuiDockNodePtr node)
		{
			int ret = DockNodeGetDepthNative(node);
			return ret;
		}

		public static int DockNodeGetDepth(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetDepthNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		internal static int DockNodeGetWindowMenuButtonIdNative(ImGuiDockNode* node)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, int>)vt[1177])(node);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[1177])((nint)node);
			#endif
		}

		public static int DockNodeGetWindowMenuButtonId(ImGuiDockNodePtr node)
		{
			int ret = DockNodeGetWindowMenuButtonIdNative(node);
			return ret;
		}

		public static int DockNodeGetWindowMenuButtonId(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetWindowMenuButtonIdNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		internal static ImGuiDockNode* GetWindowDockNodeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*>)vt[1178])();
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<nint>)vt[1178])();
			#endif
		}

		public static ImGuiDockNodePtr GetWindowDockNode()
		{
			ImGuiDockNodePtr ret = GetWindowDockNodeNative();
			return ret;
		}

		internal static byte GetWindowAlwaysWantOwnTabBarNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte>)vt[1179])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[1179])((nint)window);
			#endif
		}

		public static bool GetWindowAlwaysWantOwnTabBar(ImGuiWindowPtr window)
		{
			byte ret = GetWindowAlwaysWantOwnTabBarNative(window);
			return ret != 0;
		}

		public static bool GetWindowAlwaysWantOwnTabBar(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = GetWindowAlwaysWantOwnTabBarNative((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}

		internal static void BeginDockedNative(ImGuiWindow* window, bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, bool*, void>)vt[1180])(window, pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1180])((nint)window, (nint)pOpen);
			#endif
		}

		public static void BeginDocked(ImGuiWindowPtr window, bool* pOpen)
		{
			BeginDockedNative(window, pOpen);
		}

		public static void BeginDocked(ref ImGuiWindow window, bool* pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockedNative((ImGuiWindow*)pwindow, pOpen);
			}
		}

		public static void BeginDocked(ImGuiWindowPtr window, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				BeginDockedNative(window, (bool*)ppOpen);
			}
		}

		public static void BeginDocked(ref ImGuiWindow window, ref bool pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					BeginDockedNative((ImGuiWindow*)pwindow, (bool*)ppOpen);
				}
			}
		}

		internal static void BeginDockableDragDropSourceNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)vt[1181])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1181])((nint)window);
			#endif
		}

		public static void BeginDockableDragDropSource(ImGuiWindowPtr window)
		{
			BeginDockableDragDropSourceNative(window);
		}

		public static void BeginDockableDragDropSource(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropSourceNative((ImGuiWindow*)pwindow);
			}
		}

		internal static void BeginDockableDragDropTargetNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)vt[1182])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1182])((nint)window);
			#endif
		}

		public static void BeginDockableDragDropTarget(ImGuiWindowPtr window)
		{
			BeginDockableDragDropTargetNative(window);
		}

		public static void BeginDockableDragDropTarget(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropTargetNative((ImGuiWindow*)pwindow);
			}
		}

		internal static void SetWindowDockNative(ImGuiWindow* window, int dockId, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, int, ImGuiCond, void>)vt[1183])(window, dockId, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImGuiCond, void>)vt[1183])((nint)window, dockId, cond);
			#endif
		}

		public static void SetWindowDock(ImGuiWindowPtr window, int dockId, ImGuiCond cond)
		{
			SetWindowDockNative(window, dockId, cond);
		}

		public static void SetWindowDock(ref ImGuiWindow window, int dockId, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowDockNative((ImGuiWindow*)pwindow, dockId, cond);
			}
		}

		internal static void DockBuilderDockWindowNative(byte* windowName, int nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, void>)vt[1184])(windowName, nodeId);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[1184])((nint)windowName, nodeId);
			#endif
		}

		public static void DockBuilderDockWindow(byte* windowName, int nodeId)
		{
			DockBuilderDockWindowNative(windowName, nodeId);
		}

		public static void DockBuilderDockWindow(ref byte windowName, int nodeId)
		{
			fixed (byte* pwindowName = &windowName)
			{
				DockBuilderDockWindowNative((byte*)pwindowName, nodeId);
			}
		}

		public static void DockBuilderDockWindow(string windowName, int nodeId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (windowName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(windowName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(windowName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderDockWindowNative(pStr0, nodeId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderDockWindow(ReadOnlySpan<byte> windowName, int nodeId)
		{
			fixed (byte* pwindowName = windowName)
			{
				DockBuilderDockWindowNative((byte*)pwindowName, nodeId);
			}
		}

		internal static ImGuiDockNode* DockBuilderGetNodeNative(int nodeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiDockNode*>)vt[1185])(nodeId);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<int, nint>)vt[1185])(nodeId);
			#endif
		}

		public static ImGuiDockNodePtr DockBuilderGetNode(int nodeId)
		{
			ImGuiDockNodePtr ret = DockBuilderGetNodeNative(nodeId);
			return ret;
		}

		internal static ImGuiDockNode* DockBuilderGetCentralNodeNative(int nodeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiDockNode*>)vt[1186])(nodeId);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<int, nint>)vt[1186])(nodeId);
			#endif
		}

		public static ImGuiDockNodePtr DockBuilderGetCentralNode(int nodeId)
		{
			ImGuiDockNodePtr ret = DockBuilderGetCentralNodeNative(nodeId);
			return ret;
		}

		internal static int DockBuilderAddNodeNative(int nodeId, ImGuiDockNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiDockNodeFlags, int>)vt[1187])(nodeId, flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, ImGuiDockNodeFlags, int>)vt[1187])(nodeId, flags);
			#endif
		}

		public static int DockBuilderAddNode(int nodeId, ImGuiDockNodeFlags flags)
		{
			int ret = DockBuilderAddNodeNative(nodeId, flags);
			return ret;
		}

		internal static void DockBuilderRemoveNodeNative(int nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1188])(nodeId);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1188])(nodeId);
			#endif
		}

		public static void DockBuilderRemoveNode(int nodeId)
		{
			DockBuilderRemoveNodeNative(nodeId);
		}

		internal static void DockBuilderRemoveNodeDockedWindowsNative(int nodeId, byte clearSettingsRefs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte, void>)vt[1189])(nodeId, clearSettingsRefs);
			#else
			((delegate* unmanaged[Cdecl]<int, byte, void>)vt[1189])(nodeId, clearSettingsRefs);
			#endif
		}

		public static void DockBuilderRemoveNodeDockedWindows(int nodeId, bool clearSettingsRefs)
		{
			DockBuilderRemoveNodeDockedWindowsNative(nodeId, clearSettingsRefs ? (byte)1 : (byte)0);
		}

		internal static void DockBuilderRemoveNodeChildNodesNative(int nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1190])(nodeId);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1190])(nodeId);
			#endif
		}

		public static void DockBuilderRemoveNodeChildNodes(int nodeId)
		{
			DockBuilderRemoveNodeChildNodesNative(nodeId);
		}

		internal static void DockBuilderSetNodePosNative(int nodeId, Vector2 pos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, Vector2, void>)vt[1191])(nodeId, pos);
			#else
			((delegate* unmanaged[Cdecl]<int, Vector2, void>)vt[1191])(nodeId, pos);
			#endif
		}

		public static void DockBuilderSetNodePos(int nodeId, Vector2 pos)
		{
			DockBuilderSetNodePosNative(nodeId, pos);
		}

		internal static void DockBuilderSetNodeSizeNative(int nodeId, Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, Vector2, void>)vt[1192])(nodeId, size);
			#else
			((delegate* unmanaged[Cdecl]<int, Vector2, void>)vt[1192])(nodeId, size);
			#endif
		}

		public static void DockBuilderSetNodeSize(int nodeId, Vector2 size)
		{
			DockBuilderSetNodeSizeNative(nodeId, size);
		}

		internal static int DockBuilderSplitNodeNative(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, int* outIdAtOppositeDir)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiDir, float, int*, int*, int>)vt[1193])(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, outIdAtOppositeDir);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, ImGuiDir, float, nint, nint, int>)vt[1193])(nodeId, splitDir, sizeRatioForNodeAtDir, (nint)outIdAtDir, (nint)outIdAtOppositeDir);
			#endif
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, int* outIdAtOppositeDir)
		{
			int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, outIdAtOppositeDir);
			return ret;
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, ref int outIdAtDir, int* outIdAtOppositeDir)
		{
			fixed (int* poutIdAtDir = &outIdAtDir)
			{
				int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, (int*)poutIdAtDir, outIdAtOppositeDir);
				return ret;
			}
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, ref int outIdAtOppositeDir)
		{
			fixed (int* poutIdAtOppositeDir = &outIdAtOppositeDir)
			{
				int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, (int*)poutIdAtOppositeDir);
				return ret;
			}
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, ref int outIdAtDir, ref int outIdAtOppositeDir)
		{
			fixed (int* poutIdAtDir = &outIdAtDir)
			{
				fixed (int* poutIdAtOppositeDir = &outIdAtOppositeDir)
				{
					int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, (int*)poutIdAtDir, (int*)poutIdAtOppositeDir);
					return ret;
				}
			}
		}

		internal static void DockBuilderCopyDockSpaceNative(int srcDockspaceId, int dstDockspaceId, ImVector<ConstPointer<byte>>* inWindowRemapPairs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ImVector<ConstPointer<byte>>*, void>)vt[1194])(srcDockspaceId, dstDockspaceId, inWindowRemapPairs);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)vt[1194])(srcDockspaceId, dstDockspaceId, (nint)inWindowRemapPairs);
			#endif
		}

		public static void DockBuilderCopyDockSpace(int srcDockspaceId, int dstDockspaceId, ImVector<ConstPointer<byte>>* inWindowRemapPairs)
		{
			DockBuilderCopyDockSpaceNative(srcDockspaceId, dstDockspaceId, inWindowRemapPairs);
		}

		public static void DockBuilderCopyDockSpace(int srcDockspaceId, int dstDockspaceId, ref ImVector<ConstPointer<byte>> inWindowRemapPairs)
		{
			fixed (ImVector<ConstPointer<byte>>* pinWindowRemapPairs = &inWindowRemapPairs)
			{
				DockBuilderCopyDockSpaceNative(srcDockspaceId, dstDockspaceId, (ImVector<ConstPointer<byte>>*)pinWindowRemapPairs);
			}
		}

		internal static void DockBuilderCopyNodeNative(int srcNodeId, int dstNodeId, ImVector<int>* outNodeRemapPairs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ImVector<int>*, void>)vt[1195])(srcNodeId, dstNodeId, outNodeRemapPairs);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)vt[1195])(srcNodeId, dstNodeId, (nint)outNodeRemapPairs);
			#endif
		}

		public static void DockBuilderCopyNode(int srcNodeId, int dstNodeId, ImVector<int>* outNodeRemapPairs)
		{
			DockBuilderCopyNodeNative(srcNodeId, dstNodeId, outNodeRemapPairs);
		}

		public static void DockBuilderCopyNode(int srcNodeId, int dstNodeId, ref ImVector<int> outNodeRemapPairs)
		{
			fixed (ImVector<int>* poutNodeRemapPairs = &outNodeRemapPairs)
			{
				DockBuilderCopyNodeNative(srcNodeId, dstNodeId, (ImVector<int>*)poutNodeRemapPairs);
			}
		}

		internal static void DockBuilderCopyWindowSettingsNative(byte* srcName, byte* dstName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)vt[1196])(srcName, dstName);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1196])((nint)srcName, (nint)dstName);
			#endif
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, byte* dstName)
		{
			DockBuilderCopyWindowSettingsNative(srcName, dstName);
		}

		public static void DockBuilderCopyWindowSettings(ref byte srcName, byte* dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, dstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(string srcName, byte* dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, dstName);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, byte* dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, dstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, ref byte dstName)
		{
			fixed (byte* pdstName = &dstName)
			{
				DockBuilderCopyWindowSettingsNative(srcName, (byte*)pdstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dstName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(srcName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* pdstName = dstName)
			{
				DockBuilderCopyWindowSettingsNative(srcName, (byte*)pdstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(ref byte srcName, ref byte dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		public static void DockBuilderCopyWindowSettings(string srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (dstName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(dstName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				fixed (byte* pdstName = dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		internal static void DockBuilderFinishNative(int nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1197])(nodeId);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1197])(nodeId);
			#endif
		}

		public static void DockBuilderFinish(int nodeId)
		{
			DockBuilderFinishNative(nodeId);
		}

		internal static void PushFocusScopeNative(int id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1198])(id);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1198])(id);
			#endif
		}

		public static void PushFocusScope(int id)
		{
			PushFocusScopeNative(id);
		}

		internal static void PopFocusScopeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1199])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1199])();
			#endif
		}

		public static void PopFocusScope()
		{
			PopFocusScopeNative();
		}

		internal static int GetCurrentFocusScopeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[1200])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[1200])();
			#endif
		}

		public static int GetCurrentFocusScope()
		{
			int ret = GetCurrentFocusScopeNative();
			return ret;
		}

		internal static byte IsDragDropActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[1201])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[1201])();
			#endif
		}

		public static bool IsDragDropActive()
		{
			byte ret = IsDragDropActiveNative();
			return ret != 0;
		}

		internal static byte BeginDragDropTargetCustomNative(ImRect bb, int id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, int, byte>)vt[1202])(bb, id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, int, byte>)vt[1202])(bb, id);
			#endif
		}

		public static bool BeginDragDropTargetCustom(ImRect bb, int id)
		{
			byte ret = BeginDragDropTargetCustomNative(bb, id);
			return ret != 0;
		}

		internal static void ClearDragDropNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1203])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1203])();
			#endif
		}

		public static void ClearDragDrop()
		{
			ClearDragDropNative();
		}

		internal static byte IsDragDropPayloadBeingAcceptedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[1204])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[1204])();
			#endif
		}

		public static bool IsDragDropPayloadBeingAccepted()
		{
			byte ret = IsDragDropPayloadBeingAcceptedNative();
			return ret != 0;
		}

		internal static void RenderDragDropTargetRectNative(ImRect bb, ImRect itemClipRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect, ImRect, void>)vt[1205])(bb, itemClipRect);
			#else
			((delegate* unmanaged[Cdecl]<ImRect, ImRect, void>)vt[1205])(bb, itemClipRect);
			#endif
		}

		public static void RenderDragDropTargetRect(ImRect bb, ImRect itemClipRect)
		{
			RenderDragDropTargetRectNative(bb, itemClipRect);
		}

		internal static ImGuiTypingSelectRequest* GetTypingSelectRequestNative(ImGuiTypingSelectFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectFlags, ImGuiTypingSelectRequest*>)vt[1206])(flags);
			#else
			return (ImGuiTypingSelectRequest*)((delegate* unmanaged[Cdecl]<ImGuiTypingSelectFlags, nint>)vt[1206])(flags);
			#endif
		}

		public static ImGuiTypingSelectRequestPtr GetTypingSelectRequest(ImGuiTypingSelectFlags flags)
		{
			ImGuiTypingSelectRequestPtr ret = GetTypingSelectRequestNative(flags);
			return ret;
		}

		internal static int TypingSelectFindMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int>, void*, int, int>)vt[1207])(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, int>)vt[1207])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData, navItemIdx);
			#endif
		}

		public static int TypingSelectFindMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			int ret = TypingSelectFindMatchNative(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			return ret;
		}

		public static int TypingSelectFindMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData, navItemIdx);
				return ret;
			}
		}

		internal static int TypingSelectFindNextSingleCharMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int>, void*, int, int>)vt[1208])(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, int>)vt[1208])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData, navItemIdx);
			#endif
		}

		public static int TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			int ret = TypingSelectFindNextSingleCharMatchNative(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			return ret;
		}

		public static int TypingSelectFindNextSingleCharMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindNextSingleCharMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData, navItemIdx);
				return ret;
			}
		}

		internal static int TypingSelectFindBestLeadingMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*> getItemNameFunc, void* userData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*>, void*, int>)vt[1209])(req, itemsCount, getItemNameFunc, userData);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int>)vt[1209])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData);
			#endif
		}

		public static int TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*> getItemNameFunc, void* userData)
		{
			int ret = TypingSelectFindBestLeadingMatchNative(req, itemsCount, getItemNameFunc, userData);
			return ret;
		}

		public static int TypingSelectFindBestLeadingMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*> getItemNameFunc, void* userData)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindBestLeadingMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData);
				return ret;
			}
		}

		internal static byte BeginBoxSelectNative(ImRect scopeRect, ImGuiWindow* window, int boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, ImGuiWindow*, int, ImGuiMultiSelectFlags, byte>)vt[1210])(scopeRect, window, boxSelectId, msFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, nint, int, ImGuiMultiSelectFlags, byte>)vt[1210])(scopeRect, (nint)window, boxSelectId, msFlags);
			#endif
		}

		public static bool BeginBoxSelect(ImRect scopeRect, ImGuiWindowPtr window, int boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			byte ret = BeginBoxSelectNative(scopeRect, window, boxSelectId, msFlags);
			return ret != 0;
		}

		public static bool BeginBoxSelect(ImRect scopeRect, ref ImGuiWindow window, int boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = BeginBoxSelectNative(scopeRect, (ImGuiWindow*)pwindow, boxSelectId, msFlags);
				return ret != 0;
			}
		}

		internal static void EndBoxSelectNative(ImRect scopeRect, ImGuiMultiSelectFlags msFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect, ImGuiMultiSelectFlags, void>)vt[1211])(scopeRect, msFlags);
			#else
			((delegate* unmanaged[Cdecl]<ImRect, ImGuiMultiSelectFlags, void>)vt[1211])(scopeRect, msFlags);
			#endif
		}

		public static void EndBoxSelect(ImRect scopeRect, ImGuiMultiSelectFlags msFlags)
		{
			EndBoxSelectNative(scopeRect, msFlags);
		}

		internal static void MultiSelectItemHeaderNative(int id, bool* pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, bool*, ImGuiButtonFlags*, void>)vt[1212])(id, pSelected, pButtonFlags);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, nint, void>)vt[1212])(id, (nint)pSelected, (nint)pButtonFlags);
			#endif
		}

		public static void MultiSelectItemHeader(int id, bool* pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			MultiSelectItemHeaderNative(id, pSelected, pButtonFlags);
		}

		public static void MultiSelectItemHeader(int id, ref bool pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				MultiSelectItemHeaderNative(id, (bool*)ppSelected, pButtonFlags);
			}
		}

		public static void MultiSelectItemHeader(int id, bool* pSelected, ref ImGuiButtonFlags pButtonFlags)
		{
			fixed (ImGuiButtonFlags* ppButtonFlags = &pButtonFlags)
			{
				MultiSelectItemHeaderNative(id, pSelected, (ImGuiButtonFlags*)ppButtonFlags);
			}
		}

		public static void MultiSelectItemHeader(int id, ref bool pSelected, ref ImGuiButtonFlags pButtonFlags)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				fixed (ImGuiButtonFlags* ppButtonFlags = &pButtonFlags)
				{
					MultiSelectItemHeaderNative(id, (bool*)ppSelected, (ImGuiButtonFlags*)ppButtonFlags);
				}
			}
		}

		internal static void MultiSelectItemFooterNative(int id, bool* pSelected, bool* pPressed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, bool*, bool*, void>)vt[1213])(id, pSelected, pPressed);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, nint, void>)vt[1213])(id, (nint)pSelected, (nint)pPressed);
			#endif
		}

		public static void MultiSelectItemFooter(int id, bool* pSelected, bool* pPressed)
		{
			MultiSelectItemFooterNative(id, pSelected, pPressed);
		}

		public static void MultiSelectItemFooter(int id, ref bool pSelected, bool* pPressed)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				MultiSelectItemFooterNative(id, (bool*)ppSelected, pPressed);
			}
		}

		public static void MultiSelectItemFooter(int id, bool* pSelected, ref bool pPressed)
		{
			fixed (bool* ppPressed = &pPressed)
			{
				MultiSelectItemFooterNative(id, pSelected, (bool*)ppPressed);
			}
		}

		public static void MultiSelectItemFooter(int id, ref bool pSelected, ref bool pPressed)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				fixed (bool* ppPressed = &pPressed)
				{
					MultiSelectItemFooterNative(id, (bool*)ppSelected, (bool*)ppPressed);
				}
			}
		}

		internal static void MultiSelectAddSetAllNative(ImGuiMultiSelectTempData* ms, byte selected)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, byte, void>)vt[1214])(ms, selected);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)vt[1214])((nint)ms, selected);
			#endif
		}

		public static void MultiSelectAddSetAll(ImGuiMultiSelectTempDataPtr ms, bool selected)
		{
			MultiSelectAddSetAllNative(ms, selected ? (byte)1 : (byte)0);
		}

		public static void MultiSelectAddSetAll(ref ImGuiMultiSelectTempData ms, bool selected)
		{
			fixed (ImGuiMultiSelectTempData* pms = &ms)
			{
				MultiSelectAddSetAllNative((ImGuiMultiSelectTempData*)pms, selected ? (byte)1 : (byte)0);
			}
		}

		internal static void MultiSelectAddSetRangeNative(ImGuiMultiSelectTempData* ms, byte selected, int rangeDir, long firstItem, long lastItem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, byte, int, long, long, void>)vt[1215])(ms, selected, rangeDir, firstItem, lastItem);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, int, long, long, void>)vt[1215])((nint)ms, selected, rangeDir, firstItem, lastItem);
			#endif
		}

		public static void MultiSelectAddSetRange(ImGuiMultiSelectTempDataPtr ms, bool selected, int rangeDir, long firstItem, long lastItem)
		{
			MultiSelectAddSetRangeNative(ms, selected ? (byte)1 : (byte)0, rangeDir, firstItem, lastItem);
		}

		public static void MultiSelectAddSetRange(ref ImGuiMultiSelectTempData ms, bool selected, int rangeDir, long firstItem, long lastItem)
		{
			fixed (ImGuiMultiSelectTempData* pms = &ms)
			{
				MultiSelectAddSetRangeNative((ImGuiMultiSelectTempData*)pms, selected ? (byte)1 : (byte)0, rangeDir, firstItem, lastItem);
			}
		}

		internal static ImGuiBoxSelectState* GetBoxSelectStateNative(int id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiBoxSelectState*>)vt[1216])(id);
			#else
			return (ImGuiBoxSelectState*)((delegate* unmanaged[Cdecl]<int, nint>)vt[1216])(id);
			#endif
		}

		public static ImGuiBoxSelectStatePtr GetBoxSelectState(int id)
		{
			ImGuiBoxSelectStatePtr ret = GetBoxSelectStateNative(id);
			return ret;
		}

		internal static ImGuiMultiSelectState* GetMultiSelectStateNative(int id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiMultiSelectState*>)vt[1217])(id);
			#else
			return (ImGuiMultiSelectState*)((delegate* unmanaged[Cdecl]<int, nint>)vt[1217])(id);
			#endif
		}

		public static ImGuiMultiSelectStatePtr GetMultiSelectState(int id)
		{
			ImGuiMultiSelectStatePtr ret = GetMultiSelectStateNative(id);
			return ret;
		}

		internal static void SetWindowClipRectBeforeSetChannelNative(ImGuiWindow* window, ImRect clipRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImRect, void>)vt[1218])(window, clipRect);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)vt[1218])((nint)window, clipRect);
			#endif
		}

		public static void SetWindowClipRectBeforeSetChannel(ImGuiWindowPtr window, ImRect clipRect)
		{
			SetWindowClipRectBeforeSetChannelNative(window, clipRect);
		}

		public static void SetWindowClipRectBeforeSetChannel(ref ImGuiWindow window, ImRect clipRect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowClipRectBeforeSetChannelNative((ImGuiWindow*)pwindow, clipRect);
			}
		}

		internal static void BeginColumnsNative(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, ImGuiOldColumnFlags, void>)vt[1219])(strId, count, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImGuiOldColumnFlags, void>)vt[1219])((nint)strId, count, flags);
			#endif
		}

		public static void BeginColumns(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			BeginColumnsNative(strId, count, flags);
		}

		public static void BeginColumns(ref byte strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				BeginColumnsNative((byte*)pstrId, count, flags);
			}
		}

		public static void BeginColumns(string strId, int count, ImGuiOldColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BeginColumnsNative(pStr0, count, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BeginColumns(ReadOnlySpan<byte> strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				BeginColumnsNative((byte*)pstrId, count, flags);
			}
		}

		internal static void EndColumnsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1220])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1220])();
			#endif
		}

		public static void EndColumns()
		{
			EndColumnsNative();
		}

		internal static void PushColumnClipRectNative(int columnIndex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1221])(columnIndex);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1221])(columnIndex);
			#endif
		}

		public static void PushColumnClipRect(int columnIndex)
		{
			PushColumnClipRectNative(columnIndex);
		}

		internal static void PushColumnsBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1222])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1222])();
			#endif
		}

		public static void PushColumnsBackground()
		{
			PushColumnsBackgroundNative();
		}

		internal static void PopColumnsBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1223])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1223])();
			#endif
		}

		public static void PopColumnsBackground()
		{
			PopColumnsBackgroundNative();
		}

		internal static int GetColumnsIDNative(byte* strId, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int>)vt[1224])(strId, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)vt[1224])((nint)strId, count);
			#endif
		}

		public static int GetColumnsID(byte* strId, int count)
		{
			int ret = GetColumnsIDNative(strId, count);
			return ret;
		}

		public static int GetColumnsID(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				int ret = GetColumnsIDNative((byte*)pstrId, count);
				return ret;
			}
		}

		public static int GetColumnsID(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetColumnsIDNative(pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetColumnsID(ReadOnlySpan<byte> strId, int count)
		{
			fixed (byte* pstrId = strId)
			{
				int ret = GetColumnsIDNative((byte*)pstrId, count);
				return ret;
			}
		}

		internal static ImGuiOldColumns* FindOrCreateColumnsNative(ImGuiWindow* window, int id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, int, ImGuiOldColumns*>)vt[1225])(window, id);
			#else
			return (ImGuiOldColumns*)((delegate* unmanaged[Cdecl]<nint, int, nint>)vt[1225])((nint)window, id);
			#endif
		}

		public static ImGuiOldColumnsPtr FindOrCreateColumns(ImGuiWindowPtr window, int id)
		{
			ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative(window, id);
			return ret;
		}

		public static ImGuiOldColumnsPtr FindOrCreateColumns(ref ImGuiWindow window, int id)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative((ImGuiWindow*)pwindow, id);
				return ret;
			}
		}

		internal static float GetColumnOffsetFromNormNative(ImGuiOldColumns* columns, float offsetNorm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*, float, float>)vt[1226])(columns, offsetNorm);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float>)vt[1226])((nint)columns, offsetNorm);
			#endif
		}

		public static float GetColumnOffsetFromNorm(ImGuiOldColumnsPtr columns, float offsetNorm)
		{
			float ret = GetColumnOffsetFromNormNative(columns, offsetNorm);
			return ret;
		}

		public static float GetColumnOffsetFromNorm(ref ImGuiOldColumns columns, float offsetNorm)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnOffsetFromNormNative((ImGuiOldColumns*)pcolumns, offsetNorm);
				return ret;
			}
		}

		internal static float GetColumnNormFromOffsetNative(ImGuiOldColumns* columns, float offset)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*, float, float>)vt[1227])(columns, offset);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float>)vt[1227])((nint)columns, offset);
			#endif
		}

		public static float GetColumnNormFromOffset(ImGuiOldColumnsPtr columns, float offset)
		{
			float ret = GetColumnNormFromOffsetNative(columns, offset);
			return ret;
		}

		public static float GetColumnNormFromOffset(ref ImGuiOldColumns columns, float offset)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnNormFromOffsetNative((ImGuiOldColumns*)pcolumns, offset);
				return ret;
			}
		}

		internal static void TableOpenContextMenuNative(int columnN)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1228])(columnN);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1228])(columnN);
			#endif
		}

		public static void TableOpenContextMenu(int columnN)
		{
			TableOpenContextMenuNative(columnN);
		}

		internal static void TableSetColumnWidthNative(int columnN, float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[1229])(columnN, width);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[1229])(columnN, width);
			#endif
		}

		public static void TableSetColumnWidth(int columnN, float width)
		{
			TableSetColumnWidthNative(columnN, width);
		}

		internal static void TableSetColumnSortDirectionNative(int columnN, ImGuiSortDirection sortDirection, byte appendToSortSpecs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ImGuiSortDirection, byte, void>)vt[1230])(columnN, sortDirection, appendToSortSpecs);
			#else
			((delegate* unmanaged[Cdecl]<int, ImGuiSortDirection, byte, void>)vt[1230])(columnN, sortDirection, appendToSortSpecs);
			#endif
		}

		public static void TableSetColumnSortDirection(int columnN, ImGuiSortDirection sortDirection, bool appendToSortSpecs)
		{
			TableSetColumnSortDirectionNative(columnN, sortDirection, appendToSortSpecs ? (byte)1 : (byte)0);
		}

		internal static int TableGetHoveredRowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[1231])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[1231])();
			#endif
		}

		public static int TableGetHoveredRow()
		{
			int ret = TableGetHoveredRowNative();
			return ret;
		}

		internal static float TableGetHeaderRowHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[1232])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[1232])();
			#endif
		}

		public static float TableGetHeaderRowHeight()
		{
			float ret = TableGetHeaderRowHeightNative();
			return ret;
		}

		internal static float TableGetHeaderAngledMaxLabelWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[1233])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[1233])();
			#endif
		}

		public static float TableGetHeaderAngledMaxLabelWidth()
		{
			float ret = TableGetHeaderAngledMaxLabelWidthNative();
			return ret;
		}

		internal static void TablePushBackgroundChannelNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1234])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1234])();
			#endif
		}

		public static void TablePushBackgroundChannel()
		{
			TablePushBackgroundChannelNative();
		}

		internal static void TablePopBackgroundChannelNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1235])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1235])();
			#endif
		}

		public static void TablePopBackgroundChannel()
		{
			TablePopBackgroundChannelNative();
		}

		internal static void TableAngledHeadersRowExNative(int rowId, float angle, float maxLabelWidth, ImGuiTableHeaderData* data, int dataCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, ImGuiTableHeaderData*, int, void>)vt[1236])(rowId, angle, maxLabelWidth, data, dataCount);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, nint, int, void>)vt[1236])(rowId, angle, maxLabelWidth, (nint)data, dataCount);
			#endif
		}

		public static void TableAngledHeadersRowEx(int rowId, float angle, float maxLabelWidth, ImGuiTableHeaderDataPtr data, int dataCount)
		{
			TableAngledHeadersRowExNative(rowId, angle, maxLabelWidth, data, dataCount);
		}

		public static void TableAngledHeadersRowEx(int rowId, float angle, float maxLabelWidth, ref ImGuiTableHeaderData data, int dataCount)
		{
			fixed (ImGuiTableHeaderData* pdata = &data)
			{
				TableAngledHeadersRowExNative(rowId, angle, maxLabelWidth, (ImGuiTableHeaderData*)pdata, dataCount);
			}
		}

		internal static ImGuiTable* GetCurrentTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*>)vt[1237])();
			#else
			return (ImGuiTable*)((delegate* unmanaged[Cdecl]<nint>)vt[1237])();
			#endif
		}

		public static ImGuiTablePtr GetCurrentTable()
		{
			ImGuiTablePtr ret = GetCurrentTableNative();
			return ret;
		}

		internal static ImGuiTable* TableFindByIDNative(int id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiTable*>)vt[1238])(id);
			#else
			return (ImGuiTable*)((delegate* unmanaged[Cdecl]<int, nint>)vt[1238])(id);
			#endif
		}

		public static ImGuiTablePtr TableFindByID(int id)
		{
			ImGuiTablePtr ret = TableFindByIDNative(id);
			return ret;
		}

		internal static byte BeginTableExNative(byte* name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int, ImGuiTableFlags, Vector2, float, byte>)vt[1239])(name, id, columnsCount, flags, outerSize, innerWidth);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, ImGuiTableFlags, Vector2, float, byte>)vt[1239])((nint)name, id, columnsCount, flags, outerSize, innerWidth);
			#endif
		}

		public static bool BeginTableEx(byte* name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, flags, outerSize, innerWidth);
			return ret != 0;
		}

		public static bool BeginTableEx(ref byte name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		public static bool BeginTableEx(string name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginTableEx(ReadOnlySpan<byte> name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		internal static void TableBeginInitMemoryNative(ImGuiTable* table, int columnsCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, int, void>)vt[1240])(table, columnsCount);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[1240])((nint)table, columnsCount);
			#endif
		}

		public static void TableBeginInitMemory(ImGuiTablePtr table, int columnsCount)
		{
			TableBeginInitMemoryNative(table, columnsCount);
		}

		public static void TableBeginInitMemory(ref ImGuiTable table, int columnsCount)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginInitMemoryNative((ImGuiTable*)ptable, columnsCount);
			}
		}

		internal static void TableBeginApplyRequestsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1241])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1241])((nint)table);
			#endif
		}

		public static void TableBeginApplyRequests(ImGuiTablePtr table)
		{
			TableBeginApplyRequestsNative(table);
		}

		public static void TableBeginApplyRequests(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginApplyRequestsNative((ImGuiTable*)ptable);
			}
		}

		internal static void TableSetupDrawChannelsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1242])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1242])((nint)table);
			#endif
		}

		public static void TableSetupDrawChannels(ImGuiTablePtr table)
		{
			TableSetupDrawChannelsNative(table);
		}

		public static void TableSetupDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetupDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		internal static void TableUpdateLayoutNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1243])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1243])((nint)table);
			#endif
		}

		public static void TableUpdateLayout(ImGuiTablePtr table)
		{
			TableUpdateLayoutNative(table);
		}

		public static void TableUpdateLayout(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateLayoutNative((ImGuiTable*)ptable);
			}
		}

		internal static void TableUpdateBordersNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1244])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1244])((nint)table);
			#endif
		}

		public static void TableUpdateBorders(ImGuiTablePtr table)
		{
			TableUpdateBordersNative(table);
		}

		public static void TableUpdateBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateBordersNative((ImGuiTable*)ptable);
			}
		}

		internal static void TableUpdateColumnsWeightFromWidthNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1245])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1245])((nint)table);
			#endif
		}

		public static void TableUpdateColumnsWeightFromWidth(ImGuiTablePtr table)
		{
			TableUpdateColumnsWeightFromWidthNative(table);
		}

		public static void TableUpdateColumnsWeightFromWidth(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateColumnsWeightFromWidthNative((ImGuiTable*)ptable);
			}
		}

		internal static void TableDrawBordersNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1246])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1246])((nint)table);
			#endif
		}

		public static void TableDrawBorders(ImGuiTablePtr table)
		{
			TableDrawBordersNative(table);
		}

		public static void TableDrawBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawBordersNative((ImGuiTable*)ptable);
			}
		}

		internal static void TableDrawDefaultContextMenuNative(ImGuiTable* table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, ImGuiTableFlags, void>)vt[1247])(table, flagsForSectionToDisplay);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiTableFlags, void>)vt[1247])((nint)table, flagsForSectionToDisplay);
			#endif
		}

		public static void TableDrawDefaultContextMenu(ImGuiTablePtr table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			TableDrawDefaultContextMenuNative(table, flagsForSectionToDisplay);
		}

		public static void TableDrawDefaultContextMenu(ref ImGuiTable table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawDefaultContextMenuNative((ImGuiTable*)ptable, flagsForSectionToDisplay);
			}
		}

		internal static byte TableBeginContextMenuPopupNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, byte>)vt[1248])(table);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[1248])((nint)table);
			#endif
		}

		public static bool TableBeginContextMenuPopup(ImGuiTablePtr table)
		{
			byte ret = TableBeginContextMenuPopupNative(table);
			return ret != 0;
		}

		public static bool TableBeginContextMenuPopup(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte ret = TableBeginContextMenuPopupNative((ImGuiTable*)ptable);
				return ret != 0;
			}
		}

		internal static void TableMergeDrawChannelsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1249])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1249])((nint)table);
			#endif
		}

		public static void TableMergeDrawChannels(ImGuiTablePtr table)
		{
			TableMergeDrawChannelsNative(table);
		}

		public static void TableMergeDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableMergeDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		internal static ImGuiTableInstanceData* TableGetInstanceDataNative(ImGuiTable* table, int instanceNo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, ImGuiTableInstanceData*>)vt[1250])(table, instanceNo);
			#else
			return (ImGuiTableInstanceData*)((delegate* unmanaged[Cdecl]<nint, int, nint>)vt[1250])((nint)table, instanceNo);
			#endif
		}

		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ImGuiTablePtr table, int instanceNo)
		{
			ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative(table, instanceNo);
			return ret;
		}

		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		internal static int TableGetInstanceIDNative(ImGuiTable* table, int instanceNo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, int>)vt[1251])(table, instanceNo);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)vt[1251])((nint)table, instanceNo);
			#endif
		}

		public static int TableGetInstanceID(ImGuiTablePtr table, int instanceNo)
		{
			int ret = TableGetInstanceIDNative(table, instanceNo);
			return ret;
		}

		public static int TableGetInstanceID(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				int ret = TableGetInstanceIDNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		internal static void TableSortSpecsSanitizeNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1252])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1252])((nint)table);
			#endif
		}

		public static void TableSortSpecsSanitize(ImGuiTablePtr table)
		{
			TableSortSpecsSanitizeNative(table);
		}

		public static void TableSortSpecsSanitize(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsSanitizeNative((ImGuiTable*)ptable);
			}
		}

		internal static void TableSortSpecsBuildNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1253])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1253])((nint)table);
			#endif
		}

		public static void TableSortSpecsBuild(ImGuiTablePtr table)
		{
			TableSortSpecsBuildNative(table);
		}

		public static void TableSortSpecsBuild(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsBuildNative((ImGuiTable*)ptable);
			}
		}

		internal static ImGuiSortDirection TableGetColumnNextSortDirectionNative(ImGuiTableColumn* column)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableColumn*, ImGuiSortDirection>)vt[1254])(column);
			#else
			return (ImGuiSortDirection)((delegate* unmanaged[Cdecl]<nint, ImGuiSortDirection>)vt[1254])((nint)column);
			#endif
		}

		public static ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumnPtr column)
		{
			ImGuiSortDirection ret = TableGetColumnNextSortDirectionNative(column);
			return ret;
		}

		public static ImGuiSortDirection TableGetColumnNextSortDirection(ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				ImGuiSortDirection ret = TableGetColumnNextSortDirectionNative((ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		internal static void TableFixColumnSortDirectionNative(ImGuiTable* table, ImGuiTableColumn* column)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, ImGuiTableColumn*, void>)vt[1255])(table, column);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1255])((nint)table, (nint)column);
			#endif
		}

		public static void TableFixColumnSortDirection(ImGuiTablePtr table, ImGuiTableColumnPtr column)
		{
			TableFixColumnSortDirectionNative(table, column);
		}

		public static void TableFixColumnSortDirection(ref ImGuiTable table, ImGuiTableColumnPtr column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableFixColumnSortDirectionNative((ImGuiTable*)ptable, column);
			}
		}

		public static void TableFixColumnSortDirection(ImGuiTablePtr table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				TableFixColumnSortDirectionNative(table, (ImGuiTableColumn*)pcolumn);
			}
		}

		public static void TableFixColumnSortDirection(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					TableFixColumnSortDirectionNative((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
				}
			}
		}

		internal static float TableGetColumnWidthAutoNative(ImGuiTable* table, ImGuiTableColumn* column)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, ImGuiTableColumn*, float>)vt[1256])(table, column);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, nint, float>)vt[1256])((nint)table, (nint)column);
			#endif
		}

		public static float TableGetColumnWidthAuto(ImGuiTablePtr table, ImGuiTableColumnPtr column)
		{
			float ret = TableGetColumnWidthAutoNative(table, column);
			return ret;
		}

		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ImGuiTableColumnPtr column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetColumnWidthAutoNative((ImGuiTable*)ptable, column);
				return ret;
			}
		}

		public static float TableGetColumnWidthAuto(ImGuiTablePtr table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				float ret = TableGetColumnWidthAutoNative(table, (ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					float ret = TableGetColumnWidthAutoNative((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
					return ret;
				}
			}
		}

		internal static void TableBeginRowNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1257])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1257])((nint)table);
			#endif
		}

		public static void TableBeginRow(ImGuiTablePtr table)
		{
			TableBeginRowNative(table);
		}

		public static void TableBeginRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginRowNative((ImGuiTable*)ptable);
			}
		}

		internal static void TableEndRowNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1258])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1258])((nint)table);
			#endif
		}
	}
}
