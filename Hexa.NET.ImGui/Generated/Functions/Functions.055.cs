// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TextIndexGetLineEnd(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextIndexGetLineEndNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TextIndexGetLineEndS(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextIndexGetLineEndNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TextIndexGetLineEnd(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = TextIndexGetLineEndNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TextIndexGetLineEndS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(TextIndexGetLineEndNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TextIndexGetLineEnd(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					byte* ret = TextIndexGetLineEndNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TextIndexGetLineEndS(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					string ret = Utils.DecodeStringUTF8(TextIndexGetLineEndNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TextIndexGetLineEnd(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = TextIndexGetLineEndNative((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TextIndexGetLineEndS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(TextIndexGetLineEndNative((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TextIndexAppendNative(ImGuiTextIndex* self, byte* baseValue, int oldSize, int newSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, byte*, int, int, void>)vt[819])(self, baseValue, oldSize, newSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)vt[819])((nint)self, (nint)baseValue, oldSize, newSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TextIndexAppend(ImGuiTextIndexPtr self, byte* baseValue, int oldSize, int newSize)
		{
			TextIndexAppendNative(self, baseValue, oldSize, newSize);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TextIndexAppend(ref ImGuiTextIndex self, byte* baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				TextIndexAppendNative((ImGuiTextIndex*)pself, baseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TextIndexAppend(ImGuiTextIndexPtr self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				TextIndexAppendNative(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TextIndexAppend(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				TextIndexAppendNative(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TextIndexAppend(ImGuiTextIndexPtr self, string baseValue, int oldSize, int newSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextIndexAppendNative(self, pStr0, oldSize, newSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TextIndexAppend(ref ImGuiTextIndex self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					TextIndexAppendNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TextIndexAppend(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					TextIndexAppendNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TextIndexAppend(ref ImGuiTextIndex self, string baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TextIndexAppendNative((ImGuiTextIndex*)pself, pStr0, oldSize, newSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStoragePair* ImLowerBoundNative(ImGuiStoragePair* inBegin, ImGuiStoragePair* inEnd, uint key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStoragePair*, ImGuiStoragePair*, uint, ImGuiStoragePair*>)vt[820])(inBegin, inEnd, key);
			#else
			return (ImGuiStoragePair*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint>)vt[820])((nint)inBegin, (nint)inEnd, key);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ImGuiStoragePairPtr inBegin, ImGuiStoragePairPtr inEnd, uint key)
		{
			ImGuiStoragePairPtr ret = ImLowerBoundNative(inBegin, inEnd, key);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ref ImGuiStoragePair inBegin, ImGuiStoragePairPtr inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinBegin = &inBegin)
			{
				ImGuiStoragePairPtr ret = ImLowerBoundNative((ImGuiStoragePair*)pinBegin, inEnd, key);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ImGuiStoragePairPtr inBegin, ref ImGuiStoragePair inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinEnd = &inEnd)
			{
				ImGuiStoragePairPtr ret = ImLowerBoundNative(inBegin, (ImGuiStoragePair*)pinEnd, key);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ref ImGuiStoragePair inBegin, ref ImGuiStoragePair inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinBegin = &inBegin)
			{
				fixed (ImGuiStoragePair* pinEnd = &inEnd)
				{
					ImGuiStoragePairPtr ret = ImLowerBoundNative((ImGuiStoragePair*)pinBegin, (ImGuiStoragePair*)pinEnd, key);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImDrawListSharedData* ImDrawListSharedDataImDrawListSharedDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawListSharedData*>)vt[821])();
			#else
			return (ImDrawListSharedData*)((delegate* unmanaged[Cdecl]<nint>)vt[821])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawListSharedDataPtr ImDrawListSharedDataImDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = ImDrawListSharedDataImDrawListSharedDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImDrawListSharedDataDestroyNative(ImDrawListSharedData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawListSharedData*, void>)vt[822])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[822])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImDrawListSharedDataDestroy(ImDrawListSharedDataPtr self)
		{
			ImDrawListSharedDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImDrawListSharedDataDestroy(ref ImDrawListSharedData self)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				ImDrawListSharedDataDestroyNative((ImDrawListSharedData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImDrawListSharedDataSetCircleTessellationMaxErrorNative(ImDrawListSharedData* self, float maxError)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawListSharedData*, float, void>)vt[823])(self, maxError);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)vt[823])((nint)self, maxError);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImDrawListSharedDataSetCircleTessellationMaxError(ImDrawListSharedDataPtr self, float maxError)
		{
			ImDrawListSharedDataSetCircleTessellationMaxErrorNative(self, maxError);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImDrawListSharedDataSetCircleTessellationMaxError(ref ImDrawListSharedData self, float maxError)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				ImDrawListSharedDataSetCircleTessellationMaxErrorNative((ImDrawListSharedData*)pself, maxError);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImDrawDataBuilder* ImDrawDataBuilderImDrawDataBuilderNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*>)vt[824])();
			#else
			return (ImDrawDataBuilder*)((delegate* unmanaged[Cdecl]<nint>)vt[824])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawDataBuilderPtr ImDrawDataBuilderImDrawDataBuilder()
		{
			ImDrawDataBuilderPtr ret = ImDrawDataBuilderImDrawDataBuilderNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImDrawDataBuilderDestroyNative(ImDrawDataBuilder* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*, void>)vt[825])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[825])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImDrawDataBuilderDestroy(ImDrawDataBuilderPtr self)
		{
			ImDrawDataBuilderDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImDrawDataBuilderDestroy(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImDrawDataBuilderDestroyNative((ImDrawDataBuilder*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void* DataVarInfoGetVarPtrNative(ImGuiDataVarInfo* self, void* parent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDataVarInfo*, void*, void*>)vt[826])(self, parent);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)vt[826])((nint)self, (nint)parent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* DataVarInfoGetVarPtr(ImGuiDataVarInfoPtr self, void* parent)
		{
			void* ret = DataVarInfoGetVarPtrNative(self, parent);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* DataVarInfoGetVarPtr(ref ImGuiDataVarInfo self, void* parent)
		{
			fixed (ImGuiDataVarInfo* pself = &self)
			{
				void* ret = DataVarInfoGetVarPtrNative((ImGuiDataVarInfo*)pself, parent);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStyleMod* StyleModImGuiStyleModIntNative(ImGuiStyleVar idx, int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, int, ImGuiStyleMod*>)vt[827])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, int, nint>)vt[827])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr StyleModImGuiStyleModInt(ImGuiStyleVar idx, int v)
		{
			ImGuiStyleModPtr ret = StyleModImGuiStyleModIntNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void StyleModDestroyNative(ImGuiStyleMod* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleMod*, void>)vt[828])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[828])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleModDestroy(ImGuiStyleModPtr self)
		{
			StyleModDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleModDestroy(ref ImGuiStyleMod self)
		{
			fixed (ImGuiStyleMod* pself = &self)
			{
				StyleModDestroyNative((ImGuiStyleMod*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStyleMod* StyleModImGuiStyleModFloatNative(ImGuiStyleVar idx, float v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, ImGuiStyleMod*>)vt[829])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, nint>)vt[829])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr StyleModImGuiStyleModFloat(ImGuiStyleVar idx, float v)
		{
			ImGuiStyleModPtr ret = StyleModImGuiStyleModFloatNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStyleMod* StyleModImGuiStyleModVec2Native(ImGuiStyleVar idx, Vector2 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, ImGuiStyleMod*>)vt[830])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, nint>)vt[830])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr StyleModImGuiStyleModVec2(ImGuiStyleVar idx, Vector2 v)
		{
			ImGuiStyleModPtr ret = StyleModImGuiStyleModVec2Native(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiComboPreviewData* ComboPreviewDataImGuiComboPreviewDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiComboPreviewData*>)vt[831])();
			#else
			return (ImGuiComboPreviewData*)((delegate* unmanaged[Cdecl]<nint>)vt[831])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiComboPreviewDataPtr ComboPreviewDataImGuiComboPreviewData()
		{
			ImGuiComboPreviewDataPtr ret = ComboPreviewDataImGuiComboPreviewDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ComboPreviewDataDestroyNative(ImGuiComboPreviewData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiComboPreviewData*, void>)vt[832])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[832])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ComboPreviewDataDestroy(ImGuiComboPreviewDataPtr self)
		{
			ComboPreviewDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ComboPreviewDataDestroy(ref ImGuiComboPreviewData self)
		{
			fixed (ImGuiComboPreviewData* pself = &self)
			{
				ComboPreviewDataDestroyNative((ImGuiComboPreviewData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiMenuColumns* MenuColumnsImGuiMenuColumnsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*>)vt[833])();
			#else
			return (ImGuiMenuColumns*)((delegate* unmanaged[Cdecl]<nint>)vt[833])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMenuColumnsPtr MenuColumnsImGuiMenuColumns()
		{
			ImGuiMenuColumnsPtr ret = MenuColumnsImGuiMenuColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MenuColumnsDestroyNative(ImGuiMenuColumns* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, void>)vt[834])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[834])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuColumnsDestroy(ImGuiMenuColumnsPtr self)
		{
			MenuColumnsDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuColumnsDestroy(ref ImGuiMenuColumns self)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				MenuColumnsDestroyNative((ImGuiMenuColumns*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MenuColumnsUpdateNative(ImGuiMenuColumns* self, float spacing, byte windowReappearing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, float, byte, void>)vt[835])(self, spacing, windowReappearing);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, byte, void>)vt[835])((nint)self, spacing, windowReappearing);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuColumnsUpdate(ImGuiMenuColumnsPtr self, float spacing, bool windowReappearing)
		{
			MenuColumnsUpdateNative(self, spacing, windowReappearing ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuColumnsUpdate(ref ImGuiMenuColumns self, float spacing, bool windowReappearing)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				MenuColumnsUpdateNative((ImGuiMenuColumns*)pself, spacing, windowReappearing ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float MenuColumnsDeclColumnsNative(ImGuiMenuColumns* self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, float, float, float, float, float>)vt[836])(self, wIcon, wLabel, wShortcut, wMark);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, float>)vt[836])((nint)self, wIcon, wLabel, wShortcut, wMark);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float MenuColumnsDeclColumns(ImGuiMenuColumnsPtr self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			float ret = MenuColumnsDeclColumnsNative(self, wIcon, wLabel, wShortcut, wMark);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float MenuColumnsDeclColumns(ref ImGuiMenuColumns self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				float ret = MenuColumnsDeclColumnsNative((ImGuiMenuColumns*)pself, wIcon, wLabel, wShortcut, wMark);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MenuColumnsCalcNextTotalWidthNative(ImGuiMenuColumns* self, byte updateOffsets)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, byte, void>)vt[837])(self, updateOffsets);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)vt[837])((nint)self, updateOffsets);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuColumnsCalcNextTotalWidth(ImGuiMenuColumnsPtr self, bool updateOffsets)
		{
			MenuColumnsCalcNextTotalWidthNative(self, updateOffsets ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuColumnsCalcNextTotalWidth(ref ImGuiMenuColumns self, bool updateOffsets)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				MenuColumnsCalcNextTotalWidthNative((ImGuiMenuColumns*)pself, updateOffsets ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiInputTextDeactivatedState* InputTextDeactivatedStateImGuiInputTextDeactivatedStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextDeactivatedState*>)vt[838])();
			#else
			return (ImGuiInputTextDeactivatedState*)((delegate* unmanaged[Cdecl]<nint>)vt[838])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputTextDeactivatedStatePtr InputTextDeactivatedStateImGuiInputTextDeactivatedState()
		{
			ImGuiInputTextDeactivatedStatePtr ret = InputTextDeactivatedStateImGuiInputTextDeactivatedStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextDeactivatedStateDestroyNative(ImGuiInputTextDeactivatedState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextDeactivatedState*, void>)vt[839])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[839])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextDeactivatedStateDestroy(ImGuiInputTextDeactivatedStatePtr self)
		{
			InputTextDeactivatedStateDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextDeactivatedStateDestroy(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				InputTextDeactivatedStateDestroyNative((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextDeactivatedStateClearFreeMemoryNative(ImGuiInputTextDeactivatedState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextDeactivatedState*, void>)vt[840])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[840])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextDeactivatedStateClearFreeMemory(ImGuiInputTextDeactivatedStatePtr self)
		{
			InputTextDeactivatedStateClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextDeactivatedStateClearFreeMemory(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				InputTextDeactivatedStateClearFreeMemoryNative((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiInputTextState* InputTextStateImGuiInputTextStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*>)vt[841])();
			#else
			return (ImGuiInputTextState*)((delegate* unmanaged[Cdecl]<nint>)vt[841])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputTextStatePtr InputTextStateImGuiInputTextState()
		{
			ImGuiInputTextStatePtr ret = InputTextStateImGuiInputTextStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateDestroyNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[842])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[842])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateDestroy(ImGuiInputTextStatePtr self)
		{
			InputTextStateDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateDestroy(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateDestroyNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateClearTextNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[843])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[843])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateClearText(ImGuiInputTextStatePtr self)
		{
			InputTextStateClearTextNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateClearText(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateClearTextNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateClearFreeMemoryNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[844])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[844])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateClearFreeMemory(ImGuiInputTextStatePtr self)
		{
			InputTextStateClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateClearFreeMemory(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateClearFreeMemoryNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateOnKeyPressedNative(ImGuiInputTextState* self, int key)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int, void>)vt[845])(self, key);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[845])((nint)self, key);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateOnKeyPressed(ImGuiInputTextStatePtr self, int key)
		{
			InputTextStateOnKeyPressedNative(self, key);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateOnKeyPressed(ref ImGuiInputTextState self, int key)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateOnKeyPressedNative((ImGuiInputTextState*)pself, key);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateOnCharPressedNative(ImGuiInputTextState* self, uint c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, uint, void>)vt[846])(self, c);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)vt[846])((nint)self, c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateOnCharPressed(ImGuiInputTextStatePtr self, uint c)
		{
			InputTextStateOnCharPressedNative(self, c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateOnCharPressed(ref ImGuiInputTextState self, uint c)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateOnCharPressedNative((ImGuiInputTextState*)pself, c);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateCursorAnimResetNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[847])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[847])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateCursorAnimReset(ImGuiInputTextStatePtr self)
		{
			InputTextStateCursorAnimResetNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateCursorAnimReset(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateCursorAnimResetNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateCursorClampNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[848])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[848])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateCursorClamp(ImGuiInputTextStatePtr self)
		{
			InputTextStateCursorClampNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateCursorClamp(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateCursorClampNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte InputTextStateHasSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, byte>)vt[849])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[849])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InputTextStateHasSelection(ImGuiInputTextStatePtr self)
		{
			byte ret = InputTextStateHasSelectionNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool InputTextStateHasSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				byte ret = InputTextStateHasSelectionNative((ImGuiInputTextState*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateClearSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[850])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[850])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateClearSelection(ImGuiInputTextStatePtr self)
		{
			InputTextStateClearSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateClearSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateClearSelectionNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int InputTextStateGetCursorPosNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)vt[851])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[851])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InputTextStateGetCursorPos(ImGuiInputTextStatePtr self)
		{
			int ret = InputTextStateGetCursorPosNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InputTextStateGetCursorPos(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = InputTextStateGetCursorPosNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int InputTextStateGetSelectionStartNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)vt[852])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[852])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InputTextStateGetSelectionStart(ImGuiInputTextStatePtr self)
		{
			int ret = InputTextStateGetSelectionStartNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InputTextStateGetSelectionStart(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = InputTextStateGetSelectionStartNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int InputTextStateGetSelectionEndNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)vt[853])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[853])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InputTextStateGetSelectionEnd(ImGuiInputTextStatePtr self)
		{
			int ret = InputTextStateGetSelectionEndNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InputTextStateGetSelectionEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = InputTextStateGetSelectionEndNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateSelectAllNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[854])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[854])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateSelectAll(ImGuiInputTextStatePtr self)
		{
			InputTextStateSelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateSelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateSelectAllNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateReloadUserBufAndSelectAllNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[855])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[855])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateReloadUserBufAndSelectAll(ImGuiInputTextStatePtr self)
		{
			InputTextStateReloadUserBufAndSelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateReloadUserBufAndSelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateReloadUserBufAndSelectAllNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateReloadUserBufAndKeepSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[856])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[856])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateReloadUserBufAndKeepSelection(ImGuiInputTextStatePtr self)
		{
			InputTextStateReloadUserBufAndKeepSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateReloadUserBufAndKeepSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateReloadUserBufAndKeepSelectionNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputTextStateReloadUserBufAndMoveToEndNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[857])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[857])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateReloadUserBufAndMoveToEnd(ImGuiInputTextStatePtr self)
		{
			InputTextStateReloadUserBufAndMoveToEndNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputTextStateReloadUserBufAndMoveToEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				InputTextStateReloadUserBufAndMoveToEndNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiNextWindowData* NextWindowDataImGuiNextWindowDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*>)vt[858])();
			#else
			return (ImGuiNextWindowData*)((delegate* unmanaged[Cdecl]<nint>)vt[858])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNextWindowDataPtr NextWindowDataImGuiNextWindowData()
		{
			ImGuiNextWindowDataPtr ret = NextWindowDataImGuiNextWindowDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void NextWindowDataDestroyNative(ImGuiNextWindowData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*, void>)vt[859])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[859])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NextWindowDataDestroy(ImGuiNextWindowDataPtr self)
		{
			NextWindowDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NextWindowDataDestroy(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				NextWindowDataDestroyNative((ImGuiNextWindowData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void NextWindowDataClearFlagsNative(ImGuiNextWindowData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*, void>)vt[860])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[860])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NextWindowDataClearFlags(ImGuiNextWindowDataPtr self)
		{
			NextWindowDataClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NextWindowDataClearFlags(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				NextWindowDataClearFlagsNative((ImGuiNextWindowData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiNextItemData* NextItemDataImGuiNextItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNextItemData*>)vt[861])();
			#else
			return (ImGuiNextItemData*)((delegate* unmanaged[Cdecl]<nint>)vt[861])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNextItemDataPtr NextItemDataImGuiNextItemData()
		{
			ImGuiNextItemDataPtr ret = NextItemDataImGuiNextItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void NextItemDataDestroyNative(ImGuiNextItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextItemData*, void>)vt[862])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[862])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NextItemDataDestroy(ImGuiNextItemDataPtr self)
		{
			NextItemDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NextItemDataDestroy(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				NextItemDataDestroyNative((ImGuiNextItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void NextItemDataClearFlagsNative(ImGuiNextItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextItemData*, void>)vt[863])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[863])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NextItemDataClearFlags(ImGuiNextItemDataPtr self)
		{
			NextItemDataClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NextItemDataClearFlags(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				NextItemDataClearFlagsNative((ImGuiNextItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiLastItemData* LastItemDataImGuiLastItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiLastItemData*>)vt[864])();
			#else
			return (ImGuiLastItemData*)((delegate* unmanaged[Cdecl]<nint>)vt[864])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiLastItemDataPtr LastItemDataImGuiLastItemData()
		{
			ImGuiLastItemDataPtr ret = LastItemDataImGuiLastItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void LastItemDataDestroyNative(ImGuiLastItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiLastItemData*, void>)vt[865])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[865])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LastItemDataDestroy(ImGuiLastItemDataPtr self)
		{
			LastItemDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LastItemDataDestroy(ref ImGuiLastItemData self)
		{
			fixed (ImGuiLastItemData* pself = &self)
			{
				LastItemDataDestroyNative((ImGuiLastItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStackSizes* StackSizesImGuiStackSizesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStackSizes*>)vt[866])();
			#else
			return (ImGuiStackSizes*)((delegate* unmanaged[Cdecl]<nint>)vt[866])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStackSizesPtr StackSizesImGuiStackSizes()
		{
			ImGuiStackSizesPtr ret = StackSizesImGuiStackSizesNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void StackSizesDestroyNative(ImGuiStackSizes* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackSizes*, void>)vt[867])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[867])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesDestroy(ImGuiStackSizesPtr self)
		{
			StackSizesDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesDestroy(ref ImGuiStackSizes self)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				StackSizesDestroyNative((ImGuiStackSizes*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void StackSizesSetToContextStateNative(ImGuiStackSizes* self, ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackSizes*, ImGuiContext*, void>)vt[868])(self, ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[868])((nint)self, (nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesSetToContextState(ImGuiStackSizesPtr self, ImGuiContextPtr ctx)
		{
			StackSizesSetToContextStateNative(self, ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesSetToContextState(ref ImGuiStackSizes self, ImGuiContextPtr ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				StackSizesSetToContextStateNative((ImGuiStackSizes*)pself, ctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesSetToContextState(ImGuiStackSizesPtr self, ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				StackSizesSetToContextStateNative(self, (ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesSetToContextState(ref ImGuiStackSizes self, ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					StackSizesSetToContextStateNative((ImGuiStackSizes*)pself, (ImGuiContext*)pctx);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void StackSizesCompareWithContextStateNative(ImGuiStackSizes* self, ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackSizes*, ImGuiContext*, void>)vt[869])(self, ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[869])((nint)self, (nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesCompareWithContextState(ImGuiStackSizesPtr self, ImGuiContextPtr ctx)
		{
			StackSizesCompareWithContextStateNative(self, ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesCompareWithContextState(ref ImGuiStackSizes self, ImGuiContextPtr ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				StackSizesCompareWithContextStateNative((ImGuiStackSizes*)pself, ctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesCompareWithContextState(ImGuiStackSizesPtr self, ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				StackSizesCompareWithContextStateNative(self, (ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackSizesCompareWithContextState(ref ImGuiStackSizes self, ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					StackSizesCompareWithContextStateNative((ImGuiStackSizes*)pself, (ImGuiContext*)pctx);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiPtrOrIndex* PtrOrIndexImGuiPtrOrIndexPtrNative(void* ptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ImGuiPtrOrIndex*>)vt[870])(ptr);
			#else
			return (ImGuiPtrOrIndex*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[870])((nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPtrOrIndexPtr PtrOrIndexImGuiPtrOrIndexPtr(void* ptr)
		{
			ImGuiPtrOrIndexPtr ret = PtrOrIndexImGuiPtrOrIndexPtrNative(ptr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PtrOrIndexDestroyNative(ImGuiPtrOrIndex* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiPtrOrIndex*, void>)vt[871])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[871])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PtrOrIndexDestroy(ImGuiPtrOrIndexPtr self)
		{
			PtrOrIndexDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PtrOrIndexDestroy(ref ImGuiPtrOrIndex self)
		{
			fixed (ImGuiPtrOrIndex* pself = &self)
			{
				PtrOrIndexDestroyNative((ImGuiPtrOrIndex*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiPtrOrIndex* PtrOrIndexImGuiPtrOrIndexIntNative(int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiPtrOrIndex*>)vt[872])(index);
			#else
			return (ImGuiPtrOrIndex*)((delegate* unmanaged[Cdecl]<int, nint>)vt[872])(index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPtrOrIndexPtr PtrOrIndexImGuiPtrOrIndexInt(int index)
		{
			ImGuiPtrOrIndexPtr ret = PtrOrIndexImGuiPtrOrIndexIntNative(index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiPopupData* PopupDataImGuiPopupDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiPopupData*>)vt[873])();
			#else
			return (ImGuiPopupData*)((delegate* unmanaged[Cdecl]<nint>)vt[873])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPopupDataPtr PopupDataImGuiPopupData()
		{
			ImGuiPopupDataPtr ret = PopupDataImGuiPopupDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopupDataDestroyNative(ImGuiPopupData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiPopupData*, void>)vt[874])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[874])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopupDataDestroy(ImGuiPopupDataPtr self)
		{
			PopupDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopupDataDestroy(ref ImGuiPopupData self)
		{
			fixed (ImGuiPopupData* pself = &self)
			{
				PopupDataDestroyNative((ImGuiPopupData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiInputEvent* InputEventImGuiInputEventNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputEvent*>)vt[875])();
			#else
			return (ImGuiInputEvent*)((delegate* unmanaged[Cdecl]<nint>)vt[875])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputEventPtr InputEventImGuiInputEvent()
		{
			ImGuiInputEventPtr ret = InputEventImGuiInputEventNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void InputEventDestroyNative(ImGuiInputEvent* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputEvent*, void>)vt[876])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[876])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputEventDestroy(ImGuiInputEventPtr self)
		{
			InputEventDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InputEventDestroy(ref ImGuiInputEvent self)
		{
			fixed (ImGuiInputEvent* pself = &self)
			{
				InputEventDestroyNative((ImGuiInputEvent*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiKeyRoutingData* KeyRoutingDataImGuiKeyRoutingDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingData*>)vt[877])();
			#else
			return (ImGuiKeyRoutingData*)((delegate* unmanaged[Cdecl]<nint>)vt[877])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyRoutingDataPtr KeyRoutingDataImGuiKeyRoutingData()
		{
			ImGuiKeyRoutingDataPtr ret = KeyRoutingDataImGuiKeyRoutingDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void KeyRoutingDataDestroyNative(ImGuiKeyRoutingData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingData*, void>)vt[878])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[878])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeyRoutingDataDestroy(ImGuiKeyRoutingDataPtr self)
		{
			KeyRoutingDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeyRoutingDataDestroy(ref ImGuiKeyRoutingData self)
		{
			fixed (ImGuiKeyRoutingData* pself = &self)
			{
				KeyRoutingDataDestroyNative((ImGuiKeyRoutingData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiKeyRoutingTable* KeyRoutingTableImGuiKeyRoutingTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingTable*>)vt[879])();
			#else
			return (ImGuiKeyRoutingTable*)((delegate* unmanaged[Cdecl]<nint>)vt[879])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyRoutingTablePtr KeyRoutingTableImGuiKeyRoutingTable()
		{
			ImGuiKeyRoutingTablePtr ret = KeyRoutingTableImGuiKeyRoutingTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void KeyRoutingTableDestroyNative(ImGuiKeyRoutingTable* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingTable*, void>)vt[880])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[880])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeyRoutingTableDestroy(ImGuiKeyRoutingTablePtr self)
		{
			KeyRoutingTableDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeyRoutingTableDestroy(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				KeyRoutingTableDestroyNative((ImGuiKeyRoutingTable*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void KeyRoutingTableClearNative(ImGuiKeyRoutingTable* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingTable*, void>)vt[881])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[881])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeyRoutingTableClear(ImGuiKeyRoutingTablePtr self)
		{
			KeyRoutingTableClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeyRoutingTableClear(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				KeyRoutingTableClearNative((ImGuiKeyRoutingTable*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiKeyOwnerData* KeyOwnerDataImGuiKeyOwnerDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyOwnerData*>)vt[882])();
			#else
			return (ImGuiKeyOwnerData*)((delegate* unmanaged[Cdecl]<nint>)vt[882])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyOwnerDataPtr KeyOwnerDataImGuiKeyOwnerData()
		{
			ImGuiKeyOwnerDataPtr ret = KeyOwnerDataImGuiKeyOwnerDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void KeyOwnerDataDestroyNative(ImGuiKeyOwnerData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyOwnerData*, void>)vt[883])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[883])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeyOwnerDataDestroy(ImGuiKeyOwnerDataPtr self)
		{
			KeyOwnerDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeyOwnerDataDestroy(ref ImGuiKeyOwnerData self)
		{
			fixed (ImGuiKeyOwnerData* pself = &self)
			{
				KeyOwnerDataDestroyNative((ImGuiKeyOwnerData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiListClipperRange ListClipperRangeFromIndicesNative(int min, int max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, ImGuiListClipperRange>)vt[884])(min, max);
			#else
			return (ImGuiListClipperRange)((delegate* unmanaged[Cdecl]<int, int, ImGuiListClipperRange>)vt[884])(min, max);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperRange ListClipperRangeFromIndices(int min, int max)
		{
			ImGuiListClipperRange ret = ListClipperRangeFromIndicesNative(min, max);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiListClipperRange ListClipperRangeFromPositionsNative(float y1, float y2, int offMin, int offMax)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, int, int, ImGuiListClipperRange>)vt[885])(y1, y2, offMin, offMax);
			#else
			return (ImGuiListClipperRange)((delegate* unmanaged[Cdecl]<float, float, int, int, ImGuiListClipperRange>)vt[885])(y1, y2, offMin, offMax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperRange ListClipperRangeFromPositions(float y1, float y2, int offMin, int offMax)
		{
			ImGuiListClipperRange ret = ListClipperRangeFromPositionsNative(y1, y2, offMin, offMax);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiListClipperData* ListClipperDataImGuiListClipperDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiListClipperData*>)vt[886])();
			#else
			return (ImGuiListClipperData*)((delegate* unmanaged[Cdecl]<nint>)vt[886])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperDataPtr ListClipperDataImGuiListClipperData()
		{
			ImGuiListClipperDataPtr ret = ListClipperDataImGuiListClipperDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ListClipperDataDestroyNative(ImGuiListClipperData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiListClipperData*, void>)vt[887])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[887])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ListClipperDataDestroy(ImGuiListClipperDataPtr self)
		{
			ListClipperDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ListClipperDataDestroy(ref ImGuiListClipperData self)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ListClipperDataDestroyNative((ImGuiListClipperData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ListClipperDataResetNative(ImGuiListClipperData* self, ImGuiListClipper* clipper)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiListClipperData*, ImGuiListClipper*, void>)vt[888])(self, clipper);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[888])((nint)self, (nint)clipper);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ListClipperDataReset(ImGuiListClipperDataPtr self, ImGuiListClipperPtr clipper)
		{
			ListClipperDataResetNative(self, clipper);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ListClipperDataReset(ref ImGuiListClipperData self, ImGuiListClipperPtr clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ListClipperDataResetNative((ImGuiListClipperData*)pself, clipper);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ListClipperDataReset(ImGuiListClipperDataPtr self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipper* pclipper = &clipper)
			{
				ListClipperDataResetNative(self, (ImGuiListClipper*)pclipper);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ListClipperDataReset(ref ImGuiListClipperData self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				fixed (ImGuiListClipper* pclipper = &clipper)
				{
					ListClipperDataResetNative((ImGuiListClipperData*)pself, (ImGuiListClipper*)pclipper);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiNavItemData* NavItemDataImGuiNavItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNavItemData*>)vt[889])();
			#else
			return (ImGuiNavItemData*)((delegate* unmanaged[Cdecl]<nint>)vt[889])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNavItemDataPtr NavItemDataImGuiNavItemData()
		{
			ImGuiNavItemDataPtr ret = NavItemDataImGuiNavItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void NavItemDataDestroyNative(ImGuiNavItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNavItemData*, void>)vt[890])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[890])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NavItemDataDestroy(ImGuiNavItemDataPtr self)
		{
			NavItemDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NavItemDataDestroy(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				NavItemDataDestroyNative((ImGuiNavItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void NavItemDataClearNative(ImGuiNavItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNavItemData*, void>)vt[891])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[891])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NavItemDataClear(ImGuiNavItemDataPtr self)
		{
			NavItemDataClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NavItemDataClear(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				NavItemDataClearNative((ImGuiNavItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTypingSelectState* TypingSelectStateImGuiTypingSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectState*>)vt[892])();
			#else
			return (ImGuiTypingSelectState*)((delegate* unmanaged[Cdecl]<nint>)vt[892])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTypingSelectStatePtr TypingSelectStateImGuiTypingSelectState()
		{
			ImGuiTypingSelectStatePtr ret = TypingSelectStateImGuiTypingSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TypingSelectStateDestroyNative(ImGuiTypingSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTypingSelectState*, void>)vt[893])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[893])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TypingSelectStateDestroy(ImGuiTypingSelectStatePtr self)
		{
			TypingSelectStateDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TypingSelectStateDestroy(ref ImGuiTypingSelectState self)
		{
			fixed (ImGuiTypingSelectState* pself = &self)
			{
				TypingSelectStateDestroyNative((ImGuiTypingSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TypingSelectStateClearNative(ImGuiTypingSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTypingSelectState*, void>)vt[894])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[894])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TypingSelectStateClear(ImGuiTypingSelectStatePtr self)
		{
			TypingSelectStateClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TypingSelectStateClear(ref ImGuiTypingSelectState self)
		{
			fixed (ImGuiTypingSelectState* pself = &self)
			{
				TypingSelectStateClearNative((ImGuiTypingSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiOldColumnData* OldColumnDataImGuiOldColumnDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumnData*>)vt[895])();
			#else
			return (ImGuiOldColumnData*)((delegate* unmanaged[Cdecl]<nint>)vt[895])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnDataPtr OldColumnDataImGuiOldColumnData()
		{
			ImGuiOldColumnDataPtr ret = OldColumnDataImGuiOldColumnDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void OldColumnDataDestroyNative(ImGuiOldColumnData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiOldColumnData*, void>)vt[896])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[896])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OldColumnDataDestroy(ImGuiOldColumnDataPtr self)
		{
			OldColumnDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OldColumnDataDestroy(ref ImGuiOldColumnData self)
		{
			fixed (ImGuiOldColumnData* pself = &self)
			{
				OldColumnDataDestroyNative((ImGuiOldColumnData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiOldColumns* OldColumnsImGuiOldColumnsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*>)vt[897])();
			#else
			return (ImGuiOldColumns*)((delegate* unmanaged[Cdecl]<nint>)vt[897])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnsPtr OldColumnsImGuiOldColumns()
		{
			ImGuiOldColumnsPtr ret = OldColumnsImGuiOldColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void OldColumnsDestroyNative(ImGuiOldColumns* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiOldColumns*, void>)vt[898])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[898])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OldColumnsDestroy(ImGuiOldColumnsPtr self)
		{
			OldColumnsDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OldColumnsDestroy(ref ImGuiOldColumns self)
		{
			fixed (ImGuiOldColumns* pself = &self)
			{
				OldColumnsDestroyNative((ImGuiOldColumns*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiBoxSelectState* BoxSelectStateImGuiBoxSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiBoxSelectState*>)vt[899])();
			#else
			return (ImGuiBoxSelectState*)((delegate* unmanaged[Cdecl]<nint>)vt[899])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiBoxSelectStatePtr BoxSelectStateImGuiBoxSelectState()
		{
			ImGuiBoxSelectStatePtr ret = BoxSelectStateImGuiBoxSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void BoxSelectStateDestroyNative(ImGuiBoxSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiBoxSelectState*, void>)vt[900])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[900])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BoxSelectStateDestroy(ImGuiBoxSelectStatePtr self)
		{
			BoxSelectStateDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BoxSelectStateDestroy(ref ImGuiBoxSelectState self)
		{
			fixed (ImGuiBoxSelectState* pself = &self)
			{
				BoxSelectStateDestroyNative((ImGuiBoxSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiMultiSelectTempData* MultiSelectTempDataImGuiMultiSelectTempDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*>)vt[901])();
			#else
			return (ImGuiMultiSelectTempData*)((delegate* unmanaged[Cdecl]<nint>)vt[901])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMultiSelectTempDataPtr MultiSelectTempDataImGuiMultiSelectTempData()
		{
			ImGuiMultiSelectTempDataPtr ret = MultiSelectTempDataImGuiMultiSelectTempDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MultiSelectTempDataDestroyNative(ImGuiMultiSelectTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, void>)vt[902])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[902])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectTempDataDestroy(ImGuiMultiSelectTempDataPtr self)
		{
			MultiSelectTempDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectTempDataDestroy(ref ImGuiMultiSelectTempData self)
		{
			fixed (ImGuiMultiSelectTempData* pself = &self)
			{
				MultiSelectTempDataDestroyNative((ImGuiMultiSelectTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MultiSelectTempDataClearNative(ImGuiMultiSelectTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, void>)vt[903])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[903])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectTempDataClear(ImGuiMultiSelectTempDataPtr self)
		{
			MultiSelectTempDataClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectTempDataClear(ref ImGuiMultiSelectTempData self)
		{
			fixed (ImGuiMultiSelectTempData* pself = &self)
			{
				MultiSelectTempDataClearNative((ImGuiMultiSelectTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MultiSelectTempDataClearIONative(ImGuiMultiSelectTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, void>)vt[904])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[904])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectTempDataClearIO(ImGuiMultiSelectTempDataPtr self)
		{
			MultiSelectTempDataClearIONative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectTempDataClearIO(ref ImGuiMultiSelectTempData self)
		{
			fixed (ImGuiMultiSelectTempData* pself = &self)
			{
				MultiSelectTempDataClearIONative((ImGuiMultiSelectTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiMultiSelectState* MultiSelectStateImGuiMultiSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMultiSelectState*>)vt[905])();
			#else
			return (ImGuiMultiSelectState*)((delegate* unmanaged[Cdecl]<nint>)vt[905])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMultiSelectStatePtr MultiSelectStateImGuiMultiSelectState()
		{
			ImGuiMultiSelectStatePtr ret = MultiSelectStateImGuiMultiSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MultiSelectStateDestroyNative(ImGuiMultiSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectState*, void>)vt[906])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[906])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectStateDestroy(ImGuiMultiSelectStatePtr self)
		{
			MultiSelectStateDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectStateDestroy(ref ImGuiMultiSelectState self)
		{
			fixed (ImGuiMultiSelectState* pself = &self)
			{
				MultiSelectStateDestroyNative((ImGuiMultiSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiDockNode* DockNodeImGuiDockNodeNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiDockNode*>)vt[907])(id);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<uint, nint>)vt[907])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr DockNodeImGuiDockNode(uint id)
		{
			ImGuiDockNodePtr ret = DockNodeImGuiDockNodeNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DockNodeDestroyNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, void>)vt[908])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[908])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeDestroy(ImGuiDockNodePtr self)
		{
			DockNodeDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeDestroy(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				DockNodeDestroyNative((ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsRootNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[909])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[909])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsRootNode(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsRootNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsRootNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsRootNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsDockSpaceNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[910])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[910])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsDockSpace(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsDockSpaceNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsDockSpace(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsDockSpaceNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsFloatingNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[911])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[911])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsFloatingNode(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsFloatingNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsFloatingNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsFloatingNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsCentralNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[912])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[912])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsCentralNode(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsCentralNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsCentralNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsCentralNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsHiddenTabBarNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[913])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[913])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsHiddenTabBar(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsHiddenTabBarNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsHiddenTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsHiddenTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsNoTabBarNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[914])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[914])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsNoTabBar(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsNoTabBarNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsNoTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsNoTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsSplitNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[915])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[915])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsSplitNode(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsSplitNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsSplitNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsSplitNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsLeafNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[916])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[916])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsLeafNode(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsLeafNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsLeafNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsLeafNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte DockNodeIsEmptyNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[917])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[917])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsEmpty(ImGuiDockNodePtr self)
		{
			byte ret = DockNodeIsEmptyNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool DockNodeIsEmpty(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = DockNodeIsEmptyNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DockNodeRectNative(ImRect* pOut, ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiDockNode*, void>)vt[918])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[918])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect DockNodeRect(ImGuiDockNodePtr self)
		{
			ImRect ret;
			DockNodeRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeRect(ImRectPtr pOut, ImGuiDockNodePtr self)
		{
			DockNodeRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeRect(ref ImRect pOut, ImGuiDockNodePtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				DockNodeRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect DockNodeRect(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImRect ret;
				DockNodeRectNative(&ret, (ImGuiDockNode*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeRect(ImRectPtr pOut, ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				DockNodeRectNative(pOut, (ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeRect(ref ImRect pOut, ref ImGuiDockNode self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiDockNode* pself = &self)
				{
					DockNodeRectNative((ImRect*)ppOut, (ImGuiDockNode*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DockNodeSetLocalFlagsNative(ImGuiDockNode* self, ImGuiDockNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, ImGuiDockNodeFlags, void>)vt[919])(self, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiDockNodeFlags, void>)vt[919])((nint)self, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeSetLocalFlags(ImGuiDockNodePtr self, ImGuiDockNodeFlags flags)
		{
			DockNodeSetLocalFlagsNative(self, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeSetLocalFlags(ref ImGuiDockNode self, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				DockNodeSetLocalFlagsNative((ImGuiDockNode*)pself, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DockNodeUpdateMergedFlagsNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, void>)vt[920])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[920])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeUpdateMergedFlags(ImGuiDockNodePtr self)
		{
			DockNodeUpdateMergedFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockNodeUpdateMergedFlags(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				DockNodeUpdateMergedFlagsNative((ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiDockContext* DockContextImGuiDockContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockContext*>)vt[921])();
			#else
			return (ImGuiDockContext*)((delegate* unmanaged[Cdecl]<nint>)vt[921])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockContextPtr DockContextImGuiDockContext()
		{
			ImGuiDockContextPtr ret = DockContextImGuiDockContextNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DockContextDestroyNative(ImGuiDockContext* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockContext*, void>)vt[922])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[922])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextDestroy(ImGuiDockContextPtr self)
		{
			DockContextDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockContextDestroy(ref ImGuiDockContext self)
		{
			fixed (ImGuiDockContext* pself = &self)
			{
				DockContextDestroyNative((ImGuiDockContext*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiViewportP* ViewportPImGuiViewportPNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewportP*>)vt[923])();
			#else
			return (ImGuiViewportP*)((delegate* unmanaged[Cdecl]<nint>)vt[923])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiViewportPPtr ViewportPImGuiViewportP()
		{
			ImGuiViewportPPtr ret = ViewportPImGuiViewportPNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ViewportPDestroyNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)vt[924])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[924])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPDestroy(ImGuiViewportPPtr self)
		{
			ViewportPDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPDestroy(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ViewportPDestroyNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ViewportPClearRequestFlagsNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)vt[925])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[925])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPClearRequestFlags(ImGuiViewportPPtr self)
		{
			ViewportPClearRequestFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPClearRequestFlags(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ViewportPClearRequestFlagsNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ViewportPCalcWorkRectPosNative(Vector2* pOut, ImGuiViewportP* self, Vector2 insetMin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiViewportP*, Vector2, void>)vt[926])(pOut, self, insetMin);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, void>)vt[926])((nint)pOut, (nint)self, insetMin);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ViewportPCalcWorkRectPos(ImGuiViewportPPtr self, Vector2 insetMin)
		{
			Vector2 ret;
			ViewportPCalcWorkRectPosNative(&ret, self, insetMin);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPCalcWorkRectPos(Vector2* pOut, ImGuiViewportPPtr self, Vector2 insetMin)
		{
			ViewportPCalcWorkRectPosNative(pOut, self, insetMin);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPCalcWorkRectPos(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 insetMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ViewportPCalcWorkRectPosNative((Vector2*)ppOut, self, insetMin);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ViewportPCalcWorkRectPos(ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				ViewportPCalcWorkRectPosNative(&ret, (ImGuiViewportP*)pself, insetMin);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPCalcWorkRectPos(Vector2* pOut, ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ViewportPCalcWorkRectPosNative(pOut, (ImGuiViewportP*)pself, insetMin);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPCalcWorkRectPos(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ViewportPCalcWorkRectPosNative((Vector2*)ppOut, (ImGuiViewportP*)pself, insetMin);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ViewportPCalcWorkRectSizeNative(Vector2* pOut, ImGuiViewportP* self, Vector2 insetMin, Vector2 insetMax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiViewportP*, Vector2, Vector2, void>)vt[927])(pOut, self, insetMin, insetMax);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, Vector2, void>)vt[927])((nint)pOut, (nint)self, insetMin, insetMax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ViewportPCalcWorkRectSize(ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			Vector2 ret;
			ViewportPCalcWorkRectSizeNative(&ret, self, insetMin, insetMax);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPCalcWorkRectSize(Vector2* pOut, ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			ViewportPCalcWorkRectSizeNative(pOut, self, insetMin, insetMax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPCalcWorkRectSize(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ViewportPCalcWorkRectSizeNative((Vector2*)ppOut, self, insetMin, insetMax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ViewportPCalcWorkRectSize(ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				ViewportPCalcWorkRectSizeNative(&ret, (ImGuiViewportP*)pself, insetMin, insetMax);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPCalcWorkRectSize(Vector2* pOut, ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ViewportPCalcWorkRectSizeNative(pOut, (ImGuiViewportP*)pself, insetMin, insetMax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPCalcWorkRectSize(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ViewportPCalcWorkRectSizeNative((Vector2*)ppOut, (ImGuiViewportP*)pself, insetMin, insetMax);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ViewportPUpdateWorkRectNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)vt[928])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[928])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPUpdateWorkRect(ImGuiViewportPPtr self)
		{
			ViewportPUpdateWorkRectNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPUpdateWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ViewportPUpdateWorkRectNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ViewportPGetMainRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)vt[929])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[929])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect ViewportPGetMainRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			ViewportPGetMainRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetMainRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			ViewportPGetMainRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetMainRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ViewportPGetMainRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect ViewportPGetMainRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ViewportPGetMainRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetMainRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ViewportPGetMainRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetMainRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ViewportPGetMainRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ViewportPGetWorkRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)vt[930])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[930])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect ViewportPGetWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			ViewportPGetWorkRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			ViewportPGetWorkRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ViewportPGetWorkRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect ViewportPGetWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ViewportPGetWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ViewportPGetWorkRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ViewportPGetWorkRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ViewportPGetBuildWorkRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)vt[931])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[931])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect ViewportPGetBuildWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			ViewportPGetBuildWorkRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetBuildWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			ViewportPGetBuildWorkRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetBuildWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ViewportPGetBuildWorkRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect ViewportPGetBuildWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ViewportPGetBuildWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetBuildWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ViewportPGetBuildWorkRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ViewportPGetBuildWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ViewportPGetBuildWorkRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiWindowSettings* WindowSettingsImGuiWindowSettingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*>)vt[932])();
			#else
			return (ImGuiWindowSettings*)((delegate* unmanaged[Cdecl]<nint>)vt[932])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr WindowSettingsImGuiWindowSettings()
		{
			ImGuiWindowSettingsPtr ret = WindowSettingsImGuiWindowSettingsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void WindowSettingsDestroyNative(ImGuiWindowSettings* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*, void>)vt[933])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[933])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowSettingsDestroy(ImGuiWindowSettingsPtr self)
		{
			WindowSettingsDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowSettingsDestroy(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				WindowSettingsDestroyNative((ImGuiWindowSettings*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte* WindowSettingsGetNameNative(ImGuiWindowSettings* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*, byte*>)vt[934])(self);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[934])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* WindowSettingsGetName(ImGuiWindowSettingsPtr self)
		{
			byte* ret = WindowSettingsGetNameNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string WindowSettingsGetNameS(ImGuiWindowSettingsPtr self)
		{
			string ret = Utils.DecodeStringUTF8(WindowSettingsGetNameNative(self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* WindowSettingsGetName(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				byte* ret = WindowSettingsGetNameNative((ImGuiWindowSettings*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string WindowSettingsGetNameS(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(WindowSettingsGetNameNative((ImGuiWindowSettings*)pself));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiSettingsHandler* SettingsHandlerImGuiSettingsHandlerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiSettingsHandler*>)vt[935])();
			#else
			return (ImGuiSettingsHandler*)((delegate* unmanaged[Cdecl]<nint>)vt[935])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSettingsHandlerPtr SettingsHandlerImGuiSettingsHandler()
		{
			ImGuiSettingsHandlerPtr ret = SettingsHandlerImGuiSettingsHandlerNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void SettingsHandlerDestroyNative(ImGuiSettingsHandler* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiSettingsHandler*, void>)vt[936])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[936])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SettingsHandlerDestroy(ImGuiSettingsHandlerPtr self)
		{
			SettingsHandlerDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SettingsHandlerDestroy(ref ImGuiSettingsHandler self)
		{
			fixed (ImGuiSettingsHandler* pself = &self)
			{
				SettingsHandlerDestroyNative((ImGuiSettingsHandler*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiDebugAllocInfo* DebugAllocInfoImGuiDebugAllocInfoNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDebugAllocInfo*>)vt[937])();
			#else
			return (ImGuiDebugAllocInfo*)((delegate* unmanaged[Cdecl]<nint>)vt[937])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDebugAllocInfoPtr DebugAllocInfoImGuiDebugAllocInfo()
		{
			ImGuiDebugAllocInfoPtr ret = DebugAllocInfoImGuiDebugAllocInfoNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DebugAllocInfoDestroyNative(ImGuiDebugAllocInfo* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDebugAllocInfo*, void>)vt[938])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[938])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugAllocInfoDestroy(ImGuiDebugAllocInfoPtr self)
		{
			DebugAllocInfoDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugAllocInfoDestroy(ref ImGuiDebugAllocInfo self)
		{
			fixed (ImGuiDebugAllocInfo* pself = &self)
			{
				DebugAllocInfoDestroyNative((ImGuiDebugAllocInfo*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStackLevelInfo* StackLevelInfoImGuiStackLevelInfoNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStackLevelInfo*>)vt[939])();
			#else
			return (ImGuiStackLevelInfo*)((delegate* unmanaged[Cdecl]<nint>)vt[939])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStackLevelInfoPtr StackLevelInfoImGuiStackLevelInfo()
		{
			ImGuiStackLevelInfoPtr ret = StackLevelInfoImGuiStackLevelInfoNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void StackLevelInfoDestroyNative(ImGuiStackLevelInfo* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackLevelInfo*, void>)vt[940])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[940])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackLevelInfoDestroy(ImGuiStackLevelInfoPtr self)
		{
			StackLevelInfoDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StackLevelInfoDestroy(ref ImGuiStackLevelInfo self)
		{
			fixed (ImGuiStackLevelInfo* pself = &self)
			{
				StackLevelInfoDestroyNative((ImGuiStackLevelInfo*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiIDStackTool* IDStackToolImGuiIDStackToolNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiIDStackTool*>)vt[941])();
			#else
			return (ImGuiIDStackTool*)((delegate* unmanaged[Cdecl]<nint>)vt[941])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiIDStackToolPtr IDStackToolImGuiIDStackTool()
		{
			ImGuiIDStackToolPtr ret = IDStackToolImGuiIDStackToolNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void IDStackToolDestroyNative(ImGuiIDStackTool* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIDStackTool*, void>)vt[942])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[942])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void IDStackToolDestroy(ImGuiIDStackToolPtr self)
		{
			IDStackToolDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void IDStackToolDestroy(ref ImGuiIDStackTool self)
		{
			fixed (ImGuiIDStackTool* pself = &self)
			{
				IDStackToolDestroyNative((ImGuiIDStackTool*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiContextHook* ContextHookImGuiContextHookNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContextHook*>)vt[943])();
			#else
			return (ImGuiContextHook*)((delegate* unmanaged[Cdecl]<nint>)vt[943])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextHookPtr ContextHookImGuiContextHook()
		{
			ImGuiContextHookPtr ret = ContextHookImGuiContextHookNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ContextHookDestroyNative(ImGuiContextHook* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContextHook*, void>)vt[944])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[944])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ContextHookDestroy(ImGuiContextHookPtr self)
		{
			ContextHookDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ContextHookDestroy(ref ImGuiContextHook self)
		{
			fixed (ImGuiContextHook* pself = &self)
			{
				ContextHookDestroyNative((ImGuiContextHook*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiContext* ContextImGuiContextNative(ImFontAtlas* sharedFontAtlas)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFontAtlas*, ImGuiContext*>)vt[945])(sharedFontAtlas);
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[945])((nint)sharedFontAtlas);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr ContextImGuiContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = ContextImGuiContextNative(sharedFontAtlas);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr ContextImGuiContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = ContextImGuiContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ContextDestroyNative(ImGuiContext* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[946])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[946])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ContextDestroy(ImGuiContextPtr self)
		{
			ContextDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ContextDestroy(ref ImGuiContext self)
		{
			fixed (ImGuiContext* pself = &self)
			{
				ContextDestroyNative((ImGuiContext*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiWindow* WindowImGuiWindowNative(ImGuiContext* context, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, byte*, ImGuiWindow*>)vt[947])(context, name);
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)vt[947])((nint)context, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr WindowImGuiWindow(ImGuiContextPtr context, byte* name)
		{
			ImGuiWindowPtr ret = WindowImGuiWindowNative(context, name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr WindowImGuiWindow(ref ImGuiContext context, byte* name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				ImGuiWindowPtr ret = WindowImGuiWindowNative((ImGuiContext*)pcontext, name);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr WindowImGuiWindow(ImGuiContextPtr context, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowPtr ret = WindowImGuiWindowNative(context, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr WindowImGuiWindow(ImGuiContextPtr context, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowPtr ret = WindowImGuiWindowNative(context, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr WindowImGuiWindow(ImGuiContextPtr context, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowPtr ret = WindowImGuiWindowNative(context, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr WindowImGuiWindow(ref ImGuiContext context, ref byte name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = &name)
				{
					ImGuiWindowPtr ret = WindowImGuiWindowNative((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr WindowImGuiWindow(ref ImGuiContext context, ReadOnlySpan<byte> name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = name)
				{
					ImGuiWindowPtr ret = WindowImGuiWindowNative((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr WindowImGuiWindow(ref ImGuiContext context, string name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiWindowPtr ret = WindowImGuiWindowNative((ImGuiContext*)pcontext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void WindowDestroyNative(ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)vt[948])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[948])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowDestroy(ImGuiWindowPtr self)
		{
			WindowDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowDestroy(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				WindowDestroyNative((ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint WindowGetIDNative(ImGuiWindow* self, byte* str, byte* strEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte*, byte*, uint>)vt[949])(self, str, strEnd);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)vt[949])((nint)self, (nint)str, (nint)strEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, byte* str, byte* strEnd)
		{
			uint ret = WindowGetIDNative(self, str, strEnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, byte* str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = WindowGetIDNative((ImGuiWindow*)pself, str, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = WindowGetIDNative(self, (byte*)pstr, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, byte* strEnd)
		{
			fixed (byte* pstr = str)
			{
				uint ret = WindowGetIDNative(self, (byte*)pstr, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = WindowGetIDNative(self, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, ref byte str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					uint ret = WindowGetIDNative((ImGuiWindow*)pself, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					uint ret = WindowGetIDNative((ImGuiWindow*)pself, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, string str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = WindowGetIDNative((ImGuiWindow*)pself, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				uint ret = WindowGetIDNative(self, str, (byte*)pstrEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, byte* str, ReadOnlySpan<byte> strEnd)
		{
			fixed (byte* pstrEnd = strEnd)
			{
				uint ret = WindowGetIDNative(self, str, (byte*)pstrEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = WindowGetIDNative(self, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, byte* str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = WindowGetIDNative((ImGuiWindow*)pself, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, byte* str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = WindowGetIDNative((ImGuiWindow*)pself, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, byte* str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = WindowGetIDNative((ImGuiWindow*)pself, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = WindowGetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, ReadOnlySpan<byte> strEnd)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = WindowGetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ImGuiWindowPtr self, string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			uint ret = WindowGetIDNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, ref byte str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						uint ret = WindowGetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					fixed (byte* pstrEnd = strEnd)
					{
						uint ret = WindowGetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetID(ref ImGuiWindow self, string str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				uint ret = WindowGetIDNative((ImGuiWindow*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint WindowGetIDPtrNative(ImGuiWindow* self, void* ptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, void*, uint>)vt[950])(self, ptr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)vt[950])((nint)self, (nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetIDPtr(ImGuiWindowPtr self, void* ptr)
		{
			uint ret = WindowGetIDPtrNative(self, ptr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetIDPtr(ref ImGuiWindow self, void* ptr)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = WindowGetIDPtrNative((ImGuiWindow*)pself, ptr);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint WindowGetIDIntNative(ImGuiWindow* self, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, int, uint>)vt[951])(self, n);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)vt[951])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetIDInt(ImGuiWindowPtr self, int n)
		{
			uint ret = WindowGetIDIntNative(self, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint WindowGetIDInt(ref ImGuiWindow self, int n)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = WindowGetIDIntNative((ImGuiWindow*)pself, n);
				return ret;
			}
		}
	}
}
