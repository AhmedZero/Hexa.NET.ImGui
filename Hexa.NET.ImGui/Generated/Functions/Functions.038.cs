// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							fixed (Vector2* poutPos = &outPos)
							{
								byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextFindNodeByID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiDockNode* DockContextFindNodeByIDNative(ImGuiContext* ctx, int id);

		public static ImGuiDockNodePtr DockContextFindNodeByID(ImGuiContextPtr ctx, int id)
		{
			ImGuiDockNodePtr ret = DockContextFindNodeByIDNative(ctx, id);
			return ret;
		}

		public static ImGuiDockNodePtr DockContextFindNodeByID(ref ImGuiContext ctx, int id)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiDockNodePtr ret = DockContextFindNodeByIDNative((ImGuiContext*)pctx, id);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockNodeWindowMenuHandler_Default")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockNodeWindowMenuHandlerDefaultNative(ImGuiContext* ctx, ImGuiDockNode* node, ImGuiTabBar* tabBar);

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContextPtr ctx, ImGuiDockNodePtr node, ImGuiTabBarPtr tabBar)
		{
			DockNodeWindowMenuHandlerDefaultNative(ctx, node, tabBar);
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ImGuiDockNodePtr node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, node, tabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContextPtr ctx, ref ImGuiDockNode node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockNodeWindowMenuHandlerDefaultNative(ctx, (ImGuiDockNode*)pnode, tabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ref ImGuiDockNode node, ImGuiTabBarPtr tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, tabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContextPtr ctx, ImGuiDockNodePtr node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				DockNodeWindowMenuHandlerDefaultNative(ctx, node, (ImGuiTabBar*)ptabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ImGuiDockNodePtr node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, node, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContextPtr ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandlerDefaultNative(ctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					fixed (ImGuiTabBar* ptabBar = &tabBar)
					{
						DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockNodeBeginAmendTabBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte DockNodeBeginAmendTabBarNative(ImGuiDockNode* node);

		public static bool DockNodeBeginAmendTabBar(ImGuiDockNodePtr node)
		{
			byte ret = DockNodeBeginAmendTabBarNative(node);
			return ret != 0;
		}

		public static bool DockNodeBeginAmendTabBar(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = DockNodeBeginAmendTabBarNative((ImGuiDockNode*)pnode);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockNodeEndAmendTabBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockNodeEndAmendTabBarNative();

		public static void DockNodeEndAmendTabBar()
		{
			DockNodeEndAmendTabBarNative();
		}

		[LibraryImport(LibName, EntryPoint = "igDockNodeGetRootNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiDockNode* DockNodeGetRootNodeNative(ImGuiDockNode* node);

		public static ImGuiDockNodePtr DockNodeGetRootNode(ImGuiDockNodePtr node)
		{
			ImGuiDockNodePtr ret = DockNodeGetRootNodeNative(node);
			return ret;
		}

		public static ImGuiDockNodePtr DockNodeGetRootNode(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiDockNodePtr ret = DockNodeGetRootNodeNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockNodeIsInHierarchyOf")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte DockNodeIsInHierarchyOfNative(ImGuiDockNode* node, ImGuiDockNode* parent);

		public static bool DockNodeIsInHierarchyOf(ImGuiDockNodePtr node, ImGuiDockNodePtr parent)
		{
			byte ret = DockNodeIsInHierarchyOfNative(node, parent);
			return ret != 0;
		}

		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ImGuiDockNodePtr parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = DockNodeIsInHierarchyOfNative((ImGuiDockNode*)pnode, parent);
				return ret != 0;
			}
		}

		public static bool DockNodeIsInHierarchyOf(ImGuiDockNodePtr node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pparent = &parent)
			{
				byte ret = DockNodeIsInHierarchyOfNative(node, (ImGuiDockNode*)pparent);
				return ret != 0;
			}
		}

		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiDockNode* pparent = &parent)
				{
					byte ret = DockNodeIsInHierarchyOfNative((ImGuiDockNode*)pnode, (ImGuiDockNode*)pparent);
					return ret != 0;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockNodeGetDepth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int DockNodeGetDepthNative(ImGuiDockNode* node);

		public static int DockNodeGetDepth(ImGuiDockNodePtr node)
		{
			int ret = DockNodeGetDepthNative(node);
			return ret;
		}

		public static int DockNodeGetDepth(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetDepthNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockNodeGetWindowMenuButtonId")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int DockNodeGetWindowMenuButtonIdNative(ImGuiDockNode* node);

		public static int DockNodeGetWindowMenuButtonId(ImGuiDockNodePtr node)
		{
			int ret = DockNodeGetWindowMenuButtonIdNative(node);
			return ret;
		}

		public static int DockNodeGetWindowMenuButtonId(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetWindowMenuButtonIdNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowDockNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiDockNode* GetWindowDockNodeNative();

		public static ImGuiDockNodePtr GetWindowDockNode()
		{
			ImGuiDockNodePtr ret = GetWindowDockNodeNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetWindowAlwaysWantOwnTabBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte GetWindowAlwaysWantOwnTabBarNative(ImGuiWindow* window);

		public static bool GetWindowAlwaysWantOwnTabBar(ImGuiWindowPtr window)
		{
			byte ret = GetWindowAlwaysWantOwnTabBarNative(window);
			return ret != 0;
		}

		public static bool GetWindowAlwaysWantOwnTabBar(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = GetWindowAlwaysWantOwnTabBarNative((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBeginDocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BeginDockedNative(ImGuiWindow* window, bool* pOpen);

		public static void BeginDocked(ImGuiWindowPtr window, bool* pOpen)
		{
			BeginDockedNative(window, pOpen);
		}

		public static void BeginDocked(ref ImGuiWindow window, bool* pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockedNative((ImGuiWindow*)pwindow, pOpen);
			}
		}

		public static void BeginDocked(ImGuiWindowPtr window, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				BeginDockedNative(window, (bool*)ppOpen);
			}
		}

		public static void BeginDocked(ref ImGuiWindow window, ref bool pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					BeginDockedNative((ImGuiWindow*)pwindow, (bool*)ppOpen);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBeginDockableDragDropSource")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BeginDockableDragDropSourceNative(ImGuiWindow* window);

		public static void BeginDockableDragDropSource(ImGuiWindowPtr window)
		{
			BeginDockableDragDropSourceNative(window);
		}

		public static void BeginDockableDragDropSource(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropSourceNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBeginDockableDragDropTarget")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BeginDockableDragDropTargetNative(ImGuiWindow* window);

		public static void BeginDockableDragDropTarget(ImGuiWindowPtr window)
		{
			BeginDockableDragDropTargetNative(window);
		}

		public static void BeginDockableDragDropTarget(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropTargetNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowDock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowDockNative(ImGuiWindow* window, int dockId, ImGuiCond cond);

		public static void SetWindowDock(ImGuiWindowPtr window, int dockId, ImGuiCond cond)
		{
			SetWindowDockNative(window, dockId, cond);
		}

		public static void SetWindowDock(ref ImGuiWindow window, int dockId, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowDockNative((ImGuiWindow*)pwindow, dockId, cond);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderDockWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderDockWindowNative(byte* windowName, int nodeId);

		public static void DockBuilderDockWindow(byte* windowName, int nodeId)
		{
			DockBuilderDockWindowNative(windowName, nodeId);
		}

		public static void DockBuilderDockWindow(ref byte windowName, int nodeId)
		{
			fixed (byte* pwindowName = &windowName)
			{
				DockBuilderDockWindowNative((byte*)pwindowName, nodeId);
			}
		}

		public static void DockBuilderDockWindow(string windowName, int nodeId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (windowName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(windowName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(windowName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderDockWindowNative(pStr0, nodeId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderGetNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiDockNode* DockBuilderGetNodeNative(int nodeId);

		public static ImGuiDockNodePtr DockBuilderGetNode(int nodeId)
		{
			ImGuiDockNodePtr ret = DockBuilderGetNodeNative(nodeId);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderGetCentralNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiDockNode* DockBuilderGetCentralNodeNative(int nodeId);

		public static ImGuiDockNodePtr DockBuilderGetCentralNode(int nodeId)
		{
			ImGuiDockNodePtr ret = DockBuilderGetCentralNodeNative(nodeId);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderAddNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int DockBuilderAddNodeNative(int nodeId, ImGuiDockNodeFlags flags);

		public static int DockBuilderAddNode(int nodeId, ImGuiDockNodeFlags flags)
		{
			int ret = DockBuilderAddNodeNative(nodeId, flags);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderRemoveNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderRemoveNodeNative(int nodeId);

		public static void DockBuilderRemoveNode(int nodeId)
		{
			DockBuilderRemoveNodeNative(nodeId);
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderRemoveNodeDockedWindows")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderRemoveNodeDockedWindowsNative(int nodeId, byte clearSettingsRefs);

		public static void DockBuilderRemoveNodeDockedWindows(int nodeId, bool clearSettingsRefs)
		{
			DockBuilderRemoveNodeDockedWindowsNative(nodeId, clearSettingsRefs ? (byte)1 : (byte)0);
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderRemoveNodeChildNodes")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderRemoveNodeChildNodesNative(int nodeId);

		public static void DockBuilderRemoveNodeChildNodes(int nodeId)
		{
			DockBuilderRemoveNodeChildNodesNative(nodeId);
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderSetNodePos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderSetNodePosNative(int nodeId, Vector2 pos);

		public static void DockBuilderSetNodePos(int nodeId, Vector2 pos)
		{
			DockBuilderSetNodePosNative(nodeId, pos);
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderSetNodeSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderSetNodeSizeNative(int nodeId, Vector2 size);

		public static void DockBuilderSetNodeSize(int nodeId, Vector2 size)
		{
			DockBuilderSetNodeSizeNative(nodeId, size);
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderSplitNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int DockBuilderSplitNodeNative(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, int* outIdAtOppositeDir);

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, int* outIdAtOppositeDir)
		{
			int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, outIdAtOppositeDir);
			return ret;
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, ref int outIdAtDir, int* outIdAtOppositeDir)
		{
			fixed (int* poutIdAtDir = &outIdAtDir)
			{
				int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, (int*)poutIdAtDir, outIdAtOppositeDir);
				return ret;
			}
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, ref int outIdAtOppositeDir)
		{
			fixed (int* poutIdAtOppositeDir = &outIdAtOppositeDir)
			{
				int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, (int*)poutIdAtOppositeDir);
				return ret;
			}
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, ref int outIdAtDir, ref int outIdAtOppositeDir)
		{
			fixed (int* poutIdAtDir = &outIdAtDir)
			{
				fixed (int* poutIdAtOppositeDir = &outIdAtOppositeDir)
				{
					int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, (int*)poutIdAtDir, (int*)poutIdAtOppositeDir);
					return ret;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderCopyDockSpace")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderCopyDockSpaceNative(int srcDockspaceId, int dstDockspaceId, ImVectorConstCharPtr* inWindowRemapPairs);

		public static void DockBuilderCopyDockSpace(int srcDockspaceId, int dstDockspaceId, ImVectorConstCharPtrPtr inWindowRemapPairs)
		{
			DockBuilderCopyDockSpaceNative(srcDockspaceId, dstDockspaceId, inWindowRemapPairs);
		}

		public static void DockBuilderCopyDockSpace(int srcDockspaceId, int dstDockspaceId, ref ImVectorConstCharPtr inWindowRemapPairs)
		{
			fixed (ImVectorConstCharPtr* pinWindowRemapPairs = &inWindowRemapPairs)
			{
				DockBuilderCopyDockSpaceNative(srcDockspaceId, dstDockspaceId, (ImVectorConstCharPtr*)pinWindowRemapPairs);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderCopyNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderCopyNodeNative(int srcNodeId, int dstNodeId, ImVectorImGuiID* outNodeRemapPairs);

		public static void DockBuilderCopyNode(int srcNodeId, int dstNodeId, ImVectorImGuiIDPtr outNodeRemapPairs)
		{
			DockBuilderCopyNodeNative(srcNodeId, dstNodeId, outNodeRemapPairs);
		}

		public static void DockBuilderCopyNode(int srcNodeId, int dstNodeId, ref ImVectorImGuiID outNodeRemapPairs)
		{
			fixed (ImVectorImGuiID* poutNodeRemapPairs = &outNodeRemapPairs)
			{
				DockBuilderCopyNodeNative(srcNodeId, dstNodeId, (ImVectorImGuiID*)poutNodeRemapPairs);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderCopyWindowSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderCopyWindowSettingsNative(byte* srcName, byte* dstName);

		public static void DockBuilderCopyWindowSettings(byte* srcName, byte* dstName)
		{
			DockBuilderCopyWindowSettingsNative(srcName, dstName);
		}

		public static void DockBuilderCopyWindowSettings(ref byte srcName, byte* dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, dstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(string srcName, byte* dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, dstName);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, ref byte dstName)
		{
			fixed (byte* pdstName = &dstName)
			{
				DockBuilderCopyWindowSettingsNative(srcName, (byte*)pdstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dstName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(srcName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(ref byte srcName, ref byte dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		public static void DockBuilderCopyWindowSettings(string srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (dstName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(dstName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockBuilderFinish")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockBuilderFinishNative(int nodeId);

		public static void DockBuilderFinish(int nodeId)
		{
			DockBuilderFinishNative(nodeId);
		}

		[LibraryImport(LibName, EntryPoint = "igPushFocusScope")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushFocusScopeNative(int id);

		public static void PushFocusScope(int id)
		{
			PushFocusScopeNative(id);
		}

		[LibraryImport(LibName, EntryPoint = "igPopFocusScope")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopFocusScopeNative();

		public static void PopFocusScope()
		{
			PopFocusScopeNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetCurrentFocusScope")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetCurrentFocusScopeNative();

		public static int GetCurrentFocusScope()
		{
			int ret = GetCurrentFocusScopeNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igIsDragDropActive")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsDragDropActiveNative();

		public static bool IsDragDropActive()
		{
			byte ret = IsDragDropActiveNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginDragDropTargetCustom")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginDragDropTargetCustomNative(ImRect bb, int id);

		public static bool BeginDragDropTargetCustom(ImRect bb, int id)
		{
			byte ret = BeginDragDropTargetCustomNative(bb, id);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igClearDragDrop")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearDragDropNative();

		public static void ClearDragDrop()
		{
			ClearDragDropNative();
		}

		[LibraryImport(LibName, EntryPoint = "igIsDragDropPayloadBeingAccepted")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsDragDropPayloadBeingAcceptedNative();

		public static bool IsDragDropPayloadBeingAccepted()
		{
			byte ret = IsDragDropPayloadBeingAcceptedNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igRenderDragDropTargetRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderDragDropTargetRectNative(ImRect bb, ImRect itemClipRect);

		public static void RenderDragDropTargetRect(ImRect bb, ImRect itemClipRect)
		{
			RenderDragDropTargetRectNative(bb, itemClipRect);
		}

		[LibraryImport(LibName, EntryPoint = "igGetTypingSelectRequest")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTypingSelectRequest* GetTypingSelectRequestNative(ImGuiTypingSelectFlags flags);

		public static ImGuiTypingSelectRequestPtr GetTypingSelectRequest(ImGuiTypingSelectFlags flags)
		{
			ImGuiTypingSelectRequestPtr ret = GetTypingSelectRequestNative(flags);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igTypingSelectFindMatch")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TypingSelectFindMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx);

		public static int TypingSelectFindMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			int ret = TypingSelectFindMatchNative(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			return ret;
		}

		public static int TypingSelectFindMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData, navItemIdx);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTypingSelectFindNextSingleCharMatch")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TypingSelectFindNextSingleCharMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx);

		public static int TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			int ret = TypingSelectFindNextSingleCharMatchNative(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			return ret;
		}

		public static int TypingSelectFindNextSingleCharMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*, int> getItemNameFunc, void* userData, int navItemIdx)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindNextSingleCharMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData, navItemIdx);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTypingSelectFindBestLeadingMatch")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TypingSelectFindBestLeadingMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*> getItemNameFunc, void* userData);

		public static int TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*> getItemNameFunc, void* userData)
		{
			int ret = TypingSelectFindBestLeadingMatchNative(req, itemsCount, getItemNameFunc, userData);
			return ret;
		}

		public static int TypingSelectFindBestLeadingMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int>, void*> getItemNameFunc, void* userData)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindBestLeadingMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowClipRectBeforeSetChannel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowClipRectBeforeSetChannelNative(ImGuiWindow* window, ImRect clipRect);

		public static void SetWindowClipRectBeforeSetChannel(ImGuiWindowPtr window, ImRect clipRect)
		{
			SetWindowClipRectBeforeSetChannelNative(window, clipRect);
		}

		public static void SetWindowClipRectBeforeSetChannel(ref ImGuiWindow window, ImRect clipRect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowClipRectBeforeSetChannelNative((ImGuiWindow*)pwindow, clipRect);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBeginColumns")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BeginColumnsNative(byte* strId, int count, ImGuiOldColumnFlags flags);

		public static void BeginColumns(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			BeginColumnsNative(strId, count, flags);
		}

		public static void BeginColumns(ref byte strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				BeginColumnsNative((byte*)pstrId, count, flags);
			}
		}

		public static void BeginColumns(string strId, int count, ImGuiOldColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BeginColumnsNative(pStr0, count, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igEndColumns")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndColumnsNative();

		public static void EndColumns()
		{
			EndColumnsNative();
		}

		[LibraryImport(LibName, EntryPoint = "igPushColumnClipRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushColumnClipRectNative(int columnIndex);

		public static void PushColumnClipRect(int columnIndex)
		{
			PushColumnClipRectNative(columnIndex);
		}

		[LibraryImport(LibName, EntryPoint = "igPushColumnsBackground")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushColumnsBackgroundNative();

		public static void PushColumnsBackground()
		{
			PushColumnsBackgroundNative();
		}

		[LibraryImport(LibName, EntryPoint = "igPopColumnsBackground")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopColumnsBackgroundNative();

		public static void PopColumnsBackground()
		{
			PopColumnsBackgroundNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetColumnsID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetColumnsIDNative(byte* strId, int count);

		public static int GetColumnsID(byte* strId, int count)
		{
			int ret = GetColumnsIDNative(strId, count);
			return ret;
		}

		public static int GetColumnsID(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				int ret = GetColumnsIDNative((byte*)pstrId, count);
				return ret;
			}
		}

		public static int GetColumnsID(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetColumnsIDNative(pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igFindOrCreateColumns")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiOldColumns* FindOrCreateColumnsNative(ImGuiWindow* window, int id);

		public static ImGuiOldColumnsPtr FindOrCreateColumns(ImGuiWindowPtr window, int id)
		{
			ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative(window, id);
			return ret;
		}

		public static ImGuiOldColumnsPtr FindOrCreateColumns(ref ImGuiWindow window, int id)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative((ImGuiWindow*)pwindow, id);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetColumnOffsetFromNorm")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetColumnOffsetFromNormNative(ImGuiOldColumns* columns, float offsetNorm);

		public static float GetColumnOffsetFromNorm(ImGuiOldColumnsPtr columns, float offsetNorm)
		{
			float ret = GetColumnOffsetFromNormNative(columns, offsetNorm);
			return ret;
		}

		public static float GetColumnOffsetFromNorm(ref ImGuiOldColumns columns, float offsetNorm)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnOffsetFromNormNative((ImGuiOldColumns*)pcolumns, offsetNorm);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetColumnNormFromOffset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetColumnNormFromOffsetNative(ImGuiOldColumns* columns, float offset);

		public static float GetColumnNormFromOffset(ImGuiOldColumnsPtr columns, float offset)
		{
			float ret = GetColumnNormFromOffsetNative(columns, offset);
			return ret;
		}

		public static float GetColumnNormFromOffset(ref ImGuiOldColumns columns, float offset)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnNormFromOffsetNative((ImGuiOldColumns*)pcolumns, offset);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableOpenContextMenu")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableOpenContextMenuNative(int columnN);

		public static void TableOpenContextMenu(int columnN)
		{
			TableOpenContextMenuNative(columnN);
		}

		[LibraryImport(LibName, EntryPoint = "igTableSetColumnWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetColumnWidthNative(int columnN, float width);

		public static void TableSetColumnWidth(int columnN, float width)
		{
			TableSetColumnWidthNative(columnN, width);
		}

		[LibraryImport(LibName, EntryPoint = "igTableSetColumnSortDirection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetColumnSortDirectionNative(int columnN, ImGuiSortDirection sortDirection, byte appendToSortSpecs);

		public static void TableSetColumnSortDirection(int columnN, ImGuiSortDirection sortDirection, bool appendToSortSpecs)
		{
			TableSetColumnSortDirectionNative(columnN, sortDirection, appendToSortSpecs ? (byte)1 : (byte)0);
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetHoveredColumn")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TableGetHoveredColumnNative();

		public static int TableGetHoveredColumn()
		{
			int ret = TableGetHoveredColumnNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetHoveredRow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TableGetHoveredRowNative();

		public static int TableGetHoveredRow()
		{
			int ret = TableGetHoveredRowNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetHeaderRowHeight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float TableGetHeaderRowHeightNative();

		public static float TableGetHeaderRowHeight()
		{
			float ret = TableGetHeaderRowHeightNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetHeaderAngledMaxLabelWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float TableGetHeaderAngledMaxLabelWidthNative();

		public static float TableGetHeaderAngledMaxLabelWidth()
		{
			float ret = TableGetHeaderAngledMaxLabelWidthNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igTablePushBackgroundChannel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TablePushBackgroundChannelNative();

		public static void TablePushBackgroundChannel()
		{
			TablePushBackgroundChannelNative();
		}

		[LibraryImport(LibName, EntryPoint = "igTablePopBackgroundChannel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TablePopBackgroundChannelNative();

		public static void TablePopBackgroundChannel()
		{
			TablePopBackgroundChannelNative();
		}

		[LibraryImport(LibName, EntryPoint = "igTableAngledHeadersRowEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableAngledHeadersRowExNative(float angle, float maxLabelWidth);

		public static void TableAngledHeadersRowEx(float angle, float maxLabelWidth)
		{
			TableAngledHeadersRowExNative(angle, maxLabelWidth);
		}

		[LibraryImport(LibName, EntryPoint = "igGetCurrentTable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTable* GetCurrentTableNative();

		public static ImGuiTablePtr GetCurrentTable()
		{
			ImGuiTablePtr ret = GetCurrentTableNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igTableFindByID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTable* TableFindByIDNative(int id);

		public static ImGuiTablePtr TableFindByID(int id)
		{
			ImGuiTablePtr ret = TableFindByIDNative(id);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginTableEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginTableExNative(byte* name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth);

		public static bool BeginTableEx(byte* name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, flags, outerSize, innerWidth);
			return ret != 0;
		}

		public static bool BeginTableEx(ref byte name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		public static bool BeginTableEx(string name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igTableBeginInitMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableBeginInitMemoryNative(ImGuiTable* table, int columnsCount);

		public static void TableBeginInitMemory(ImGuiTablePtr table, int columnsCount)
		{
			TableBeginInitMemoryNative(table, columnsCount);
		}

		public static void TableBeginInitMemory(ref ImGuiTable table, int columnsCount)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginInitMemoryNative((ImGuiTable*)ptable, columnsCount);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableBeginApplyRequests")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableBeginApplyRequestsNative(ImGuiTable* table);

		public static void TableBeginApplyRequests(ImGuiTablePtr table)
		{
			TableBeginApplyRequestsNative(table);
		}

		public static void TableBeginApplyRequests(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginApplyRequestsNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableSetupDrawChannels")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetupDrawChannelsNative(ImGuiTable* table);

		public static void TableSetupDrawChannels(ImGuiTablePtr table)
		{
			TableSetupDrawChannelsNative(table);
		}

		public static void TableSetupDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetupDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableUpdateLayout")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableUpdateLayoutNative(ImGuiTable* table);

		public static void TableUpdateLayout(ImGuiTablePtr table)
		{
			TableUpdateLayoutNative(table);
		}

		public static void TableUpdateLayout(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateLayoutNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableUpdateBorders")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableUpdateBordersNative(ImGuiTable* table);

		public static void TableUpdateBorders(ImGuiTablePtr table)
		{
			TableUpdateBordersNative(table);
		}

		public static void TableUpdateBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateBordersNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableUpdateColumnsWeightFromWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableUpdateColumnsWeightFromWidthNative(ImGuiTable* table);

		public static void TableUpdateColumnsWeightFromWidth(ImGuiTablePtr table)
		{
			TableUpdateColumnsWeightFromWidthNative(table);
		}

		public static void TableUpdateColumnsWeightFromWidth(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateColumnsWeightFromWidthNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableDrawBorders")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableDrawBordersNative(ImGuiTable* table);

		public static void TableDrawBorders(ImGuiTablePtr table)
		{
			TableDrawBordersNative(table);
		}

		public static void TableDrawBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawBordersNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableDrawDefaultContextMenu")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableDrawDefaultContextMenuNative(ImGuiTable* table, ImGuiTableFlags flagsForSectionToDisplay);

		public static void TableDrawDefaultContextMenu(ImGuiTablePtr table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			TableDrawDefaultContextMenuNative(table, flagsForSectionToDisplay);
		}

		public static void TableDrawDefaultContextMenu(ref ImGuiTable table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawDefaultContextMenuNative((ImGuiTable*)ptable, flagsForSectionToDisplay);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableBeginContextMenuPopup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TableBeginContextMenuPopupNative(ImGuiTable* table);

		public static bool TableBeginContextMenuPopup(ImGuiTablePtr table)
		{
			byte ret = TableBeginContextMenuPopupNative(table);
			return ret != 0;
		}

		public static bool TableBeginContextMenuPopup(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte ret = TableBeginContextMenuPopupNative((ImGuiTable*)ptable);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableMergeDrawChannels")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableMergeDrawChannelsNative(ImGuiTable* table);

		public static void TableMergeDrawChannels(ImGuiTablePtr table)
		{
			TableMergeDrawChannelsNative(table);
		}

		public static void TableMergeDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableMergeDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetInstanceData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTableInstanceData* TableGetInstanceDataNative(ImGuiTable* table, int instanceNo);

		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ImGuiTablePtr table, int instanceNo)
		{
			ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative(table, instanceNo);
			return ret;
		}

		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetInstanceID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TableGetInstanceIDNative(ImGuiTable* table, int instanceNo);

		public static int TableGetInstanceID(ImGuiTablePtr table, int instanceNo)
		{
			int ret = TableGetInstanceIDNative(table, instanceNo);
			return ret;
		}

		public static int TableGetInstanceID(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				int ret = TableGetInstanceIDNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableSortSpecsSanitize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSortSpecsSanitizeNative(ImGuiTable* table);

		public static void TableSortSpecsSanitize(ImGuiTablePtr table)
		{
			TableSortSpecsSanitizeNative(table);
		}

		public static void TableSortSpecsSanitize(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsSanitizeNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableSortSpecsBuild")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSortSpecsBuildNative(ImGuiTable* table);

		public static void TableSortSpecsBuild(ImGuiTablePtr table)
		{
			TableSortSpecsBuildNative(table);
		}

		public static void TableSortSpecsBuild(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsBuildNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetColumnNextSortDirection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiSortDirection TableGetColumnNextSortDirectionNative(ImGuiTableColumn* column);

		public static ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumnPtr column)
		{
			ImGuiSortDirection ret = TableGetColumnNextSortDirectionNative(column);
			return ret;
		}

		public static ImGuiSortDirection TableGetColumnNextSortDirection(ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				ImGuiSortDirection ret = TableGetColumnNextSortDirectionNative((ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableFixColumnSortDirection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableFixColumnSortDirectionNative(ImGuiTable* table, ImGuiTableColumn* column);

		public static void TableFixColumnSortDirection(ImGuiTablePtr table, ImGuiTableColumnPtr column)
		{
			TableFixColumnSortDirectionNative(table, column);
		}

		public static void TableFixColumnSortDirection(ref ImGuiTable table, ImGuiTableColumnPtr column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableFixColumnSortDirectionNative((ImGuiTable*)ptable, column);
			}
		}

		public static void TableFixColumnSortDirection(ImGuiTablePtr table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				TableFixColumnSortDirectionNative(table, (ImGuiTableColumn*)pcolumn);
			}
		}

		public static void TableFixColumnSortDirection(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					TableFixColumnSortDirectionNative((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetColumnWidthAuto")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float TableGetColumnWidthAutoNative(ImGuiTable* table, ImGuiTableColumn* column);

		public static float TableGetColumnWidthAuto(ImGuiTablePtr table, ImGuiTableColumnPtr column)
		{
			float ret = TableGetColumnWidthAutoNative(table, column);
			return ret;
		}

		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ImGuiTableColumnPtr column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetColumnWidthAutoNative((ImGuiTable*)ptable, column);
				return ret;
			}
		}

		public static float TableGetColumnWidthAuto(ImGuiTablePtr table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				float ret = TableGetColumnWidthAutoNative(table, (ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					float ret = TableGetColumnWidthAutoNative((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
					return ret;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableBeginRow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableBeginRowNative(ImGuiTable* table);

		public static void TableBeginRow(ImGuiTablePtr table)
		{
			TableBeginRowNative(table);
		}

		public static void TableBeginRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginRowNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableEndRow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableEndRowNative(ImGuiTable* table);

		public static void TableEndRow(ImGuiTablePtr table)
		{
			TableEndRowNative(table);
		}

		public static void TableEndRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableEndRowNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableBeginCell")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableBeginCellNative(ImGuiTable* table, int columnN);

		public static void TableBeginCell(ImGuiTablePtr table, int columnN)
		{
			TableBeginCellNative(table, columnN);
		}

		public static void TableBeginCell(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginCellNative((ImGuiTable*)ptable, columnN);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableEndCell")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableEndCellNative(ImGuiTable* table);

		public static void TableEndCell(ImGuiTablePtr table)
		{
			TableEndCellNative(table);
		}

		public static void TableEndCell(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableEndCellNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetCellBgRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableGetCellBgRectNative(ImRect* output, ImGuiTable* table, int columnN);

		public static ImRect TableGetCellBgRect(ImGuiTablePtr table, int columnN)
		{
			ImRect ret;
			TableGetCellBgRectNative(&ret, table, columnN);
			return ret;
		}

		public static void TableGetCellBgRect(ImRectPtr output, ImGuiTablePtr table, int columnN)
		{
			TableGetCellBgRectNative(output, table, columnN);
		}

		public static void TableGetCellBgRect(ref ImRect output, ImGuiTablePtr table, int columnN)
		{
			fixed (ImRect* poutput = &output)
			{
				TableGetCellBgRectNative((ImRect*)poutput, table, columnN);
			}
		}

		public static ImRect TableGetCellBgRect(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImRect ret;
				TableGetCellBgRectNative(&ret, (ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		public static void TableGetCellBgRect(ImRectPtr output, ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableGetCellBgRectNative(output, (ImGuiTable*)ptable, columnN);
			}
		}

		public static void TableGetCellBgRect(ref ImRect output, ref ImGuiTable table, int columnN)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiTable* ptable = &table)
				{
					TableGetCellBgRectNative((ImRect*)poutput, (ImGuiTable*)ptable, columnN);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetColumnName_TablePtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* TableGetColumnNameTablePtrNative(ImGuiTable* table, int columnN);

		public static byte* TableGetColumnNameTablePtr(ImGuiTablePtr table, int columnN)
		{
			byte* ret = TableGetColumnNameTablePtrNative(table, columnN);
			return ret;
		}

		public static string TableGetColumnNameTablePtrS(ImGuiTablePtr table, int columnN)
		{
			string ret = Utils.DecodeStringUTF8(TableGetColumnNameTablePtrNative(table, columnN));
			return ret;
		}

		public static byte* TableGetColumnNameTablePtr(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte* ret = TableGetColumnNameTablePtrNative((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		public static string TableGetColumnNameTablePtrS(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				string ret = Utils.DecodeStringUTF8(TableGetColumnNameTablePtrNative((ImGuiTable*)ptable, columnN));
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetColumnResizeID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TableGetColumnResizeIDNative(ImGuiTable* table, int columnN, int instanceNo);

		public static int TableGetColumnResizeID(ImGuiTablePtr table, int columnN, int instanceNo)
		{
			int ret = TableGetColumnResizeIDNative(table, columnN, instanceNo);
			return ret;
		}

		public static int TableGetColumnResizeID(ref ImGuiTable table, int columnN, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				int ret = TableGetColumnResizeIDNative((ImGuiTable*)ptable, columnN, instanceNo);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetMaxColumnWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float TableGetMaxColumnWidthNative(ImGuiTable* table, int columnN);

		public static float TableGetMaxColumnWidth(ImGuiTablePtr table, int columnN)
		{
			float ret = TableGetMaxColumnWidthNative(table, columnN);
			return ret;
		}

		public static float TableGetMaxColumnWidth(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetMaxColumnWidthNative((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableSetColumnWidthAutoSingle")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetColumnWidthAutoSingleNative(ImGuiTable* table, int columnN);

		public static void TableSetColumnWidthAutoSingle(ImGuiTablePtr table, int columnN)
		{
			TableSetColumnWidthAutoSingleNative(table, columnN);
		}

		public static void TableSetColumnWidthAutoSingle(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetColumnWidthAutoSingleNative((ImGuiTable*)ptable, columnN);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableSetColumnWidthAutoAll")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetColumnWidthAutoAllNative(ImGuiTable* table);

		public static void TableSetColumnWidthAutoAll(ImGuiTablePtr table)
		{
			TableSetColumnWidthAutoAllNative(table);
		}

		public static void TableSetColumnWidthAutoAll(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetColumnWidthAutoAllNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableRemove")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableRemoveNative(ImGuiTable* table);

		public static void TableRemove(ImGuiTablePtr table)
		{
			TableRemoveNative(table);
		}

		public static void TableRemove(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableRemoveNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGcCompactTransientBuffers_TablePtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableGcCompactTransientBuffersTablePtrNative(ImGuiTable* table);

		public static void TableGcCompactTransientBuffersTablePtr(ImGuiTablePtr table)
		{
			TableGcCompactTransientBuffersTablePtrNative(table);
		}

		public static void TableGcCompactTransientBuffersTablePtr(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableGcCompactTransientBuffersTablePtrNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGcCompactTransientBuffers_TableTempDataPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableGcCompactTransientBuffersTableTempDataPtrNative(ImGuiTableTempData* table);

		public static void TableGcCompactTransientBuffersTableTempDataPtr(ImGuiTableTempDataPtr table)
		{
			TableGcCompactTransientBuffersTableTempDataPtrNative(table);
		}

		public static void TableGcCompactTransientBuffersTableTempDataPtr(ref ImGuiTableTempData table)
		{
			fixed (ImGuiTableTempData* ptable = &table)
			{
				TableGcCompactTransientBuffersTableTempDataPtrNative((ImGuiTableTempData*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGcCompactSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableGcCompactSettingsNative();

		public static void TableGcCompactSettings()
		{
			TableGcCompactSettingsNative();
		}

		[LibraryImport(LibName, EntryPoint = "igTableLoadSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableLoadSettingsNative(ImGuiTable* table);

		public static void TableLoadSettings(ImGuiTablePtr table)
		{
			TableLoadSettingsNative(table);
		}

		public static void TableLoadSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableLoadSettingsNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableSaveSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSaveSettingsNative(ImGuiTable* table);

		public static void TableSaveSettings(ImGuiTablePtr table)
		{
			TableSaveSettingsNative(table);
		}

		public static void TableSaveSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSaveSettingsNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableResetSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableResetSettingsNative(ImGuiTable* table);

		public static void TableResetSettings(ImGuiTablePtr table)
		{
			TableResetSettingsNative(table);
		}

		public static void TableResetSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableResetSettingsNative((ImGuiTable*)ptable);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableGetBoundSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTableSettings* TableGetBoundSettingsNative(ImGuiTable* table);

		public static ImGuiTableSettingsPtr TableGetBoundSettings(ImGuiTablePtr table)
		{
			ImGuiTableSettingsPtr ret = TableGetBoundSettingsNative(table);
			return ret;
		}

		public static ImGuiTableSettingsPtr TableGetBoundSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableSettingsPtr ret = TableGetBoundSettingsNative((ImGuiTable*)ptable);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTableSettingsAddSettingsHandler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSettingsAddSettingsHandlerNative();

		public static void TableSettingsAddSettingsHandler()
		{
			TableSettingsAddSettingsHandlerNative();
		}

		[LibraryImport(LibName, EntryPoint = "igTableSettingsCreate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTableSettings* TableSettingsCreateNative(int id, int columnsCount);

		public static ImGuiTableSettingsPtr TableSettingsCreate(int id, int columnsCount)
		{
			ImGuiTableSettingsPtr ret = TableSettingsCreateNative(id, columnsCount);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igTableSettingsFindByID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTableSettings* TableSettingsFindByIDNative(int id);

		public static ImGuiTableSettingsPtr TableSettingsFindByID(int id)
		{
			ImGuiTableSettingsPtr ret = TableSettingsFindByIDNative(id);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetCurrentTabBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTabBar* GetCurrentTabBarNative();

		public static ImGuiTabBarPtr GetCurrentTabBar()
		{
			ImGuiTabBarPtr ret = GetCurrentTabBarNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginTabBarEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginTabBarExNative(ImGuiTabBar* tabBar, ImRect bb, ImGuiTabBarFlags flags);

		public static bool BeginTabBarEx(ImGuiTabBarPtr tabBar, ImRect bb, ImGuiTabBarFlags flags)
		{
			byte ret = BeginTabBarExNative(tabBar, bb, flags);
			return ret != 0;
		}

		public static bool BeginTabBarEx(ref ImGuiTabBar tabBar, ImRect bb, ImGuiTabBarFlags flags)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = BeginTabBarExNative((ImGuiTabBar*)ptabBar, bb, flags);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarFindTabByID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTabItem* TabBarFindTabByIDNative(ImGuiTabBar* tabBar, int tabId);

		public static ImGuiTabItemPtr TabBarFindTabByID(ImGuiTabBarPtr tabBar, int tabId)
		{
			ImGuiTabItemPtr ret = TabBarFindTabByIDNative(tabBar, tabId);
			return ret;
		}

		public static ImGuiTabItemPtr TabBarFindTabByID(ref ImGuiTabBar tabBar, int tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindTabByIDNative((ImGuiTabBar*)ptabBar, tabId);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarFindTabByOrder")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTabItem* TabBarFindTabByOrderNative(ImGuiTabBar* tabBar, int order);

		public static ImGuiTabItemPtr TabBarFindTabByOrder(ImGuiTabBarPtr tabBar, int order)
		{
			ImGuiTabItemPtr ret = TabBarFindTabByOrderNative(tabBar, order);
			return ret;
		}

		public static ImGuiTabItemPtr TabBarFindTabByOrder(ref ImGuiTabBar tabBar, int order)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindTabByOrderNative((ImGuiTabBar*)ptabBar, order);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarFindMostRecentlySelectedTabForActiveWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTabItem* TabBarFindMostRecentlySelectedTabForActiveWindowNative(ImGuiTabBar* tabBar);

		public static ImGuiTabItemPtr TabBarFindMostRecentlySelectedTabForActiveWindow(ImGuiTabBarPtr tabBar)
		{
			ImGuiTabItemPtr ret = TabBarFindMostRecentlySelectedTabForActiveWindowNative(tabBar);
			return ret;
		}

		public static ImGuiTabItemPtr TabBarFindMostRecentlySelectedTabForActiveWindow(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindMostRecentlySelectedTabForActiveWindowNative((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarGetCurrentTab")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTabItem* TabBarGetCurrentTabNative(ImGuiTabBar* tabBar);

		public static ImGuiTabItemPtr TabBarGetCurrentTab(ImGuiTabBarPtr tabBar)
		{
			ImGuiTabItemPtr ret = TabBarGetCurrentTabNative(tabBar);
			return ret;
		}

		public static ImGuiTabItemPtr TabBarGetCurrentTab(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarGetCurrentTabNative((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarGetTabOrder")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TabBarGetTabOrderNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static int TabBarGetTabOrder(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			int ret = TabBarGetTabOrderNative(tabBar, tab);
			return ret;
		}

		public static int TabBarGetTabOrder(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				int ret = TabBarGetTabOrderNative((ImGuiTabBar*)ptabBar, tab);
				return ret;
			}
		}

		public static int TabBarGetTabOrder(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				int ret = TabBarGetTabOrderNative(tabBar, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		public static int TabBarGetTabOrder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					int ret = TabBarGetTabOrderNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarGetTabName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* TabBarGetTabNameNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static byte* TabBarGetTabName(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			byte* ret = TabBarGetTabNameNative(tabBar, tab);
			return ret;
		}

		public static string TabBarGetTabNameS(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative(tabBar, tab));
			return ret;
		}

		public static byte* TabBarGetTabName(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* ret = TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, tab);
				return ret;
			}
		}

		public static string TabBarGetTabNameS(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, tab));
				return ret;
			}
		}

		public static byte* TabBarGetTabName(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				byte* ret = TabBarGetTabNameNative(tabBar, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		public static string TabBarGetTabNameS(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative(tabBar, (ImGuiTabItem*)ptab));
				return ret;
			}
		}

		public static byte* TabBarGetTabName(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					byte* ret = TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		public static string TabBarGetTabNameS(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab));
					return ret;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarAddTab")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabBarAddTabNative(ImGuiTabBar* tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindow* window);

		public static void TabBarAddTab(ImGuiTabBarPtr tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindowPtr window)
		{
			TabBarAddTabNative(tabBar, tabFlags, window);
		}

		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindowPtr window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarAddTabNative((ImGuiTabBar*)ptabBar, tabFlags, window);
			}
		}

		public static void TabBarAddTab(ImGuiTabBarPtr tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				TabBarAddTabNative(tabBar, tabFlags, (ImGuiWindow*)pwindow);
			}
		}

		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					TabBarAddTabNative((ImGuiTabBar*)ptabBar, tabFlags, (ImGuiWindow*)pwindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarRemoveTab")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabBarRemoveTabNative(ImGuiTabBar* tabBar, int tabId);

		public static void TabBarRemoveTab(ImGuiTabBarPtr tabBar, int tabId)
		{
			TabBarRemoveTabNative(tabBar, tabId);
		}

		public static void TabBarRemoveTab(ref ImGuiTabBar tabBar, int tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarRemoveTabNative((ImGuiTabBar*)ptabBar, tabId);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarCloseTab")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabBarCloseTabNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static void TabBarCloseTab(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			TabBarCloseTabNative(tabBar, tab);
		}

		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarCloseTabNative((ImGuiTabBar*)ptabBar, tab);
			}
		}

		public static void TabBarCloseTab(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarCloseTabNative(tabBar, (ImGuiTabItem*)ptab);
			}
		}

		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarCloseTabNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarQueueFocus")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabBarQueueFocusNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static void TabBarQueueFocus(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			TabBarQueueFocusNative(tabBar, tab);
		}

		public static void TabBarQueueFocus(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueFocusNative((ImGuiTabBar*)ptabBar, tab);
			}
		}

		public static void TabBarQueueFocus(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueFocusNative(tabBar, (ImGuiTabItem*)ptab);
			}
		}

		public static void TabBarQueueFocus(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueFocusNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarQueueReorder")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabBarQueueReorderNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab, int offset);

		public static void TabBarQueueReorder(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab, int offset)
		{
			TabBarQueueReorderNative(tabBar, tab, offset);
		}

		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueReorderNative((ImGuiTabBar*)ptabBar, tab, offset);
			}
		}

		public static void TabBarQueueReorder(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueReorderNative(tabBar, (ImGuiTabItem*)ptab, offset);
			}
		}

		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueReorderNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, offset);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarQueueReorderFromMousePos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabBarQueueReorderFromMousePosNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab, Vector2 mousePos);

		public static void TabBarQueueReorderFromMousePos(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab, Vector2 mousePos)
		{
			TabBarQueueReorderFromMousePosNative(tabBar, tab, mousePos);
		}

		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueReorderFromMousePosNative((ImGuiTabBar*)ptabBar, tab, mousePos);
			}
		}

		public static void TabBarQueueReorderFromMousePos(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueReorderFromMousePosNative(tabBar, (ImGuiTabItem*)ptab, mousePos);
			}
		}

		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueReorderFromMousePosNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, mousePos);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabBarProcessReorder")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TabBarProcessReorderNative(ImGuiTabBar* tabBar);

		public static bool TabBarProcessReorder(ImGuiTabBarPtr tabBar)
		{
			byte ret = TabBarProcessReorderNative(tabBar);
			return ret != 0;
		}

		public static bool TabBarProcessReorder(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = TabBarProcessReorderNative((ImGuiTabBar*)ptabBar);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabItemEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TabItemExNative(ImGuiTabBar* tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow);

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte ret = TabItemExNative(tabBar, label, pOpen, flags, dockedWindow);
			return ret != 0;
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TabItemExNative(tabBar, (byte*)plabel, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TabItemExNative(tabBar, pStr0, pOpen, flags, dockedWindow);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = TabItemExNative(tabBar, label, (bool*)ppOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative(tabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = TabItemExNative(tabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
						return ret != 0;
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				byte ret = TabItemExNative(tabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				return ret != 0;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				byte ret = TabItemExNative(tabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative(tabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
						{
							byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabItemCalcSize_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabItemCalcSizeNative(Vector2* output, byte* label, byte hasCloseButtonOrUnsavedMarker);

		public static Vector2 TabItemCalcSize(byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			Vector2 ret;
			TabItemCalcSizeNative(&ret, label, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			return ret;
		}

		public static void TabItemCalcSize(Vector2* output, byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			TabItemCalcSizeNative(output, label, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
		}

		public static void TabItemCalcSize(ref Vector2 output, byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				TabItemCalcSizeNative((Vector2*)poutput, label, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			}
		}

		public static Vector2 TabItemCalcSize(ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (byte* plabel = &label)
			{
				Vector2 ret;
				TabItemCalcSizeNative(&ret, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public static Vector2 TabItemCalcSize(string label, bool hasCloseButtonOrUnsavedMarker)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			TabItemCalcSizeNative(&ret, pStr0, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void TabItemCalcSize(ref Vector2 output, ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* plabel = &label)
				{
					TabItemCalcSizeNative((Vector2*)poutput, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				}
			}
		}

		public static void TabItemCalcSize(ref Vector2 output, string label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TabItemCalcSizeNative((Vector2*)poutput, pStr0, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemCalcSize(Vector2* output, ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (byte* plabel = &label)
			{
				TabItemCalcSizeNative(output, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			}
		}

		public static void TabItemCalcSize(Vector2* output, string label, bool hasCloseButtonOrUnsavedMarker)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TabItemCalcSizeNative(output, pStr0, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabItemCalcSize_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabItemCalcSizeWindowPtrNative(Vector2* output, ImGuiWindow* window);

		public static Vector2 TabItemCalcSizeWindowPtr(ImGuiWindowPtr window)
		{
			Vector2 ret;
			TabItemCalcSizeWindowPtrNative(&ret, window);
			return ret;
		}

		public static void TabItemCalcSizeWindowPtr(Vector2* output, ImGuiWindowPtr window)
		{
			TabItemCalcSizeWindowPtrNative(output, window);
		}

		public static void TabItemCalcSizeWindowPtr(ref Vector2 output, ImGuiWindowPtr window)
		{
			fixed (Vector2* poutput = &output)
			{
				TabItemCalcSizeWindowPtrNative((Vector2*)poutput, window);
			}
		}

		public static Vector2 TabItemCalcSizeWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				TabItemCalcSizeWindowPtrNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		public static void TabItemCalcSizeWindowPtr(Vector2* output, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				TabItemCalcSizeWindowPtrNative(output, (ImGuiWindow*)pwindow);
			}
		}

		public static void TabItemCalcSizeWindowPtr(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					TabItemCalcSizeWindowPtrNative((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabItemBackground")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabItemBackgroundNative(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, uint col);

		public static void TabItemBackground(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			TabItemBackgroundNative(drawList, bb, flags, col);
		}

		public static void TabItemBackground(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				TabItemBackgroundNative((ImDrawList*)pdrawList, bb, flags, col);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTabItemLabelAndCloseButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TabItemLabelAndCloseButtonNative(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, byte isContentsVisible, bool* outJustClosed, bool* outTextClipped);

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						fixed (bool* poutTextClipped = &outTextClipped)
						{
							TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						}
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igRenderText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderTextNative(Vector2 pos, byte* text, byte* textEnd, byte hideTextAfterHash);

		public static void RenderText(Vector2 pos, byte* text, byte* textEnd, bool hideTextAfterHash)
		{
			RenderTextNative(pos, text, textEnd, hideTextAfterHash ? (byte)1 : (byte)0);
		}

		public static void RenderText(Vector2 pos, ref byte text, byte* textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextNative(pos, (byte*)ptext, textEnd, hideTextAfterHash ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText(Vector2 pos, string text, byte* textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(pos, pStr0, textEnd, hideTextAfterHash ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(Vector2 pos, byte* text, ref byte textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(pos, text, (byte*)ptextEnd, hideTextAfterHash ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText(Vector2 pos, byte* text, string textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(pos, text, pStr0, hideTextAfterHash ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(Vector2 pos, ref byte text, ref byte textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(pos, (byte*)ptext, (byte*)ptextEnd, hideTextAfterHash ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText(Vector2 pos, string text, string textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(pos, pStr0, pStr1, hideTextAfterHash ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igRenderTextWrapped")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderTextWrappedNative(Vector2 pos, byte* text, byte* textEnd, float wrapWidth);

		public static void RenderTextWrapped(Vector2 pos, byte* text, byte* textEnd, float wrapWidth)
		{
			RenderTextWrappedNative(pos, text, textEnd, wrapWidth);
		}

		public static void RenderTextWrapped(Vector2 pos, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextWrappedNative(pos, (byte*)ptext, textEnd, wrapWidth);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextWrappedNative(pos, pStr0, textEnd, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextWrappedNative(pos, text, (byte*)ptextEnd, wrapWidth);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextWrappedNative(pos, text, pStr0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextWrappedNative(pos, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
				}
			}
		}

		public static void RenderTextWrapped(Vector2 pos, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextWrappedNative(pos, pStr0, pStr1, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igRenderTextClipped")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderTextClippedNative(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect);

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			RenderTextClippedNative(posMin, posMax, text, textEnd, textSizeIfKnown, align, clipRect);
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextClippedNative(posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedNative(posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextClippedNative(posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedNative(posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClippedNative(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextClippedNative(posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedNative(posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedNative(posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedNative(posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedNative(posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedNative(posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedNative(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedNative(posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedNative(posMin, posMax, text, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedNative(posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedNative(posMin, posMax, text, pStr0, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedNative(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedNative(posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedNative(posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedNative(posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedNative(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igRenderTextClippedEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderTextClippedExNative(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect);

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			RenderTextClippedExNative(drawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, clipRect);
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedExNative(drawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedExNative(drawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextClippedExNative(drawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawListPtr drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRectPtr clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
						{
							RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
						}
					}
				}
			}
		}
	}
}
