// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		[LibraryImport(LibName, EntryPoint = "igUpdateWindowParentAndRootLinks")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void UpdateWindowParentAndRootLinksNative(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parentWindow);

		public static void UpdateWindowParentAndRootLinks(ImGuiWindowPtr window, ImGuiWindowFlags flags, ImGuiWindowPtr parentWindow)
		{
			UpdateWindowParentAndRootLinksNative(window, flags, parentWindow);
		}

		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ImGuiWindowPtr parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				UpdateWindowParentAndRootLinksNative((ImGuiWindow*)pwindow, flags, parentWindow);
			}
		}

		public static void UpdateWindowParentAndRootLinks(ImGuiWindowPtr window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pparentWindow = &parentWindow)
			{
				UpdateWindowParentAndRootLinksNative(window, flags, (ImGuiWindow*)pparentWindow);
			}
		}

		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* pparentWindow = &parentWindow)
				{
					UpdateWindowParentAndRootLinksNative((ImGuiWindow*)pwindow, flags, (ImGuiWindow*)pparentWindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igCalcWindowNextAutoFitSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void CalcWindowNextAutoFitSizeNative(Vector2* output, ImGuiWindow* window);

		public static Vector2 CalcWindowNextAutoFitSize(ImGuiWindowPtr window)
		{
			Vector2 ret;
			CalcWindowNextAutoFitSizeNative(&ret, window);
			return ret;
		}

		public static void CalcWindowNextAutoFitSize(Vector2* output, ImGuiWindowPtr window)
		{
			CalcWindowNextAutoFitSizeNative(output, window);
		}

		public static void CalcWindowNextAutoFitSize(ref Vector2 output, ImGuiWindowPtr window)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcWindowNextAutoFitSizeNative((Vector2*)poutput, window);
			}
		}

		public static Vector2 CalcWindowNextAutoFitSize(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				CalcWindowNextAutoFitSizeNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		public static void CalcWindowNextAutoFitSize(Vector2* output, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				CalcWindowNextAutoFitSizeNative(output, (ImGuiWindow*)pwindow);
			}
		}

		public static void CalcWindowNextAutoFitSize(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					CalcWindowNextAutoFitSizeNative((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowChildOf")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowChildOfNative(ImGuiWindow* window, ImGuiWindow* potentialParent, byte popupHierarchy, byte dockHierarchy);

		public static bool IsWindowChildOf(ImGuiWindowPtr window, ImGuiWindowPtr potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			byte ret = IsWindowChildOfNative(window, potentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool IsWindowChildOf(ref ImGuiWindow window, ImGuiWindowPtr potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowChildOfNative((ImGuiWindow*)pwindow, potentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool IsWindowChildOf(ImGuiWindowPtr window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				byte ret = IsWindowChildOfNative(window, (ImGuiWindow*)ppotentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool IsWindowChildOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					byte ret = IsWindowChildOfNative((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowWithinBeginStackOf")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowWithinBeginStackOfNative(ImGuiWindow* window, ImGuiWindow* potentialParent);

		public static bool IsWindowWithinBeginStackOf(ImGuiWindowPtr window, ImGuiWindowPtr potentialParent)
		{
			byte ret = IsWindowWithinBeginStackOfNative(window, potentialParent);
			return ret != 0;
		}

		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ImGuiWindowPtr potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowWithinBeginStackOfNative((ImGuiWindow*)pwindow, potentialParent);
				return ret != 0;
			}
		}

		public static bool IsWindowWithinBeginStackOf(ImGuiWindowPtr window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				byte ret = IsWindowWithinBeginStackOfNative(window, (ImGuiWindow*)ppotentialParent);
				return ret != 0;
			}
		}

		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					byte ret = IsWindowWithinBeginStackOfNative((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent);
					return ret != 0;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowAbove")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowAboveNative(ImGuiWindow* potentialAbove, ImGuiWindow* potentialBelow);

		public static bool IsWindowAbove(ImGuiWindowPtr potentialAbove, ImGuiWindowPtr potentialBelow)
		{
			byte ret = IsWindowAboveNative(potentialAbove, potentialBelow);
			return ret != 0;
		}

		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ImGuiWindowPtr potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				byte ret = IsWindowAboveNative((ImGuiWindow*)ppotentialAbove, potentialBelow);
				return ret != 0;
			}
		}

		public static bool IsWindowAbove(ImGuiWindowPtr potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
			{
				byte ret = IsWindowAboveNative(potentialAbove, (ImGuiWindow*)ppotentialBelow);
				return ret != 0;
			}
		}

		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
				{
					byte ret = IsWindowAboveNative((ImGuiWindow*)ppotentialAbove, (ImGuiWindow*)ppotentialBelow);
					return ret != 0;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowNavFocusable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowNavFocusableNative(ImGuiWindow* window);

		public static bool IsWindowNavFocusable(ImGuiWindowPtr window)
		{
			byte ret = IsWindowNavFocusableNative(window);
			return ret != 0;
		}

		public static bool IsWindowNavFocusable(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowNavFocusableNative((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowPos_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowPosWindowPtrNative(ImGuiWindow* window, Vector2 pos, ImGuiCond cond);

		public static void SetWindowPosWindowPtr(ImGuiWindowPtr window, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosWindowPtrNative(window, pos, cond);
		}

		public static void SetWindowPosWindowPtr(ref ImGuiWindow window, Vector2 pos, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowPosWindowPtrNative((ImGuiWindow*)pwindow, pos, cond);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowSize_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowSizeWindowPtrNative(ImGuiWindow* window, Vector2 size, ImGuiCond cond);

		public static void SetWindowSizeWindowPtr(ImGuiWindowPtr window, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeWindowPtrNative(window, size, cond);
		}

		public static void SetWindowSizeWindowPtr(ref ImGuiWindow window, Vector2 size, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowSizeWindowPtrNative((ImGuiWindow*)pwindow, size, cond);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowCollapsed_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowCollapsedWindowPtrNative(ImGuiWindow* window, byte collapsed, ImGuiCond cond);

		public static void SetWindowCollapsedWindowPtr(ImGuiWindowPtr window, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedWindowPtrNative(window, collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsedWindowPtr(ref ImGuiWindow window, bool collapsed, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowCollapsedWindowPtrNative((ImGuiWindow*)pwindow, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowHitTestHole")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowHitTestHoleNative(ImGuiWindow* window, Vector2 pos, Vector2 size);

		public static void SetWindowHitTestHole(ImGuiWindowPtr window, Vector2 pos, Vector2 size)
		{
			SetWindowHitTestHoleNative(window, pos, size);
		}

		public static void SetWindowHitTestHole(ref ImGuiWindow window, Vector2 pos, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHitTestHoleNative((ImGuiWindow*)pwindow, pos, size);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowHiddenAndSkipItemsForCurrentFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowHiddenAndSkipItemsForCurrentFrameNative(ImGuiWindow* window);

		public static void SetWindowHiddenAndSkipItemsForCurrentFrame(ImGuiWindowPtr window)
		{
			SetWindowHiddenAndSkipItemsForCurrentFrameNative(window);
		}

		public static void SetWindowHiddenAndSkipItemsForCurrentFrame(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHiddenAndSkipItemsForCurrentFrameNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowParentWindowForFocusRoute")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowParentWindowForFocusRouteNative(ImGuiWindow* window, ImGuiWindow* parentWindow);

		public static void SetWindowParentWindowForFocusRoute(ImGuiWindowPtr window, ImGuiWindowPtr parentWindow)
		{
			SetWindowParentWindowForFocusRouteNative(window, parentWindow);
		}

		public static void SetWindowParentWindowForFocusRoute(ref ImGuiWindow window, ImGuiWindowPtr parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowParentWindowForFocusRouteNative((ImGuiWindow*)pwindow, parentWindow);
			}
		}

		public static void SetWindowParentWindowForFocusRoute(ImGuiWindowPtr window, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pparentWindow = &parentWindow)
			{
				SetWindowParentWindowForFocusRouteNative(window, (ImGuiWindow*)pparentWindow);
			}
		}

		public static void SetWindowParentWindowForFocusRoute(ref ImGuiWindow window, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* pparentWindow = &parentWindow)
				{
					SetWindowParentWindowForFocusRouteNative((ImGuiWindow*)pwindow, (ImGuiWindow*)pparentWindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igWindowRectAbsToRel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void WindowRectAbsToRelNative(ImRect* output, ImGuiWindow* window, ImRect r);

		public static ImRect WindowRectAbsToRel(ImGuiWindowPtr window, ImRect r)
		{
			ImRect ret;
			WindowRectAbsToRelNative(&ret, window, r);
			return ret;
		}

		public static void WindowRectAbsToRel(ImRectPtr output, ImGuiWindowPtr window, ImRect r)
		{
			WindowRectAbsToRelNative(output, window, r);
		}

		public static void WindowRectAbsToRel(ref ImRect output, ImGuiWindowPtr window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				WindowRectAbsToRelNative((ImRect*)poutput, window, r);
			}
		}

		public static ImRect WindowRectAbsToRel(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				WindowRectAbsToRelNative(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}

		public static void WindowRectAbsToRel(ImRectPtr output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowRectAbsToRelNative(output, (ImGuiWindow*)pwindow, r);
			}
		}

		public static void WindowRectAbsToRel(ref ImRect output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectAbsToRelNative((ImRect*)poutput, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igWindowRectRelToAbs")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void WindowRectRelToAbsNative(ImRect* output, ImGuiWindow* window, ImRect r);

		public static ImRect WindowRectRelToAbs(ImGuiWindowPtr window, ImRect r)
		{
			ImRect ret;
			WindowRectRelToAbsNative(&ret, window, r);
			return ret;
		}

		public static void WindowRectRelToAbs(ImRectPtr output, ImGuiWindowPtr window, ImRect r)
		{
			WindowRectRelToAbsNative(output, window, r);
		}

		public static void WindowRectRelToAbs(ref ImRect output, ImGuiWindowPtr window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				WindowRectRelToAbsNative((ImRect*)poutput, window, r);
			}
		}

		public static ImRect WindowRectRelToAbs(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				WindowRectRelToAbsNative(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}

		public static void WindowRectRelToAbs(ImRectPtr output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowRectRelToAbsNative(output, (ImGuiWindow*)pwindow, r);
			}
		}

		public static void WindowRectRelToAbs(ref ImRect output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectRelToAbsNative((ImRect*)poutput, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igWindowPosRelToAbs")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void WindowPosRelToAbsNative(Vector2* output, ImGuiWindow* window, Vector2 p);

		public static Vector2 WindowPosRelToAbs(ImGuiWindowPtr window, Vector2 p)
		{
			Vector2 ret;
			WindowPosRelToAbsNative(&ret, window, p);
			return ret;
		}

		public static void WindowPosRelToAbs(Vector2* output, ImGuiWindowPtr window, Vector2 p)
		{
			WindowPosRelToAbsNative(output, window, p);
		}

		public static void WindowPosRelToAbs(ref Vector2 output, ImGuiWindowPtr window, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				WindowPosRelToAbsNative((Vector2*)poutput, window, p);
			}
		}

		public static Vector2 WindowPosRelToAbs(ref ImGuiWindow window, Vector2 p)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				WindowPosRelToAbsNative(&ret, (ImGuiWindow*)pwindow, p);
				return ret;
			}
		}

		public static void WindowPosRelToAbs(Vector2* output, ref ImGuiWindow window, Vector2 p)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowPosRelToAbsNative(output, (ImGuiWindow*)pwindow, p);
			}
		}

		public static void WindowPosRelToAbs(ref Vector2 output, ref ImGuiWindow window, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowPosRelToAbsNative((Vector2*)poutput, (ImGuiWindow*)pwindow, p);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igFocusWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void FocusWindowNative(ImGuiWindow* window, ImGuiFocusRequestFlags flags);

		public static void FocusWindow(ImGuiWindowPtr window, ImGuiFocusRequestFlags flags)
		{
			FocusWindowNative(window, flags);
		}

		public static void FocusWindow(ref ImGuiWindow window, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				FocusWindowNative((ImGuiWindow*)pwindow, flags);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igFocusTopMostWindowUnderOne")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void FocusTopMostWindowUnderOneNative(ImGuiWindow* underThisWindow, ImGuiWindow* ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags);

		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ImGuiWindowPtr ignoreWindow, ImGuiViewportPtr filterViewport, ImGuiFocusRequestFlags flags)
		{
			FocusTopMostWindowUnderOneNative(underThisWindow, ignoreWindow, filterViewport, flags);
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindowPtr ignoreWindow, ImGuiViewportPtr filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, ignoreWindow, filterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ref ImGuiWindow ignoreWindow, ImGuiViewportPtr filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				FocusTopMostWindowUnderOneNative(underThisWindow, (ImGuiWindow*)pignoreWindow, filterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow, ImGuiViewportPtr filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow, filterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ImGuiWindowPtr ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiViewport* pfilterViewport = &filterViewport)
			{
				FocusTopMostWindowUnderOneNative(underThisWindow, ignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindowPtr ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiViewport* pfilterViewport = &filterViewport)
				{
					FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, ignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ref ImGuiWindow ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				fixed (ImGuiViewport* pfilterViewport = &filterViewport)
				{
					FocusTopMostWindowUnderOneNative(underThisWindow, (ImGuiWindow*)pignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					fixed (ImGuiViewport* pfilterViewport = &filterViewport)
					{
						FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBringWindowToFocusFront")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BringWindowToFocusFrontNative(ImGuiWindow* window);

		public static void BringWindowToFocusFront(ImGuiWindowPtr window)
		{
			BringWindowToFocusFrontNative(window);
		}

		public static void BringWindowToFocusFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToFocusFrontNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBringWindowToDisplayFront")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BringWindowToDisplayFrontNative(ImGuiWindow* window);

		public static void BringWindowToDisplayFront(ImGuiWindowPtr window)
		{
			BringWindowToDisplayFrontNative(window);
		}

		public static void BringWindowToDisplayFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayFrontNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBringWindowToDisplayBack")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BringWindowToDisplayBackNative(ImGuiWindow* window);

		public static void BringWindowToDisplayBack(ImGuiWindowPtr window)
		{
			BringWindowToDisplayBackNative(window);
		}

		public static void BringWindowToDisplayBack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayBackNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBringWindowToDisplayBehind")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BringWindowToDisplayBehindNative(ImGuiWindow* window, ImGuiWindow* aboveWindow);

		public static void BringWindowToDisplayBehind(ImGuiWindowPtr window, ImGuiWindowPtr aboveWindow)
		{
			BringWindowToDisplayBehindNative(window, aboveWindow);
		}

		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ImGuiWindowPtr aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayBehindNative((ImGuiWindow*)pwindow, aboveWindow);
			}
		}

		public static void BringWindowToDisplayBehind(ImGuiWindowPtr window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* paboveWindow = &aboveWindow)
			{
				BringWindowToDisplayBehindNative(window, (ImGuiWindow*)paboveWindow);
			}
		}

		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* paboveWindow = &aboveWindow)
				{
					BringWindowToDisplayBehindNative((ImGuiWindow*)pwindow, (ImGuiWindow*)paboveWindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igFindWindowDisplayIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int FindWindowDisplayIndexNative(ImGuiWindow* window);

		public static int FindWindowDisplayIndex(ImGuiWindowPtr window)
		{
			int ret = FindWindowDisplayIndexNative(window);
			return ret;
		}

		public static int FindWindowDisplayIndex(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = FindWindowDisplayIndexNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igFindBottomMostVisibleWindowWithinBeginStack")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiWindow* FindBottomMostVisibleWindowWithinBeginStackNative(ImGuiWindow* window);

		public static ImGuiWindowPtr FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindowPtr window)
		{
			ImGuiWindowPtr ret = FindBottomMostVisibleWindowWithinBeginStackNative(window);
			return ret;
		}

		public static ImGuiWindowPtr FindBottomMostVisibleWindowWithinBeginStack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowPtr ret = FindBottomMostVisibleWindowWithinBeginStackNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetCurrentFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCurrentFontNative(ImFont* font);

		public static void SetCurrentFont(ImFontPtr font)
		{
			SetCurrentFontNative(font);
		}

		public static void SetCurrentFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				SetCurrentFontNative((ImFont*)pfont);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetDefaultFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImFont* GetDefaultFontNative();

		public static ImFontPtr GetDefaultFont()
		{
			ImFontPtr ret = GetDefaultFontNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetForegroundDrawList_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawList* GetForegroundDrawListWindowPtrNative(ImGuiWindow* window);

		public static ImDrawListPtr GetForegroundDrawListWindowPtr(ImGuiWindowPtr window)
		{
			ImDrawListPtr ret = GetForegroundDrawListWindowPtrNative(window);
			return ret;
		}

		public static ImDrawListPtr GetForegroundDrawListWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImDrawListPtr ret = GetForegroundDrawListWindowPtrNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igAddDrawListToDrawDataEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddDrawListToDrawDataExNative(ImDrawData* drawData, ImVectorImDrawListPtr* outList, ImDrawList* drawList);

		public static void AddDrawListToDrawDataEx(ImDrawDataPtr drawData, ImVectorImDrawListPtrPtr outList, ImDrawListPtr drawList)
		{
			AddDrawListToDrawDataExNative(drawData, outList, drawList);
		}

		public static void AddDrawListToDrawDataEx(ref ImDrawData drawData, ImVectorImDrawListPtrPtr outList, ImDrawListPtr drawList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				AddDrawListToDrawDataExNative((ImDrawData*)pdrawData, outList, drawList);
			}
		}

		public static void AddDrawListToDrawDataEx(ImDrawDataPtr drawData, ref ImVectorImDrawListPtr outList, ImDrawListPtr drawList)
		{
			fixed (ImVectorImDrawListPtr* poutList = &outList)
			{
				AddDrawListToDrawDataExNative(drawData, (ImVectorImDrawListPtr*)poutList, drawList);
			}
		}

		public static void AddDrawListToDrawDataEx(ref ImDrawData drawData, ref ImVectorImDrawListPtr outList, ImDrawListPtr drawList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (ImVectorImDrawListPtr* poutList = &outList)
				{
					AddDrawListToDrawDataExNative((ImDrawData*)pdrawData, (ImVectorImDrawListPtr*)poutList, drawList);
				}
			}
		}

		public static void AddDrawListToDrawDataEx(ImDrawDataPtr drawData, ImVectorImDrawListPtrPtr outList, ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				AddDrawListToDrawDataExNative(drawData, outList, (ImDrawList*)pdrawList);
			}
		}

		public static void AddDrawListToDrawDataEx(ref ImDrawData drawData, ImVectorImDrawListPtrPtr outList, ref ImDrawList drawList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					AddDrawListToDrawDataExNative((ImDrawData*)pdrawData, outList, (ImDrawList*)pdrawList);
				}
			}
		}

		public static void AddDrawListToDrawDataEx(ImDrawDataPtr drawData, ref ImVectorImDrawListPtr outList, ref ImDrawList drawList)
		{
			fixed (ImVectorImDrawListPtr* poutList = &outList)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					AddDrawListToDrawDataExNative(drawData, (ImVectorImDrawListPtr*)poutList, (ImDrawList*)pdrawList);
				}
			}
		}

		public static void AddDrawListToDrawDataEx(ref ImDrawData drawData, ref ImVectorImDrawListPtr outList, ref ImDrawList drawList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (ImVectorImDrawListPtr* poutList = &outList)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						AddDrawListToDrawDataExNative((ImDrawData*)pdrawData, (ImVectorImDrawListPtr*)poutList, (ImDrawList*)pdrawList);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igInitialize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void InitializeNative();

		public static void Initialize()
		{
			InitializeNative();
		}

		[LibraryImport(LibName, EntryPoint = "igShutdown")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShutdownNative();

		public static void Shutdown()
		{
			ShutdownNative();
		}

		[LibraryImport(LibName, EntryPoint = "igUpdateInputEvents")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void UpdateInputEventsNative(byte trickleFastInputs);

		public static void UpdateInputEvents(bool trickleFastInputs)
		{
			UpdateInputEventsNative(trickleFastInputs ? (byte)1 : (byte)0);
		}

		[LibraryImport(LibName, EntryPoint = "igUpdateHoveredWindowAndCaptureFlags")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void UpdateHoveredWindowAndCaptureFlagsNative();

		public static void UpdateHoveredWindowAndCaptureFlags()
		{
			UpdateHoveredWindowAndCaptureFlagsNative();
		}

		[LibraryImport(LibName, EntryPoint = "igStartMouseMovingWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void StartMouseMovingWindowNative(ImGuiWindow* window);

		public static void StartMouseMovingWindow(ImGuiWindowPtr window)
		{
			StartMouseMovingWindowNative(window);
		}

		public static void StartMouseMovingWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				StartMouseMovingWindowNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igStartMouseMovingWindowOrNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void StartMouseMovingWindowOrNodeNative(ImGuiWindow* window, ImGuiDockNode* node, byte undock);

		public static void StartMouseMovingWindowOrNode(ImGuiWindowPtr window, ImGuiDockNodePtr node, bool undock)
		{
			StartMouseMovingWindowOrNodeNative(window, node, undock ? (byte)1 : (byte)0);
		}

		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ImGuiDockNodePtr node, bool undock)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				StartMouseMovingWindowOrNodeNative((ImGuiWindow*)pwindow, node, undock ? (byte)1 : (byte)0);
			}
		}

		public static void StartMouseMovingWindowOrNode(ImGuiWindowPtr window, ref ImGuiDockNode node, bool undock)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				StartMouseMovingWindowOrNodeNative(window, (ImGuiDockNode*)pnode, undock ? (byte)1 : (byte)0);
			}
		}

		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ref ImGuiDockNode node, bool undock)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					StartMouseMovingWindowOrNodeNative((ImGuiWindow*)pwindow, (ImGuiDockNode*)pnode, undock ? (byte)1 : (byte)0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igUpdateMouseMovingWindowNewFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void UpdateMouseMovingWindowNewFrameNative();

		public static void UpdateMouseMovingWindowNewFrame()
		{
			UpdateMouseMovingWindowNewFrameNative();
		}

		[LibraryImport(LibName, EntryPoint = "igUpdateMouseMovingWindowEndFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void UpdateMouseMovingWindowEndFrameNative();

		public static void UpdateMouseMovingWindowEndFrame()
		{
			UpdateMouseMovingWindowEndFrameNative();
		}

		[LibraryImport(LibName, EntryPoint = "igAddContextHook")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int AddContextHookNative(ImGuiContext* context, ImGuiContextHook* hook);

		public static int AddContextHook(ImGuiContextPtr context, ImGuiContextHookPtr hook)
		{
			int ret = AddContextHookNative(context, hook);
			return ret;
		}

		public static int AddContextHook(ref ImGuiContext context, ImGuiContextHookPtr hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				int ret = AddContextHookNative((ImGuiContext*)pcontext, hook);
				return ret;
			}
		}

		public static int AddContextHook(ImGuiContextPtr context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContextHook* phook = &hook)
			{
				int ret = AddContextHookNative(context, (ImGuiContextHook*)phook);
				return ret;
			}
		}

		public static int AddContextHook(ref ImGuiContext context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (ImGuiContextHook* phook = &hook)
				{
					int ret = AddContextHookNative((ImGuiContext*)pcontext, (ImGuiContextHook*)phook);
					return ret;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igRemoveContextHook")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RemoveContextHookNative(ImGuiContext* context, int hookToRemove);

		public static void RemoveContextHook(ImGuiContextPtr context, int hookToRemove)
		{
			RemoveContextHookNative(context, hookToRemove);
		}

		public static void RemoveContextHook(ref ImGuiContext context, int hookToRemove)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				RemoveContextHookNative((ImGuiContext*)pcontext, hookToRemove);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igCallContextHooks")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void CallContextHooksNative(ImGuiContext* context, ImGuiContextHookType type);

		public static void CallContextHooks(ImGuiContextPtr context, ImGuiContextHookType type)
		{
			CallContextHooksNative(context, type);
		}

		public static void CallContextHooks(ref ImGuiContext context, ImGuiContextHookType type)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				CallContextHooksNative((ImGuiContext*)pcontext, type);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTranslateWindowsInViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TranslateWindowsInViewportNative(ImGuiViewportP* viewport, Vector2 oldPos, Vector2 newPos);

		public static void TranslateWindowsInViewport(ImGuiViewportPPtr viewport, Vector2 oldPos, Vector2 newPos)
		{
			TranslateWindowsInViewportNative(viewport, oldPos, newPos);
		}

		public static void TranslateWindowsInViewport(ref ImGuiViewportP viewport, Vector2 oldPos, Vector2 newPos)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				TranslateWindowsInViewportNative((ImGuiViewportP*)pviewport, oldPos, newPos);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igScaleWindowsInViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ScaleWindowsInViewportNative(ImGuiViewportP* viewport, float scale);

		public static void ScaleWindowsInViewport(ImGuiViewportPPtr viewport, float scale)
		{
			ScaleWindowsInViewportNative(viewport, scale);
		}

		public static void ScaleWindowsInViewport(ref ImGuiViewportP viewport, float scale)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ScaleWindowsInViewportNative((ImGuiViewportP*)pviewport, scale);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDestroyPlatformWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyPlatformWindowNative(ImGuiViewportP* viewport);

		public static void DestroyPlatformWindow(ImGuiViewportPPtr viewport)
		{
			DestroyPlatformWindowNative(viewport);
		}

		public static void DestroyPlatformWindow(ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DestroyPlatformWindowNative((ImGuiViewportP*)pviewport);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetWindowViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowViewportNative(ImGuiWindow* window, ImGuiViewportP* viewport);

		public static void SetWindowViewport(ImGuiWindowPtr window, ImGuiViewportPPtr viewport)
		{
			SetWindowViewportNative(window, viewport);
		}

		public static void SetWindowViewport(ref ImGuiWindow window, ImGuiViewportPPtr viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowViewportNative((ImGuiWindow*)pwindow, viewport);
			}
		}

		public static void SetWindowViewport(ImGuiWindowPtr window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				SetWindowViewportNative(window, (ImGuiViewportP*)pviewport);
			}
		}

		public static void SetWindowViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					SetWindowViewportNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetCurrentViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCurrentViewportNative(ImGuiWindow* window, ImGuiViewportP* viewport);

		public static void SetCurrentViewport(ImGuiWindowPtr window, ImGuiViewportPPtr viewport)
		{
			SetCurrentViewportNative(window, viewport);
		}

		public static void SetCurrentViewport(ref ImGuiWindow window, ImGuiViewportPPtr viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetCurrentViewportNative((ImGuiWindow*)pwindow, viewport);
			}
		}

		public static void SetCurrentViewport(ImGuiWindowPtr window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				SetCurrentViewportNative(window, (ImGuiViewportP*)pviewport);
			}
		}

		public static void SetCurrentViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					SetCurrentViewportNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetViewportPlatformMonitor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPlatformMonitor* GetViewportPlatformMonitorNative(ImGuiViewport* viewport);

		public static ImGuiPlatformMonitorPtr GetViewportPlatformMonitor(ImGuiViewportPtr viewport)
		{
			ImGuiPlatformMonitorPtr ret = GetViewportPlatformMonitorNative(viewport);
			return ret;
		}

		public static ImGuiPlatformMonitorPtr GetViewportPlatformMonitor(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImGuiPlatformMonitorPtr ret = GetViewportPlatformMonitorNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igFindHoveredViewportFromPlatformWindowStack")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiViewportP* FindHoveredViewportFromPlatformWindowStackNative(Vector2 mousePlatformPos);

		public static ImGuiViewportPPtr FindHoveredViewportFromPlatformWindowStack(Vector2 mousePlatformPos)
		{
			ImGuiViewportPPtr ret = FindHoveredViewportFromPlatformWindowStackNative(mousePlatformPos);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igMarkIniSettingsDirty_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void MarkIniSettingsDirtyNilNative();

		public static void MarkIniSettingsDirtyNil()
		{
			MarkIniSettingsDirtyNilNative();
		}

		[LibraryImport(LibName, EntryPoint = "igMarkIniSettingsDirty_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void MarkIniSettingsDirtyWindowPtrNative(ImGuiWindow* window);

		public static void MarkIniSettingsDirtyWindowPtr(ImGuiWindowPtr window)
		{
			MarkIniSettingsDirtyWindowPtrNative(window);
		}

		public static void MarkIniSettingsDirtyWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				MarkIniSettingsDirtyWindowPtrNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igClearIniSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearIniSettingsNative();

		public static void ClearIniSettings()
		{
			ClearIniSettingsNative();
		}

		[LibraryImport(LibName, EntryPoint = "igAddSettingsHandler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddSettingsHandlerNative(ImGuiSettingsHandler* handler);

		public static void AddSettingsHandler(ImGuiSettingsHandlerPtr handler)
		{
			AddSettingsHandlerNative(handler);
		}

		public static void AddSettingsHandler(ref ImGuiSettingsHandler handler)
		{
			fixed (ImGuiSettingsHandler* phandler = &handler)
			{
				AddSettingsHandlerNative((ImGuiSettingsHandler*)phandler);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igRemoveSettingsHandler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RemoveSettingsHandlerNative(byte* typeName);

		public static void RemoveSettingsHandler(byte* typeName)
		{
			RemoveSettingsHandlerNative(typeName);
		}

		public static void RemoveSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				RemoveSettingsHandlerNative((byte*)ptypeName);
			}
		}

		public static void RemoveSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RemoveSettingsHandlerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igFindSettingsHandler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiSettingsHandler* FindSettingsHandlerNative(byte* typeName);

		public static ImGuiSettingsHandlerPtr FindSettingsHandler(byte* typeName)
		{
			ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative(typeName);
			return ret;
		}

		public static ImGuiSettingsHandlerPtr FindSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative((byte*)ptypeName);
				return ret;
			}
		}

		public static ImGuiSettingsHandlerPtr FindSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igCreateNewWindowSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiWindowSettings* CreateNewWindowSettingsNative(byte* name);

		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(byte* name)
		{
			ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative(name);
			return ret;
		}

		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative((byte*)pname);
				return ret;
			}
		}

		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igFindWindowSettingsByID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiWindowSettings* FindWindowSettingsByIDNative(int id);

		public static ImGuiWindowSettingsPtr FindWindowSettingsByID(int id)
		{
			ImGuiWindowSettingsPtr ret = FindWindowSettingsByIDNative(id);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igFindWindowSettingsByWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiWindowSettings* FindWindowSettingsByWindowNative(ImGuiWindow* window);

		public static ImGuiWindowSettingsPtr FindWindowSettingsByWindow(ImGuiWindowPtr window)
		{
			ImGuiWindowSettingsPtr ret = FindWindowSettingsByWindowNative(window);
			return ret;
		}

		public static ImGuiWindowSettingsPtr FindWindowSettingsByWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowSettingsPtr ret = FindWindowSettingsByWindowNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igClearWindowSettings")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearWindowSettingsNative(byte* name);

		public static void ClearWindowSettings(byte* name)
		{
			ClearWindowSettingsNative(name);
		}

		public static void ClearWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ClearWindowSettingsNative((byte*)pname);
			}
		}

		public static void ClearWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ClearWindowSettingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igLocalizeRegisterEntries")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LocalizeRegisterEntriesNative(ImGuiLocEntry* entries, int count);

		public static void LocalizeRegisterEntries(ImGuiLocEntryPtr entries, int count)
		{
			LocalizeRegisterEntriesNative(entries, count);
		}

		public static void LocalizeRegisterEntries(ref ImGuiLocEntry entries, int count)
		{
			fixed (ImGuiLocEntry* pentries = &entries)
			{
				LocalizeRegisterEntriesNative((ImGuiLocEntry*)pentries, count);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igLocalizeGetMsg")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* LocalizeGetMsgNative(ImGuiLocKey key);

		public static byte* LocalizeGetMsg(ImGuiLocKey key)
		{
			byte* ret = LocalizeGetMsgNative(key);
			return ret;
		}

		public static string LocalizeGetMsgS(ImGuiLocKey key)
		{
			string ret = Utils.DecodeStringUTF8(LocalizeGetMsgNative(key));
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollX_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollXWindowPtrNative(ImGuiWindow* window, float scrollX);

		public static void SetScrollXWindowPtr(ImGuiWindowPtr window, float scrollX)
		{
			SetScrollXWindowPtrNative(window, scrollX);
		}

		public static void SetScrollXWindowPtr(ref ImGuiWindow window, float scrollX)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollXWindowPtrNative((ImGuiWindow*)pwindow, scrollX);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollY_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollYWindowPtrNative(ImGuiWindow* window, float scrollY);

		public static void SetScrollYWindowPtr(ImGuiWindowPtr window, float scrollY)
		{
			SetScrollYWindowPtrNative(window, scrollY);
		}

		public static void SetScrollYWindowPtr(ref ImGuiWindow window, float scrollY)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollYWindowPtrNative((ImGuiWindow*)pwindow, scrollY);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollFromPosX_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollFromPosXWindowPtrNative(ImGuiWindow* window, float localX, float centerXRatio);

		public static void SetScrollFromPosXWindowPtr(ImGuiWindowPtr window, float localX, float centerXRatio)
		{
			SetScrollFromPosXWindowPtrNative(window, localX, centerXRatio);
		}

		public static void SetScrollFromPosXWindowPtr(ref ImGuiWindow window, float localX, float centerXRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollFromPosXWindowPtrNative((ImGuiWindow*)pwindow, localX, centerXRatio);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetScrollFromPosY_WindowPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollFromPosYWindowPtrNative(ImGuiWindow* window, float localY, float centerYRatio);

		public static void SetScrollFromPosYWindowPtr(ImGuiWindowPtr window, float localY, float centerYRatio)
		{
			SetScrollFromPosYWindowPtrNative(window, localY, centerYRatio);
		}

		public static void SetScrollFromPosYWindowPtr(ref ImGuiWindow window, float localY, float centerYRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollFromPosYWindowPtrNative((ImGuiWindow*)pwindow, localY, centerYRatio);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igScrollToItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ScrollToItemNative(ImGuiScrollFlags flags);

		public static void ScrollToItem(ImGuiScrollFlags flags)
		{
			ScrollToItemNative(flags);
		}

		[LibraryImport(LibName, EntryPoint = "igScrollToRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ScrollToRectNative(ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags);

		public static void ScrollToRect(ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			ScrollToRectNative(window, rect, flags);
		}

		public static void ScrollToRect(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRectNative((ImGuiWindow*)pwindow, rect, flags);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igScrollToRectEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ScrollToRectExNative(Vector2* output, ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags);

		public static Vector2 ScrollToRectEx(ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			Vector2 ret;
			ScrollToRectExNative(&ret, window, rect, flags);
			return ret;
		}

		public static void ScrollToRectEx(Vector2* output, ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			ScrollToRectExNative(output, window, rect, flags);
		}

		public static void ScrollToRectEx(ref Vector2 output, ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* poutput = &output)
			{
				ScrollToRectExNative((Vector2*)poutput, window, rect, flags);
			}
		}

		public static Vector2 ScrollToRectEx(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				ScrollToRectExNative(&ret, (ImGuiWindow*)pwindow, rect, flags);
				return ret;
			}
		}

		public static void ScrollToRectEx(Vector2* output, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRectExNative(output, (ImGuiWindow*)pwindow, rect, flags);
			}
		}

		public static void ScrollToRectEx(ref Vector2 output, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ScrollToRectExNative((Vector2*)poutput, (ImGuiWindow*)pwindow, rect, flags);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igScrollToBringRectIntoView")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ScrollToBringRectIntoViewNative(ImGuiWindow* window, ImRect rect);

		public static void ScrollToBringRectIntoView(ImGuiWindowPtr window, ImRect rect)
		{
			ScrollToBringRectIntoViewNative(window, rect);
		}

		public static void ScrollToBringRectIntoView(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToBringRectIntoViewNative((ImGuiWindow*)pwindow, rect);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetItemStatusFlags")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiItemStatusFlags GetItemStatusFlagsNative();

		public static ImGuiItemStatusFlags GetItemStatusFlags()
		{
			ImGuiItemStatusFlags ret = GetItemStatusFlagsNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetItemFlags")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiItemFlags GetItemFlagsNative();

		public static ImGuiItemFlags GetItemFlags()
		{
			ImGuiItemFlags ret = GetItemFlagsNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetActiveID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetActiveIDNative();

		public static int GetActiveID()
		{
			int ret = GetActiveIDNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetFocusID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetFocusIDNative();

		public static int GetFocusID()
		{
			int ret = GetFocusIDNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetActiveID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetActiveIDNative(int id, ImGuiWindow* window);

		public static void SetActiveID(int id, ImGuiWindowPtr window)
		{
			SetActiveIDNative(id, window);
		}

		public static void SetActiveID(int id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetActiveIDNative(id, (ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetFocusID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetFocusIDNative(int id, ImGuiWindow* window);

		public static void SetFocusID(int id, ImGuiWindowPtr window)
		{
			SetFocusIDNative(id, window);
		}

		public static void SetFocusID(int id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetFocusIDNative(id, (ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igClearActiveID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearActiveIDNative();

		public static void ClearActiveID()
		{
			ClearActiveIDNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetHoveredID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetHoveredIDNative();

		public static int GetHoveredID()
		{
			int ret = GetHoveredIDNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetHoveredID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetHoveredIDNative(int id);

		public static void SetHoveredID(int id)
		{
			SetHoveredIDNative(id);
		}

		[LibraryImport(LibName, EntryPoint = "igKeepAliveID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void KeepAliveIDNative(int id);

		public static void KeepAliveID(int id)
		{
			KeepAliveIDNative(id);
		}

		[LibraryImport(LibName, EntryPoint = "igMarkItemEdited")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void MarkItemEditedNative(int id);

		public static void MarkItemEdited(int id)
		{
			MarkItemEditedNative(id);
		}

		[LibraryImport(LibName, EntryPoint = "igPushOverrideID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushOverrideIDNative(int id);

		public static void PushOverrideID(int id)
		{
			PushOverrideIDNative(id);
		}

		[LibraryImport(LibName, EntryPoint = "igGetIDWithSeed_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetIDWithSeedNative(byte* strIdBegin, byte* strIdEnd, int seed);

		public static int GetIDWithSeed(byte* strIdBegin, byte* strIdEnd, int seed)
		{
			int ret = GetIDWithSeedNative(strIdBegin, strIdEnd, seed);
			return ret;
		}

		public static int GetIDWithSeed(ref byte strIdBegin, byte* strIdEnd, int seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				int ret = GetIDWithSeedNative((byte*)pstrIdBegin, strIdEnd, seed);
				return ret;
			}
		}

		public static int GetIDWithSeed(string strIdBegin, byte* strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDWithSeedNative(pStr0, strIdEnd, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetIDWithSeed(byte* strIdBegin, ref byte strIdEnd, int seed)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				int ret = GetIDWithSeedNative(strIdBegin, (byte*)pstrIdEnd, seed);
				return ret;
			}
		}

		public static int GetIDWithSeed(byte* strIdBegin, string strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDWithSeedNative(strIdBegin, pStr0, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetIDWithSeed(ref byte strIdBegin, ref byte strIdEnd, int seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					int ret = GetIDWithSeedNative((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		public static int GetIDWithSeed(string strIdBegin, string strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = GetIDWithSeedNative(pStr0, pStr1, seed);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetIDWithSeed_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetIDWithSeedIntNative(int n, int seed);

		public static int GetIDWithSeedInt(int n, int seed)
		{
			int ret = GetIDWithSeedIntNative(n, seed);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igItemSize_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ItemSizeVec2Native(Vector2 size, float textBaselineY);

		public static void ItemSizeVec2(Vector2 size, float textBaselineY)
		{
			ItemSizeVec2Native(size, textBaselineY);
		}

		[LibraryImport(LibName, EntryPoint = "igItemSize_Rect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ItemSizeRectNative(ImRect bb, float textBaselineY);

		public static void ItemSizeRect(ImRect bb, float textBaselineY)
		{
			ItemSizeRectNative(bb, textBaselineY);
		}

		[LibraryImport(LibName, EntryPoint = "igItemAdd")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ItemAddNative(ImRect bb, int id, ImRect* navBb, ImGuiItemFlags extraFlags);

		public static bool ItemAdd(ImRect bb, int id, ImRectPtr navBb, ImGuiItemFlags extraFlags)
		{
			byte ret = ItemAddNative(bb, id, navBb, extraFlags);
			return ret != 0;
		}

		public static bool ItemAdd(ImRect bb, int id, ref ImRect navBb, ImGuiItemFlags extraFlags)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				byte ret = ItemAddNative(bb, id, (ImRect*)pnavBb, extraFlags);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igItemHoverable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ItemHoverableNative(ImRect bb, int id, ImGuiItemFlags itemFlags);

		public static bool ItemHoverable(ImRect bb, int id, ImGuiItemFlags itemFlags)
		{
			byte ret = ItemHoverableNative(bb, id, itemFlags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsWindowContentHoverable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowContentHoverableNative(ImGuiWindow* window, ImGuiHoveredFlags flags);

		public static bool IsWindowContentHoverable(ImGuiWindowPtr window, ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowContentHoverableNative(window, flags);
			return ret != 0;
		}

		public static bool IsWindowContentHoverable(ref ImGuiWindow window, ImGuiHoveredFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowContentHoverableNative((ImGuiWindow*)pwindow, flags);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igIsClippedEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsClippedExNative(ImRect bb, int id);

		public static bool IsClippedEx(ImRect bb, int id)
		{
			byte ret = IsClippedExNative(bb, id);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igSetLastItemData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetLastItemDataNative(int itemId, ImGuiItemFlags inFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect);

		public static void SetLastItemData(int itemId, ImGuiItemFlags inFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect)
		{
			SetLastItemDataNative(itemId, inFlags, statusFlags, itemRect);
		}

		[LibraryImport(LibName, EntryPoint = "igCalcItemSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void CalcItemSizeNative(Vector2* output, Vector2 size, float defaultW, float defaultH);

		public static Vector2 CalcItemSize(Vector2 size, float defaultW, float defaultH)
		{
			Vector2 ret;
			CalcItemSizeNative(&ret, size, defaultW, defaultH);
			return ret;
		}

		public static void CalcItemSize(Vector2* output, Vector2 size, float defaultW, float defaultH)
		{
			CalcItemSizeNative(output, size, defaultW, defaultH);
		}

		public static void CalcItemSize(ref Vector2 output, Vector2 size, float defaultW, float defaultH)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcItemSizeNative((Vector2*)poutput, size, defaultW, defaultH);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igCalcWrapWidthForPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float CalcWrapWidthForPosNative(Vector2 pos, float wrapPosX);

		public static float CalcWrapWidthForPos(Vector2 pos, float wrapPosX)
		{
			float ret = CalcWrapWidthForPosNative(pos, wrapPosX);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igPushMultiItemsWidths")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushMultiItemsWidthsNative(int components, float widthFull);

		public static void PushMultiItemsWidths(int components, float widthFull)
		{
			PushMultiItemsWidthsNative(components, widthFull);
		}

		[LibraryImport(LibName, EntryPoint = "igIsItemToggledSelection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemToggledSelectionNative();

		public static bool IsItemToggledSelection()
		{
			byte ret = IsItemToggledSelectionNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igGetContentRegionMaxAbs")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetContentRegionMaxAbsNative(Vector2* output);

		public static Vector2 GetContentRegionMaxAbs()
		{
			Vector2 ret;
			GetContentRegionMaxAbsNative(&ret);
			return ret;
		}

		public static void GetContentRegionMaxAbs(Vector2* output)
		{
			GetContentRegionMaxAbsNative(output);
		}

		public static void GetContentRegionMaxAbs(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionMaxAbsNative((Vector2*)poutput);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igShrinkWidths")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShrinkWidthsNative(ImGuiShrinkWidthItem* items, int count, float widthExcess);

		public static void ShrinkWidths(ImGuiShrinkWidthItemPtr items, int count, float widthExcess)
		{
			ShrinkWidthsNative(items, count, widthExcess);
		}

		public static void ShrinkWidths(ref ImGuiShrinkWidthItem items, int count, float widthExcess)
		{
			fixed (ImGuiShrinkWidthItem* pitems = &items)
			{
				ShrinkWidthsNative((ImGuiShrinkWidthItem*)pitems, count, widthExcess);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igPushItemFlag")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushItemFlagNative(ImGuiItemFlags option, byte enabled);

		public static void PushItemFlag(ImGuiItemFlags option, bool enabled)
		{
			PushItemFlagNative(option, enabled ? (byte)1 : (byte)0);
		}

		[LibraryImport(LibName, EntryPoint = "igPopItemFlag")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopItemFlagNative();

		public static void PopItemFlag()
		{
			PopItemFlagNative();
		}

		[LibraryImport(LibName, EntryPoint = "igGetStyleVarInfo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiDataVarInfo* GetStyleVarInfoNative(ImGuiStyleVar idx);

		public static ImGuiDataVarInfoPtr GetStyleVarInfo(ImGuiStyleVar idx)
		{
			ImGuiDataVarInfoPtr ret = GetStyleVarInfoNative(idx);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igLogBegin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogBeginNative(ImGuiLogType type, int autoOpenDepth);

		public static void LogBegin(ImGuiLogType type, int autoOpenDepth)
		{
			LogBeginNative(type, autoOpenDepth);
		}

		[LibraryImport(LibName, EntryPoint = "igLogToBuffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogToBufferNative(int autoOpenDepth);

		public static void LogToBuffer(int autoOpenDepth)
		{
			LogToBufferNative(autoOpenDepth);
		}

		[LibraryImport(LibName, EntryPoint = "igLogRenderedText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogRenderedTextNative(Vector2* refPos, byte* text, byte* textEnd);

		public static void LogRenderedText(Vector2* refPos, byte* text, byte* textEnd)
		{
			LogRenderedTextNative(refPos, text, textEnd);
		}

		public static void LogRenderedText(ref Vector2 refPos, byte* text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				LogRenderedTextNative((Vector2*)prefPos, text, textEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, textEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, ref byte text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, textEnd);
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, string text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				LogRenderedTextNative(refPos, text, (byte*)ptextEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, byte* text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative((Vector2*)prefPos, text, (byte*)ptextEnd);
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, byte* text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, ref byte text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, string text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igLogSetNextTextDecoration")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogSetNextTextDecorationNative(byte* prefix, byte* suffix);

		public static void LogSetNextTextDecoration(byte* prefix, byte* suffix)
		{
			LogSetNextTextDecorationNative(prefix, suffix);
		}

		public static void LogSetNextTextDecoration(ref byte prefix, byte* suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				LogSetNextTextDecorationNative((byte*)pprefix, suffix);
			}
		}

		public static void LogSetNextTextDecoration(string prefix, byte* suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogSetNextTextDecorationNative(pStr0, suffix);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogSetNextTextDecoration(byte* prefix, ref byte suffix)
		{
			fixed (byte* psuffix = &suffix)
			{
				LogSetNextTextDecorationNative(prefix, (byte*)psuffix);
			}
		}

		public static void LogSetNextTextDecoration(byte* prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (suffix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogSetNextTextDecorationNative(prefix, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogSetNextTextDecoration(ref byte prefix, ref byte suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* psuffix = &suffix)
				{
					LogSetNextTextDecorationNative((byte*)pprefix, (byte*)psuffix);
				}
			}
		}

		public static void LogSetNextTextDecoration(string prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (suffix != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(suffix, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogSetNextTextDecorationNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBeginChildEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginChildExNative(byte* name, int id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags);

		public static bool BeginChildEx(byte* name, int id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildExNative(name, id, sizeArg, childFlags, windowFlags);
			return ret != 0;
		}

		public static bool BeginChildEx(ref byte name, int id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginChildExNative((byte*)pname, id, sizeArg, childFlags, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginChildEx(string name, int id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildExNative(pStr0, id, sizeArg, childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igOpenPopupEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void OpenPopupExNative(int id, ImGuiPopupFlags popupFlags);

		public static void OpenPopupEx(int id, ImGuiPopupFlags popupFlags)
		{
			OpenPopupExNative(id, popupFlags);
		}

		[LibraryImport(LibName, EntryPoint = "igClosePopupToLevel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClosePopupToLevelNative(int remaining, byte restoreFocusToWindowUnderPopup);

		public static void ClosePopupToLevel(int remaining, bool restoreFocusToWindowUnderPopup)
		{
			ClosePopupToLevelNative(remaining, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
		}

		[LibraryImport(LibName, EntryPoint = "igClosePopupsOverWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClosePopupsOverWindowNative(ImGuiWindow* refWindow, byte restoreFocusToWindowUnderPopup);

		public static void ClosePopupsOverWindow(ImGuiWindowPtr refWindow, bool restoreFocusToWindowUnderPopup)
		{
			ClosePopupsOverWindowNative(refWindow, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
		}

		public static void ClosePopupsOverWindow(ref ImGuiWindow refWindow, bool restoreFocusToWindowUnderPopup)
		{
			fixed (ImGuiWindow* prefWindow = &refWindow)
			{
				ClosePopupsOverWindowNative((ImGuiWindow*)prefWindow, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igClosePopupsExceptModals")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClosePopupsExceptModalsNative();

		public static void ClosePopupsExceptModals()
		{
			ClosePopupsExceptModalsNative();
		}

		[LibraryImport(LibName, EntryPoint = "igIsPopupOpen_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsPopupOpenIDNative(int id, ImGuiPopupFlags popupFlags);

		public static bool IsPopupOpenID(int id, ImGuiPopupFlags popupFlags)
		{
			byte ret = IsPopupOpenIDNative(id, popupFlags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginPopupEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginPopupExNative(int id, ImGuiWindowFlags extraFlags);

		public static bool BeginPopupEx(int id, ImGuiWindowFlags extraFlags)
		{
			byte ret = BeginPopupExNative(id, extraFlags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginTooltipEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginTooltipExNative(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags);

		public static bool BeginTooltipEx(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags)
		{
			byte ret = BeginTooltipExNative(tooltipFlags, extraWindowFlags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginTooltipHidden")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginTooltipHiddenNative();

		public static bool BeginTooltipHidden()
		{
			byte ret = BeginTooltipHiddenNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igGetPopupAllowedExtentRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetPopupAllowedExtentRectNative(ImRect* output, ImGuiWindow* window);

		public static ImRect GetPopupAllowedExtentRect(ImGuiWindowPtr window)
		{
			ImRect ret;
			GetPopupAllowedExtentRectNative(&ret, window);
			return ret;
		}

		public static void GetPopupAllowedExtentRect(ImRectPtr output, ImGuiWindowPtr window)
		{
			GetPopupAllowedExtentRectNative(output, window);
		}

		public static void GetPopupAllowedExtentRect(ref ImRect output, ImGuiWindowPtr window)
		{
			fixed (ImRect* poutput = &output)
			{
				GetPopupAllowedExtentRectNative((ImRect*)poutput, window);
			}
		}

		public static ImRect GetPopupAllowedExtentRect(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				GetPopupAllowedExtentRectNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		public static void GetPopupAllowedExtentRect(ImRectPtr output, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				GetPopupAllowedExtentRectNative(output, (ImGuiWindow*)pwindow);
			}
		}

		public static void GetPopupAllowedExtentRect(ref ImRect output, ref ImGuiWindow window)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					GetPopupAllowedExtentRectNative((ImRect*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetTopMostPopupModal")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiWindow* GetTopMostPopupModalNative();

		public static ImGuiWindowPtr GetTopMostPopupModal()
		{
			ImGuiWindowPtr ret = GetTopMostPopupModalNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetTopMostAndVisiblePopupModal")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiWindow* GetTopMostAndVisiblePopupModalNative();

		public static ImGuiWindowPtr GetTopMostAndVisiblePopupModal()
		{
			ImGuiWindowPtr ret = GetTopMostAndVisiblePopupModalNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igFindBlockingModal")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiWindow* FindBlockingModalNative(ImGuiWindow* window);

		public static ImGuiWindowPtr FindBlockingModal(ImGuiWindowPtr window)
		{
			ImGuiWindowPtr ret = FindBlockingModalNative(window);
			return ret;
		}

		public static ImGuiWindowPtr FindBlockingModal(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowPtr ret = FindBlockingModalNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igFindBestWindowPosForPopup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void FindBestWindowPosForPopupNative(Vector2* output, ImGuiWindow* window);

		public static Vector2 FindBestWindowPosForPopup(ImGuiWindowPtr window)
		{
			Vector2 ret;
			FindBestWindowPosForPopupNative(&ret, window);
			return ret;
		}

		public static void FindBestWindowPosForPopup(Vector2* output, ImGuiWindowPtr window)
		{
			FindBestWindowPosForPopupNative(output, window);
		}

		public static void FindBestWindowPosForPopup(ref Vector2 output, ImGuiWindowPtr window)
		{
			fixed (Vector2* poutput = &output)
			{
				FindBestWindowPosForPopupNative((Vector2*)poutput, window);
			}
		}

		public static Vector2 FindBestWindowPosForPopup(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				FindBestWindowPosForPopupNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		public static void FindBestWindowPosForPopup(Vector2* output, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				FindBestWindowPosForPopupNative(output, (ImGuiWindow*)pwindow);
			}
		}

		public static void FindBestWindowPosForPopup(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					FindBestWindowPosForPopupNative((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igFindBestWindowPosForPopupEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void FindBestWindowPosForPopupExNative(Vector2* output, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy);

		public static Vector2 FindBestWindowPosForPopupEx(Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			Vector2 ret;
			FindBestWindowPosForPopupExNative(&ret, refPos, size, lastDir, rOuter, rAvoid, policy);
			return ret;
		}

		public static void FindBestWindowPosForPopupEx(Vector2* output, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			FindBestWindowPosForPopupExNative(output, refPos, size, lastDir, rOuter, rAvoid, policy);
		}

		public static void FindBestWindowPosForPopupEx(ref Vector2 output, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* poutput = &output)
			{
				FindBestWindowPosForPopupExNative((Vector2*)poutput, refPos, size, lastDir, rOuter, rAvoid, policy);
			}
		}

		public static Vector2 FindBestWindowPosForPopupEx(Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (ImGuiDir* plastDir = &lastDir)
			{
				Vector2 ret;
				FindBestWindowPosForPopupExNative(&ret, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				return ret;
			}
		}

		public static void FindBestWindowPosForPopupEx(Vector2* output, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (ImGuiDir* plastDir = &lastDir)
			{
				FindBestWindowPosForPopupExNative(output, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
			}
		}

		public static void FindBestWindowPosForPopupEx(ref Vector2 output, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiDir* plastDir = &lastDir)
				{
					FindBestWindowPosForPopupExNative((Vector2*)poutput, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBeginViewportSideBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginViewportSideBarNative(byte* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags);

		public static bool BeginViewportSideBar(byte* name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginViewportSideBarNative(name, viewport, dir, size, windowFlags);
			return ret != 0;
		}

		public static bool BeginViewportSideBar(ref byte name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginViewportSideBarNative((byte*)pname, viewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginViewportSideBar(string name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginViewportSideBarNative(pStr0, viewport, dir, size, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginViewportSideBar(byte* name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = BeginViewportSideBarNative(name, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginViewportSideBar(ref byte name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					byte ret = BeginViewportSideBarNative((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret != 0;
				}
			}
		}

		public static bool BeginViewportSideBar(string name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = BeginViewportSideBarNative(pStr0, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igBeginMenuEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginMenuExNative(byte* label, byte* icon, byte enabled);

		public static bool BeginMenuEx(byte* label, byte* icon, bool enabled)
		{
			byte ret = BeginMenuExNative(label, icon, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool BeginMenuEx(ref byte label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginMenuExNative((byte*)plabel, icon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenuEx(string label, byte* icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, icon, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginMenuEx(byte* label, ref byte icon, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = BeginMenuExNative(label, (byte*)picon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenuEx(byte* label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(label, pStr0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginMenuEx(ref byte label, ref byte icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = BeginMenuExNative((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool BeginMenuEx(string label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, pStr1, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igMenuItemEx")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte MenuItemExNative(byte* label, byte* icon, byte* shortcut, byte selected, byte enabled);

		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte ret = MenuItemExNative(label, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(string label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(byte* label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(string label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(byte* label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, icon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(string label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(byte* label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		public static bool MenuItemEx(string label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, pStr2, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginComboPopup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginComboPopupNative(int popupId, ImRect bb, ImGuiComboFlags flags);

		public static bool BeginComboPopup(int popupId, ImRect bb, ImGuiComboFlags flags)
		{
			byte ret = BeginComboPopupNative(popupId, bb, flags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igBeginComboPreview")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginComboPreviewNative();

		public static bool BeginComboPreview()
		{
			byte ret = BeginComboPreviewNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igEndComboPreview")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndComboPreviewNative();

		public static void EndComboPreview()
		{
			EndComboPreviewNative();
		}

		[LibraryImport(LibName, EntryPoint = "igNavInitWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavInitWindowNative(ImGuiWindow* window, byte forceReinit);

		public static void NavInitWindow(ImGuiWindowPtr window, bool forceReinit)
		{
			NavInitWindowNative(window, forceReinit ? (byte)1 : (byte)0);
		}

		public static void NavInitWindow(ref ImGuiWindow window, bool forceReinit)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavInitWindowNative((ImGuiWindow*)pwindow, forceReinit ? (byte)1 : (byte)0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igNavInitRequestApplyResult")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavInitRequestApplyResultNative();

		public static void NavInitRequestApplyResult()
		{
			NavInitRequestApplyResultNative();
		}

		[LibraryImport(LibName, EntryPoint = "igNavMoveRequestButNoResultYet")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte NavMoveRequestButNoResultYetNative();

		public static bool NavMoveRequestButNoResultYet()
		{
			byte ret = NavMoveRequestButNoResultYetNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igNavMoveRequestSubmit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavMoveRequestSubmitNative(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags);

		public static void NavMoveRequestSubmit(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			NavMoveRequestSubmitNative(moveDir, clipDir, moveFlags, scrollFlags);
		}

		[LibraryImport(LibName, EntryPoint = "igNavMoveRequestForward")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavMoveRequestForwardNative(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags);

		public static void NavMoveRequestForward(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			NavMoveRequestForwardNative(moveDir, clipDir, moveFlags, scrollFlags);
		}

		[LibraryImport(LibName, EntryPoint = "igNavMoveRequestResolveWithLastItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavMoveRequestResolveWithLastItemNative(ImGuiNavItemData* result);

		public static void NavMoveRequestResolveWithLastItem(ImGuiNavItemDataPtr result)
		{
			NavMoveRequestResolveWithLastItemNative(result);
		}

		public static void NavMoveRequestResolveWithLastItem(ref ImGuiNavItemData result)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				NavMoveRequestResolveWithLastItemNative((ImGuiNavItemData*)presult);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igNavMoveRequestResolveWithPastTreeNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavMoveRequestResolveWithPastTreeNodeNative(ImGuiNavItemData* result, ImGuiNavTreeNodeData* treeNodeData);

		public static void NavMoveRequestResolveWithPastTreeNode(ImGuiNavItemDataPtr result, ImGuiNavTreeNodeDataPtr treeNodeData)
		{
			NavMoveRequestResolveWithPastTreeNodeNative(result, treeNodeData);
		}

		public static void NavMoveRequestResolveWithPastTreeNode(ref ImGuiNavItemData result, ImGuiNavTreeNodeDataPtr treeNodeData)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				NavMoveRequestResolveWithPastTreeNodeNative((ImGuiNavItemData*)presult, treeNodeData);
			}
		}

		public static void NavMoveRequestResolveWithPastTreeNode(ImGuiNavItemDataPtr result, ref ImGuiNavTreeNodeData treeNodeData)
		{
			fixed (ImGuiNavTreeNodeData* ptreeNodeData = &treeNodeData)
			{
				NavMoveRequestResolveWithPastTreeNodeNative(result, (ImGuiNavTreeNodeData*)ptreeNodeData);
			}
		}

		public static void NavMoveRequestResolveWithPastTreeNode(ref ImGuiNavItemData result, ref ImGuiNavTreeNodeData treeNodeData)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				fixed (ImGuiNavTreeNodeData* ptreeNodeData = &treeNodeData)
				{
					NavMoveRequestResolveWithPastTreeNodeNative((ImGuiNavItemData*)presult, (ImGuiNavTreeNodeData*)ptreeNodeData);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igNavMoveRequestCancel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavMoveRequestCancelNative();

		public static void NavMoveRequestCancel()
		{
			NavMoveRequestCancelNative();
		}

		[LibraryImport(LibName, EntryPoint = "igNavMoveRequestApplyResult")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavMoveRequestApplyResultNative();

		public static void NavMoveRequestApplyResult()
		{
			NavMoveRequestApplyResultNative();
		}

		[LibraryImport(LibName, EntryPoint = "igNavMoveRequestTryWrapping")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavMoveRequestTryWrappingNative(ImGuiWindow* window, ImGuiNavMoveFlags moveFlags);

		public static void NavMoveRequestTryWrapping(ImGuiWindowPtr window, ImGuiNavMoveFlags moveFlags)
		{
			NavMoveRequestTryWrappingNative(window, moveFlags);
		}

		public static void NavMoveRequestTryWrapping(ref ImGuiWindow window, ImGuiNavMoveFlags moveFlags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavMoveRequestTryWrappingNative((ImGuiWindow*)pwindow, moveFlags);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igNavHighlightActivated")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavHighlightActivatedNative(int id);

		public static void NavHighlightActivated(int id)
		{
			NavHighlightActivatedNative(id);
		}

		[LibraryImport(LibName, EntryPoint = "igNavClearPreferredPosForAxis")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavClearPreferredPosForAxisNative(ImGuiAxis axis);

		public static void NavClearPreferredPosForAxis(ImGuiAxis axis)
		{
			NavClearPreferredPosForAxisNative(axis);
		}

		[LibraryImport(LibName, EntryPoint = "igNavRestoreHighlightAfterMove")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavRestoreHighlightAfterMoveNative();

		public static void NavRestoreHighlightAfterMove()
		{
			NavRestoreHighlightAfterMoveNative();
		}

		[LibraryImport(LibName, EntryPoint = "igNavUpdateCurrentWindowIsScrollPushableX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NavUpdateCurrentWindowIsScrollPushableXNative();

		public static void NavUpdateCurrentWindowIsScrollPushableX()
		{
			NavUpdateCurrentWindowIsScrollPushableXNative();
		}

		[LibraryImport(LibName, EntryPoint = "igSetNavWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNavWindowNative(ImGuiWindow* window);

		public static void SetNavWindow(ImGuiWindowPtr window)
		{
			SetNavWindowNative(window);
		}

		public static void SetNavWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetNavWindowNative((ImGuiWindow*)pwindow);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igSetNavID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNavIDNative(int id, ImGuiNavLayer navLayer, int focusScopeId, ImRect rectRel);

		public static void SetNavID(int id, ImGuiNavLayer navLayer, int focusScopeId, ImRect rectRel)
		{
			SetNavIDNative(id, navLayer, focusScopeId, rectRel);
		}

		[LibraryImport(LibName, EntryPoint = "igSetNavFocusScope")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNavFocusScopeNative(int focusScopeId);

		public static void SetNavFocusScope(int focusScopeId)
		{
			SetNavFocusScopeNative(focusScopeId);
		}

		[LibraryImport(LibName, EntryPoint = "igFocusItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void FocusItemNative();

		public static void FocusItem()
		{
			FocusItemNative();
		}

		[LibraryImport(LibName, EntryPoint = "igActivateItemByID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ActivateItemByIDNative(int id);

		public static void ActivateItemByID(int id)
		{
			ActivateItemByIDNative(id);
		}

		[LibraryImport(LibName, EntryPoint = "igIsNamedKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsNamedKeyNative(ImGuiKey key);

		public static bool IsNamedKey(ImGuiKey key)
		{
			byte ret = IsNamedKeyNative(key);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsNamedKeyOrModKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsNamedKeyOrModKeyNative(ImGuiKey key);

		public static bool IsNamedKeyOrModKey(ImGuiKey key)
		{
			byte ret = IsNamedKeyOrModKeyNative(key);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsLegacyKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsLegacyKeyNative(ImGuiKey key);

		public static bool IsLegacyKey(ImGuiKey key)
		{
			byte ret = IsLegacyKeyNative(key);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsKeyboardKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsKeyboardKeyNative(ImGuiKey key);

		public static bool IsKeyboardKey(ImGuiKey key)
		{
			byte ret = IsKeyboardKeyNative(key);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsGamepadKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsGamepadKeyNative(ImGuiKey key);

		public static bool IsGamepadKey(ImGuiKey key)
		{
			byte ret = IsGamepadKeyNative(key);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsMouseKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseKeyNative(ImGuiKey key);

		public static bool IsMouseKey(ImGuiKey key)
		{
			byte ret = IsMouseKeyNative(key);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsAliasKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsAliasKeyNative(ImGuiKey key);

		public static bool IsAliasKey(ImGuiKey key)
		{
			byte ret = IsAliasKeyNative(key);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsModKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsModKeyNative(ImGuiKey key);

		public static bool IsModKey(ImGuiKey key)
		{
			byte ret = IsModKeyNative(key);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igFixupKeyChord")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int FixupKeyChordNative(ImGuiContext* ctx, int keyChord);

		public static int FixupKeyChord(ImGuiContextPtr ctx, int keyChord)
		{
			int ret = FixupKeyChordNative(ctx, keyChord);
			return ret;
		}

		public static int FixupKeyChord(ref ImGuiContext ctx, int keyChord)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				int ret = FixupKeyChordNative((ImGuiContext*)pctx, keyChord);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igConvertSingleModFlagToKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKey ConvertSingleModFlagToKeyNative(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKey ConvertSingleModFlagToKey(ImGuiContextPtr ctx, ImGuiKey key)
		{
			ImGuiKey ret = ConvertSingleModFlagToKeyNative(ctx, key);
			return ret;
		}

		public static ImGuiKey ConvertSingleModFlagToKey(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKey ret = ConvertSingleModFlagToKeyNative((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetKeyData_ContextPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKeyData* GetKeyDataContextPtrNative(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKeyDataPtr GetKeyDataContextPtr(ImGuiContextPtr ctx, ImGuiKey key)
		{
			ImGuiKeyDataPtr ret = GetKeyDataContextPtrNative(ctx, key);
			return ret;
		}

		public static ImGuiKeyDataPtr GetKeyDataContextPtr(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKeyDataPtr ret = GetKeyDataContextPtrNative((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetKeyData_Key")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKeyData* GetKeyDataKeyNative(ImGuiKey key);

		public static ImGuiKeyDataPtr GetKeyDataKey(ImGuiKey key)
		{
			ImGuiKeyDataPtr ret = GetKeyDataKeyNative(key);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igMouseButtonToKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKey MouseButtonToKeyNative(ImGuiMouseButton button);

		public static ImGuiKey MouseButtonToKey(ImGuiMouseButton button)
		{
			ImGuiKey ret = MouseButtonToKeyNative(button);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igIsMouseDragPastThreshold")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseDragPastThresholdNative(ImGuiMouseButton button, float lockThreshold);

		public static bool IsMouseDragPastThreshold(ImGuiMouseButton button, float lockThreshold)
		{
			byte ret = IsMouseDragPastThresholdNative(button, lockThreshold);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igGetKeyMagnitude2d")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetKeyMagnitude2dNative(Vector2* output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown);

		public static Vector2 GetKeyMagnitude2d(ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			Vector2 ret;
			GetKeyMagnitude2dNative(&ret, keyLeft, keyRight, keyUp, keyDown);
			return ret;
		}

		public static void GetKeyMagnitude2d(Vector2* output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			GetKeyMagnitude2dNative(output, keyLeft, keyRight, keyUp, keyDown);
		}

		public static void GetKeyMagnitude2d(ref Vector2 output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			fixed (Vector2* poutput = &output)
			{
				GetKeyMagnitude2dNative((Vector2*)poutput, keyLeft, keyRight, keyUp, keyDown);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igGetNavTweakPressedAmount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetNavTweakPressedAmountNative(ImGuiAxis axis);

		public static float GetNavTweakPressedAmount(ImGuiAxis axis)
		{
			float ret = GetNavTweakPressedAmountNative(axis);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igCalcTypematicRepeatAmount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int CalcTypematicRepeatAmountNative(float t0, float t1, float repeatDelay, float repeatRate);

		public static int CalcTypematicRepeatAmount(float t0, float t1, float repeatDelay, float repeatRate)
		{
			int ret = CalcTypematicRepeatAmountNative(t0, t1, repeatDelay, repeatRate);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igGetTypematicRepeatRate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetTypematicRepeatRateNative(ImGuiInputFlags flags, float* repeatDelay, float* repeatRate);

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeatDelay, float* repeatRate)
		{
			GetTypematicRepeatRateNative(flags, repeatDelay, repeatRate);
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, ref float repeatDelay, float* repeatRate)
		{
			fixed (float* prepeatDelay = &repeatDelay)
			{
				GetTypematicRepeatRateNative(flags, (float*)prepeatDelay, repeatRate);
			}
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeatDelay, ref float repeatRate)
		{
			fixed (float* prepeatRate = &repeatRate)
			{
				GetTypematicRepeatRateNative(flags, repeatDelay, (float*)prepeatRate);
			}
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, ref float repeatDelay, ref float repeatRate)
		{
			fixed (float* prepeatDelay = &repeatDelay)
			{
				fixed (float* prepeatRate = &repeatRate)
				{
					GetTypematicRepeatRateNative(flags, (float*)prepeatDelay, (float*)prepeatRate);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igTeleportMousePos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TeleportMousePosNative(Vector2 pos);

		public static void TeleportMousePos(Vector2 pos)
		{
			TeleportMousePosNative(pos);
		}

		[LibraryImport(LibName, EntryPoint = "igSetActiveIdUsingAllKeyboardKeys")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetActiveIdUsingAllKeyboardKeysNative();

		public static void SetActiveIdUsingAllKeyboardKeys()
		{
			SetActiveIdUsingAllKeyboardKeysNative();
		}

		[LibraryImport(LibName, EntryPoint = "igIsActiveIdUsingNavDir")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsActiveIdUsingNavDirNative(ImGuiDir dir);

		public static bool IsActiveIdUsingNavDir(ImGuiDir dir)
		{
			byte ret = IsActiveIdUsingNavDirNative(dir);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igGetKeyOwner")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetKeyOwnerNative(ImGuiKey key);

		public static int GetKeyOwner(ImGuiKey key)
		{
			int ret = GetKeyOwnerNative(key);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igSetKeyOwner")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetKeyOwnerNative(ImGuiKey key, int ownerId, ImGuiInputFlags flags);

		public static void SetKeyOwner(ImGuiKey key, int ownerId, ImGuiInputFlags flags)
		{
			SetKeyOwnerNative(key, ownerId, flags);
		}

		[LibraryImport(LibName, EntryPoint = "igSetKeyOwnersForKeyChord")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetKeyOwnersForKeyChordNative(int key, int ownerId, ImGuiInputFlags flags);

		public static void SetKeyOwnersForKeyChord(int key, int ownerId, ImGuiInputFlags flags)
		{
			SetKeyOwnersForKeyChordNative(key, ownerId, flags);
		}

		[LibraryImport(LibName, EntryPoint = "igSetItemKeyOwner")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetItemKeyOwnerNative(ImGuiKey key, ImGuiInputFlags flags);

		public static void SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags)
		{
			SetItemKeyOwnerNative(key, flags);
		}

		[LibraryImport(LibName, EntryPoint = "igTestKeyOwner")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TestKeyOwnerNative(ImGuiKey key, int ownerId);

		public static bool TestKeyOwner(ImGuiKey key, int ownerId)
		{
			byte ret = TestKeyOwnerNative(key, ownerId);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igGetKeyOwnerData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKeyOwnerData* GetKeyOwnerDataNative(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKeyOwnerDataPtr GetKeyOwnerData(ImGuiContextPtr ctx, ImGuiKey key)
		{
			ImGuiKeyOwnerDataPtr ret = GetKeyOwnerDataNative(ctx, key);
			return ret;
		}

		public static ImGuiKeyOwnerDataPtr GetKeyOwnerData(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKeyOwnerDataPtr ret = GetKeyOwnerDataNative((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igIsKeyDown_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsKeyDownIDNative(ImGuiKey key, int ownerId);

		public static bool IsKeyDownID(ImGuiKey key, int ownerId)
		{
			byte ret = IsKeyDownIDNative(key, ownerId);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsKeyPressed_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsKeyPressedIDNative(ImGuiKey key, int ownerId, ImGuiInputFlags flags);

		public static bool IsKeyPressedID(ImGuiKey key, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = IsKeyPressedIDNative(key, ownerId, flags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsKeyReleased_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsKeyReleasedIDNative(ImGuiKey key, int ownerId);

		public static bool IsKeyReleasedID(ImGuiKey key, int ownerId)
		{
			byte ret = IsKeyReleasedIDNative(key, ownerId);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsMouseDown_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseDownIDNative(ImGuiMouseButton button, int ownerId);

		public static bool IsMouseDownID(ImGuiMouseButton button, int ownerId)
		{
			byte ret = IsMouseDownIDNative(button, ownerId);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsMouseClicked_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseClickedIDNative(ImGuiMouseButton button, int ownerId, ImGuiInputFlags flags);

		public static bool IsMouseClickedID(ImGuiMouseButton button, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = IsMouseClickedIDNative(button, ownerId, flags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsMouseReleased_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseReleasedIDNative(ImGuiMouseButton button, int ownerId);

		public static bool IsMouseReleasedID(ImGuiMouseButton button, int ownerId)
		{
			byte ret = IsMouseReleasedIDNative(button, ownerId);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsMouseDoubleClicked_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseDoubleClickedIDNative(ImGuiMouseButton button, int ownerId);

		public static bool IsMouseDoubleClickedID(ImGuiMouseButton button, int ownerId)
		{
			byte ret = IsMouseDoubleClickedIDNative(button, ownerId);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igIsKeyChordPressed_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsKeyChordPressedIDNative(int keyChord, int ownerId, ImGuiInputFlags flags);

		public static bool IsKeyChordPressedID(int keyChord, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = IsKeyChordPressedIDNative(keyChord, ownerId, flags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igSetNextItemShortcut")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextItemShortcutNative(int keyChord);

		public static void SetNextItemShortcut(int keyChord)
		{
			SetNextItemShortcutNative(keyChord);
		}

		[LibraryImport(LibName, EntryPoint = "igShortcut")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ShortcutNative(int keyChord, int ownerId, ImGuiInputFlags flags);

		public static bool Shortcut(int keyChord, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = ShortcutNative(keyChord, ownerId, flags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igSetShortcutRouting")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte SetShortcutRoutingNative(int keyChord, int ownerId, ImGuiInputFlags flags);

		public static bool SetShortcutRouting(int keyChord, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = SetShortcutRoutingNative(keyChord, ownerId, flags);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igTestShortcutRouting")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TestShortcutRoutingNative(int keyChord, int ownerId);

		public static bool TestShortcutRouting(int keyChord, int ownerId)
		{
			byte ret = TestShortcutRoutingNative(keyChord, ownerId);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "igGetShortcutRoutingData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKeyRoutingData* GetShortcutRoutingDataNative(int keyChord);

		public static ImGuiKeyRoutingDataPtr GetShortcutRoutingData(int keyChord)
		{
			ImGuiKeyRoutingDataPtr ret = GetShortcutRoutingDataNative(keyChord);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextInitialize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextInitializeNative(ImGuiContext* ctx);

		public static void DockContextInitialize(ImGuiContextPtr ctx)
		{
			DockContextInitializeNative(ctx);
		}

		public static void DockContextInitialize(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextInitializeNative((ImGuiContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextShutdown")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextShutdownNative(ImGuiContext* ctx);

		public static void DockContextShutdown(ImGuiContextPtr ctx)
		{
			DockContextShutdownNative(ctx);
		}

		public static void DockContextShutdown(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextShutdownNative((ImGuiContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextClearNodes")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextClearNodesNative(ImGuiContext* ctx, int rootId, byte clearSettingsRefs);

		public static void DockContextClearNodes(ImGuiContextPtr ctx, int rootId, bool clearSettingsRefs)
		{
			DockContextClearNodesNative(ctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
		}

		public static void DockContextClearNodes(ref ImGuiContext ctx, int rootId, bool clearSettingsRefs)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextClearNodesNative((ImGuiContext*)pctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextRebuildNodes")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextRebuildNodesNative(ImGuiContext* ctx);

		public static void DockContextRebuildNodes(ImGuiContextPtr ctx)
		{
			DockContextRebuildNodesNative(ctx);
		}

		public static void DockContextRebuildNodes(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextRebuildNodesNative((ImGuiContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextNewFrameUpdateUndocking")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextNewFrameUpdateUndockingNative(ImGuiContext* ctx);

		public static void DockContextNewFrameUpdateUndocking(ImGuiContextPtr ctx)
		{
			DockContextNewFrameUpdateUndockingNative(ctx);
		}

		public static void DockContextNewFrameUpdateUndocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateUndockingNative((ImGuiContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextNewFrameUpdateDocking")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextNewFrameUpdateDockingNative(ImGuiContext* ctx);

		public static void DockContextNewFrameUpdateDocking(ImGuiContextPtr ctx)
		{
			DockContextNewFrameUpdateDockingNative(ctx);
		}

		public static void DockContextNewFrameUpdateDocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateDockingNative((ImGuiContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextEndFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextEndFrameNative(ImGuiContext* ctx);

		public static void DockContextEndFrame(ImGuiContextPtr ctx)
		{
			DockContextEndFrameNative(ctx);
		}

		public static void DockContextEndFrame(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextEndFrameNative((ImGuiContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextGenNodeID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int DockContextGenNodeIDNative(ImGuiContext* ctx);

		public static int DockContextGenNodeID(ImGuiContextPtr ctx)
		{
			int ret = DockContextGenNodeIDNative(ctx);
			return ret;
		}

		public static int DockContextGenNodeID(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				int ret = DockContextGenNodeIDNative((ImGuiContext*)pctx);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextQueueDock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextQueueDockNative(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, byte splitOuter);

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			DockContextQueueDockNative(ctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueDockNative((ImGuiContext*)pctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				DockContextQueueDockNative(ctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ppayload = &payload)
			{
				DockContextQueueDockNative(ctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative(ctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						fixed (ImGuiWindow* ppayload = &payload)
						{
							DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextQueueUndockWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextQueueUndockWindowNative(ImGuiContext* ctx, ImGuiWindow* window);

		public static void DockContextQueueUndockWindow(ImGuiContextPtr ctx, ImGuiWindowPtr window)
		{
			DockContextQueueUndockWindowNative(ctx, window);
		}

		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ImGuiWindowPtr window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockWindowNative((ImGuiContext*)pctx, window);
			}
		}

		public static void DockContextQueueUndockWindow(ImGuiContextPtr ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextQueueUndockWindowNative(ctx, (ImGuiWindow*)pwindow);
			}
		}

		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextQueueUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextQueueUndockNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextQueueUndockNodeNative(ImGuiContext* ctx, ImGuiDockNode* node);

		public static void DockContextQueueUndockNode(ImGuiContextPtr ctx, ImGuiDockNodePtr node)
		{
			DockContextQueueUndockNodeNative(ctx, node);
		}

		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ImGuiDockNodePtr node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockNodeNative((ImGuiContext*)pctx, node);
			}
		}

		public static void DockContextQueueUndockNode(ImGuiContextPtr ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextQueueUndockNodeNative(ctx, (ImGuiDockNode*)pnode);
			}
		}

		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextQueueUndockNodeNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextProcessUndockWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextProcessUndockWindowNative(ImGuiContext* ctx, ImGuiWindow* window, byte clearPersistentDockingRef);

		public static void DockContextProcessUndockWindow(ImGuiContextPtr ctx, ImGuiWindowPtr window, bool clearPersistentDockingRef)
		{
			DockContextProcessUndockWindowNative(ctx, window, clearPersistentDockingRef ? (byte)1 : (byte)0);
		}

		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ImGuiWindowPtr window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockWindowNative((ImGuiContext*)pctx, window, clearPersistentDockingRef ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextProcessUndockWindow(ImGuiContextPtr ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextProcessUndockWindowNative(ctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextProcessUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef ? (byte)1 : (byte)0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextProcessUndockNode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DockContextProcessUndockNodeNative(ImGuiContext* ctx, ImGuiDockNode* node);

		public static void DockContextProcessUndockNode(ImGuiContextPtr ctx, ImGuiDockNodePtr node)
		{
			DockContextProcessUndockNodeNative(ctx, node);
		}

		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ImGuiDockNodePtr node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockNodeNative((ImGuiContext*)pctx, node);
			}
		}

		public static void DockContextProcessUndockNode(ImGuiContextPtr ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextProcessUndockNodeNative(ctx, (ImGuiDockNode*)pnode);
			}
		}

		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextProcessUndockNodeNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "igDockContextCalcDropPosForDocking")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte DockContextCalcDropPosForDockingNative(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, byte splitOuter, Vector2* outPos);

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
			return ret != 0;
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (Vector2* poutPos = &outPos)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNodePtr payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}
	}
}
