// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGuiP
	{

		/// <summary>
		/// Top-right<br/>
		/// </summary>
		internal static void GetTRNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)vt[835])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[835])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// Top-right<br/>
		/// </summary>
		public static Vector2 GetTR(ImRectPtr self)
		{
			Vector2 ret;
			GetTRNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// Top-right<br/>
		/// </summary>
		public static void GetTR(Vector2* pOut, ImRectPtr self)
		{
			GetTRNative(pOut, self);
		}

		/// <summary>
		/// Top-right<br/>
		/// </summary>
		public static void GetTR(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetTRNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// Top-right<br/>
		/// </summary>
		public static Vector2 GetTR(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetTRNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// Top-right<br/>
		/// </summary>
		public static void GetTR(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetTRNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// Top-right<br/>
		/// </summary>
		public static void GetTR(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetTRNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// Bottom-left<br/>
		/// </summary>
		internal static void GetBLNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)vt[836])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[836])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// Bottom-left<br/>
		/// </summary>
		public static Vector2 GetBL(ImRectPtr self)
		{
			Vector2 ret;
			GetBLNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// Bottom-left<br/>
		/// </summary>
		public static void GetBL(Vector2* pOut, ImRectPtr self)
		{
			GetBLNative(pOut, self);
		}

		/// <summary>
		/// Bottom-left<br/>
		/// </summary>
		public static void GetBL(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetBLNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// Bottom-left<br/>
		/// </summary>
		public static Vector2 GetBL(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetBLNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// Bottom-left<br/>
		/// </summary>
		public static void GetBL(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetBLNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// Bottom-left<br/>
		/// </summary>
		public static void GetBL(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetBLNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// Bottom-right<br/>
		/// </summary>
		internal static void GetBRNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)vt[837])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[837])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// Bottom-right<br/>
		/// </summary>
		public static Vector2 GetBR(ImRectPtr self)
		{
			Vector2 ret;
			GetBRNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// Bottom-right<br/>
		/// </summary>
		public static void GetBR(Vector2* pOut, ImRectPtr self)
		{
			GetBRNative(pOut, self);
		}

		/// <summary>
		/// Bottom-right<br/>
		/// </summary>
		public static void GetBR(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetBRNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// Bottom-right<br/>
		/// </summary>
		public static Vector2 GetBR(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetBRNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// Bottom-right<br/>
		/// </summary>
		public static void GetBR(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetBRNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// Bottom-right<br/>
		/// </summary>
		public static void GetBR(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetBRNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ContainsNative(ImRect* self, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, Vector2, byte>)vt[838])(self, p);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, byte>)vt[838])((nint)self, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Contains(ImRectPtr self, Vector2 p)
		{
			byte ret = ContainsNative(self, p);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Contains(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ContainsNative((ImRect*)pself, p);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ContainsNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, ImRect, byte>)vt[839])(self, r);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImRect, byte>)vt[839])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Contains(ImRectPtr self, ImRect r)
		{
			byte ret = ContainsNative(self, r);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Contains(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ContainsNative((ImRect*)pself, r);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ContainsWithPadNative(ImRect* self, Vector2 p, Vector2 pad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, Vector2, Vector2, byte>)vt[840])(self, p, pad);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, byte>)vt[840])((nint)self, p, pad);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ContainsWithPad(ImRectPtr self, Vector2 p, Vector2 pad)
		{
			byte ret = ContainsWithPadNative(self, p, pad);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ContainsWithPad(ref ImRect self, Vector2 p, Vector2 pad)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ContainsWithPadNative((ImRect*)pself, p, pad);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte OverlapsNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, ImRect, byte>)vt[841])(self, r);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImRect, byte>)vt[841])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Overlaps(ImRectPtr self, ImRect r)
		{
			byte ret = OverlapsNative(self, r);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Overlaps(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = OverlapsNative((ImRect*)pself, r);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void AddNative(ImRect* self, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, Vector2, void>)vt[842])(self, p);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, void>)vt[842])((nint)self, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Add(ImRectPtr self, Vector2 p)
		{
			AddNative(self, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Add(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				AddNative((ImRect*)pself, p);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void AddNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImRect, void>)vt[843])(self, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)vt[843])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Add(ImRectPtr self, ImRect r)
		{
			AddNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Add(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				AddNative((ImRect*)pself, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ExpandNative(ImRect* self, float amount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, float, void>)vt[844])(self, amount);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)vt[844])((nint)self, amount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Expand(ImRectPtr self, float amount)
		{
			ExpandNative(self, amount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Expand(ref ImRect self, float amount)
		{
			fixed (ImRect* pself = &self)
			{
				ExpandNative((ImRect*)pself, amount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ExpandNative(ImRect* self, Vector2 amount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, Vector2, void>)vt[845])(self, amount);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, void>)vt[845])((nint)self, amount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Expand(ImRectPtr self, Vector2 amount)
		{
			ExpandNative(self, amount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Expand(ref ImRect self, Vector2 amount)
		{
			fixed (ImRect* pself = &self)
			{
				ExpandNative((ImRect*)pself, amount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TranslateNative(ImRect* self, Vector2 d)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, Vector2, void>)vt[846])(self, d);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, void>)vt[846])((nint)self, d);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Translate(ImRectPtr self, Vector2 d)
		{
			TranslateNative(self, d);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Translate(ref ImRect self, Vector2 d)
		{
			fixed (ImRect* pself = &self)
			{
				TranslateNative((ImRect*)pself, d);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TranslateXNative(ImRect* self, float dx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, float, void>)vt[847])(self, dx);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)vt[847])((nint)self, dx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateX(ImRectPtr self, float dx)
		{
			TranslateXNative(self, dx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateX(ref ImRect self, float dx)
		{
			fixed (ImRect* pself = &self)
			{
				TranslateXNative((ImRect*)pself, dx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TranslateYNative(ImRect* self, float dy)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, float, void>)vt[848])(self, dy);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)vt[848])((nint)self, dy);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateY(ImRectPtr self, float dy)
		{
			TranslateYNative(self, dy);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateY(ref ImRect self, float dy)
		{
			fixed (ImRect* pself = &self)
			{
				TranslateYNative((ImRect*)pself, dy);
			}
		}

		/// <summary>
		/// Simple version, may lead to an inverted rectangle, which is fine for ContainsOverlaps test but not for display.<br/>
		/// </summary>
		internal static void ClipWithNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImRect, void>)vt[849])(self, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)vt[849])((nint)self, r);
			#endif
		}

		/// <summary>
		/// Simple version, may lead to an inverted rectangle, which is fine for ContainsOverlaps test but not for display.<br/>
		/// </summary>
		public static void ClipWith(ImRectPtr self, ImRect r)
		{
			ClipWithNative(self, r);
		}

		/// <summary>
		/// Simple version, may lead to an inverted rectangle, which is fine for ContainsOverlaps test but not for display.<br/>
		/// </summary>
		public static void ClipWith(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ClipWithNative((ImRect*)pself, r);
			}
		}

		/// <summary>
		/// Full version, ensure both points are fully clipped.<br/>
		/// </summary>
		internal static void ClipWithFullNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImRect, void>)vt[850])(self, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)vt[850])((nint)self, r);
			#endif
		}

		/// <summary>
		/// Full version, ensure both points are fully clipped.<br/>
		/// </summary>
		public static void ClipWithFull(ImRectPtr self, ImRect r)
		{
			ClipWithFullNative(self, r);
		}

		/// <summary>
		/// Full version, ensure both points are fully clipped.<br/>
		/// </summary>
		public static void ClipWithFull(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ClipWithFullNative((ImRect*)pself, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void FloorNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, void>)vt[851])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[851])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Floor(ImRectPtr self)
		{
			FloorNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Floor(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				FloorNative((ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsInvertedNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, byte>)vt[852])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[852])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInverted(ImRectPtr self)
		{
			byte ret = IsInvertedNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInverted(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = IsInvertedNative((ImRect*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ToVec4Native(Vector4* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, ImRect*, void>)vt[853])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[853])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 ToVec4(ImRectPtr self)
		{
			Vector4 ret;
			ToVec4Native(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(Vector4* pOut, ImRectPtr self)
		{
			ToVec4Native(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(ref Vector4 pOut, ImRectPtr self)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				ToVec4Native((Vector4*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 ToVec4(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector4 ret;
				ToVec4Native(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(Vector4* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ToVec4Native(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(ref Vector4 pOut, ref ImRect self)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ToVec4Native((Vector4*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ulong ImBitArrayGetStorageSizeInBytesNative(int bitcount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ulong>)vt[854])(bitcount);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<int, ulong>)vt[854])(bitcount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImBitArrayGetStorageSizeInBytes(int bitcount)
		{
			ulong ret = ImBitArrayGetStorageSizeInBytesNative(bitcount);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImBitArrayClearAllBitsNative(uint* arr, int bitcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, void>)vt[855])(arr, bitcount);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[855])((nint)arr, bitcount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArrayClearAllBits(uint* arr, int bitcount)
		{
			ImBitArrayClearAllBitsNative(arr, bitcount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArrayClearAllBits(ref uint arr, int bitcount)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArrayClearAllBitsNative((uint*)parr, bitcount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImBitArrayTestBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, byte>)vt[856])(arr, n);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)vt[856])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImBitArrayTestBit(uint* arr, int n)
		{
			byte ret = ImBitArrayTestBitNative(arr, n);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImBitArrayTestBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				byte ret = ImBitArrayTestBitNative((uint*)parr, n);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImBitArrayClearBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, void>)vt[857])(arr, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[857])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArrayClearBit(uint* arr, int n)
		{
			ImBitArrayClearBitNative(arr, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArrayClearBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArrayClearBitNative((uint*)parr, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImBitArraySetBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, void>)vt[858])(arr, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[858])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArraySetBit(uint* arr, int n)
		{
			ImBitArraySetBitNative(arr, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArraySetBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArraySetBitNative((uint*)parr, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImBitArraySetBitRangeNative(uint* arr, int n, int n2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, int, void>)vt[859])(arr, n, n2);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)vt[859])((nint)arr, n, n2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArraySetBitRange(uint* arr, int n, int n2)
		{
			ImBitArraySetBitRangeNative(arr, n, n2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArraySetBitRange(ref uint arr, int n, int n2)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArraySetBitRangeNative((uint*)parr, n, n2);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void CreateNative(ImBitVector* self, int sz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)vt[860])(self, sz);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[860])((nint)self, sz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Create(ImBitVectorPtr self, int sz)
		{
			CreateNative(self, sz);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Create(ref ImBitVector self, int sz)
		{
			fixed (ImBitVector* pself = &self)
			{
				CreateNative((ImBitVector*)pself, sz);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearNative(ImBitVector* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, void>)vt[861])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[861])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImBitVectorPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImBitVector self)
		{
			fixed (ImBitVector* pself = &self)
			{
				ClearNative((ImBitVector*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte TestBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImBitVector*, int, byte>)vt[862])(self, n);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)vt[862])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TestBit(ImBitVectorPtr self, int n)
		{
			byte ret = TestBitNative(self, n);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TestBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				byte ret = TestBitNative((ImBitVector*)pself, n);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void SetBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)vt[863])(self, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[863])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetBit(ImBitVectorPtr self, int n)
		{
			SetBitNative(self, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				SetBitNative((ImBitVector*)pself, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)vt[864])(self, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[864])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearBit(ImBitVectorPtr self, int n)
		{
			ClearBitNative(self, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ClearBitNative((ImBitVector*)pself, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void clearNative(ImGuiTextIndex* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, void>)vt[865])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[865])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void clear(ImGuiTextIndexPtr self)
		{
			clearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void clear(ref ImGuiTextIndex self)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				clearNative((ImGuiTextIndex*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int sizeNative(ImGuiTextIndex* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, int>)vt[866])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[866])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int size(ImGuiTextIndexPtr self)
		{
			int ret = sizeNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int size(ref ImGuiTextIndex self)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				int ret = sizeNative((ImGuiTextIndex*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte* get_line_beginNative(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, byte*, int, byte*>)vt[867])(self, baseValue, n);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)vt[867])((nint)self, (nint)baseValue, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ImGuiTextIndexPtr self, byte* baseValue, int n)
		{
			byte* ret = get_line_beginNative(self, baseValue, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ImGuiTextIndexPtr self, byte* baseValue, int n)
		{
			string ret = Utils.DecodeStringUTF8(get_line_beginNative(self, baseValue, n));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* ret = get_line_beginNative((ImGuiTextIndex*)pself, baseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(get_line_beginNative((ImGuiTextIndex*)pself, baseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ImGuiTextIndexPtr self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = get_line_beginNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ImGuiTextIndexPtr self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(get_line_beginNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				byte* ret = get_line_beginNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				string ret = Utils.DecodeStringUTF8(get_line_beginNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = get_line_beginNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(get_line_beginNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = get_line_beginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(get_line_beginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					byte* ret = get_line_beginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					string ret = Utils.DecodeStringUTF8(get_line_beginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = get_line_beginNative((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(get_line_beginNative((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte* get_line_endNative(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, byte*, int, byte*>)vt[868])(self, baseValue, n);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)vt[868])((nint)self, (nint)baseValue, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ImGuiTextIndexPtr self, byte* baseValue, int n)
		{
			byte* ret = get_line_endNative(self, baseValue, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ImGuiTextIndexPtr self, byte* baseValue, int n)
		{
			string ret = Utils.DecodeStringUTF8(get_line_endNative(self, baseValue, n));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* ret = get_line_endNative((ImGuiTextIndex*)pself, baseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(get_line_endNative((ImGuiTextIndex*)pself, baseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ImGuiTextIndexPtr self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = get_line_endNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ImGuiTextIndexPtr self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(get_line_endNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				byte* ret = get_line_endNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				string ret = Utils.DecodeStringUTF8(get_line_endNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = get_line_endNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(get_line_endNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = get_line_endNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(get_line_endNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					byte* ret = get_line_endNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					string ret = Utils.DecodeStringUTF8(get_line_endNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = get_line_endNative((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(get_line_endNative((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void appendNative(ImGuiTextIndex* self, byte* baseValue, int oldSize, int newSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, byte*, int, int, void>)vt[869])(self, baseValue, oldSize, newSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)vt[869])((nint)self, (nint)baseValue, oldSize, newSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ImGuiTextIndexPtr self, byte* baseValue, int oldSize, int newSize)
		{
			appendNative(self, baseValue, oldSize, newSize);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ref ImGuiTextIndex self, byte* baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				appendNative((ImGuiTextIndex*)pself, baseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ImGuiTextIndexPtr self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				appendNative(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				appendNative(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ImGuiTextIndexPtr self, string baseValue, int oldSize, int newSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendNative(self, pStr0, oldSize, newSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ref ImGuiTextIndex self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					appendNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					appendNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ref ImGuiTextIndex self, string baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendNative((ImGuiTextIndex*)pself, pStr0, oldSize, newSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStoragePair* ImLowerBoundNative(ImGuiStoragePair* inBegin, ImGuiStoragePair* inEnd, uint key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStoragePair*, ImGuiStoragePair*, uint, ImGuiStoragePair*>)vt[870])(inBegin, inEnd, key);
			#else
			return (ImGuiStoragePair*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint>)vt[870])((nint)inBegin, (nint)inEnd, key);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ImGuiStoragePairPtr inBegin, ImGuiStoragePairPtr inEnd, uint key)
		{
			ImGuiStoragePairPtr ret = ImLowerBoundNative(inBegin, inEnd, key);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ref ImGuiStoragePair inBegin, ImGuiStoragePairPtr inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinBegin = &inBegin)
			{
				ImGuiStoragePairPtr ret = ImLowerBoundNative((ImGuiStoragePair*)pinBegin, inEnd, key);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ImGuiStoragePairPtr inBegin, ref ImGuiStoragePair inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinEnd = &inEnd)
			{
				ImGuiStoragePairPtr ret = ImLowerBoundNative(inBegin, (ImGuiStoragePair*)pinEnd, key);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ref ImGuiStoragePair inBegin, ref ImGuiStoragePair inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinBegin = &inBegin)
			{
				fixed (ImGuiStoragePair* pinEnd = &inEnd)
				{
					ImGuiStoragePairPtr ret = ImLowerBoundNative((ImGuiStoragePair*)pinBegin, (ImGuiStoragePair*)pinEnd, key);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImDrawListSharedData* ImDrawListSharedDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawListSharedData*>)vt[871])();
			#else
			return (ImDrawListSharedData*)((delegate* unmanaged[Cdecl]<nint>)vt[871])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawListSharedDataPtr ImDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = ImDrawListSharedDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void SetCircleTessellationMaxErrorNative(ImDrawListSharedData* self, float maxError)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawListSharedData*, float, void>)vt[872])(self, maxError);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)vt[872])((nint)self, maxError);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCircleTessellationMaxError(ImDrawListSharedDataPtr self, float maxError)
		{
			SetCircleTessellationMaxErrorNative(self, maxError);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCircleTessellationMaxError(ref ImDrawListSharedData self, float maxError)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				SetCircleTessellationMaxErrorNative((ImDrawListSharedData*)pself, maxError);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImDrawDataBuilder* ImDrawDataBuilderNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*>)vt[873])();
			#else
			return (ImDrawDataBuilder*)((delegate* unmanaged[Cdecl]<nint>)vt[873])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawDataBuilderPtr ImDrawDataBuilder()
		{
			ImDrawDataBuilderPtr ret = ImDrawDataBuilderNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void* GetVarPtrNative(ImGuiDataVarInfo* self, void* parent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDataVarInfo*, void*, void*>)vt[874])(self, parent);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)vt[874])((nint)self, (nint)parent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetVarPtr(ImGuiDataVarInfoPtr self, void* parent)
		{
			void* ret = GetVarPtrNative(self, parent);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetVarPtr(ref ImGuiDataVarInfo self, void* parent)
		{
			fixed (ImGuiDataVarInfo* pself = &self)
			{
				void* ret = GetVarPtrNative((ImGuiDataVarInfo*)pself, parent);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, int, ImGuiStyleMod*>)vt[875])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, int, nint>)vt[875])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, int v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, float v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, ImGuiStyleMod*>)vt[876])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, nint>)vt[876])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, float v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, Vector2 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, ImGuiStyleMod*>)vt[877])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, nint>)vt[877])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, Vector2 v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiComboPreviewData* ImGuiComboPreviewDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiComboPreviewData*>)vt[878])();
			#else
			return (ImGuiComboPreviewData*)((delegate* unmanaged[Cdecl]<nint>)vt[878])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiComboPreviewDataPtr ImGuiComboPreviewData()
		{
			ImGuiComboPreviewDataPtr ret = ImGuiComboPreviewDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiMenuColumns* ImGuiMenuColumnsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*>)vt[879])();
			#else
			return (ImGuiMenuColumns*)((delegate* unmanaged[Cdecl]<nint>)vt[879])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMenuColumnsPtr ImGuiMenuColumns()
		{
			ImGuiMenuColumnsPtr ret = ImGuiMenuColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void UpdateNative(ImGuiMenuColumns* self, float spacing, byte windowReappearing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, float, byte, void>)vt[880])(self, spacing, windowReappearing);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, byte, void>)vt[880])((nint)self, spacing, windowReappearing);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImGuiMenuColumnsPtr self, float spacing, bool windowReappearing)
		{
			UpdateNative(self, spacing, windowReappearing ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImGuiMenuColumns self, float spacing, bool windowReappearing)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				UpdateNative((ImGuiMenuColumns*)pself, spacing, windowReappearing ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float DeclColumnsNative(ImGuiMenuColumns* self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, float, float, float, float, float>)vt[881])(self, wIcon, wLabel, wShortcut, wMark);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, float>)vt[881])((nint)self, wIcon, wLabel, wShortcut, wMark);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float DeclColumns(ImGuiMenuColumnsPtr self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			float ret = DeclColumnsNative(self, wIcon, wLabel, wShortcut, wMark);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float DeclColumns(ref ImGuiMenuColumns self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				float ret = DeclColumnsNative((ImGuiMenuColumns*)pself, wIcon, wLabel, wShortcut, wMark);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void CalcNextTotalWidthNative(ImGuiMenuColumns* self, byte updateOffsets)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, byte, void>)vt[882])(self, updateOffsets);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)vt[882])((nint)self, updateOffsets);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcNextTotalWidth(ImGuiMenuColumnsPtr self, bool updateOffsets)
		{
			CalcNextTotalWidthNative(self, updateOffsets ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcNextTotalWidth(ref ImGuiMenuColumns self, bool updateOffsets)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				CalcNextTotalWidthNative((ImGuiMenuColumns*)pself, updateOffsets ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiInputTextDeactivatedState* ImGuiInputTextDeactivatedStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextDeactivatedState*>)vt[883])();
			#else
			return (ImGuiInputTextDeactivatedState*)((delegate* unmanaged[Cdecl]<nint>)vt[883])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputTextDeactivatedStatePtr ImGuiInputTextDeactivatedState()
		{
			ImGuiInputTextDeactivatedStatePtr ret = ImGuiInputTextDeactivatedStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearFreeMemoryNative(ImGuiInputTextDeactivatedState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextDeactivatedState*, void>)vt[884])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[884])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ImGuiInputTextDeactivatedStatePtr self)
		{
			ClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				ClearFreeMemoryNative((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiInputTextState* ImGuiInputTextStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*>)vt[885])();
			#else
			return (ImGuiInputTextState*)((delegate* unmanaged[Cdecl]<nint>)vt[885])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputTextStatePtr ImGuiInputTextState()
		{
			ImGuiInputTextStatePtr ret = ImGuiInputTextStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DestroyNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[886])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[886])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiInputTextStatePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				DestroyNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearTextNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[887])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[887])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearText(ImGuiInputTextStatePtr self)
		{
			ClearTextNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearText(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearTextNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearFreeMemoryNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[888])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[888])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ImGuiInputTextStatePtr self)
		{
			ClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearFreeMemoryNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// Cannot be inline because we call in code in stb_textedit.h implementation<br/>
		/// </summary>
		internal static void OnKeyPressedNative(ImGuiInputTextState* self, int key)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int, void>)vt[889])(self, key);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[889])((nint)self, key);
			#endif
		}

		/// <summary>
		/// Cannot be inline because we call in code in stb_textedit.h implementation<br/>
		/// </summary>
		public static void OnKeyPressed(ImGuiInputTextStatePtr self, int key)
		{
			OnKeyPressedNative(self, key);
		}

		/// <summary>
		/// Cannot be inline because we call in code in stb_textedit.h implementation<br/>
		/// </summary>
		public static void OnKeyPressed(ref ImGuiInputTextState self, int key)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				OnKeyPressedNative((ImGuiInputTextState*)pself, key);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void OnCharPressedNative(ImGuiInputTextState* self, uint c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, uint, void>)vt[890])(self, c);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)vt[890])((nint)self, c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OnCharPressed(ImGuiInputTextStatePtr self, uint c)
		{
			OnCharPressedNative(self, c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OnCharPressed(ref ImGuiInputTextState self, uint c)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				OnCharPressedNative((ImGuiInputTextState*)pself, c);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void CursorAnimResetNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[891])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[891])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorAnimReset(ImGuiInputTextStatePtr self)
		{
			CursorAnimResetNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorAnimReset(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				CursorAnimResetNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void CursorClampNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[892])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[892])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorClamp(ImGuiInputTextStatePtr self)
		{
			CursorClampNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorClamp(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				CursorClampNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte HasSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, byte>)vt[893])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[893])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasSelection(ImGuiInputTextStatePtr self)
		{
			byte ret = HasSelectionNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				byte ret = HasSelectionNative((ImGuiInputTextState*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[894])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[894])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearSelection(ImGuiInputTextStatePtr self)
		{
			ClearSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearSelectionNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int GetCursorPosNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)vt[895])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[895])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetCursorPos(ImGuiInputTextStatePtr self)
		{
			int ret = GetCursorPosNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetCursorPos(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetCursorPosNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int GetSelectionStartNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)vt[896])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[896])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionStart(ImGuiInputTextStatePtr self)
		{
			int ret = GetSelectionStartNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionStart(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetSelectionStartNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int GetSelectionEndNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)vt[897])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[897])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionEnd(ImGuiInputTextStatePtr self)
		{
			int ret = GetSelectionEndNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetSelectionEndNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void SelectAllNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[898])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[898])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SelectAll(ImGuiInputTextStatePtr self)
		{
			SelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				SelectAllNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ReloadUserBufAndSelectAllNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[899])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[899])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndSelectAll(ImGuiInputTextStatePtr self)
		{
			ReloadUserBufAndSelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndSelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ReloadUserBufAndSelectAllNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ReloadUserBufAndKeepSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[900])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[900])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndKeepSelection(ImGuiInputTextStatePtr self)
		{
			ReloadUserBufAndKeepSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndKeepSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ReloadUserBufAndKeepSelectionNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ReloadUserBufAndMoveToEndNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)vt[901])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[901])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndMoveToEnd(ImGuiInputTextStatePtr self)
		{
			ReloadUserBufAndMoveToEndNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndMoveToEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ReloadUserBufAndMoveToEndNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiNextWindowData* ImGuiNextWindowDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*>)vt[902])();
			#else
			return (ImGuiNextWindowData*)((delegate* unmanaged[Cdecl]<nint>)vt[902])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNextWindowDataPtr ImGuiNextWindowData()
		{
			ImGuiNextWindowDataPtr ret = ImGuiNextWindowDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearFlagsNative(ImGuiNextWindowData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*, void>)vt[903])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[903])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ImGuiNextWindowDataPtr self)
		{
			ClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ClearFlagsNative((ImGuiNextWindowData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiNextItemData* ImGuiNextItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNextItemData*>)vt[904])();
			#else
			return (ImGuiNextItemData*)((delegate* unmanaged[Cdecl]<nint>)vt[904])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNextItemDataPtr ImGuiNextItemData()
		{
			ImGuiNextItemDataPtr ret = ImGuiNextItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearFlagsNative(ImGuiNextItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextItemData*, void>)vt[905])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[905])((nint)self);
			#endif
		}

		/// <summary>
		/// Also cleared manually by ItemAdd()!<br/>
		/// </summary>
		public static void ClearFlags(ImGuiNextItemDataPtr self)
		{
			ClearFlagsNative(self);
		}

		/// <summary>
		/// Also cleared manually by ItemAdd()!<br/>
		/// </summary>
		public static void ClearFlags(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ClearFlagsNative((ImGuiNextItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiLastItemData* ImGuiLastItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiLastItemData*>)vt[906])();
			#else
			return (ImGuiLastItemData*)((delegate* unmanaged[Cdecl]<nint>)vt[906])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiLastItemDataPtr ImGuiLastItemData()
		{
			ImGuiLastItemDataPtr ret = ImGuiLastItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStackSizes* ImGuiStackSizesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStackSizes*>)vt[907])();
			#else
			return (ImGuiStackSizes*)((delegate* unmanaged[Cdecl]<nint>)vt[907])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStackSizesPtr ImGuiStackSizes()
		{
			ImGuiStackSizesPtr ret = ImGuiStackSizesNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void SetToContextStateNative(ImGuiStackSizes* self, ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackSizes*, ImGuiContext*, void>)vt[908])(self, ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[908])((nint)self, (nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetToContextState(ImGuiStackSizesPtr self, ImGuiContextPtr ctx)
		{
			SetToContextStateNative(self, ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetToContextState(ref ImGuiStackSizes self, ImGuiContextPtr ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				SetToContextStateNative((ImGuiStackSizes*)pself, ctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetToContextState(ImGuiStackSizesPtr self, ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetToContextStateNative(self, (ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetToContextState(ref ImGuiStackSizes self, ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					SetToContextStateNative((ImGuiStackSizes*)pself, (ImGuiContext*)pctx);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void CompareWithContextStateNative(ImGuiStackSizes* self, ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackSizes*, ImGuiContext*, void>)vt[909])(self, ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[909])((nint)self, (nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompareWithContextState(ImGuiStackSizesPtr self, ImGuiContextPtr ctx)
		{
			CompareWithContextStateNative(self, ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompareWithContextState(ref ImGuiStackSizes self, ImGuiContextPtr ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				CompareWithContextStateNative((ImGuiStackSizes*)pself, ctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompareWithContextState(ImGuiStackSizesPtr self, ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				CompareWithContextStateNative(self, (ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompareWithContextState(ref ImGuiStackSizes self, ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					CompareWithContextStateNative((ImGuiStackSizes*)pself, (ImGuiContext*)pctx);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiPtrOrIndex* ImGuiPtrOrIndexNative(void* ptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ImGuiPtrOrIndex*>)vt[910])(ptr);
			#else
			return (ImGuiPtrOrIndex*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[910])((nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndex(void* ptr)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPtrOrIndexNative(ptr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiPtrOrIndex* ImGuiPtrOrIndexNative(int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiPtrOrIndex*>)vt[911])(index);
			#else
			return (ImGuiPtrOrIndex*)((delegate* unmanaged[Cdecl]<int, nint>)vt[911])(index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndex(int index)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPtrOrIndexNative(index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiPopupData* ImGuiPopupDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiPopupData*>)vt[912])();
			#else
			return (ImGuiPopupData*)((delegate* unmanaged[Cdecl]<nint>)vt[912])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPopupDataPtr ImGuiPopupData()
		{
			ImGuiPopupDataPtr ret = ImGuiPopupDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiInputEvent* ImGuiInputEventNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputEvent*>)vt[913])();
			#else
			return (ImGuiInputEvent*)((delegate* unmanaged[Cdecl]<nint>)vt[913])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputEventPtr ImGuiInputEvent()
		{
			ImGuiInputEventPtr ret = ImGuiInputEventNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiKeyRoutingData* ImGuiKeyRoutingDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingData*>)vt[914])();
			#else
			return (ImGuiKeyRoutingData*)((delegate* unmanaged[Cdecl]<nint>)vt[914])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyRoutingDataPtr ImGuiKeyRoutingData()
		{
			ImGuiKeyRoutingDataPtr ret = ImGuiKeyRoutingDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiKeyRoutingTable* ImGuiKeyRoutingTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingTable*>)vt[915])();
			#else
			return (ImGuiKeyRoutingTable*)((delegate* unmanaged[Cdecl]<nint>)vt[915])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyRoutingTablePtr ImGuiKeyRoutingTable()
		{
			ImGuiKeyRoutingTablePtr ret = ImGuiKeyRoutingTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearNative(ImGuiKeyRoutingTable* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingTable*, void>)vt[916])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[916])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImGuiKeyRoutingTablePtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				ClearNative((ImGuiKeyRoutingTable*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiKeyOwnerData* ImGuiKeyOwnerDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyOwnerData*>)vt[917])();
			#else
			return (ImGuiKeyOwnerData*)((delegate* unmanaged[Cdecl]<nint>)vt[917])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyOwnerDataPtr ImGuiKeyOwnerData()
		{
			ImGuiKeyOwnerDataPtr ret = ImGuiKeyOwnerDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiListClipperRange FromIndicesNative(int min, int max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, ImGuiListClipperRange>)vt[918])(min, max);
			#else
			return (ImGuiListClipperRange)((delegate* unmanaged[Cdecl]<int, int, ImGuiListClipperRange>)vt[918])(min, max);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperRange FromIndices(int min, int max)
		{
			ImGuiListClipperRange ret = FromIndicesNative(min, max);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiListClipperRange FromPositionsNative(float y1, float y2, int offMin, int offMax)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, int, int, ImGuiListClipperRange>)vt[919])(y1, y2, offMin, offMax);
			#else
			return (ImGuiListClipperRange)((delegate* unmanaged[Cdecl]<float, float, int, int, ImGuiListClipperRange>)vt[919])(y1, y2, offMin, offMax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperRange FromPositions(float y1, float y2, int offMin, int offMax)
		{
			ImGuiListClipperRange ret = FromPositionsNative(y1, y2, offMin, offMax);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiListClipperData* ImGuiListClipperDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiListClipperData*>)vt[920])();
			#else
			return (ImGuiListClipperData*)((delegate* unmanaged[Cdecl]<nint>)vt[920])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperDataPtr ImGuiListClipperData()
		{
			ImGuiListClipperDataPtr ret = ImGuiListClipperDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ResetNative(ImGuiListClipperData* self, ImGuiListClipper* clipper)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiListClipperData*, ImGuiListClipper*, void>)vt[921])(self, clipper);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[921])((nint)self, (nint)clipper);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImGuiListClipperDataPtr self, ImGuiListClipperPtr clipper)
		{
			ResetNative(self, clipper);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImGuiListClipperData self, ImGuiListClipperPtr clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ResetNative((ImGuiListClipperData*)pself, clipper);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImGuiListClipperDataPtr self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipper* pclipper = &clipper)
			{
				ResetNative(self, (ImGuiListClipper*)pclipper);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImGuiListClipperData self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				fixed (ImGuiListClipper* pclipper = &clipper)
				{
					ResetNative((ImGuiListClipperData*)pself, (ImGuiListClipper*)pclipper);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiNavItemData* ImGuiNavItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNavItemData*>)vt[922])();
			#else
			return (ImGuiNavItemData*)((delegate* unmanaged[Cdecl]<nint>)vt[922])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNavItemDataPtr ImGuiNavItemData()
		{
			ImGuiNavItemDataPtr ret = ImGuiNavItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearNative(ImGuiNavItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNavItemData*, void>)vt[923])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[923])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImGuiNavItemDataPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ClearNative((ImGuiNavItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTypingSelectState* ImGuiTypingSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectState*>)vt[924])();
			#else
			return (ImGuiTypingSelectState*)((delegate* unmanaged[Cdecl]<nint>)vt[924])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTypingSelectStatePtr ImGuiTypingSelectState()
		{
			ImGuiTypingSelectStatePtr ret = ImGuiTypingSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearNative(ImGuiTypingSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTypingSelectState*, void>)vt[925])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[925])((nint)self);
			#endif
		}

		/// <summary>
		/// We preserve remaining data for easier debugging<br/>
		/// </summary>
		public static void Clear(ImGuiTypingSelectStatePtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// We preserve remaining data for easier debugging<br/>
		/// </summary>
		public static void Clear(ref ImGuiTypingSelectState self)
		{
			fixed (ImGuiTypingSelectState* pself = &self)
			{
				ClearNative((ImGuiTypingSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiOldColumnData* ImGuiOldColumnDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumnData*>)vt[926])();
			#else
			return (ImGuiOldColumnData*)((delegate* unmanaged[Cdecl]<nint>)vt[926])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnDataPtr ImGuiOldColumnData()
		{
			ImGuiOldColumnDataPtr ret = ImGuiOldColumnDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiOldColumns* ImGuiOldColumnsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*>)vt[927])();
			#else
			return (ImGuiOldColumns*)((delegate* unmanaged[Cdecl]<nint>)vt[927])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnsPtr ImGuiOldColumns()
		{
			ImGuiOldColumnsPtr ret = ImGuiOldColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiBoxSelectState* ImGuiBoxSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiBoxSelectState*>)vt[928])();
			#else
			return (ImGuiBoxSelectState*)((delegate* unmanaged[Cdecl]<nint>)vt[928])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiBoxSelectStatePtr ImGuiBoxSelectState()
		{
			ImGuiBoxSelectStatePtr ret = ImGuiBoxSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiMultiSelectTempData* ImGuiMultiSelectTempDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*>)vt[929])();
			#else
			return (ImGuiMultiSelectTempData*)((delegate* unmanaged[Cdecl]<nint>)vt[929])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMultiSelectTempDataPtr ImGuiMultiSelectTempData()
		{
			ImGuiMultiSelectTempDataPtr ret = ImGuiMultiSelectTempDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearNative(ImGuiMultiSelectTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, void>)vt[930])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[930])((nint)self);
			#endif
		}

		/// <summary>
		/// Zero-clear except IO as we preserve IO.Requests[] buffer allocation.<br/>
		/// </summary>
		public static void Clear(ImGuiMultiSelectTempDataPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// Zero-clear except IO as we preserve IO.Requests[] buffer allocation.<br/>
		/// </summary>
		public static void Clear(ref ImGuiMultiSelectTempData self)
		{
			fixed (ImGuiMultiSelectTempData* pself = &self)
			{
				ClearNative((ImGuiMultiSelectTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearIONative(ImGuiMultiSelectTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, void>)vt[931])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[931])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearIO(ImGuiMultiSelectTempDataPtr self)
		{
			ClearIONative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearIO(ref ImGuiMultiSelectTempData self)
		{
			fixed (ImGuiMultiSelectTempData* pself = &self)
			{
				ClearIONative((ImGuiMultiSelectTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiMultiSelectState* ImGuiMultiSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMultiSelectState*>)vt[932])();
			#else
			return (ImGuiMultiSelectState*)((delegate* unmanaged[Cdecl]<nint>)vt[932])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMultiSelectStatePtr ImGuiMultiSelectState()
		{
			ImGuiMultiSelectStatePtr ret = ImGuiMultiSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiDockNode* ImGuiDockNodeNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiDockNode*>)vt[933])(id);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<uint, nint>)vt[933])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr ImGuiDockNode(uint id)
		{
			ImGuiDockNodePtr ret = ImGuiDockNodeNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DestroyNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, void>)vt[934])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[934])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiDockNodePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				DestroyNative((ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsRootNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[935])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[935])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsRootNode(ImGuiDockNodePtr self)
		{
			byte ret = IsRootNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsRootNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsRootNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsDockSpaceNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[936])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[936])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDockSpace(ImGuiDockNodePtr self)
		{
			byte ret = IsDockSpaceNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDockSpace(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsDockSpaceNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsFloatingNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[937])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[937])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsFloatingNode(ImGuiDockNodePtr self)
		{
			byte ret = IsFloatingNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsFloatingNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsFloatingNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsCentralNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[938])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[938])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsCentralNode(ImGuiDockNodePtr self)
		{
			byte ret = IsCentralNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsCentralNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsCentralNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// Hidden tab bar can be shown back by clicking the small triangle<br/>
		/// </summary>
		internal static byte IsHiddenTabBarNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[939])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[939])((nint)self);
			#endif
		}

		/// <summary>
		/// Hidden tab bar can be shown back by clicking the small triangle<br/>
		/// </summary>
		public static bool IsHiddenTabBar(ImGuiDockNodePtr self)
		{
			byte ret = IsHiddenTabBarNative(self);
			return ret != 0;
		}

		/// <summary>
		/// Hidden tab bar can be shown back by clicking the small triangle<br/>
		/// </summary>
		public static bool IsHiddenTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsHiddenTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// Never show a tab bar<br/>
		/// </summary>
		internal static byte IsNoTabBarNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[940])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[940])((nint)self);
			#endif
		}

		/// <summary>
		/// Never show a tab bar<br/>
		/// </summary>
		public static bool IsNoTabBar(ImGuiDockNodePtr self)
		{
			byte ret = IsNoTabBarNative(self);
			return ret != 0;
		}

		/// <summary>
		/// Never show a tab bar<br/>
		/// </summary>
		public static bool IsNoTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsNoTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsSplitNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[941])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[941])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsSplitNode(ImGuiDockNodePtr self)
		{
			byte ret = IsSplitNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsSplitNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsSplitNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsLeafNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[942])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[942])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLeafNode(ImGuiDockNodePtr self)
		{
			byte ret = IsLeafNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLeafNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsLeafNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsEmptyNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)vt[943])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[943])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsEmpty(ImGuiDockNodePtr self)
		{
			byte ret = IsEmptyNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsEmpty(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsEmptyNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void RectNative(ImRect* pOut, ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiDockNode*, void>)vt[944])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[944])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ImGuiDockNodePtr self)
		{
			ImRect ret;
			RectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ImGuiDockNodePtr self)
		{
			RectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ImGuiDockNodePtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				RectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImRect ret;
				RectNative(&ret, (ImGuiDockNode*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				RectNative(pOut, (ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ref ImGuiDockNode self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiDockNode* pself = &self)
				{
					RectNative((ImRect*)ppOut, (ImGuiDockNode*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void SetLocalFlagsNative(ImGuiDockNode* self, ImGuiDockNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, ImGuiDockNodeFlags, void>)vt[945])(self, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiDockNodeFlags, void>)vt[945])((nint)self, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetLocalFlags(ImGuiDockNodePtr self, ImGuiDockNodeFlags flags)
		{
			SetLocalFlagsNative(self, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetLocalFlags(ref ImGuiDockNode self, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				SetLocalFlagsNative((ImGuiDockNode*)pself, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void UpdateMergedFlagsNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, void>)vt[946])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[946])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateMergedFlags(ImGuiDockNodePtr self)
		{
			UpdateMergedFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateMergedFlags(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				UpdateMergedFlagsNative((ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiDockContext* ImGuiDockContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockContext*>)vt[947])();
			#else
			return (ImGuiDockContext*)((delegate* unmanaged[Cdecl]<nint>)vt[947])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockContextPtr ImGuiDockContext()
		{
			ImGuiDockContextPtr ret = ImGuiDockContextNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiViewportP* ImGuiViewportPNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewportP*>)vt[948])();
			#else
			return (ImGuiViewportP*)((delegate* unmanaged[Cdecl]<nint>)vt[948])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiViewportPPtr ImGuiViewportP()
		{
			ImGuiViewportPPtr ret = ImGuiViewportPNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DestroyNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)vt[949])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[949])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiViewportPPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				DestroyNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearRequestFlagsNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)vt[950])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[950])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearRequestFlags(ImGuiViewportPPtr self)
		{
			ClearRequestFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearRequestFlags(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ClearRequestFlagsNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void CalcWorkRectPosNative(Vector2* pOut, ImGuiViewportP* self, Vector2 insetMin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiViewportP*, Vector2, void>)vt[951])(pOut, self, insetMin);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, void>)vt[951])((nint)pOut, (nint)self, insetMin);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectPos(ImGuiViewportPPtr self, Vector2 insetMin)
		{
			Vector2 ret;
			CalcWorkRectPosNative(&ret, self, insetMin);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(Vector2* pOut, ImGuiViewportPPtr self, Vector2 insetMin)
		{
			CalcWorkRectPosNative(pOut, self, insetMin);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 insetMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcWorkRectPosNative((Vector2*)ppOut, self, insetMin);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectPos(ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				CalcWorkRectPosNative(&ret, (ImGuiViewportP*)pself, insetMin);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(Vector2* pOut, ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				CalcWorkRectPosNative(pOut, (ImGuiViewportP*)pself, insetMin);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					CalcWorkRectPosNative((Vector2*)ppOut, (ImGuiViewportP*)pself, insetMin);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void CalcWorkRectSizeNative(Vector2* pOut, ImGuiViewportP* self, Vector2 insetMin, Vector2 insetMax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiViewportP*, Vector2, Vector2, void>)vt[952])(pOut, self, insetMin, insetMax);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, Vector2, void>)vt[952])((nint)pOut, (nint)self, insetMin, insetMax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectSize(ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			Vector2 ret;
			CalcWorkRectSizeNative(&ret, self, insetMin, insetMax);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(Vector2* pOut, ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			CalcWorkRectSizeNative(pOut, self, insetMin, insetMax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcWorkRectSizeNative((Vector2*)ppOut, self, insetMin, insetMax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectSize(ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				CalcWorkRectSizeNative(&ret, (ImGuiViewportP*)pself, insetMin, insetMax);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(Vector2* pOut, ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				CalcWorkRectSizeNative(pOut, (ImGuiViewportP*)pself, insetMin, insetMax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					CalcWorkRectSizeNative((Vector2*)ppOut, (ImGuiViewportP*)pself, insetMin, insetMax);
				}
			}
		}

		/// <summary>
		/// Update public fields<br/>
		/// </summary>
		internal static void UpdateWorkRectNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)vt[953])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[953])((nint)self);
			#endif
		}

		/// <summary>
		/// Update public fields<br/>
		/// </summary>
		public static void UpdateWorkRect(ImGuiViewportPPtr self)
		{
			UpdateWorkRectNative(self);
		}

		/// <summary>
		/// Update public fields<br/>
		/// </summary>
		public static void UpdateWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				UpdateWorkRectNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void GetMainRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)vt[954])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[954])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetMainRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetMainRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetMainRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetMainRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetMainRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetMainRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetMainRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetMainRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void GetWorkRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)vt[955])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[955])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetWorkRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetWorkRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetWorkRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetWorkRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetWorkRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void GetBuildWorkRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)vt[956])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[956])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetBuildWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetBuildWorkRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetBuildWorkRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetBuildWorkRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetBuildWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetBuildWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetBuildWorkRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetBuildWorkRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiWindowSettings* ImGuiWindowSettingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*>)vt[957])();
			#else
			return (ImGuiWindowSettings*)((delegate* unmanaged[Cdecl]<nint>)vt[957])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr ImGuiWindowSettings()
		{
			ImGuiWindowSettingsPtr ret = ImGuiWindowSettingsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte* GetNameNative(ImGuiWindowSettings* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*, byte*>)vt[958])(self);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[958])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(ImGuiWindowSettingsPtr self)
		{
			byte* ret = GetNameNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(ImGuiWindowSettingsPtr self)
		{
			string ret = Utils.DecodeStringUTF8(GetNameNative(self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				byte* ret = GetNameNative((ImGuiWindowSettings*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetNameNative((ImGuiWindowSettings*)pself));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiSettingsHandler* ImGuiSettingsHandlerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiSettingsHandler*>)vt[959])();
			#else
			return (ImGuiSettingsHandler*)((delegate* unmanaged[Cdecl]<nint>)vt[959])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSettingsHandlerPtr ImGuiSettingsHandler()
		{
			ImGuiSettingsHandlerPtr ret = ImGuiSettingsHandlerNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiDebugAllocInfo* ImGuiDebugAllocInfoNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDebugAllocInfo*>)vt[960])();
			#else
			return (ImGuiDebugAllocInfo*)((delegate* unmanaged[Cdecl]<nint>)vt[960])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDebugAllocInfoPtr ImGuiDebugAllocInfo()
		{
			ImGuiDebugAllocInfoPtr ret = ImGuiDebugAllocInfoNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiStackLevelInfo* ImGuiStackLevelInfoNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStackLevelInfo*>)vt[961])();
			#else
			return (ImGuiStackLevelInfo*)((delegate* unmanaged[Cdecl]<nint>)vt[961])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStackLevelInfoPtr ImGuiStackLevelInfo()
		{
			ImGuiStackLevelInfoPtr ret = ImGuiStackLevelInfoNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiIDStackTool* ImGuiIDStackToolNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiIDStackTool*>)vt[962])();
			#else
			return (ImGuiIDStackTool*)((delegate* unmanaged[Cdecl]<nint>)vt[962])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiIDStackToolPtr ImGuiIDStackTool()
		{
			ImGuiIDStackToolPtr ret = ImGuiIDStackToolNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiContextHook* ImGuiContextHookNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContextHook*>)vt[963])();
			#else
			return (ImGuiContextHook*)((delegate* unmanaged[Cdecl]<nint>)vt[963])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextHookPtr ImGuiContextHook()
		{
			ImGuiContextHookPtr ret = ImGuiContextHookNative();
			return ret;
		}

		/// <summary>
		/// All platforms use Ctrl+Tab but Ctrl&lt;&gt;Super are swapped on Mac...<br/>
		/// FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..<br/>
		/// ConfigNavWindowingKeyNext = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiKey_Tab);<br/>
		/// ConfigNavWindowingKeyPrev = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab);<br/>
		/// NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow =                                                                               ((void *)0)                                                                                  ;<br/>
		/// NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;<br/>
		/// NavWindowingToggleLayer = false;<br/>
		/// NavWindowingToggleKey = ImGuiKey_None;<br/>
		/// DimBgRatio = 0.0f;<br/>
		/// DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;<br/>
		/// DragDropSourceFlags = ImGuiDragDropFlags_None;<br/>
		/// DragDropSourceFrameCount = -1;<br/>
		/// DragDropMouseButton = -1;<br/>
		/// DragDropTargetId = 0;<br/>
		/// DragDropAcceptFlags = ImGuiDragDropFlags_None;<br/>
		/// DragDropAcceptIdCurrRectSurface = 0.0f;<br/>
		/// DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;<br/>
		/// DragDropAcceptFrameCount = -1;<br/>
		/// DragDropHoldJustPressedId = 0;<br/>
		/// memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));<br/>
		/// ClipperTempDataStacked = 0;<br/>
		/// CurrentTable =                       ((void *)0)                          ;<br/>
		/// TablesTempDataStacked = 0;<br/>
		/// CurrentTabBar =                        ((void *)0)                           ;<br/>
		/// CurrentMultiSelect =                             ((void *)0)                                ;<br/>
		/// MultiSelectTempDataStacked = 0;<br/>
		/// HoverItemDelayId = HoverItemDelayIdPreviousFrame = HoverItemUnlockedStationaryId = HoverWindowUnlockedStationaryId = 0;<br/>
		/// HoverItemDelayTimer = HoverItemDelayClearTimer = 0.0f;<br/>
		/// MouseCursor = ImGuiMouseCursor_Arrow;<br/>
		/// MouseStationaryTimer = 0.0f;<br/>
		/// TempInputId = 0;<br/>
		/// memset(&amp;DataTypeZeroValue, 0, sizeof(DataTypeZeroValue));<br/>
		/// BeginMenuDepth = BeginComboDepth = 0;<br/>
		/// ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;<br/>
		/// ColorEditCurrentID = ColorEditSavedID = 0;<br/>
		/// ColorEditSavedHue = ColorEditSavedSat = 0.0f;<br/>
		/// ColorEditSavedColor = 0;<br/>
		/// WindowResizeRelativeMode = false;<br/>
		/// ScrollbarSeekMode = 0;<br/>
		/// ScrollbarClickDeltaToGrabCenter = 0.0f;<br/>
		/// SliderGrabClickOffset = 0.0f;<br/>
		/// SliderCurrentAccum = 0.0f;<br/>
		/// SliderCurrentAccumDirty = false;<br/>
		/// DragCurrentAccumDirty = false;<br/>
		/// DragCurrentAccum = 0.0f;<br/>
		/// DragSpeedDefaultRatio = 1.0f  100.0f;<br/>
		/// DisabledAlphaBackup = 0.0f;<br/>
		/// DisabledStackSize = 0;<br/>
		/// LockMarkEdited = 0;<br/>
		/// TooltipOverrideCount = 0;<br/>
		/// PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);<br/>
		/// PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f);  Different to ensure initial submission<br/>
		/// PlatformImeViewport = 0;<br/>
		/// DockNodeWindowMenuHandler =                                    ((void *)0)                                       ;<br/>
		/// SettingsLoaded = false;<br/>
		/// SettingsDirtyTimer = 0.0f;<br/>
		/// HookIdNext = 0;<br/>
		/// memset(LocalizationTable, 0, sizeof(LocalizationTable));<br/>
		/// LogEnabled = false;<br/>
		/// LogType = ImGuiLogType_None;<br/>
		/// LogNextPrefix = LogNextSuffix =                                        ((void *)0)                                           ;<br/>
		/// LogFile =                  ((void *)0)                     ;<br/>
		/// LogLinePosY = 3.40282346638528859811704183484516925e+38F;<br/>
		/// LogLineFirstItem = false;<br/>
		/// LogDepthRef = 0;<br/>
		/// LogDepthToExpand = LogDepthToExpandDefault = 2;<br/>
		/// DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;<br/>
		/// DebugLocateId = 0;<br/>
		/// DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;<br/>
		/// DebugLogAutoDisableFrames = 0;<br/>
		/// DebugLocateFrames = 0;<br/>
		/// DebugBeginReturnValueCullDepth = -1;<br/>
		/// DebugItemPickerActive = false;<br/>
		/// DebugItemPickerMouseButton = ImGuiMouseButton_Left;<br/>
		/// DebugItemPickerBreakId = 0;<br/>
		/// DebugFlashStyleColorTime = 0.0f;<br/>
		/// DebugFlashStyleColorIdx = ImGuiCol_COUNT;<br/>
		/// DebugHoveredDockNode =                               ((void *)0)                                  ;<br/>
		/// Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations<br/>
		/// DebugBreakInWindow = 0;<br/>
		/// DebugBreakInTable = 0;<br/>
		/// DebugBreakInLocateId = false;<br/>
		/// DebugBreakKeyChord = ImGuiKey_Pause;<br/>
		/// DebugBreakInShortcutRouting = ImGuiKey_None;<br/>
		/// memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));<br/>
		/// FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;<br/>
		/// FramerateSecPerFrameAccum = 0.0f;<br/>
		/// WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;<br/>
		/// memset(TempKeychordName, 0, sizeof(TempKeychordName));<br/>
		/// }<br/>
		/// </summary>
		internal static ImGuiContext* ImGuiContextNative(ImFontAtlas* sharedFontAtlas)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFontAtlas*, ImGuiContext*>)vt[964])(sharedFontAtlas);
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[964])((nint)sharedFontAtlas);
			#endif
		}

		/// <summary>
		/// All platforms use Ctrl+Tab but Ctrl&lt;&gt;Super are swapped on Mac...<br/>
		/// FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..<br/>
		/// ConfigNavWindowingKeyNext = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiKey_Tab);<br/>
		/// ConfigNavWindowingKeyPrev = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab);<br/>
		/// NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow =                                                                               ((void *)0)                                                                                  ;<br/>
		/// NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;<br/>
		/// NavWindowingToggleLayer = false;<br/>
		/// NavWindowingToggleKey = ImGuiKey_None;<br/>
		/// DimBgRatio = 0.0f;<br/>
		/// DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;<br/>
		/// DragDropSourceFlags = ImGuiDragDropFlags_None;<br/>
		/// DragDropSourceFrameCount = -1;<br/>
		/// DragDropMouseButton = -1;<br/>
		/// DragDropTargetId = 0;<br/>
		/// DragDropAcceptFlags = ImGuiDragDropFlags_None;<br/>
		/// DragDropAcceptIdCurrRectSurface = 0.0f;<br/>
		/// DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;<br/>
		/// DragDropAcceptFrameCount = -1;<br/>
		/// DragDropHoldJustPressedId = 0;<br/>
		/// memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));<br/>
		/// ClipperTempDataStacked = 0;<br/>
		/// CurrentTable =                       ((void *)0)                          ;<br/>
		/// TablesTempDataStacked = 0;<br/>
		/// CurrentTabBar =                        ((void *)0)                           ;<br/>
		/// CurrentMultiSelect =                             ((void *)0)                                ;<br/>
		/// MultiSelectTempDataStacked = 0;<br/>
		/// HoverItemDelayId = HoverItemDelayIdPreviousFrame = HoverItemUnlockedStationaryId = HoverWindowUnlockedStationaryId = 0;<br/>
		/// HoverItemDelayTimer = HoverItemDelayClearTimer = 0.0f;<br/>
		/// MouseCursor = ImGuiMouseCursor_Arrow;<br/>
		/// MouseStationaryTimer = 0.0f;<br/>
		/// TempInputId = 0;<br/>
		/// memset(&amp;DataTypeZeroValue, 0, sizeof(DataTypeZeroValue));<br/>
		/// BeginMenuDepth = BeginComboDepth = 0;<br/>
		/// ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;<br/>
		/// ColorEditCurrentID = ColorEditSavedID = 0;<br/>
		/// ColorEditSavedHue = ColorEditSavedSat = 0.0f;<br/>
		/// ColorEditSavedColor = 0;<br/>
		/// WindowResizeRelativeMode = false;<br/>
		/// ScrollbarSeekMode = 0;<br/>
		/// ScrollbarClickDeltaToGrabCenter = 0.0f;<br/>
		/// SliderGrabClickOffset = 0.0f;<br/>
		/// SliderCurrentAccum = 0.0f;<br/>
		/// SliderCurrentAccumDirty = false;<br/>
		/// DragCurrentAccumDirty = false;<br/>
		/// DragCurrentAccum = 0.0f;<br/>
		/// DragSpeedDefaultRatio = 1.0f  100.0f;<br/>
		/// DisabledAlphaBackup = 0.0f;<br/>
		/// DisabledStackSize = 0;<br/>
		/// LockMarkEdited = 0;<br/>
		/// TooltipOverrideCount = 0;<br/>
		/// PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);<br/>
		/// PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f);  Different to ensure initial submission<br/>
		/// PlatformImeViewport = 0;<br/>
		/// DockNodeWindowMenuHandler =                                    ((void *)0)                                       ;<br/>
		/// SettingsLoaded = false;<br/>
		/// SettingsDirtyTimer = 0.0f;<br/>
		/// HookIdNext = 0;<br/>
		/// memset(LocalizationTable, 0, sizeof(LocalizationTable));<br/>
		/// LogEnabled = false;<br/>
		/// LogType = ImGuiLogType_None;<br/>
		/// LogNextPrefix = LogNextSuffix =                                        ((void *)0)                                           ;<br/>
		/// LogFile =                  ((void *)0)                     ;<br/>
		/// LogLinePosY = 3.40282346638528859811704183484516925e+38F;<br/>
		/// LogLineFirstItem = false;<br/>
		/// LogDepthRef = 0;<br/>
		/// LogDepthToExpand = LogDepthToExpandDefault = 2;<br/>
		/// DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;<br/>
		/// DebugLocateId = 0;<br/>
		/// DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;<br/>
		/// DebugLogAutoDisableFrames = 0;<br/>
		/// DebugLocateFrames = 0;<br/>
		/// DebugBeginReturnValueCullDepth = -1;<br/>
		/// DebugItemPickerActive = false;<br/>
		/// DebugItemPickerMouseButton = ImGuiMouseButton_Left;<br/>
		/// DebugItemPickerBreakId = 0;<br/>
		/// DebugFlashStyleColorTime = 0.0f;<br/>
		/// DebugFlashStyleColorIdx = ImGuiCol_COUNT;<br/>
		/// DebugHoveredDockNode =                               ((void *)0)                                  ;<br/>
		/// Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations<br/>
		/// DebugBreakInWindow = 0;<br/>
		/// DebugBreakInTable = 0;<br/>
		/// DebugBreakInLocateId = false;<br/>
		/// DebugBreakKeyChord = ImGuiKey_Pause;<br/>
		/// DebugBreakInShortcutRouting = ImGuiKey_None;<br/>
		/// memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));<br/>
		/// FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;<br/>
		/// FramerateSecPerFrameAccum = 0.0f;<br/>
		/// WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;<br/>
		/// memset(TempKeychordName, 0, sizeof(TempKeychordName));<br/>
		/// }<br/>
		/// </summary>
		public static ImGuiContextPtr ImGuiContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = ImGuiContextNative(sharedFontAtlas);
			return ret;
		}
	}
}
