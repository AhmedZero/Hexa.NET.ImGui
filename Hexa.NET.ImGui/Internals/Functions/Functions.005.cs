// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGuiP
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeepAliveID(uint id)
		{
			KeepAliveIDNative(id);
		}

		/// <summary>
		/// Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MarkItemEditedNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1067])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1067])(id);
			#endif
		}

		/// <summary>
		/// Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.<br/>
		/// </summary>
		public static void MarkItemEdited(uint id)
		{
			MarkItemEditedNative(id);
		}

		/// <summary>
		/// Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushOverrideIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1068])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1068])(id);
			#endif
		}

		/// <summary>
		/// Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)<br/>
		/// </summary>
		public static void PushOverrideID(uint id)
		{
			PushOverrideIDNative(id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDWithSeedNative(byte* strIdBegin, byte* strIdEnd, uint seed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, uint, uint>)funcTable[1069])(strIdBegin, strIdEnd, seed);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint, uint>)funcTable[1069])((nint)strIdBegin, (nint)strIdEnd, seed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(byte* strIdBegin, byte* strIdEnd, uint seed)
		{
			uint ret = GetIDWithSeedNative(strIdBegin, strIdEnd, seed);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ref byte strIdBegin, byte* strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, strIdEnd, seed);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, strIdEnd, seed);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(string strIdBegin, byte* strIdEnd, uint seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDWithSeedNative(pStr0, strIdEnd, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(byte* strIdBegin, ref byte strIdEnd, uint seed)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				uint ret = GetIDWithSeedNative(strIdBegin, (byte*)pstrIdEnd, seed);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd, uint seed)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				uint ret = GetIDWithSeedNative(strIdBegin, (byte*)pstrIdEnd, seed);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(byte* strIdBegin, string strIdEnd, uint seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDWithSeedNative(strIdBegin, pStr0, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ref byte strIdBegin, ref byte strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ReadOnlySpan<byte> strIdBegin, ReadOnlySpan<byte> strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(string strIdBegin, string strIdEnd, uint seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			uint ret = GetIDWithSeedNative(pStr0, pStr1, seed);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDWithSeedNative(int n, uint seed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint, uint>)funcTable[1070])(n, seed);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint, uint>)funcTable[1070])(n, seed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(int n, uint seed)
		{
			uint ret = GetIDWithSeedNative(n, seed);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ItemSizeNative(Vector2 size, float textBaselineY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, float, void>)funcTable[1071])(size, textBaselineY);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, float, void>)funcTable[1071])(size, textBaselineY);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemSize(Vector2 size, float textBaselineY)
		{
			ItemSizeNative(size, textBaselineY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemSize(Vector2 size)
		{
			ItemSizeNative(size, (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ItemSizeNative(ImRect bb, float textBaselineY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect, float, void>)funcTable[1072])(bb, textBaselineY);
			#else
			((delegate* unmanaged[Cdecl]<ImRect, float, void>)funcTable[1072])(bb, textBaselineY);
			#endif
		}

		/// <summary>
		/// FIXME: This is a misleading API since we expect CursorPos to be bb.Min.<br/>
		/// </summary>
		public static void ItemSize(ImRect bb, float textBaselineY)
		{
			ItemSizeNative(bb, textBaselineY);
		}

		/// <summary>
		/// FIXME: This is a misleading API since we expect CursorPos to be bb.Min.<br/>
		/// </summary>
		public static void ItemSize(ImRect bb)
		{
			ItemSizeNative(bb, (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ItemAddNative(ImRect bb, uint id, ImRect* navBb, ImGuiItemFlags extraFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, uint, ImRect*, ImGuiItemFlags, byte>)funcTable[1073])(bb, id, navBb, extraFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, uint, nint, ImGuiItemFlags, byte>)funcTable[1073])(bb, id, (nint)navBb, extraFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ImRectPtr navBb, ImGuiItemFlags extraFlags)
		{
			byte ret = ItemAddNative(bb, id, navBb, extraFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ImRectPtr navBb)
		{
			byte ret = ItemAddNative(bb, id, navBb, (ImGuiItemFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id)
		{
			byte ret = ItemAddNative(bb, id, (ImRect*)(default), (ImGuiItemFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ImGuiItemFlags extraFlags)
		{
			byte ret = ItemAddNative(bb, id, (ImRect*)(default), extraFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ref ImRect navBb, ImGuiItemFlags extraFlags)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				byte ret = ItemAddNative(bb, id, (ImRect*)pnavBb, extraFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ref ImRect navBb)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				byte ret = ItemAddNative(bb, id, (ImRect*)pnavBb, (ImGuiItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ItemHoverableNative(ImRect bb, uint id, ImGuiItemFlags itemFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, uint, ImGuiItemFlags, byte>)funcTable[1074])(bb, id, itemFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, uint, ImGuiItemFlags, byte>)funcTable[1074])(bb, id, itemFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemHoverable(ImRect bb, uint id, ImGuiItemFlags itemFlags)
		{
			byte ret = ItemHoverableNative(bb, id, itemFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowContentHoverableNative(ImGuiWindow* window, ImGuiHoveredFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiHoveredFlags, byte>)funcTable[1075])(window, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiHoveredFlags, byte>)funcTable[1075])((nint)window, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowContentHoverable(ImGuiWindowPtr window, ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowContentHoverableNative(window, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowContentHoverable(ImGuiWindowPtr window)
		{
			byte ret = IsWindowContentHoverableNative(window, (ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowContentHoverable(ref ImGuiWindow window, ImGuiHoveredFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowContentHoverableNative((ImGuiWindow*)pwindow, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowContentHoverable(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowContentHoverableNative((ImGuiWindow*)pwindow, (ImGuiHoveredFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsClippedExNative(ImRect bb, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, uint, byte>)funcTable[1076])(bb, id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, uint, byte>)funcTable[1076])(bb, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsClippedEx(ImRect bb, uint id)
		{
			byte ret = IsClippedExNative(bb, id);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetLastItemDataNative(uint itemId, ImGuiItemFlags inFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ImGuiItemFlags, ImGuiItemStatusFlags, ImRect, void>)funcTable[1077])(itemId, inFlags, statusFlags, itemRect);
			#else
			((delegate* unmanaged[Cdecl]<uint, ImGuiItemFlags, ImGuiItemStatusFlags, ImRect, void>)funcTable[1077])(itemId, inFlags, statusFlags, itemRect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetLastItemData(uint itemId, ImGuiItemFlags inFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect)
		{
			SetLastItemDataNative(itemId, inFlags, statusFlags, itemRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcItemSizeNative(Vector2* pOut, Vector2 size, float defaultW, float defaultH)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, float, float, void>)funcTable[1078])(pOut, size, defaultW, defaultH);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, float, float, void>)funcTable[1078])((nint)pOut, size, defaultW, defaultH);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcItemSize(Vector2 size, float defaultW, float defaultH)
		{
			Vector2 ret;
			CalcItemSizeNative(&ret, size, defaultW, defaultH);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcItemSize(Vector2* pOut, Vector2 size, float defaultW, float defaultH)
		{
			CalcItemSizeNative(pOut, size, defaultW, defaultH);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcItemSize(ref Vector2 pOut, Vector2 size, float defaultW, float defaultH)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcItemSizeNative((Vector2*)ppOut, size, defaultW, defaultH);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CalcWrapWidthForPosNative(Vector2 pos, float wrapPosX)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, float, float>)funcTable[1079])(pos, wrapPosX);
			#else
			return (float)((delegate* unmanaged[Cdecl]<Vector2, float, float>)funcTable[1079])(pos, wrapPosX);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float CalcWrapWidthForPos(Vector2 pos, float wrapPosX)
		{
			float ret = CalcWrapWidthForPosNative(pos, wrapPosX);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushMultiItemsWidthsNative(int components, float widthFull)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[1080])(components, widthFull);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[1080])(components, widthFull);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushMultiItemsWidths(int components, float widthFull)
		{
			PushMultiItemsWidthsNative(components, widthFull);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShrinkWidthsNative(ImGuiShrinkWidthItem* items, int count, float widthExcess)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiShrinkWidthItem*, int, float, void>)funcTable[1081])(items, count, widthExcess);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, void>)funcTable[1081])((nint)items, count, widthExcess);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShrinkWidths(ImGuiShrinkWidthItemPtr items, int count, float widthExcess)
		{
			ShrinkWidthsNative(items, count, widthExcess);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShrinkWidths(ref ImGuiShrinkWidthItem items, int count, float widthExcess)
		{
			fixed (ImGuiShrinkWidthItem* pitems = &items)
			{
				ShrinkWidthsNative((ImGuiShrinkWidthItem*)pitems, count, widthExcess);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDataVarInfo* GetStyleVarInfoNative(ImGuiStyleVar idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, ImGuiDataVarInfo*>)funcTable[1082])(idx);
			#else
			return (ImGuiDataVarInfo*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, nint>)funcTable[1082])(idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDataVarInfoPtr GetStyleVarInfo(ImGuiStyleVar idx)
		{
			ImGuiDataVarInfoPtr ret = GetStyleVarInfoNative(idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginDisabledOverrideReenableNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1083])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1083])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDisabledOverrideReenable()
		{
			BeginDisabledOverrideReenableNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndDisabledOverrideReenableNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1084])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1084])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndDisabledOverrideReenable()
		{
			EndDisabledOverrideReenableNative();
		}

		/// <summary>
		/// -&gt; BeginCapture() when we design v2 api, for now stay under the radar by using the old name.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogBeginNative(ImGuiLogType type, int autoOpenDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiLogType, int, void>)funcTable[1085])(type, autoOpenDepth);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiLogType, int, void>)funcTable[1085])(type, autoOpenDepth);
			#endif
		}

		/// <summary>
		/// -&gt; BeginCapture() when we design v2 api, for now stay under the radar by using the old name.<br/>
		/// </summary>
		public static void LogBegin(ImGuiLogType type, int autoOpenDepth)
		{
			LogBeginNative(type, autoOpenDepth);
		}

		/// <summary>
		/// Start loggingcapturing to internal buffer<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogToBufferNative(int autoOpenDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1086])(autoOpenDepth);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1086])(autoOpenDepth);
			#endif
		}

		/// <summary>
		/// Start loggingcapturing to internal buffer<br/>
		/// </summary>
		public static void LogToBuffer(int autoOpenDepth)
		{
			LogToBufferNative(autoOpenDepth);
		}

		/// <summary>
		/// Start loggingcapturing to internal buffer<br/>
		/// </summary>
		public static void LogToBuffer()
		{
			LogToBufferNative((int)(-1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogRenderedTextNative(Vector2* refPos, byte* text, byte* textEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, byte*, byte*, void>)funcTable[1087])(refPos, text, textEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1087])((nint)refPos, (nint)text, (nint)textEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text, byte* textEnd)
		{
			LogRenderedTextNative(refPos, text, textEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text)
		{
			LogRenderedTextNative(refPos, text, (byte*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				LogRenderedTextNative((Vector2*)prefPos, text, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				LogRenderedTextNative((Vector2*)prefPos, text, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (byte* ptext = text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ref byte text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ref byte text)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ReadOnlySpan<byte> text)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, string text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, string text)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				LogRenderedTextNative(refPos, text, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				LogRenderedTextNative(refPos, text, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative((Vector2*)prefPos, text, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					LogRenderedTextNative((Vector2*)prefPos, text, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					LogRenderedTextNative(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ref byte text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, string text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogSetNextTextDecorationNative(byte* prefix, byte* suffix)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)funcTable[1088])(prefix, suffix);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1088])((nint)prefix, (nint)suffix);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(byte* prefix, byte* suffix)
		{
			LogSetNextTextDecorationNative(prefix, suffix);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(ref byte prefix, byte* suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				LogSetNextTextDecorationNative((byte*)pprefix, suffix);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(ReadOnlySpan<byte> prefix, byte* suffix)
		{
			fixed (byte* pprefix = prefix)
			{
				LogSetNextTextDecorationNative((byte*)pprefix, suffix);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(string prefix, byte* suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogSetNextTextDecorationNative(pStr0, suffix);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(byte* prefix, ref byte suffix)
		{
			fixed (byte* psuffix = &suffix)
			{
				LogSetNextTextDecorationNative(prefix, (byte*)psuffix);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(byte* prefix, ReadOnlySpan<byte> suffix)
		{
			fixed (byte* psuffix = suffix)
			{
				LogSetNextTextDecorationNative(prefix, (byte*)psuffix);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(byte* prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (suffix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogSetNextTextDecorationNative(prefix, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(ref byte prefix, ref byte suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* psuffix = &suffix)
				{
					LogSetNextTextDecorationNative((byte*)pprefix, (byte*)psuffix);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(ReadOnlySpan<byte> prefix, ReadOnlySpan<byte> suffix)
		{
			fixed (byte* pprefix = prefix)
			{
				fixed (byte* psuffix = suffix)
				{
					LogSetNextTextDecorationNative((byte*)pprefix, (byte*)psuffix);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogSetNextTextDecoration(string prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (suffix != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(suffix, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogSetNextTextDecorationNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginChildExNative(byte* name, uint id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)funcTable[1089])(name, id, sizeArg, childFlags, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)funcTable[1089])((nint)name, id, sizeArg, childFlags, windowFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChildEx(byte* name, uint id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildExNative(name, id, sizeArg, childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChildEx(ref byte name, uint id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginChildExNative((byte*)pname, id, sizeArg, childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChildEx(ReadOnlySpan<byte> name, uint id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginChildExNative((byte*)pname, id, sizeArg, childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChildEx(string name, uint id, Vector2 sizeArg, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildExNative(pStr0, id, sizeArg, childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginPopupExNative(uint id, ImGuiWindowFlags extraWindowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiWindowFlags, byte>)funcTable[1090])(id, extraWindowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, ImGuiWindowFlags, byte>)funcTable[1090])(id, extraWindowFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginPopupEx(uint id, ImGuiWindowFlags extraWindowFlags)
		{
			byte ret = BeginPopupExNative(id, extraWindowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OpenPopupExNative(uint id, ImGuiPopupFlags popupFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ImGuiPopupFlags, void>)funcTable[1091])(id, popupFlags);
			#else
			((delegate* unmanaged[Cdecl]<uint, ImGuiPopupFlags, void>)funcTable[1091])(id, popupFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OpenPopupEx(uint id, ImGuiPopupFlags popupFlags)
		{
			OpenPopupExNative(id, popupFlags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OpenPopupEx(uint id)
		{
			OpenPopupExNative(id, (ImGuiPopupFlags)(ImGuiPopupFlags.None));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClosePopupToLevelNative(int remaining, byte restoreFocusToWindowUnderPopup)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte, void>)funcTable[1092])(remaining, restoreFocusToWindowUnderPopup);
			#else
			((delegate* unmanaged[Cdecl]<int, byte, void>)funcTable[1092])(remaining, restoreFocusToWindowUnderPopup);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClosePopupToLevel(int remaining, bool restoreFocusToWindowUnderPopup)
		{
			ClosePopupToLevelNative(remaining, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClosePopupsOverWindowNative(ImGuiWindow* refWindow, byte restoreFocusToWindowUnderPopup)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte, void>)funcTable[1093])(refWindow, restoreFocusToWindowUnderPopup);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[1093])((nint)refWindow, restoreFocusToWindowUnderPopup);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClosePopupsOverWindow(ImGuiWindowPtr refWindow, bool restoreFocusToWindowUnderPopup)
		{
			ClosePopupsOverWindowNative(refWindow, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClosePopupsOverWindow(ref ImGuiWindow refWindow, bool restoreFocusToWindowUnderPopup)
		{
			fixed (ImGuiWindow* prefWindow = &refWindow)
			{
				ClosePopupsOverWindowNative((ImGuiWindow*)prefWindow, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClosePopupsExceptModalsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1094])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1094])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClosePopupsExceptModals()
		{
			ClosePopupsExceptModalsNative();
		}

		/// <summary>
		/// return true if the popup is open.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPopupOpenNative(uint id, ImGuiPopupFlags popupFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiPopupFlags, byte>)funcTable[1095])(id, popupFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, ImGuiPopupFlags, byte>)funcTable[1095])(id, popupFlags);
			#endif
		}

		/// <summary>
		/// return true if the popup is open.<br/>
		/// </summary>
		public static bool IsPopupOpen(uint id, ImGuiPopupFlags popupFlags)
		{
			byte ret = IsPopupOpenNative(id, popupFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPopupAllowedExtentRectNative(ImRect* pOut, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, void>)funcTable[1096])(pOut, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1096])((nint)pOut, (nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetPopupAllowedExtentRect(ImGuiWindowPtr window)
		{
			ImRect ret;
			GetPopupAllowedExtentRectNative(&ret, window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetPopupAllowedExtentRect(ImRectPtr pOut, ImGuiWindowPtr window)
		{
			GetPopupAllowedExtentRectNative(pOut, window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetPopupAllowedExtentRect(ref ImRect pOut, ImGuiWindowPtr window)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetPopupAllowedExtentRectNative((ImRect*)ppOut, window);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetPopupAllowedExtentRect(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				GetPopupAllowedExtentRectNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetPopupAllowedExtentRect(ImRectPtr pOut, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				GetPopupAllowedExtentRectNative(pOut, (ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetPopupAllowedExtentRect(ref ImRect pOut, ref ImGuiWindow window)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					GetPopupAllowedExtentRectNative((ImRect*)ppOut, (ImGuiWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* GetTopMostPopupModalNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*>)funcTable[1097])();
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1097])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr GetTopMostPopupModal()
		{
			ImGuiWindowPtr ret = GetTopMostPopupModalNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* GetTopMostAndVisiblePopupModalNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*>)funcTable[1098])();
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1098])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr GetTopMostAndVisiblePopupModal()
		{
			ImGuiWindowPtr ret = GetTopMostAndVisiblePopupModalNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* FindBlockingModalNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*>)funcTable[1099])(window);
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1099])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindBlockingModal(ImGuiWindowPtr window)
		{
			ImGuiWindowPtr ret = FindBlockingModalNative(window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindBlockingModal(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowPtr ret = FindBlockingModalNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FindBestWindowPosForPopupNative(Vector2* pOut, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiWindow*, void>)funcTable[1100])(pOut, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1100])((nint)pOut, (nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 FindBestWindowPosForPopup(ImGuiWindowPtr window)
		{
			Vector2 ret;
			FindBestWindowPosForPopupNative(&ret, window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindBestWindowPosForPopup(Vector2* pOut, ImGuiWindowPtr window)
		{
			FindBestWindowPosForPopupNative(pOut, window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindBestWindowPosForPopup(ref Vector2 pOut, ImGuiWindowPtr window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				FindBestWindowPosForPopupNative((Vector2*)ppOut, window);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 FindBestWindowPosForPopup(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				FindBestWindowPosForPopupNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindBestWindowPosForPopup(Vector2* pOut, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				FindBestWindowPosForPopupNative(pOut, (ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindBestWindowPosForPopup(ref Vector2 pOut, ref ImGuiWindow window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					FindBestWindowPosForPopupNative((Vector2*)ppOut, (ImGuiWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FindBestWindowPosForPopupExNative(Vector2* pOut, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, ImGuiDir*, ImRect, ImRect, ImGuiPopupPositionPolicy, void>)funcTable[1101])(pOut, refPos, size, lastDir, rOuter, rAvoid, policy);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, nint, ImRect, ImRect, ImGuiPopupPositionPolicy, void>)funcTable[1101])((nint)pOut, refPos, size, (nint)lastDir, rOuter, rAvoid, policy);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 FindBestWindowPosForPopupEx(Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			Vector2 ret;
			FindBestWindowPosForPopupExNative(&ret, refPos, size, lastDir, rOuter, rAvoid, policy);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindBestWindowPosForPopupEx(Vector2* pOut, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			FindBestWindowPosForPopupExNative(pOut, refPos, size, lastDir, rOuter, rAvoid, policy);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindBestWindowPosForPopupEx(ref Vector2 pOut, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				FindBestWindowPosForPopupExNative((Vector2*)ppOut, refPos, size, lastDir, rOuter, rAvoid, policy);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 FindBestWindowPosForPopupEx(Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (ImGuiDir* plastDir = &lastDir)
			{
				Vector2 ret;
				FindBestWindowPosForPopupExNative(&ret, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindBestWindowPosForPopupEx(Vector2* pOut, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (ImGuiDir* plastDir = &lastDir)
			{
				FindBestWindowPosForPopupExNative(pOut, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindBestWindowPosForPopupEx(ref Vector2 pOut, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiDir* plastDir = &lastDir)
				{
					FindBestWindowPosForPopupExNative((Vector2*)ppOut, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginTooltipExNative(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTooltipFlags, ImGuiWindowFlags, byte>)funcTable[1102])(tooltipFlags, extraWindowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiTooltipFlags, ImGuiWindowFlags, byte>)funcTable[1102])(tooltipFlags, extraWindowFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTooltipEx(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags)
		{
			byte ret = BeginTooltipExNative(tooltipFlags, extraWindowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginTooltipHiddenNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1103])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1103])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTooltipHidden()
		{
			byte ret = BeginTooltipHiddenNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginViewportSideBarNative(byte* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiViewport*, ImGuiDir, float, ImGuiWindowFlags, byte>)funcTable[1104])(name, viewport, dir, size, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ImGuiDir, float, ImGuiWindowFlags, byte>)funcTable[1104])((nint)name, (nint)viewport, dir, size, windowFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginViewportSideBar(byte* name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginViewportSideBarNative(name, viewport, dir, size, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginViewportSideBar(ref byte name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginViewportSideBarNative((byte*)pname, viewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginViewportSideBar(ReadOnlySpan<byte> name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginViewportSideBarNative((byte*)pname, viewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginViewportSideBar(string name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginViewportSideBarNative(pStr0, viewport, dir, size, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginViewportSideBar(byte* name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = BeginViewportSideBarNative(name, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginViewportSideBar(ref byte name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					byte ret = BeginViewportSideBarNative((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginViewportSideBar(ReadOnlySpan<byte> name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					byte ret = BeginViewportSideBarNative((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginViewportSideBar(string name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = BeginViewportSideBarNative(pStr0, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginMenuExNative(byte* label, byte* icon, byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte, byte>)funcTable[1105])(label, icon, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte>)funcTable[1105])((nint)label, (nint)icon, enabled);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(byte* label, byte* icon, bool enabled)
		{
			byte ret = BeginMenuExNative(label, icon, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(byte* label, byte* icon)
		{
			byte ret = BeginMenuExNative(label, icon, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(ref byte label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginMenuExNative((byte*)plabel, icon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(ref byte label, byte* icon)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginMenuExNative((byte*)plabel, icon, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginMenuExNative((byte*)plabel, icon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, byte* icon)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginMenuExNative((byte*)plabel, icon, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(string label, byte* icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, icon, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(string label, byte* icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, icon, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(byte* label, ref byte icon, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = BeginMenuExNative(label, (byte*)picon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(byte* label, ref byte icon)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = BeginMenuExNative(label, (byte*)picon, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(byte* label, ReadOnlySpan<byte> icon, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte ret = BeginMenuExNative(label, (byte*)picon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(byte* label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* picon = icon)
			{
				byte ret = BeginMenuExNative(label, (byte*)picon, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(byte* label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(label, pStr0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(byte* label, string icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(label, pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(ref byte label, ref byte icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = BeginMenuExNative((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(ref byte label, ref byte icon)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = BeginMenuExNative((byte*)plabel, (byte*)picon, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = BeginMenuExNative((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = BeginMenuExNative((byte*)plabel, (byte*)picon, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(string label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, pStr1, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginMenuEx(string label, string icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, pStr1, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MenuItemExNative(byte* label, byte* icon, byte* shortcut, byte selected, byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, byte, byte, byte>)funcTable[1106])(label, icon, shortcut, selected, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, byte, byte>)funcTable[1106])((nint)label, (nint)icon, (nint)shortcut, selected, enabled);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte ret = MenuItemExNative(label, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut, bool selected)
		{
			byte ret = MenuItemExNative(label, icon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut)
		{
			byte ret = MenuItemExNative(label, icon, shortcut, (byte)(0), (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon)
		{
			byte ret = MenuItemExNative(label, icon, (byte*)(default), (byte)(0), (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, bool selected)
		{
			byte ret = MenuItemExNative(label, icon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, bool selected, bool enabled)
		{
			byte ret = MenuItemExNative(label, icon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, byte* shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon)
		{
			fixed (byte* plabel = label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, shortcut, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, (byte*)(default), (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut, bool selected)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon, bool selected)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected)
		{
			fixed (byte* picon = icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, byte* shortcut)
		{
			fixed (byte* picon = icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* picon = icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, bool selected)
		{
			fixed (byte* picon = icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, shortcut, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, (byte*)(default), (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, byte* shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, shortcut, (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, (byte*)(default), (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut, bool selected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, icon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, icon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, byte* icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, icon, pStr0, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, byte* icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, pStr1, (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut, bool selected)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(byte* label, string icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, pStr1, (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, pStr2, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, pStr2, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MenuItemEx(string label, string icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, pStr2, (byte)(0), (byte)(1));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginComboPopupNative(uint popupId, ImRect bb, ImGuiComboFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImRect, ImGuiComboFlags, byte>)funcTable[1107])(popupId, bb, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, ImRect, ImGuiComboFlags, byte>)funcTable[1107])(popupId, bb, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginComboPopup(uint popupId, ImRect bb, ImGuiComboFlags flags)
		{
			byte ret = BeginComboPopupNative(popupId, bb, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginComboPreviewNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1108])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1108])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginComboPreview()
		{
			byte ret = BeginComboPreviewNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndComboPreviewNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1109])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1109])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndComboPreview()
		{
			EndComboPreviewNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NavInitWindowNative(ImGuiWindow* window, byte forceReinit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte, void>)funcTable[1110])(window, forceReinit);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[1110])((nint)window, forceReinit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NavInitWindow(ImGuiWindowPtr window, bool forceReinit)
		{
			NavInitWindowNative(window, forceReinit ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NavInitWindow(ref ImGuiWindow window, bool forceReinit)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavInitWindowNative((ImGuiWindow*)pwindow, forceReinit ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NavInitRequestApplyResultNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1111])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1111])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NavInitRequestApplyResult()
		{
			NavInitRequestApplyResultNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte NavMoveRequestButNoResultYetNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1112])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1112])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool NavMoveRequestButNoResultYet()
		{
			byte ret = NavMoveRequestButNoResultYetNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NavMoveRequestSubmitNative(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDir, ImGuiDir, ImGuiNavMoveFlags, ImGuiScrollFlags, void>)funcTable[1113])(moveDir, clipDir, moveFlags, scrollFlags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiDir, ImGuiDir, ImGuiNavMoveFlags, ImGuiScrollFlags, void>)funcTable[1113])(moveDir, clipDir, moveFlags, scrollFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NavMoveRequestSubmit(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			NavMoveRequestSubmitNative(moveDir, clipDir, moveFlags, scrollFlags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NavMoveRequestForwardNative(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDir, ImGuiDir, ImGuiNavMoveFlags, ImGuiScrollFlags, void>)funcTable[1114])(moveDir, clipDir, moveFlags, scrollFlags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiDir, ImGuiDir, ImGuiNavMoveFlags, ImGuiScrollFlags, void>)funcTable[1114])(moveDir, clipDir, moveFlags, scrollFlags);
			#endif
		}
	}
}
