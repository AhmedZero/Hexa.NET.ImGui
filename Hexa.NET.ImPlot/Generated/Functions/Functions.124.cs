// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImPlot
{
	public unsafe partial class ImPlot
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, ref byte format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, output, (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, ref byte format)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref byte format)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref byte format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, output, (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, ReadOnlySpan<byte> format)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ReadOnlySpan<byte> format)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, string format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, (float*)pt, output, pStr0, cmap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, Vector4* output, string format)
		{
			fixed (float* pt = &t)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, (float*)pt, output, pStr0, (ImPlotColormap)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, string format)
		{
			fixed (float* pt = &t)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), pStr0, (ImPlotColormap)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, string format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)(default), pStr0, cmap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ref byte label, ref float t, Vector4* output, ref byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ref byte label, ref float t, Vector4* output, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ref byte label, ref float t, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ref byte label, ref float t, ref byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, Vector4* output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, Vector4* output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, output, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)(default), (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, Vector4* output, string format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, (float*)pt, output, pStr1, cmap);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, Vector4* output, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, (float*)pt, output, pStr1, (ImPlotColormap)(-1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)(default), pStr1, (ImPlotColormap)(-1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, string format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)(default), pStr1, cmap);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, ref byte format, ImPlotColormap cmap)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, ref byte format)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, (byte*)pformat, cmap);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			fixed (Vector4* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, pStr0, cmap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, float* t, ref Vector4 output, string format)
		{
			fixed (Vector4* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ColormapSliderNative(label, t, (Vector4*)poutput, pStr0, (ImPlotColormap)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ref byte label, float* t, ref Vector4 output, ref byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ref byte label, float* t, ref Vector4 output, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, float* t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, float* t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative((byte*)plabel, t, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, float* t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* poutput = &output)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, t, (Vector4*)poutput, pStr1, cmap);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, float* t, ref Vector4 output, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* poutput = &output)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ColormapSliderNative(pStr0, t, (Vector4*)poutput, pStr1, (ImPlotColormap)(-1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, ref byte format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, ref byte format)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					fixed (byte* pformat = format)
					{
						byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, pStr0, cmap);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(byte* label, ref float t, ref Vector4 output, string format)
		{
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ColormapSliderNative(label, (float*)pt, (Vector4*)poutput, pStr0, (ImPlotColormap)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ref byte label, ref float t, ref Vector4 output, ref byte format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ref byte label, ref float t, ref Vector4 output, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, cmap);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(ReadOnlySpan<byte> label, ref float t, ref Vector4 output, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pt = &t)
				{
					fixed (Vector4* poutput = &output)
					{
						fixed (byte* pformat = format)
						{
							byte ret = ColormapSliderNative((byte*)plabel, (float*)pt, (Vector4*)poutput, (byte*)pformat, (ImPlotColormap)(-1));
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ref Vector4 output, string format, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)poutput, pStr1, cmap);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapSlider(string label, ref float t, ref Vector4 output, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pt = &t)
			{
				fixed (Vector4* poutput = &output)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = ColormapSliderNative(pStr0, (float*)pt, (Vector4*)poutput, pStr1, (ImPlotColormap)(-1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ColormapButtonNative(byte* label, Vector2 size, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Vector2, ImPlotColormap, byte>)vt[346])(label, size, cmap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, ImPlotColormap, byte>)vt[346])((nint)label, size, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(byte* label, Vector2 size, ImPlotColormap cmap)
		{
			byte ret = ColormapButtonNative(label, size, cmap);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(byte* label, Vector2 size)
		{
			byte ret = ColormapButtonNative(label, size, (ImPlotColormap)(-1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(byte* label)
		{
			byte ret = ColormapButtonNative(label, (Vector2)(new Vector2(0,0)), (ImPlotColormap)(-1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(byte* label, ImPlotColormap cmap)
		{
			byte ret = ColormapButtonNative(label, (Vector2)(new Vector2(0,0)), cmap);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ref byte label, Vector2 size, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, size, cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, size, (ImPlotColormap)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)), (ImPlotColormap)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ref byte label, ImPlotColormap cmap)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)), cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ReadOnlySpan<byte> label, Vector2 size, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, size, cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ReadOnlySpan<byte> label, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, size, (ImPlotColormap)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)), (ImPlotColormap)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(ReadOnlySpan<byte> label, ImPlotColormap cmap)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColormapButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)), cmap);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(string label, Vector2 size, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColormapButtonNative(pStr0, size, cmap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColormapButtonNative(pStr0, size, (ImPlotColormap)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColormapButtonNative(pStr0, (Vector2)(new Vector2(0,0)), (ImPlotColormap)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ColormapButton(string label, ImPlotColormap cmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColormapButtonNative(pStr0, (Vector2)(new Vector2(0,0)), cmap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void BustColorCacheNative(byte* plotTitleId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[347])(plotTitleId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[347])((nint)plotTitleId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache(byte* plotTitleId)
		{
			BustColorCacheNative(plotTitleId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache()
		{
			BustColorCacheNative((byte*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache(ref byte plotTitleId)
		{
			fixed (byte* pplotTitleId = &plotTitleId)
			{
				BustColorCacheNative((byte*)pplotTitleId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache(ReadOnlySpan<byte> plotTitleId)
		{
			fixed (byte* pplotTitleId = plotTitleId)
			{
				BustColorCacheNative((byte*)pplotTitleId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BustColorCache(string plotTitleId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (plotTitleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(plotTitleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(plotTitleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BustColorCacheNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImPlotInputMap* GetInputMapNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotInputMap*>)vt[348])();
			#else
			return (ImPlotInputMap*)((delegate* unmanaged[Cdecl]<nint>)vt[348])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotInputMapPtr GetInputMap()
		{
			ImPlotInputMapPtr ret = GetInputMapNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MapInputDefaultNative(ImPlotInputMap* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotInputMap*, void>)vt[349])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[349])((nint)dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputDefault(ImPlotInputMapPtr dst)
		{
			MapInputDefaultNative(dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputDefault()
		{
			MapInputDefaultNative((ImPlotInputMap*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputDefault(ref ImPlotInputMap dst)
		{
			fixed (ImPlotInputMap* pdst = &dst)
			{
				MapInputDefaultNative((ImPlotInputMap*)pdst);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MapInputReverseNative(ImPlotInputMap* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotInputMap*, void>)vt[350])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[350])((nint)dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputReverse(ImPlotInputMapPtr dst)
		{
			MapInputReverseNative(dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputReverse()
		{
			MapInputReverseNative((ImPlotInputMap*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MapInputReverse(ref ImPlotInputMap dst)
		{
			fixed (ImPlotInputMap* pdst = &dst)
			{
				MapInputReverseNative((ImPlotInputMap*)pdst);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ItemIconNative(Vector4 col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4, void>)vt[351])(col);
			#else
			((delegate* unmanaged[Cdecl]<Vector4, void>)vt[351])(col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemIcon(Vector4 col)
		{
			ItemIconNative(col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ItemIconNative(uint col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)vt[352])(col);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)vt[352])(col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemIcon(uint col)
		{
			ItemIconNative(col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ColormapIconNative(ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotColormap, void>)vt[353])(cmap);
			#else
			((delegate* unmanaged[Cdecl]<ImPlotColormap, void>)vt[353])(cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColormapIcon(ImPlotColormap cmap)
		{
			ColormapIconNative(cmap);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImDrawList* GetPlotDrawListNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawList*>)vt[354])();
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint>)vt[354])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawList* GetPlotDrawList()
		{
			ImDrawList* ret = GetPlotDrawListNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PushPlotClipRectNative(float expand)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[355])(expand);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[355])(expand);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushPlotClipRect(float expand)
		{
			PushPlotClipRectNative(expand);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushPlotClipRect()
		{
			PushPlotClipRectNative((float)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopPlotClipRectNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[356])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[356])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopPlotClipRect()
		{
			PopPlotClipRectNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ShowStyleSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)vt[357])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[357])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(byte* label)
		{
			byte ret = ShowStyleSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowStyleSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ShowColormapSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)vt[358])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[358])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowColormapSelector(byte* label)
		{
			byte ret = ShowColormapSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowColormapSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowColormapSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowColormapSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowColormapSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowColormapSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowColormapSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ShowInputMapSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)vt[359])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[359])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowInputMapSelector(byte* label)
		{
			byte ret = ShowInputMapSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowInputMapSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowInputMapSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowInputMapSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowInputMapSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowInputMapSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowInputMapSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ShowStyleEditorNative(ImPlotStyle* reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotStyle*, void>)vt[360])(reference);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[360])((nint)reference);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor(ImPlotStylePtr reference)
		{
			ShowStyleEditorNative(reference);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor()
		{
			ShowStyleEditorNative((ImPlotStyle*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor(ref ImPlotStyle reference)
		{
			fixed (ImPlotStyle* preference = &reference)
			{
				ShowStyleEditorNative((ImPlotStyle*)preference);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ShowUserGuideNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[361])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[361])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowUserGuide()
		{
			ShowUserGuideNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ShowMetricsWindowNative(bool* pPopen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[362])(pPopen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[362])((nint)pPopen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow(bool* pPopen)
		{
			ShowMetricsWindowNative(pPopen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow()
		{
			ShowMetricsWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow(ref bool pPopen)
		{
			fixed (bool* ppPopen = &pPopen)
			{
				ShowMetricsWindowNative((bool*)ppPopen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ShowDemoWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[363])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[363])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow(bool* pOpen)
		{
			ShowDemoWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow()
		{
			ShowDemoWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDemoWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float ImLog10FloatNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)vt[364])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)vt[364])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImLog10Float(float x)
		{
			float ret = ImLog10FloatNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImLog10DoubleNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)vt[365])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)vt[365])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImLog10Double(double x)
		{
			double ret = ImLog10DoubleNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float ImSinhFloatNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)vt[366])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)vt[366])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImSinhFloat(float x)
		{
			float ret = ImSinhFloatNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImSinhDoubleNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)vt[367])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)vt[367])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImSinhDouble(double x)
		{
			double ret = ImSinhDoubleNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float ImAsinhFloatNative(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)vt[368])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)vt[368])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImAsinhFloat(float x)
		{
			float ret = ImAsinhFloatNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImAsinhDoubleNative(double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)vt[369])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)vt[369])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImAsinhDouble(double x)
		{
			double ret = ImAsinhDoubleNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float ImRemapFloatNative(float x, float x0, float x1, float y0, float y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, float, float>)vt[370])(x, x0, x1, y0, y1);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float, float, float, float>)vt[370])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImRemapFloat(float x, float x0, float x1, float y0, float y1)
		{
			float ret = ImRemapFloatNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImRemapDoubleNative(double x, double x0, double x1, double y0, double y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double, double, double, double>)vt[371])(x, x0, x1, y0, y1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double, double, double, double>)vt[371])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImRemapDouble(double x, double x0, double x1, double y0, double y1)
		{
			double ret = ImRemapDoubleNative(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImRemapS8Native(byte x, byte x0, byte x1, byte y0, byte y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, byte, byte>)vt[372])(x, x0, x1, y0, y1);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, byte, byte>)vt[372])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImRemapS8(byte x, byte x0, byte x1, byte y0, byte y1)
		{
			byte ret = ImRemapS8Native(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImRemapU8Native(byte x, byte x0, byte x1, byte y0, byte y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, byte, byte>)vt[373])(x, x0, x1, y0, y1);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, byte, byte>)vt[373])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImRemapU8(byte x, byte x0, byte x1, byte y0, byte y1)
		{
			byte ret = ImRemapU8Native(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static short ImRemapS16Native(short x, short x0, short x1, short y0, short y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short, short, short, short, short, short>)vt[374])(x, x0, x1, y0, y1);
			#else
			return (short)((delegate* unmanaged[Cdecl]<short, short, short, short, short, short>)vt[374])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImRemapS16(short x, short x0, short x1, short y0, short y1)
		{
			short ret = ImRemapS16Native(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ushort ImRemapU16Native(ushort x, ushort x0, ushort x1, ushort y0, ushort y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort, ushort, ushort>)vt[375])(x, x0, x1, y0, y1);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort, ushort, ushort>)vt[375])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImRemapU16(ushort x, ushort x0, ushort x1, ushort y0, ushort y1)
		{
			ushort ret = ImRemapU16Native(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int ImRemapS32Native(int x, int x0, int x1, int y0, int y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int, int, int, int>)vt[376])(x, x0, x1, y0, y1);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int, int, int, int>)vt[376])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImRemapS32(int x, int x0, int x1, int y0, int y1)
		{
			int ret = ImRemapS32Native(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint ImRemapU32Native(uint x, uint x0, uint x1, uint y0, uint y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, uint>)vt[377])(x, x0, x1, y0, y1);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, uint>)vt[377])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImRemapU32(uint x, uint x0, uint x1, uint y0, uint y1)
		{
			uint ret = ImRemapU32Native(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static long ImRemapS64Native(long x, long x0, long x1, long y0, long y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, long, long, long, long, long>)vt[378])(x, x0, x1, y0, y1);
			#else
			return (long)((delegate* unmanaged[Cdecl]<long, long, long, long, long, long>)vt[378])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImRemapS64(long x, long x0, long x1, long y0, long y1)
		{
			long ret = ImRemapS64Native(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ulong ImRemapU64Native(ulong x, ulong x0, ulong x1, ulong y0, ulong y1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong, ulong, ulong>)vt[379])(x, x0, x1, y0, y1);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong, ulong, ulong>)vt[379])(x, x0, x1, y0, y1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImRemapU64(ulong x, ulong x0, ulong x1, ulong y0, ulong y1)
		{
			ulong ret = ImRemapU64Native(x, x0, x1, y0, y1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float ImRemap01FloatNative(float x, float x0, float x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float>)vt[380])(x, x0, x1);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float, float>)vt[380])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImRemap01Float(float x, float x0, float x1)
		{
			float ret = ImRemap01FloatNative(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImRemap01DoubleNative(double x, double x0, double x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double, double>)vt[381])(x, x0, x1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double, double>)vt[381])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImRemap01Double(double x, double x0, double x1)
		{
			double ret = ImRemap01DoubleNative(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImRemap01S8Native(byte x, byte x0, byte x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, byte, byte>)vt[382])(x, x0, x1);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, byte, byte>)vt[382])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImRemap01S8(byte x, byte x0, byte x1)
		{
			byte ret = ImRemap01S8Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImRemap01U8Native(byte x, byte x0, byte x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, byte, byte>)vt[383])(x, x0, x1);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, byte, byte>)vt[383])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImRemap01U8(byte x, byte x0, byte x1)
		{
			byte ret = ImRemap01U8Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static short ImRemap01S16Native(short x, short x0, short x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short, short, short, short>)vt[384])(x, x0, x1);
			#else
			return (short)((delegate* unmanaged[Cdecl]<short, short, short, short>)vt[384])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImRemap01S16(short x, short x0, short x1)
		{
			short ret = ImRemap01S16Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ushort ImRemap01U16Native(ushort x, ushort x0, ushort x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort>)vt[385])(x, x0, x1);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort>)vt[385])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImRemap01U16(ushort x, ushort x0, ushort x1)
		{
			ushort ret = ImRemap01U16Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int ImRemap01S32Native(int x, int x0, int x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int, int>)vt[386])(x, x0, x1);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int, int>)vt[386])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImRemap01S32(int x, int x0, int x1)
		{
			int ret = ImRemap01S32Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint ImRemap01U32Native(uint x, uint x0, uint x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, uint, uint>)vt[387])(x, x0, x1);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, uint, uint>)vt[387])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImRemap01U32(uint x, uint x0, uint x1)
		{
			uint ret = ImRemap01U32Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static long ImRemap01S64Native(long x, long x0, long x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, long, long, long>)vt[388])(x, x0, x1);
			#else
			return (long)((delegate* unmanaged[Cdecl]<long, long, long, long>)vt[388])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImRemap01S64(long x, long x0, long x1)
		{
			long ret = ImRemap01S64Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ulong ImRemap01U64Native(ulong x, ulong x0, ulong x1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong>)vt[389])(x, x0, x1);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong, ulong, ulong, ulong>)vt[389])(x, x0, x1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImRemap01U64(ulong x, ulong x0, ulong x1)
		{
			ulong ret = ImRemap01U64Native(x, x0, x1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int ImPosModNative(int l, int r)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)vt[390])(l, r);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)vt[390])(l, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImPosMod(int l, int r)
		{
			int ret = ImPosModNative(l, r);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImNanNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte>)vt[391])(val);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<double, byte>)vt[391])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImNan(double val)
		{
			byte ret = ImNanNative(val);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImNanOrInfNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte>)vt[392])(val);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<double, byte>)vt[392])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImNanOrInf(double val)
		{
			byte ret = ImNanOrInfNative(val);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImConstrainNanNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)vt[393])(val);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)vt[393])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImConstrainNan(double val)
		{
			double ret = ImConstrainNanNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImConstrainInfNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)vt[394])(val);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)vt[394])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImConstrainInf(double val)
		{
			double ret = ImConstrainInfNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImConstrainLogNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)vt[395])(val);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)vt[395])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImConstrainLog(double val)
		{
			double ret = ImConstrainLogNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImConstrainTimeNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)vt[396])(val);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)vt[396])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImConstrainTime(double val)
		{
			double ret = ImConstrainTimeNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImAlmostEqualNative(double v1, double v2, int ulp)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, int, byte>)vt[397])(v1, v2, ulp);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<double, double, int, byte>)vt[397])(v1, v2, ulp);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImAlmostEqual(double v1, double v2, int ulp)
		{
			byte ret = ImAlmostEqualNative(v1, v2, ulp);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float ImMinArrayFloatPtrNative(float* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, int, float>)vt[398])(values, count);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, int, float>)vt[398])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImMinArrayFloatPtr(float* values, int count)
		{
			float ret = ImMinArrayFloatPtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImMinArrayFloatPtr(ref float values, int count)
		{
			fixed (float* pvalues = &values)
			{
				float ret = ImMinArrayFloatPtrNative((float*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImMinArrayDoublePtrNative(double* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double*, int, double>)vt[399])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)vt[399])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMinArrayDoublePtr(double* values, int count)
		{
			double ret = ImMinArrayDoublePtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMinArrayDoublePtr(ref double values, int count)
		{
			fixed (double* pvalues = &values)
			{
				double ret = ImMinArrayDoublePtrNative((double*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImMinArrayS8PtrNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)vt[400])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)vt[400])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMinArrayS8Ptr(byte* values, int count)
		{
			byte ret = ImMinArrayS8PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMinArrayS8Ptr(ref byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImMinArrayS8PtrNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImMinArrayU8PtrNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)vt[401])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)vt[401])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMinArrayU8Ptr(byte* values, int count)
		{
			byte ret = ImMinArrayU8PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMinArrayU8Ptr(ref byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImMinArrayU8PtrNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static short ImMinArrayS16PtrNative(short* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short*, int, short>)vt[402])(values, count);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)vt[402])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImMinArrayS16Ptr(short* values, int count)
		{
			short ret = ImMinArrayS16PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImMinArrayS16Ptr(ref short values, int count)
		{
			fixed (short* pvalues = &values)
			{
				short ret = ImMinArrayS16PtrNative((short*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ushort ImMinArrayU16PtrNative(ushort* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, int, ushort>)vt[403])(values, count);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, int, ushort>)vt[403])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImMinArrayU16Ptr(ushort* values, int count)
		{
			ushort ret = ImMinArrayU16PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImMinArrayU16Ptr(ref ushort values, int count)
		{
			fixed (ushort* pvalues = &values)
			{
				ushort ret = ImMinArrayU16PtrNative((ushort*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int ImMinArrayS32PtrNative(int* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, int>)vt[404])(values, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)vt[404])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImMinArrayS32Ptr(int* values, int count)
		{
			int ret = ImMinArrayS32PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImMinArrayS32Ptr(ref int values, int count)
		{
			fixed (int* pvalues = &values)
			{
				int ret = ImMinArrayS32PtrNative((int*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint ImMinArrayU32PtrNative(uint* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, uint>)vt[405])(values, count);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)vt[405])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMinArrayU32Ptr(uint* values, int count)
		{
			uint ret = ImMinArrayU32PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMinArrayU32Ptr(ref uint values, int count)
		{
			fixed (uint* pvalues = &values)
			{
				uint ret = ImMinArrayU32PtrNative((uint*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static long ImMinArrayS64PtrNative(long* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, int, long>)vt[406])(values, count);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, int, long>)vt[406])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImMinArrayS64Ptr(long* values, int count)
		{
			long ret = ImMinArrayS64PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImMinArrayS64Ptr(ref long values, int count)
		{
			fixed (long* pvalues = &values)
			{
				long ret = ImMinArrayS64PtrNative((long*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ulong ImMinArrayU64PtrNative(ulong* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong*, int, ulong>)vt[407])(values, count);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, int, ulong>)vt[407])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImMinArrayU64Ptr(ulong* values, int count)
		{
			ulong ret = ImMinArrayU64PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImMinArrayU64Ptr(ref ulong values, int count)
		{
			fixed (ulong* pvalues = &values)
			{
				ulong ret = ImMinArrayU64PtrNative((ulong*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float ImMaxArrayFloatPtrNative(float* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, int, float>)vt[408])(values, count);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, int, float>)vt[408])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImMaxArrayFloatPtr(float* values, int count)
		{
			float ret = ImMaxArrayFloatPtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImMaxArrayFloatPtr(ref float values, int count)
		{
			fixed (float* pvalues = &values)
			{
				float ret = ImMaxArrayFloatPtrNative((float*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImMaxArrayDoublePtrNative(double* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double*, int, double>)vt[409])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)vt[409])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMaxArrayDoublePtr(double* values, int count)
		{
			double ret = ImMaxArrayDoublePtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImMaxArrayDoublePtr(ref double values, int count)
		{
			fixed (double* pvalues = &values)
			{
				double ret = ImMaxArrayDoublePtrNative((double*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImMaxArrayS8PtrNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)vt[410])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)vt[410])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMaxArrayS8Ptr(byte* values, int count)
		{
			byte ret = ImMaxArrayS8PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMaxArrayS8Ptr(ref byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImMaxArrayS8PtrNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImMaxArrayU8PtrNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)vt[411])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)vt[411])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMaxArrayU8Ptr(byte* values, int count)
		{
			byte ret = ImMaxArrayU8PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImMaxArrayU8Ptr(ref byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImMaxArrayU8PtrNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static short ImMaxArrayS16PtrNative(short* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short*, int, short>)vt[412])(values, count);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)vt[412])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImMaxArrayS16Ptr(short* values, int count)
		{
			short ret = ImMaxArrayS16PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImMaxArrayS16Ptr(ref short values, int count)
		{
			fixed (short* pvalues = &values)
			{
				short ret = ImMaxArrayS16PtrNative((short*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ushort ImMaxArrayU16PtrNative(ushort* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, int, ushort>)vt[413])(values, count);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, int, ushort>)vt[413])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImMaxArrayU16Ptr(ushort* values, int count)
		{
			ushort ret = ImMaxArrayU16PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImMaxArrayU16Ptr(ref ushort values, int count)
		{
			fixed (ushort* pvalues = &values)
			{
				ushort ret = ImMaxArrayU16PtrNative((ushort*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int ImMaxArrayS32PtrNative(int* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, int>)vt[414])(values, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)vt[414])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImMaxArrayS32Ptr(int* values, int count)
		{
			int ret = ImMaxArrayS32PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImMaxArrayS32Ptr(ref int values, int count)
		{
			fixed (int* pvalues = &values)
			{
				int ret = ImMaxArrayS32PtrNative((int*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint ImMaxArrayU32PtrNative(uint* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, uint>)vt[415])(values, count);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)vt[415])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMaxArrayU32Ptr(uint* values, int count)
		{
			uint ret = ImMaxArrayU32PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImMaxArrayU32Ptr(ref uint values, int count)
		{
			fixed (uint* pvalues = &values)
			{
				uint ret = ImMaxArrayU32PtrNative((uint*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static long ImMaxArrayS64PtrNative(long* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, int, long>)vt[416])(values, count);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, int, long>)vt[416])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImMaxArrayS64Ptr(long* values, int count)
		{
			long ret = ImMaxArrayS64PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImMaxArrayS64Ptr(ref long values, int count)
		{
			fixed (long* pvalues = &values)
			{
				long ret = ImMaxArrayS64PtrNative((long*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ulong ImMaxArrayU64PtrNative(ulong* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong*, int, ulong>)vt[417])(values, count);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, int, ulong>)vt[417])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImMaxArrayU64Ptr(ulong* values, int count)
		{
			ulong ret = ImMaxArrayU64PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImMaxArrayU64Ptr(ref ulong values, int count)
		{
			fixed (ulong* pvalues = &values)
			{
				ulong ret = ImMaxArrayU64PtrNative((ulong*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayFloatPtrNative(float* values, int count, float* minOut, float* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, int, float*, float*, void>)vt[418])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[418])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayFloatPtr(float* values, int count, float* minOut, float* maxOut)
		{
			ImMinMaxArrayFloatPtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayFloatPtr(ref float values, int count, float* minOut, float* maxOut)
		{
			fixed (float* pvalues = &values)
			{
				ImMinMaxArrayFloatPtrNative((float*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayFloatPtr(float* values, int count, ref float minOut, float* maxOut)
		{
			fixed (float* pminOut = &minOut)
			{
				ImMinMaxArrayFloatPtrNative(values, count, (float*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayFloatPtr(ref float values, int count, ref float minOut, float* maxOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (float* pminOut = &minOut)
				{
					ImMinMaxArrayFloatPtrNative((float*)pvalues, count, (float*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayFloatPtr(float* values, int count, float* minOut, ref float maxOut)
		{
			fixed (float* pmaxOut = &maxOut)
			{
				ImMinMaxArrayFloatPtrNative(values, count, minOut, (float*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayFloatPtr(ref float values, int count, float* minOut, ref float maxOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (float* pmaxOut = &maxOut)
				{
					ImMinMaxArrayFloatPtrNative((float*)pvalues, count, minOut, (float*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayFloatPtr(float* values, int count, ref float minOut, ref float maxOut)
		{
			fixed (float* pminOut = &minOut)
			{
				fixed (float* pmaxOut = &maxOut)
				{
					ImMinMaxArrayFloatPtrNative(values, count, (float*)pminOut, (float*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayFloatPtr(ref float values, int count, ref float minOut, ref float maxOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (float* pminOut = &minOut)
				{
					fixed (float* pmaxOut = &maxOut)
					{
						ImMinMaxArrayFloatPtrNative((float*)pvalues, count, (float*)pminOut, (float*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayDoublePtrNative(double* values, int count, double* minOut, double* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, int, double*, double*, void>)vt[419])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[419])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayDoublePtr(double* values, int count, double* minOut, double* maxOut)
		{
			ImMinMaxArrayDoublePtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayDoublePtr(ref double values, int count, double* minOut, double* maxOut)
		{
			fixed (double* pvalues = &values)
			{
				ImMinMaxArrayDoublePtrNative((double*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayDoublePtr(double* values, int count, ref double minOut, double* maxOut)
		{
			fixed (double* pminOut = &minOut)
			{
				ImMinMaxArrayDoublePtrNative(values, count, (double*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayDoublePtr(ref double values, int count, ref double minOut, double* maxOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pminOut = &minOut)
				{
					ImMinMaxArrayDoublePtrNative((double*)pvalues, count, (double*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayDoublePtr(double* values, int count, double* minOut, ref double maxOut)
		{
			fixed (double* pmaxOut = &maxOut)
			{
				ImMinMaxArrayDoublePtrNative(values, count, minOut, (double*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayDoublePtr(ref double values, int count, double* minOut, ref double maxOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pmaxOut = &maxOut)
				{
					ImMinMaxArrayDoublePtrNative((double*)pvalues, count, minOut, (double*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayDoublePtr(double* values, int count, ref double minOut, ref double maxOut)
		{
			fixed (double* pminOut = &minOut)
			{
				fixed (double* pmaxOut = &maxOut)
				{
					ImMinMaxArrayDoublePtrNative(values, count, (double*)pminOut, (double*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayDoublePtr(ref double values, int count, ref double minOut, ref double maxOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pminOut = &minOut)
				{
					fixed (double* pmaxOut = &maxOut)
					{
						ImMinMaxArrayDoublePtrNative((double*)pvalues, count, (double*)pminOut, (double*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayS8PtrNative(byte* values, int count, byte* minOut, byte* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, byte*, byte*, void>)vt[420])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[420])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS8Ptr(byte* values, int count, byte* minOut, byte* maxOut)
		{
			ImMinMaxArrayS8PtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS8Ptr(ref byte values, int count, byte* minOut, byte* maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				ImMinMaxArrayS8PtrNative((byte*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS8Ptr(byte* values, int count, ref byte minOut, byte* maxOut)
		{
			fixed (byte* pminOut = &minOut)
			{
				ImMinMaxArrayS8PtrNative(values, count, (byte*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS8Ptr(ref byte values, int count, ref byte minOut, byte* maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pminOut = &minOut)
				{
					ImMinMaxArrayS8PtrNative((byte*)pvalues, count, (byte*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS8Ptr(byte* values, int count, byte* minOut, ref byte maxOut)
		{
			fixed (byte* pmaxOut = &maxOut)
			{
				ImMinMaxArrayS8PtrNative(values, count, minOut, (byte*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS8Ptr(ref byte values, int count, byte* minOut, ref byte maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pmaxOut = &maxOut)
				{
					ImMinMaxArrayS8PtrNative((byte*)pvalues, count, minOut, (byte*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS8Ptr(byte* values, int count, ref byte minOut, ref byte maxOut)
		{
			fixed (byte* pminOut = &minOut)
			{
				fixed (byte* pmaxOut = &maxOut)
				{
					ImMinMaxArrayS8PtrNative(values, count, (byte*)pminOut, (byte*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS8Ptr(ref byte values, int count, ref byte minOut, ref byte maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pminOut = &minOut)
				{
					fixed (byte* pmaxOut = &maxOut)
					{
						ImMinMaxArrayS8PtrNative((byte*)pvalues, count, (byte*)pminOut, (byte*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayU8PtrNative(byte* values, int count, byte* minOut, byte* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, byte*, byte*, void>)vt[421])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[421])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU8Ptr(byte* values, int count, byte* minOut, byte* maxOut)
		{
			ImMinMaxArrayU8PtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU8Ptr(ref byte values, int count, byte* minOut, byte* maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				ImMinMaxArrayU8PtrNative((byte*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU8Ptr(byte* values, int count, ref byte minOut, byte* maxOut)
		{
			fixed (byte* pminOut = &minOut)
			{
				ImMinMaxArrayU8PtrNative(values, count, (byte*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU8Ptr(ref byte values, int count, ref byte minOut, byte* maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pminOut = &minOut)
				{
					ImMinMaxArrayU8PtrNative((byte*)pvalues, count, (byte*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU8Ptr(byte* values, int count, byte* minOut, ref byte maxOut)
		{
			fixed (byte* pmaxOut = &maxOut)
			{
				ImMinMaxArrayU8PtrNative(values, count, minOut, (byte*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU8Ptr(ref byte values, int count, byte* minOut, ref byte maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pmaxOut = &maxOut)
				{
					ImMinMaxArrayU8PtrNative((byte*)pvalues, count, minOut, (byte*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU8Ptr(byte* values, int count, ref byte minOut, ref byte maxOut)
		{
			fixed (byte* pminOut = &minOut)
			{
				fixed (byte* pmaxOut = &maxOut)
				{
					ImMinMaxArrayU8PtrNative(values, count, (byte*)pminOut, (byte*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU8Ptr(ref byte values, int count, ref byte minOut, ref byte maxOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (byte* pminOut = &minOut)
				{
					fixed (byte* pmaxOut = &maxOut)
					{
						ImMinMaxArrayU8PtrNative((byte*)pvalues, count, (byte*)pminOut, (byte*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayS16PtrNative(short* values, int count, short* minOut, short* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, int, short*, short*, void>)vt[422])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[422])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS16Ptr(short* values, int count, short* minOut, short* maxOut)
		{
			ImMinMaxArrayS16PtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS16Ptr(ref short values, int count, short* minOut, short* maxOut)
		{
			fixed (short* pvalues = &values)
			{
				ImMinMaxArrayS16PtrNative((short*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS16Ptr(short* values, int count, ref short minOut, short* maxOut)
		{
			fixed (short* pminOut = &minOut)
			{
				ImMinMaxArrayS16PtrNative(values, count, (short*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS16Ptr(ref short values, int count, ref short minOut, short* maxOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (short* pminOut = &minOut)
				{
					ImMinMaxArrayS16PtrNative((short*)pvalues, count, (short*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS16Ptr(short* values, int count, short* minOut, ref short maxOut)
		{
			fixed (short* pmaxOut = &maxOut)
			{
				ImMinMaxArrayS16PtrNative(values, count, minOut, (short*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS16Ptr(ref short values, int count, short* minOut, ref short maxOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (short* pmaxOut = &maxOut)
				{
					ImMinMaxArrayS16PtrNative((short*)pvalues, count, minOut, (short*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS16Ptr(short* values, int count, ref short minOut, ref short maxOut)
		{
			fixed (short* pminOut = &minOut)
			{
				fixed (short* pmaxOut = &maxOut)
				{
					ImMinMaxArrayS16PtrNative(values, count, (short*)pminOut, (short*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS16Ptr(ref short values, int count, ref short minOut, ref short maxOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (short* pminOut = &minOut)
				{
					fixed (short* pmaxOut = &maxOut)
					{
						ImMinMaxArrayS16PtrNative((short*)pvalues, count, (short*)pminOut, (short*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayU16PtrNative(ushort* values, int count, ushort* minOut, ushort* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort*, int, ushort*, ushort*, void>)vt[423])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[423])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU16Ptr(ushort* values, int count, ushort* minOut, ushort* maxOut)
		{
			ImMinMaxArrayU16PtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU16Ptr(ref ushort values, int count, ushort* minOut, ushort* maxOut)
		{
			fixed (ushort* pvalues = &values)
			{
				ImMinMaxArrayU16PtrNative((ushort*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU16Ptr(ushort* values, int count, ref ushort minOut, ushort* maxOut)
		{
			fixed (ushort* pminOut = &minOut)
			{
				ImMinMaxArrayU16PtrNative(values, count, (ushort*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU16Ptr(ref ushort values, int count, ref ushort minOut, ushort* maxOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (ushort* pminOut = &minOut)
				{
					ImMinMaxArrayU16PtrNative((ushort*)pvalues, count, (ushort*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU16Ptr(ushort* values, int count, ushort* minOut, ref ushort maxOut)
		{
			fixed (ushort* pmaxOut = &maxOut)
			{
				ImMinMaxArrayU16PtrNative(values, count, minOut, (ushort*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU16Ptr(ref ushort values, int count, ushort* minOut, ref ushort maxOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (ushort* pmaxOut = &maxOut)
				{
					ImMinMaxArrayU16PtrNative((ushort*)pvalues, count, minOut, (ushort*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU16Ptr(ushort* values, int count, ref ushort minOut, ref ushort maxOut)
		{
			fixed (ushort* pminOut = &minOut)
			{
				fixed (ushort* pmaxOut = &maxOut)
				{
					ImMinMaxArrayU16PtrNative(values, count, (ushort*)pminOut, (ushort*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU16Ptr(ref ushort values, int count, ref ushort minOut, ref ushort maxOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (ushort* pminOut = &minOut)
				{
					fixed (ushort* pmaxOut = &maxOut)
					{
						ImMinMaxArrayU16PtrNative((ushort*)pvalues, count, (ushort*)pminOut, (ushort*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayS32PtrNative(int* values, int count, int* minOut, int* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, int, int*, int*, void>)vt[424])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[424])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS32Ptr(int* values, int count, int* minOut, int* maxOut)
		{
			ImMinMaxArrayS32PtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS32Ptr(ref int values, int count, int* minOut, int* maxOut)
		{
			fixed (int* pvalues = &values)
			{
				ImMinMaxArrayS32PtrNative((int*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS32Ptr(int* values, int count, ref int minOut, int* maxOut)
		{
			fixed (int* pminOut = &minOut)
			{
				ImMinMaxArrayS32PtrNative(values, count, (int*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS32Ptr(ref int values, int count, ref int minOut, int* maxOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pminOut = &minOut)
				{
					ImMinMaxArrayS32PtrNative((int*)pvalues, count, (int*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS32Ptr(int* values, int count, int* minOut, ref int maxOut)
		{
			fixed (int* pmaxOut = &maxOut)
			{
				ImMinMaxArrayS32PtrNative(values, count, minOut, (int*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS32Ptr(ref int values, int count, int* minOut, ref int maxOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pmaxOut = &maxOut)
				{
					ImMinMaxArrayS32PtrNative((int*)pvalues, count, minOut, (int*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS32Ptr(int* values, int count, ref int minOut, ref int maxOut)
		{
			fixed (int* pminOut = &minOut)
			{
				fixed (int* pmaxOut = &maxOut)
				{
					ImMinMaxArrayS32PtrNative(values, count, (int*)pminOut, (int*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS32Ptr(ref int values, int count, ref int minOut, ref int maxOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pminOut = &minOut)
				{
					fixed (int* pmaxOut = &maxOut)
					{
						ImMinMaxArrayS32PtrNative((int*)pvalues, count, (int*)pminOut, (int*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayU32PtrNative(uint* values, int count, uint* minOut, uint* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, uint*, uint*, void>)vt[425])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[425])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU32Ptr(uint* values, int count, uint* minOut, uint* maxOut)
		{
			ImMinMaxArrayU32PtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU32Ptr(ref uint values, int count, uint* minOut, uint* maxOut)
		{
			fixed (uint* pvalues = &values)
			{
				ImMinMaxArrayU32PtrNative((uint*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU32Ptr(uint* values, int count, ref uint minOut, uint* maxOut)
		{
			fixed (uint* pminOut = &minOut)
			{
				ImMinMaxArrayU32PtrNative(values, count, (uint*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU32Ptr(ref uint values, int count, ref uint minOut, uint* maxOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (uint* pminOut = &minOut)
				{
					ImMinMaxArrayU32PtrNative((uint*)pvalues, count, (uint*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU32Ptr(uint* values, int count, uint* minOut, ref uint maxOut)
		{
			fixed (uint* pmaxOut = &maxOut)
			{
				ImMinMaxArrayU32PtrNative(values, count, minOut, (uint*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU32Ptr(ref uint values, int count, uint* minOut, ref uint maxOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (uint* pmaxOut = &maxOut)
				{
					ImMinMaxArrayU32PtrNative((uint*)pvalues, count, minOut, (uint*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU32Ptr(uint* values, int count, ref uint minOut, ref uint maxOut)
		{
			fixed (uint* pminOut = &minOut)
			{
				fixed (uint* pmaxOut = &maxOut)
				{
					ImMinMaxArrayU32PtrNative(values, count, (uint*)pminOut, (uint*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU32Ptr(ref uint values, int count, ref uint minOut, ref uint maxOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (uint* pminOut = &minOut)
				{
					fixed (uint* pmaxOut = &maxOut)
					{
						ImMinMaxArrayU32PtrNative((uint*)pvalues, count, (uint*)pminOut, (uint*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayS64PtrNative(long* values, int count, long* minOut, long* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<long*, int, long*, long*, void>)vt[426])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[426])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS64Ptr(long* values, int count, long* minOut, long* maxOut)
		{
			ImMinMaxArrayS64PtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS64Ptr(ref long values, int count, long* minOut, long* maxOut)
		{
			fixed (long* pvalues = &values)
			{
				ImMinMaxArrayS64PtrNative((long*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS64Ptr(long* values, int count, ref long minOut, long* maxOut)
		{
			fixed (long* pminOut = &minOut)
			{
				ImMinMaxArrayS64PtrNative(values, count, (long*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS64Ptr(ref long values, int count, ref long minOut, long* maxOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (long* pminOut = &minOut)
				{
					ImMinMaxArrayS64PtrNative((long*)pvalues, count, (long*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS64Ptr(long* values, int count, long* minOut, ref long maxOut)
		{
			fixed (long* pmaxOut = &maxOut)
			{
				ImMinMaxArrayS64PtrNative(values, count, minOut, (long*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS64Ptr(ref long values, int count, long* minOut, ref long maxOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (long* pmaxOut = &maxOut)
				{
					ImMinMaxArrayS64PtrNative((long*)pvalues, count, minOut, (long*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS64Ptr(long* values, int count, ref long minOut, ref long maxOut)
		{
			fixed (long* pminOut = &minOut)
			{
				fixed (long* pmaxOut = &maxOut)
				{
					ImMinMaxArrayS64PtrNative(values, count, (long*)pminOut, (long*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayS64Ptr(ref long values, int count, ref long minOut, ref long maxOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (long* pminOut = &minOut)
				{
					fixed (long* pmaxOut = &maxOut)
					{
						ImMinMaxArrayS64PtrNative((long*)pvalues, count, (long*)pminOut, (long*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ImMinMaxArrayU64PtrNative(ulong* values, int count, ulong* minOut, ulong* maxOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong*, int, ulong*, ulong*, void>)vt[427])(values, count, minOut, maxOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)vt[427])((nint)values, count, (nint)minOut, (nint)maxOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU64Ptr(ulong* values, int count, ulong* minOut, ulong* maxOut)
		{
			ImMinMaxArrayU64PtrNative(values, count, minOut, maxOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU64Ptr(ref ulong values, int count, ulong* minOut, ulong* maxOut)
		{
			fixed (ulong* pvalues = &values)
			{
				ImMinMaxArrayU64PtrNative((ulong*)pvalues, count, minOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU64Ptr(ulong* values, int count, ref ulong minOut, ulong* maxOut)
		{
			fixed (ulong* pminOut = &minOut)
			{
				ImMinMaxArrayU64PtrNative(values, count, (ulong*)pminOut, maxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU64Ptr(ref ulong values, int count, ref ulong minOut, ulong* maxOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (ulong* pminOut = &minOut)
				{
					ImMinMaxArrayU64PtrNative((ulong*)pvalues, count, (ulong*)pminOut, maxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU64Ptr(ulong* values, int count, ulong* minOut, ref ulong maxOut)
		{
			fixed (ulong* pmaxOut = &maxOut)
			{
				ImMinMaxArrayU64PtrNative(values, count, minOut, (ulong*)pmaxOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU64Ptr(ref ulong values, int count, ulong* minOut, ref ulong maxOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (ulong* pmaxOut = &maxOut)
				{
					ImMinMaxArrayU64PtrNative((ulong*)pvalues, count, minOut, (ulong*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU64Ptr(ulong* values, int count, ref ulong minOut, ref ulong maxOut)
		{
			fixed (ulong* pminOut = &minOut)
			{
				fixed (ulong* pmaxOut = &maxOut)
				{
					ImMinMaxArrayU64PtrNative(values, count, (ulong*)pminOut, (ulong*)pmaxOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMinMaxArrayU64Ptr(ref ulong values, int count, ref ulong minOut, ref ulong maxOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (ulong* pminOut = &minOut)
				{
					fixed (ulong* pmaxOut = &maxOut)
					{
						ImMinMaxArrayU64PtrNative((ulong*)pvalues, count, (ulong*)pminOut, (ulong*)pmaxOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float ImSumFloatPtrNative(float* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, int, float>)vt[428])(values, count);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, int, float>)vt[428])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImSumFloatPtr(float* values, int count)
		{
			float ret = ImSumFloatPtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImSumFloatPtr(ref float values, int count)
		{
			fixed (float* pvalues = &values)
			{
				float ret = ImSumFloatPtrNative((float*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static double ImSumDoublePtrNative(double* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double*, int, double>)vt[429])(values, count);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, int, double>)vt[429])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImSumDoublePtr(double* values, int count)
		{
			double ret = ImSumDoublePtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ImSumDoublePtr(ref double values, int count)
		{
			fixed (double* pvalues = &values)
			{
				double ret = ImSumDoublePtrNative((double*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImSumS8PtrNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)vt[430])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)vt[430])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImSumS8Ptr(byte* values, int count)
		{
			byte ret = ImSumS8PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImSumS8Ptr(ref byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImSumS8PtrNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte ImSumU8PtrNative(byte* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte>)vt[431])(values, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)vt[431])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImSumU8Ptr(byte* values, int count)
		{
			byte ret = ImSumU8PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte ImSumU8Ptr(ref byte values, int count)
		{
			fixed (byte* pvalues = &values)
			{
				byte ret = ImSumU8PtrNative((byte*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static short ImSumS16PtrNative(short* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short*, int, short>)vt[432])(values, count);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, int, short>)vt[432])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImSumS16Ptr(short* values, int count)
		{
			short ret = ImSumS16PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static short ImSumS16Ptr(ref short values, int count)
		{
			fixed (short* pvalues = &values)
			{
				short ret = ImSumS16PtrNative((short*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ushort ImSumU16PtrNative(ushort* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, int, ushort>)vt[433])(values, count);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, int, ushort>)vt[433])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImSumU16Ptr(ushort* values, int count)
		{
			ushort ret = ImSumU16PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort ImSumU16Ptr(ref ushort values, int count)
		{
			fixed (ushort* pvalues = &values)
			{
				ushort ret = ImSumU16PtrNative((ushort*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int ImSumS32PtrNative(int* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, int>)vt[434])(values, count);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)vt[434])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImSumS32Ptr(int* values, int count)
		{
			int ret = ImSumS32PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImSumS32Ptr(ref int values, int count)
		{
			fixed (int* pvalues = &values)
			{
				int ret = ImSumS32PtrNative((int*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint ImSumU32PtrNative(uint* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, uint>)vt[435])(values, count);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)vt[435])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImSumU32Ptr(uint* values, int count)
		{
			uint ret = ImSumU32PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ImSumU32Ptr(ref uint values, int count)
		{
			fixed (uint* pvalues = &values)
			{
				uint ret = ImSumU32PtrNative((uint*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static long ImSumS64PtrNative(long* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long*, int, long>)vt[436])(values, count);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, int, long>)vt[436])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImSumS64Ptr(long* values, int count)
		{
			long ret = ImSumS64PtrNative(values, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long ImSumS64Ptr(ref long values, int count)
		{
			fixed (long* pvalues = &values)
			{
				long ret = ImSumS64PtrNative((long*)pvalues, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ulong ImSumU64PtrNative(ulong* values, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong*, int, ulong>)vt[437])(values, count);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, int, ulong>)vt[437])((nint)values, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImSumU64Ptr(ulong* values, int count)
		{
			ulong ret = ImSumU64PtrNative(values, count);
			return ret;
		}
	}
}
