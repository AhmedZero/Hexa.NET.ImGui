// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImPlot
{
	public unsafe partial class ImPlot
	{

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_HasTickLabels")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisHasTickLabelsNative(ImPlotAxis* self);

		public static bool ImPlotAxisHasTickLabels(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisHasTickLabelsNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisHasTickLabels(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisHasTickLabelsNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_HasTickMarks")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisHasTickMarksNative(ImPlotAxis* self);

		public static bool ImPlotAxisHasTickMarks(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisHasTickMarksNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisHasTickMarks(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisHasTickMarksNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_WillRender")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisWillRenderNative(ImPlotAxis* self);

		public static bool ImPlotAxisWillRender(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisWillRenderNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisWillRender(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisWillRenderNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsOpposite")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsOppositeNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsOpposite(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsOppositeNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsOpposite(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsOppositeNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsInverted")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsInvertedNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsInverted(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsInvertedNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsInverted(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsInvertedNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsForeground")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsForegroundNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsForeground(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsForegroundNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsForeground(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsForegroundNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsAutoFitting")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsAutoFittingNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsAutoFitting(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsAutoFittingNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsAutoFitting(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsAutoFittingNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_CanInitFit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisCanInitFitNative(ImPlotAxis* self);

		public static bool ImPlotAxisCanInitFit(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisCanInitFitNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisCanInitFit(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisCanInitFitNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsRangeLocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsRangeLockedNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsRangeLocked(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsRangeLockedNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsRangeLocked(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsRangeLockedNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsLockedMin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsLockedMinNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsLockedMin(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsLockedMinNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsLockedMin(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsLockedMinNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsLockedMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsLockedMaxNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsLockedMax(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsLockedMaxNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsLockedMax(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsLockedMaxNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsLocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsLockedNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsLocked(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsLockedNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsLocked(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsLockedNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsInputLockedMin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsInputLockedMinNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsInputLockedMin(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsInputLockedMinNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsInputLockedMin(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsInputLockedMinNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsInputLockedMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsInputLockedMaxNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsInputLockedMax(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsInputLockedMaxNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsInputLockedMax(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsInputLockedMaxNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsInputLocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsInputLockedNative(ImPlotAxis* self);

		public static bool ImPlotAxisIsInputLocked(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisIsInputLockedNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisIsInputLocked(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsInputLockedNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_HasMenus")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisHasMenusNative(ImPlotAxis* self);

		public static bool ImPlotAxisHasMenus(ImPlotAxisPtr self)
		{
			byte ret = ImPlotAxisHasMenusNative(self);
			return ret != 0;
		}

		public static bool ImPlotAxisHasMenus(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisHasMenusNative((ImPlotAxis*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_IsPanLocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAxisIsPanLockedNative(ImPlotAxis* self, byte increasing);

		public static bool ImPlotAxisIsPanLocked(ImPlotAxisPtr self, bool increasing)
		{
			byte ret = ImPlotAxisIsPanLockedNative(self, increasing ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool ImPlotAxisIsPanLocked(ref ImPlotAxis self, bool increasing)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				byte ret = ImPlotAxisIsPanLockedNative((ImPlotAxis*)pself, increasing ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_PushLinks")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAxisPushLinksNative(ImPlotAxis* self);

		public static void ImPlotAxisPushLinks(ImPlotAxisPtr self)
		{
			ImPlotAxisPushLinksNative(self);
		}

		public static void ImPlotAxisPushLinks(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				ImPlotAxisPushLinksNative((ImPlotAxis*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAxis_PullLinks")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAxisPullLinksNative(ImPlotAxis* self);

		public static void ImPlotAxisPullLinks(ImPlotAxisPtr self)
		{
			ImPlotAxisPullLinksNative(self);
		}

		public static void ImPlotAxisPullLinks(ref ImPlotAxis self)
		{
			fixed (ImPlotAxis* pself = &self)
			{
				ImPlotAxisPullLinksNative((ImPlotAxis*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAlignmentData_ImPlotAlignmentData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotAlignmentData* ImPlotAlignmentDataImPlotAlignmentDataNative();

		public static ImPlotAlignmentDataPtr ImPlotAlignmentDataImPlotAlignmentData()
		{
			ImPlotAlignmentDataPtr ret = ImPlotAlignmentDataImPlotAlignmentDataNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAlignmentData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAlignmentDataDestroyNative(ImPlotAlignmentData* self);

		public static void ImPlotAlignmentDataDestroy(ImPlotAlignmentDataPtr self)
		{
			ImPlotAlignmentDataDestroyNative(self);
		}

		public static void ImPlotAlignmentDataDestroy(ref ImPlotAlignmentData self)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				ImPlotAlignmentDataDestroyNative((ImPlotAlignmentData*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAlignmentData_Begin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAlignmentDataBeginNative(ImPlotAlignmentData* self);

		public static void ImPlotAlignmentDataBegin(ImPlotAlignmentDataPtr self)
		{
			ImPlotAlignmentDataBeginNative(self);
		}

		public static void ImPlotAlignmentDataBegin(ref ImPlotAlignmentData self)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				ImPlotAlignmentDataBeginNative((ImPlotAlignmentData*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAlignmentData_Update")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAlignmentDataUpdateNative(ImPlotAlignmentData* self, float* padA, float* padB, float* deltaA, float* deltaB);

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, float* padA, float* padB, float* deltaA, float* deltaB)
		{
			ImPlotAlignmentDataUpdateNative(self, padA, padB, deltaA, deltaB);
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, float* padA, float* padB, float* deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, padA, padB, deltaA, deltaB);
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, ref float padA, float* padB, float* deltaA, float* deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				ImPlotAlignmentDataUpdateNative(self, (float*)ppadA, padB, deltaA, deltaB);
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, ref float padA, float* padB, float* deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, padB, deltaA, deltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, float* padA, ref float padB, float* deltaA, float* deltaB)
		{
			fixed (float* ppadB = &padB)
			{
				ImPlotAlignmentDataUpdateNative(self, padA, (float*)ppadB, deltaA, deltaB);
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, float* padA, ref float padB, float* deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadB = &padB)
				{
					ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, padA, (float*)ppadB, deltaA, deltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, ref float padA, ref float padB, float* deltaA, float* deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* ppadB = &padB)
				{
					ImPlotAlignmentDataUpdateNative(self, (float*)ppadA, (float*)ppadB, deltaA, deltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, ref float padA, ref float padB, float* deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* ppadB = &padB)
					{
						ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, (float*)ppadB, deltaA, deltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, float* padA, float* padB, ref float deltaA, float* deltaB)
		{
			fixed (float* pdeltaA = &deltaA)
			{
				ImPlotAlignmentDataUpdateNative(self, padA, padB, (float*)pdeltaA, deltaB);
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, float* padA, float* padB, ref float deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, padA, padB, (float*)pdeltaA, deltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, ref float padA, float* padB, ref float deltaA, float* deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					ImPlotAlignmentDataUpdateNative(self, (float*)ppadA, padB, (float*)pdeltaA, deltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, ref float padA, float* padB, ref float deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, padB, (float*)pdeltaA, deltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, float* padA, ref float padB, ref float deltaA, float* deltaB)
		{
			fixed (float* ppadB = &padB)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					ImPlotAlignmentDataUpdateNative(self, padA, (float*)ppadB, (float*)pdeltaA, deltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, float* padA, ref float padB, ref float deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, padA, (float*)ppadB, (float*)pdeltaA, deltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, ref float padA, ref float padB, ref float deltaA, float* deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						ImPlotAlignmentDataUpdateNative(self, (float*)ppadA, (float*)ppadB, (float*)pdeltaA, deltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, ref float padA, ref float padB, ref float deltaA, float* deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* ppadB = &padB)
					{
						fixed (float* pdeltaA = &deltaA)
						{
							ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, (float*)ppadB, (float*)pdeltaA, deltaB);
						}
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, float* padA, float* padB, float* deltaA, ref float deltaB)
		{
			fixed (float* pdeltaB = &deltaB)
			{
				ImPlotAlignmentDataUpdateNative(self, padA, padB, deltaA, (float*)pdeltaB);
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, float* padA, float* padB, float* deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* pdeltaB = &deltaB)
				{
					ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, padA, padB, deltaA, (float*)pdeltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, ref float padA, float* padB, float* deltaA, ref float deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* pdeltaB = &deltaB)
				{
					ImPlotAlignmentDataUpdateNative(self, (float*)ppadA, padB, deltaA, (float*)pdeltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, ref float padA, float* padB, float* deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, padB, deltaA, (float*)pdeltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, float* padA, ref float padB, float* deltaA, ref float deltaB)
		{
			fixed (float* ppadB = &padB)
			{
				fixed (float* pdeltaB = &deltaB)
				{
					ImPlotAlignmentDataUpdateNative(self, padA, (float*)ppadB, deltaA, (float*)pdeltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, float* padA, ref float padB, float* deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, padA, (float*)ppadB, deltaA, (float*)pdeltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, ref float padA, ref float padB, float* deltaA, ref float deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						ImPlotAlignmentDataUpdateNative(self, (float*)ppadA, (float*)ppadB, deltaA, (float*)pdeltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, ref float padA, ref float padB, float* deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* ppadB = &padB)
					{
						fixed (float* pdeltaB = &deltaB)
						{
							ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, (float*)ppadB, deltaA, (float*)pdeltaB);
						}
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, float* padA, float* padB, ref float deltaA, ref float deltaB)
		{
			fixed (float* pdeltaA = &deltaA)
			{
				fixed (float* pdeltaB = &deltaB)
				{
					ImPlotAlignmentDataUpdateNative(self, padA, padB, (float*)pdeltaA, (float*)pdeltaB);
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, float* padA, float* padB, ref float deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, padA, padB, (float*)pdeltaA, (float*)pdeltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, ref float padA, float* padB, ref float deltaA, ref float deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						ImPlotAlignmentDataUpdateNative(self, (float*)ppadA, padB, (float*)pdeltaA, (float*)pdeltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, ref float padA, float* padB, ref float deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						fixed (float* pdeltaB = &deltaB)
						{
							ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, padB, (float*)pdeltaA, (float*)pdeltaB);
						}
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, float* padA, ref float padB, ref float deltaA, ref float deltaB)
		{
			fixed (float* ppadB = &padB)
			{
				fixed (float* pdeltaA = &deltaA)
				{
					fixed (float* pdeltaB = &deltaB)
					{
						ImPlotAlignmentDataUpdateNative(self, padA, (float*)ppadB, (float*)pdeltaA, (float*)pdeltaB);
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, float* padA, ref float padB, ref float deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						fixed (float* pdeltaB = &deltaB)
						{
							ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, padA, (float*)ppadB, (float*)pdeltaA, (float*)pdeltaB);
						}
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ImPlotAlignmentDataPtr self, ref float padA, ref float padB, ref float deltaA, ref float deltaB)
		{
			fixed (float* ppadA = &padA)
			{
				fixed (float* ppadB = &padB)
				{
					fixed (float* pdeltaA = &deltaA)
					{
						fixed (float* pdeltaB = &deltaB)
						{
							ImPlotAlignmentDataUpdateNative(self, (float*)ppadA, (float*)ppadB, (float*)pdeltaA, (float*)pdeltaB);
						}
					}
				}
			}
		}

		public static void ImPlotAlignmentDataUpdate(ref ImPlotAlignmentData self, ref float padA, ref float padB, ref float deltaA, ref float deltaB)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				fixed (float* ppadA = &padA)
				{
					fixed (float* ppadB = &padB)
					{
						fixed (float* pdeltaA = &deltaA)
						{
							fixed (float* pdeltaB = &deltaB)
							{
								ImPlotAlignmentDataUpdateNative((ImPlotAlignmentData*)pself, (float*)ppadA, (float*)ppadB, (float*)pdeltaA, (float*)pdeltaB);
							}
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAlignmentData_End")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAlignmentDataEndNative(ImPlotAlignmentData* self);

		public static void ImPlotAlignmentDataEnd(ImPlotAlignmentDataPtr self)
		{
			ImPlotAlignmentDataEndNative(self);
		}

		public static void ImPlotAlignmentDataEnd(ref ImPlotAlignmentData self)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				ImPlotAlignmentDataEndNative((ImPlotAlignmentData*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotAlignmentData_Reset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAlignmentDataResetNative(ImPlotAlignmentData* self);

		public static void ImPlotAlignmentDataReset(ImPlotAlignmentDataPtr self)
		{
			ImPlotAlignmentDataResetNative(self);
		}

		public static void ImPlotAlignmentDataReset(ref ImPlotAlignmentData self)
		{
			fixed (ImPlotAlignmentData* pself = &self)
			{
				ImPlotAlignmentDataResetNative((ImPlotAlignmentData*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItem_ImPlotItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotItemImPlotItemNative();

		public static ImPlotItemPtr ImPlotItemImPlotItem()
		{
			ImPlotItemPtr ret = ImPlotItemImPlotItemNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItem_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotItemDestroyNative(ImPlotItem* self);

		public static void ImPlotItemDestroy(ImPlotItemPtr self)
		{
			ImPlotItemDestroyNative(self);
		}

		public static void ImPlotItemDestroy(ref ImPlotItem self)
		{
			fixed (ImPlotItem* pself = &self)
			{
				ImPlotItemDestroyNative((ImPlotItem*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotLegend_ImPlotLegend")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotLegend* ImPlotLegendImPlotLegendNative();

		public static ImPlotLegendPtr ImPlotLegendImPlotLegend()
		{
			ImPlotLegendPtr ret = ImPlotLegendImPlotLegendNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotLegend_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotLegendDestroyNative(ImPlotLegend* self);

		public static void ImPlotLegendDestroy(ImPlotLegendPtr self)
		{
			ImPlotLegendDestroyNative(self);
		}

		public static void ImPlotLegendDestroy(ref ImPlotLegend self)
		{
			fixed (ImPlotLegend* pself = &self)
			{
				ImPlotLegendDestroyNative((ImPlotLegend*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotLegend_Reset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotLegendResetNative(ImPlotLegend* self);

		public static void ImPlotLegendReset(ImPlotLegendPtr self)
		{
			ImPlotLegendResetNative(self);
		}

		public static void ImPlotLegendReset(ref ImPlotLegend self)
		{
			fixed (ImPlotLegend* pself = &self)
			{
				ImPlotLegendResetNative((ImPlotLegend*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_ImPlotItemGroup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItemGroup* ImPlotItemGroupImPlotItemGroupNative();

		public static ImPlotItemGroupPtr ImPlotItemGroupImPlotItemGroup()
		{
			ImPlotItemGroupPtr ret = ImPlotItemGroupImPlotItemGroupNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotItemGroupDestroyNative(ImPlotItemGroup* self);

		public static void ImPlotItemGroupDestroy(ImPlotItemGroupPtr self)
		{
			ImPlotItemGroupDestroyNative(self);
		}

		public static void ImPlotItemGroupDestroy(ref ImPlotItemGroup self)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemGroupDestroyNative((ImPlotItemGroup*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetItemCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotItemGroupGetItemCountNative(ImPlotItemGroup* self);

		public static int ImPlotItemGroupGetItemCount(ImPlotItemGroupPtr self)
		{
			int ret = ImPlotItemGroupGetItemCountNative(self);
			return ret;
		}

		public static int ImPlotItemGroupGetItemCount(ref ImPlotItemGroup self)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				int ret = ImPlotItemGroupGetItemCountNative((ImPlotItemGroup*)pself);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetItemID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotItemGroupGetItemIDNative(ImPlotItemGroup* self, byte* labelId);

		public static int ImPlotItemGroupGetItemID(ImPlotItemGroupPtr self, byte* labelId)
		{
			int ret = ImPlotItemGroupGetItemIDNative(self, labelId);
			return ret;
		}

		public static int ImPlotItemGroupGetItemID(ref ImPlotItemGroup self, byte* labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				int ret = ImPlotItemGroupGetItemIDNative((ImPlotItemGroup*)pself, labelId);
				return ret;
			}
		}

		public static int ImPlotItemGroupGetItemID(ImPlotItemGroupPtr self, ref byte labelId)
		{
			fixed (byte* plabelId = &labelId)
			{
				int ret = ImPlotItemGroupGetItemIDNative(self, (byte*)plabelId);
				return ret;
			}
		}

		public static int ImPlotItemGroupGetItemID(ImPlotItemGroupPtr self, string labelId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImPlotItemGroupGetItemIDNative(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImPlotItemGroupGetItemID(ref ImPlotItemGroup self, ref byte labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				fixed (byte* plabelId = &labelId)
				{
					int ret = ImPlotItemGroupGetItemIDNative((ImPlotItemGroup*)pself, (byte*)plabelId);
					return ret;
				}
			}
		}

		public static int ImPlotItemGroupGetItemID(ref ImPlotItemGroup self, string labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (labelId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(labelId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImPlotItemGroupGetItemIDNative((ImPlotItemGroup*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetItem_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotItemGroupGetItemIDNative(ImPlotItemGroup* self, int id);

		public static ImPlotItemPtr ImPlotItemGroupGetItemID(ImPlotItemGroupPtr self, int id)
		{
			ImPlotItemPtr ret = ImPlotItemGroupGetItemIDNative(self, id);
			return ret;
		}

		public static ImPlotItemPtr ImPlotItemGroupGetItemID(ref ImPlotItemGroup self, int id)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = ImPlotItemGroupGetItemIDNative((ImPlotItemGroup*)pself, id);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetItem_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotItemGroupGetItemNative(ImPlotItemGroup* self, byte* labelId);

		public static ImPlotItemPtr ImPlotItemGroupGetItem(ImPlotItemGroupPtr self, byte* labelId)
		{
			ImPlotItemPtr ret = ImPlotItemGroupGetItemNative(self, labelId);
			return ret;
		}

		public static ImPlotItemPtr ImPlotItemGroupGetItem(ref ImPlotItemGroup self, byte* labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = ImPlotItemGroupGetItemNative((ImPlotItemGroup*)pself, labelId);
				return ret;
			}
		}

		public static ImPlotItemPtr ImPlotItemGroupGetItem(ImPlotItemGroupPtr self, ref byte labelId)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = ImPlotItemGroupGetItemNative(self, (byte*)plabelId);
				return ret;
			}
		}

		public static ImPlotItemPtr ImPlotItemGroupGetItem(ImPlotItemGroupPtr self, string labelId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = ImPlotItemGroupGetItemNative(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImPlotItemPtr ImPlotItemGroupGetItem(ref ImPlotItemGroup self, ref byte labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				fixed (byte* plabelId = &labelId)
				{
					ImPlotItemPtr ret = ImPlotItemGroupGetItemNative((ImPlotItemGroup*)pself, (byte*)plabelId);
					return ret;
				}
			}
		}

		public static ImPlotItemPtr ImPlotItemGroupGetItem(ref ImPlotItemGroup self, string labelId)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (labelId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(labelId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotItemPtr ret = ImPlotItemGroupGetItemNative((ImPlotItemGroup*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetOrAddItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotItemGroupGetOrAddItemNative(ImPlotItemGroup* self, int id);

		public static ImPlotItemPtr ImPlotItemGroupGetOrAddItem(ImPlotItemGroupPtr self, int id)
		{
			ImPlotItemPtr ret = ImPlotItemGroupGetOrAddItemNative(self, id);
			return ret;
		}

		public static ImPlotItemPtr ImPlotItemGroupGetOrAddItem(ref ImPlotItemGroup self, int id)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = ImPlotItemGroupGetOrAddItemNative((ImPlotItemGroup*)pself, id);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetItemByIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotItemGroupGetItemByIndexNative(ImPlotItemGroup* self, int i);

		public static ImPlotItemPtr ImPlotItemGroupGetItemByIndex(ImPlotItemGroupPtr self, int i)
		{
			ImPlotItemPtr ret = ImPlotItemGroupGetItemByIndexNative(self, i);
			return ret;
		}

		public static ImPlotItemPtr ImPlotItemGroupGetItemByIndex(ref ImPlotItemGroup self, int i)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = ImPlotItemGroupGetItemByIndexNative((ImPlotItemGroup*)pself, i);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetItemIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotItemGroupGetItemIndexNative(ImPlotItemGroup* self, ImPlotItem* item);

		public static int ImPlotItemGroupGetItemIndex(ImPlotItemGroupPtr self, ImPlotItemPtr item)
		{
			int ret = ImPlotItemGroupGetItemIndexNative(self, item);
			return ret;
		}

		public static int ImPlotItemGroupGetItemIndex(ref ImPlotItemGroup self, ImPlotItemPtr item)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				int ret = ImPlotItemGroupGetItemIndexNative((ImPlotItemGroup*)pself, item);
				return ret;
			}
		}

		public static int ImPlotItemGroupGetItemIndex(ImPlotItemGroupPtr self, ref ImPlotItem item)
		{
			fixed (ImPlotItem* pitem = &item)
			{
				int ret = ImPlotItemGroupGetItemIndexNative(self, (ImPlotItem*)pitem);
				return ret;
			}
		}

		public static int ImPlotItemGroupGetItemIndex(ref ImPlotItemGroup self, ref ImPlotItem item)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				fixed (ImPlotItem* pitem = &item)
				{
					int ret = ImPlotItemGroupGetItemIndexNative((ImPlotItemGroup*)pself, (ImPlotItem*)pitem);
					return ret;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetLegendCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotItemGroupGetLegendCountNative(ImPlotItemGroup* self);

		public static int ImPlotItemGroupGetLegendCount(ImPlotItemGroupPtr self)
		{
			int ret = ImPlotItemGroupGetLegendCountNative(self);
			return ret;
		}

		public static int ImPlotItemGroupGetLegendCount(ref ImPlotItemGroup self)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				int ret = ImPlotItemGroupGetLegendCountNative((ImPlotItemGroup*)pself);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetLegendItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotItemGroupGetLegendItemNative(ImPlotItemGroup* self, int i);

		public static ImPlotItemPtr ImPlotItemGroupGetLegendItem(ImPlotItemGroupPtr self, int i)
		{
			ImPlotItemPtr ret = ImPlotItemGroupGetLegendItemNative(self, i);
			return ret;
		}

		public static ImPlotItemPtr ImPlotItemGroupGetLegendItem(ref ImPlotItemGroup self, int i)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemPtr ret = ImPlotItemGroupGetLegendItemNative((ImPlotItemGroup*)pself, i);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_GetLegendLabel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImPlotItemGroupGetLegendLabelNative(ImPlotItemGroup* self, int i);

		public static byte* ImPlotItemGroupGetLegendLabel(ImPlotItemGroupPtr self, int i)
		{
			byte* ret = ImPlotItemGroupGetLegendLabelNative(self, i);
			return ret;
		}

		public static string ImPlotItemGroupGetLegendLabelS(ImPlotItemGroupPtr self, int i)
		{
			string ret = Utils.DecodeStringUTF8(ImPlotItemGroupGetLegendLabelNative(self, i));
			return ret;
		}

		public static byte* ImPlotItemGroupGetLegendLabel(ref ImPlotItemGroup self, int i)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				byte* ret = ImPlotItemGroupGetLegendLabelNative((ImPlotItemGroup*)pself, i);
				return ret;
			}
		}

		public static string ImPlotItemGroupGetLegendLabelS(ref ImPlotItemGroup self, int i)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImPlotItemGroupGetLegendLabelNative((ImPlotItemGroup*)pself, i));
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotItemGroup_Reset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotItemGroupResetNative(ImPlotItemGroup* self);

		public static void ImPlotItemGroupReset(ImPlotItemGroupPtr self)
		{
			ImPlotItemGroupResetNative(self);
		}

		public static void ImPlotItemGroupReset(ref ImPlotItemGroup self)
		{
			fixed (ImPlotItemGroup* pself = &self)
			{
				ImPlotItemGroupResetNative((ImPlotItemGroup*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_ImPlotPlot")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotPlot* ImPlotPlotImPlotPlotNative();

		public static ImPlotPlotPtr ImPlotPlotImPlotPlot()
		{
			ImPlotPlotPtr ret = ImPlotPlotImPlotPlotNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotPlotDestroyNative(ImPlotPlot* self);

		public static void ImPlotPlotDestroy(ImPlotPlotPtr self)
		{
			ImPlotPlotDestroyNative(self);
		}

		public static void ImPlotPlotDestroy(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotPlotDestroyNative((ImPlotPlot*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_IsInputLocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotPlotIsInputLockedNative(ImPlotPlot* self);

		public static bool ImPlotPlotIsInputLocked(ImPlotPlotPtr self)
		{
			byte ret = ImPlotPlotIsInputLockedNative(self);
			return ret != 0;
		}

		public static bool ImPlotPlotIsInputLocked(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte ret = ImPlotPlotIsInputLockedNative((ImPlotPlot*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_ClearTextBuffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotPlotClearTextBufferNative(ImPlotPlot* self);

		public static void ImPlotPlotClearTextBuffer(ImPlotPlotPtr self)
		{
			ImPlotPlotClearTextBufferNative(self);
		}

		public static void ImPlotPlotClearTextBuffer(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotPlotClearTextBufferNative((ImPlotPlot*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_SetTitle")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotPlotSetTitleNative(ImPlotPlot* self, byte* title);

		public static void ImPlotPlotSetTitle(ImPlotPlotPtr self, byte* title)
		{
			ImPlotPlotSetTitleNative(self, title);
		}

		public static void ImPlotPlotSetTitle(ref ImPlotPlot self, byte* title)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotPlotSetTitleNative((ImPlotPlot*)pself, title);
			}
		}

		public static void ImPlotPlotSetTitle(ImPlotPlotPtr self, ref byte title)
		{
			fixed (byte* ptitle = &title)
			{
				ImPlotPlotSetTitleNative(self, (byte*)ptitle);
			}
		}

		public static void ImPlotPlotSetTitle(ImPlotPlotPtr self, string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotPlotSetTitleNative(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImPlotPlotSetTitle(ref ImPlotPlot self, ref byte title)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (byte* ptitle = &title)
				{
					ImPlotPlotSetTitleNative((ImPlotPlot*)pself, (byte*)ptitle);
				}
			}
		}

		public static void ImPlotPlotSetTitle(ref ImPlotPlot self, string title)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (title != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(title);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotPlotSetTitleNative((ImPlotPlot*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_HasTitle")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotPlotHasTitleNative(ImPlotPlot* self);

		public static bool ImPlotPlotHasTitle(ImPlotPlotPtr self)
		{
			byte ret = ImPlotPlotHasTitleNative(self);
			return ret != 0;
		}

		public static bool ImPlotPlotHasTitle(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte ret = ImPlotPlotHasTitleNative((ImPlotPlot*)pself);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_GetTitle")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImPlotPlotGetTitleNative(ImPlotPlot* self);

		public static byte* ImPlotPlotGetTitle(ImPlotPlotPtr self)
		{
			byte* ret = ImPlotPlotGetTitleNative(self);
			return ret;
		}

		public static string ImPlotPlotGetTitleS(ImPlotPlotPtr self)
		{
			string ret = Utils.DecodeStringUTF8(ImPlotPlotGetTitleNative(self));
			return ret;
		}

		public static byte* ImPlotPlotGetTitle(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte* ret = ImPlotPlotGetTitleNative((ImPlotPlot*)pself);
				return ret;
			}
		}

		public static string ImPlotPlotGetTitleS(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImPlotPlotGetTitleNative((ImPlotPlot*)pself));
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_XAxis_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotAxis* ImPlotPlotXAxisNilNative(ImPlotPlot* self, int i);

		public static ImPlotAxisPtr ImPlotPlotXAxisNil(ImPlotPlotPtr self, int i)
		{
			ImPlotAxisPtr ret = ImPlotPlotXAxisNilNative(self, i);
			return ret;
		}

		public static ImPlotAxisPtr ImPlotPlotXAxisNil(ref ImPlotPlot self, int i)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotAxisPtr ret = ImPlotPlotXAxisNilNative((ImPlotPlot*)pself, i);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_XAxis__const")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotAxis* ImPlotPlotXAxisConstNative(ImPlotPlot* self, int i);

		public static ImPlotAxisPtr ImPlotPlotXAxisConst(ImPlotPlotPtr self, int i)
		{
			ImPlotAxisPtr ret = ImPlotPlotXAxisConstNative(self, i);
			return ret;
		}

		public static ImPlotAxisPtr ImPlotPlotXAxisConst(ref ImPlotPlot self, int i)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotAxisPtr ret = ImPlotPlotXAxisConstNative((ImPlotPlot*)pself, i);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_YAxis_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotAxis* ImPlotPlotYAxisNilNative(ImPlotPlot* self, int i);

		public static ImPlotAxisPtr ImPlotPlotYAxisNil(ImPlotPlotPtr self, int i)
		{
			ImPlotAxisPtr ret = ImPlotPlotYAxisNilNative(self, i);
			return ret;
		}

		public static ImPlotAxisPtr ImPlotPlotYAxisNil(ref ImPlotPlot self, int i)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotAxisPtr ret = ImPlotPlotYAxisNilNative((ImPlotPlot*)pself, i);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_YAxis__const")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotAxis* ImPlotPlotYAxisConstNative(ImPlotPlot* self, int i);

		public static ImPlotAxisPtr ImPlotPlotYAxisConst(ImPlotPlotPtr self, int i)
		{
			ImPlotAxisPtr ret = ImPlotPlotYAxisConstNative(self, i);
			return ret;
		}

		public static ImPlotAxisPtr ImPlotPlotYAxisConst(ref ImPlotPlot self, int i)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotAxisPtr ret = ImPlotPlotYAxisConstNative((ImPlotPlot*)pself, i);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_EnabledAxesX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotPlotEnabledAxesXNative(ImPlotPlot* self);

		public static int ImPlotPlotEnabledAxesX(ImPlotPlotPtr self)
		{
			int ret = ImPlotPlotEnabledAxesXNative(self);
			return ret;
		}

		public static int ImPlotPlotEnabledAxesX(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				int ret = ImPlotPlotEnabledAxesXNative((ImPlotPlot*)pself);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_EnabledAxesY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotPlotEnabledAxesYNative(ImPlotPlot* self);

		public static int ImPlotPlotEnabledAxesY(ImPlotPlotPtr self)
		{
			int ret = ImPlotPlotEnabledAxesYNative(self);
			return ret;
		}

		public static int ImPlotPlotEnabledAxesY(ref ImPlotPlot self)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				int ret = ImPlotPlotEnabledAxesYNative((ImPlotPlot*)pself);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_SetAxisLabel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotPlotSetAxisLabelNative(ImPlotPlot* self, ImPlotAxis* axis, byte* label);

		public static void ImPlotPlotSetAxisLabel(ImPlotPlotPtr self, ImPlotAxisPtr axis, byte* label)
		{
			ImPlotPlotSetAxisLabelNative(self, axis, label);
		}

		public static void ImPlotPlotSetAxisLabel(ref ImPlotPlot self, ImPlotAxisPtr axis, byte* label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				ImPlotPlotSetAxisLabelNative((ImPlotPlot*)pself, axis, label);
			}
		}

		public static void ImPlotPlotSetAxisLabel(ImPlotPlotPtr self, ref ImPlotAxis axis, byte* label)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				ImPlotPlotSetAxisLabelNative(self, (ImPlotAxis*)paxis, label);
			}
		}

		public static void ImPlotPlotSetAxisLabel(ref ImPlotPlot self, ref ImPlotAxis axis, byte* label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (ImPlotAxis* paxis = &axis)
				{
					ImPlotPlotSetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)paxis, label);
				}
			}
		}

		public static void ImPlotPlotSetAxisLabel(ImPlotPlotPtr self, ImPlotAxisPtr axis, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImPlotPlotSetAxisLabelNative(self, axis, (byte*)plabel);
			}
		}

		public static void ImPlotPlotSetAxisLabel(ImPlotPlotPtr self, ImPlotAxisPtr axis, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotPlotSetAxisLabelNative(self, axis, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImPlotPlotSetAxisLabel(ref ImPlotPlot self, ImPlotAxisPtr axis, ref byte label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					ImPlotPlotSetAxisLabelNative((ImPlotPlot*)pself, axis, (byte*)plabel);
				}
			}
		}

		public static void ImPlotPlotSetAxisLabel(ref ImPlotPlot self, ImPlotAxisPtr axis, string label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotPlotSetAxisLabelNative((ImPlotPlot*)pself, axis, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImPlotPlotSetAxisLabel(ImPlotPlotPtr self, ref ImPlotAxis axis, ref byte label)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				fixed (byte* plabel = &label)
				{
					ImPlotPlotSetAxisLabelNative(self, (ImPlotAxis*)paxis, (byte*)plabel);
				}
			}
		}

		public static void ImPlotPlotSetAxisLabel(ImPlotPlotPtr self, ref ImPlotAxis axis, string label)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotPlotSetAxisLabelNative(self, (ImPlotAxis*)paxis, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImPlotPlotSetAxisLabel(ref ImPlotPlot self, ref ImPlotAxis axis, ref byte label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (ImPlotAxis* paxis = &axis)
				{
					fixed (byte* plabel = &label)
					{
						ImPlotPlotSetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)paxis, (byte*)plabel);
					}
				}
			}
		}

		public static void ImPlotPlotSetAxisLabel(ref ImPlotPlot self, ref ImPlotAxis axis, string label)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				fixed (ImPlotAxis* paxis = &axis)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImPlotPlotSetAxisLabelNative((ImPlotPlot*)pself, (ImPlotAxis*)paxis, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotPlot_GetAxisLabel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImPlotPlotGetAxisLabelNative(ImPlotPlot* self, ImPlotAxis axis);

		public static byte* ImPlotPlotGetAxisLabel(ImPlotPlotPtr self, ImPlotAxis axis)
		{
			byte* ret = ImPlotPlotGetAxisLabelNative(self, axis);
			return ret;
		}

		public static string ImPlotPlotGetAxisLabelS(ImPlotPlotPtr self, ImPlotAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(ImPlotPlotGetAxisLabelNative(self, axis));
			return ret;
		}

		public static byte* ImPlotPlotGetAxisLabel(ref ImPlotPlot self, ImPlotAxis axis)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				byte* ret = ImPlotPlotGetAxisLabelNative((ImPlotPlot*)pself, axis);
				return ret;
			}
		}

		public static string ImPlotPlotGetAxisLabelS(ref ImPlotPlot self, ImPlotAxis axis)
		{
			fixed (ImPlotPlot* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImPlotPlotGetAxisLabelNative((ImPlotPlot*)pself, axis));
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotSubplot_ImPlotSubplot")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotSubplot* ImPlotSubplotImPlotSubplotNative();

		public static ImPlotSubplotPtr ImPlotSubplotImPlotSubplot()
		{
			ImPlotSubplotPtr ret = ImPlotSubplotImPlotSubplotNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotSubplot_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotSubplotDestroyNative(ImPlotSubplot* self);

		public static void ImPlotSubplotDestroy(ImPlotSubplotPtr self)
		{
			ImPlotSubplotDestroyNative(self);
		}

		public static void ImPlotSubplotDestroy(ref ImPlotSubplot self)
		{
			fixed (ImPlotSubplot* pself = &self)
			{
				ImPlotSubplotDestroyNative((ImPlotSubplot*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotNextPlotData_ImPlotNextPlotData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotNextPlotData* ImPlotNextPlotDataImPlotNextPlotDataNative();

		public static ImPlotNextPlotDataPtr ImPlotNextPlotDataImPlotNextPlotData()
		{
			ImPlotNextPlotDataPtr ret = ImPlotNextPlotDataImPlotNextPlotDataNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotNextPlotData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotNextPlotDataDestroyNative(ImPlotNextPlotData* self);

		public static void ImPlotNextPlotDataDestroy(ImPlotNextPlotDataPtr self)
		{
			ImPlotNextPlotDataDestroyNative(self);
		}

		public static void ImPlotNextPlotDataDestroy(ref ImPlotNextPlotData self)
		{
			fixed (ImPlotNextPlotData* pself = &self)
			{
				ImPlotNextPlotDataDestroyNative((ImPlotNextPlotData*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotNextPlotData_Reset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotNextPlotDataResetNative(ImPlotNextPlotData* self);

		public static void ImPlotNextPlotDataReset(ImPlotNextPlotDataPtr self)
		{
			ImPlotNextPlotDataResetNative(self);
		}

		public static void ImPlotNextPlotDataReset(ref ImPlotNextPlotData self)
		{
			fixed (ImPlotNextPlotData* pself = &self)
			{
				ImPlotNextPlotDataResetNative((ImPlotNextPlotData*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotNextItemData_ImPlotNextItemData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotNextItemData* ImPlotNextItemDataImPlotNextItemDataNative();

		public static ImPlotNextItemDataPtr ImPlotNextItemDataImPlotNextItemData()
		{
			ImPlotNextItemDataPtr ret = ImPlotNextItemDataImPlotNextItemDataNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotNextItemData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotNextItemDataDestroyNative(ImPlotNextItemData* self);

		public static void ImPlotNextItemDataDestroy(ImPlotNextItemDataPtr self)
		{
			ImPlotNextItemDataDestroyNative(self);
		}

		public static void ImPlotNextItemDataDestroy(ref ImPlotNextItemData self)
		{
			fixed (ImPlotNextItemData* pself = &self)
			{
				ImPlotNextItemDataDestroyNative((ImPlotNextItemData*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlotNextItemData_Reset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotNextItemDataResetNative(ImPlotNextItemData* self);

		public static void ImPlotNextItemDataReset(ImPlotNextItemDataPtr self)
		{
			ImPlotNextItemDataResetNative(self);
		}

		public static void ImPlotNextItemDataReset(ref ImPlotNextItemData self)
		{
			fixed (ImPlotNextItemData* pself = &self)
			{
				ImPlotNextItemDataResetNative((ImPlotNextItemData*)pself);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Initialize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotInitializeNative(ImPlotContext* ctx);

		public static void ImPlotInitialize(ImPlotContextPtr ctx)
		{
			ImPlotInitializeNative(ctx);
		}

		public static void ImPlotInitialize(ref ImPlotContext ctx)
		{
			fixed (ImPlotContext* pctx = &ctx)
			{
				ImPlotInitializeNative((ImPlotContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ResetCtxForNextPlot")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotResetCtxForNextPlotNative(ImPlotContext* ctx);

		public static void ImPlotResetCtxForNextPlot(ImPlotContextPtr ctx)
		{
			ImPlotResetCtxForNextPlotNative(ctx);
		}

		public static void ImPlotResetCtxForNextPlot(ref ImPlotContext ctx)
		{
			fixed (ImPlotContext* pctx = &ctx)
			{
				ImPlotResetCtxForNextPlotNative((ImPlotContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ResetCtxForNextAlignedPlots")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotResetCtxForNextAlignedPlotsNative(ImPlotContext* ctx);

		public static void ImPlotResetCtxForNextAlignedPlots(ImPlotContextPtr ctx)
		{
			ImPlotResetCtxForNextAlignedPlotsNative(ctx);
		}

		public static void ImPlotResetCtxForNextAlignedPlots(ref ImPlotContext ctx)
		{
			fixed (ImPlotContext* pctx = &ctx)
			{
				ImPlotResetCtxForNextAlignedPlotsNative((ImPlotContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ResetCtxForNextSubplot")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotResetCtxForNextSubplotNative(ImPlotContext* ctx);

		public static void ImPlotResetCtxForNextSubplot(ImPlotContextPtr ctx)
		{
			ImPlotResetCtxForNextSubplotNative(ctx);
		}

		public static void ImPlotResetCtxForNextSubplot(ref ImPlotContext ctx)
		{
			fixed (ImPlotContext* pctx = &ctx)
			{
				ImPlotResetCtxForNextSubplotNative((ImPlotContext*)pctx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetPlot")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotPlot* ImPlotGetPlotNative(byte* title);

		public static ImPlotPlotPtr ImPlotGetPlot(byte* title)
		{
			ImPlotPlotPtr ret = ImPlotGetPlotNative(title);
			return ret;
		}

		public static ImPlotPlotPtr ImPlotGetPlot(ref byte title)
		{
			fixed (byte* ptitle = &title)
			{
				ImPlotPlotPtr ret = ImPlotGetPlotNative((byte*)ptitle);
				return ret;
			}
		}

		public static ImPlotPlotPtr ImPlotGetPlot(string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotPlotPtr ret = ImPlotGetPlotNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetCurrentPlot")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotPlot* ImPlotGetCurrentPlotNative();

		public static ImPlotPlotPtr ImPlotGetCurrentPlot()
		{
			ImPlotPlotPtr ret = ImPlotGetCurrentPlotNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_BustPlotCache")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotBustPlotCacheNative();

		public static void ImPlotBustPlotCache()
		{
			ImPlotBustPlotCacheNative();
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ShowPlotContextMenu")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotShowPlotContextMenuNative(ImPlotPlot* plot);

		public static void ImPlotShowPlotContextMenu(ImPlotPlotPtr plot)
		{
			ImPlotShowPlotContextMenuNative(plot);
		}

		public static void ImPlotShowPlotContextMenu(ref ImPlotPlot plot)
		{
			fixed (ImPlotPlot* pplot = &plot)
			{
				ImPlotShowPlotContextMenuNative((ImPlotPlot*)pplot);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_SetupLock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotSetupLockNative();

		public static void ImPlotSetupLock()
		{
			ImPlotSetupLockNative();
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_SubplotNextCell")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotSubplotNextCellNative();

		public static void ImPlotSubplotNextCell()
		{
			ImPlotSubplotNextCellNative();
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ShowSubplotsContextMenu")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotShowSubplotsContextMenuNative(ImPlotSubplot* subplot);

		public static void ImPlotShowSubplotsContextMenu(ImPlotSubplotPtr subplot)
		{
			ImPlotShowSubplotsContextMenuNative(subplot);
		}

		public static void ImPlotShowSubplotsContextMenu(ref ImPlotSubplot subplot)
		{
			fixed (ImPlotSubplot* psubplot = &subplot)
			{
				ImPlotShowSubplotsContextMenuNative((ImPlotSubplot*)psubplot);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_BeginItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotBeginItemNative(byte* labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom);

		public static bool ImPlotBeginItem(byte* labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			byte ret = ImPlotBeginItemNative(labelId, flags, recolorFrom);
			return ret != 0;
		}

		public static bool ImPlotBeginItem(ref byte labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			fixed (byte* plabelId = &labelId)
			{
				byte ret = ImPlotBeginItemNative((byte*)plabelId, flags, recolorFrom);
				return ret != 0;
			}
		}

		public static bool ImPlotBeginItem(string labelId, ImPlotItemFlags flags, ImPlotCol recolorFrom)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImPlotBeginItemNative(pStr0, flags, recolorFrom);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_EndItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotEndItemNative();

		public static void ImPlotEndItem()
		{
			ImPlotEndItemNative();
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_RegisterOrGetItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotRegisterOrGetItemNative(byte* labelId, ImPlotItemFlags flags, bool* justCreated);

		public static ImPlotItemPtr ImPlotRegisterOrGetItem(byte* labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			ImPlotItemPtr ret = ImPlotRegisterOrGetItemNative(labelId, flags, justCreated);
			return ret;
		}

		public static ImPlotItemPtr ImPlotRegisterOrGetItem(ref byte labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = ImPlotRegisterOrGetItemNative((byte*)plabelId, flags, justCreated);
				return ret;
			}
		}

		public static ImPlotItemPtr ImPlotRegisterOrGetItem(string labelId, ImPlotItemFlags flags, bool* justCreated)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = ImPlotRegisterOrGetItemNative(pStr0, flags, justCreated);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImPlotItemPtr ImPlotRegisterOrGetItem(byte* labelId, ImPlotItemFlags flags, ref bool justCreated)
		{
			fixed (bool* pjustCreated = &justCreated)
			{
				ImPlotItemPtr ret = ImPlotRegisterOrGetItemNative(labelId, flags, (bool*)pjustCreated);
				return ret;
			}
		}

		public static ImPlotItemPtr ImPlotRegisterOrGetItem(ref byte labelId, ImPlotItemFlags flags, ref bool justCreated)
		{
			fixed (byte* plabelId = &labelId)
			{
				fixed (bool* pjustCreated = &justCreated)
				{
					ImPlotItemPtr ret = ImPlotRegisterOrGetItemNative((byte*)plabelId, flags, (bool*)pjustCreated);
					return ret;
				}
			}
		}

		public static ImPlotItemPtr ImPlotRegisterOrGetItem(string labelId, ImPlotItemFlags flags, ref bool justCreated)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* pjustCreated = &justCreated)
			{
				ImPlotItemPtr ret = ImPlotRegisterOrGetItemNative(pStr0, flags, (bool*)pjustCreated);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotGetItemNative(byte* labelId);

		public static ImPlotItemPtr ImPlotGetItem(byte* labelId)
		{
			ImPlotItemPtr ret = ImPlotGetItemNative(labelId);
			return ret;
		}

		public static ImPlotItemPtr ImPlotGetItem(ref byte labelId)
		{
			fixed (byte* plabelId = &labelId)
			{
				ImPlotItemPtr ret = ImPlotGetItemNative((byte*)plabelId);
				return ret;
			}
		}

		public static ImPlotItemPtr ImPlotGetItem(string labelId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotItemPtr ret = ImPlotGetItemNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetCurrentItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotItem* ImPlotGetCurrentItemNative();

		public static ImPlotItemPtr ImPlotGetCurrentItem()
		{
			ImPlotItemPtr ret = ImPlotGetCurrentItemNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_BustItemCache")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotBustItemCacheNative();

		public static void ImPlotBustItemCache()
		{
			ImPlotBustItemCacheNative();
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_AnyAxesInputLocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAnyAxesInputLockedNative(ImPlotAxis* axes, int count);

		public static bool ImPlotAnyAxesInputLocked(ImPlotAxisPtr axes, int count)
		{
			byte ret = ImPlotAnyAxesInputLockedNative(axes, count);
			return ret != 0;
		}

		public static bool ImPlotAnyAxesInputLocked(ref ImPlotAxis axes, int count)
		{
			fixed (ImPlotAxis* paxes = &axes)
			{
				byte ret = ImPlotAnyAxesInputLockedNative((ImPlotAxis*)paxes, count);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_AllAxesInputLocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAllAxesInputLockedNative(ImPlotAxis* axes, int count);

		public static bool ImPlotAllAxesInputLocked(ImPlotAxisPtr axes, int count)
		{
			byte ret = ImPlotAllAxesInputLockedNative(axes, count);
			return ret != 0;
		}

		public static bool ImPlotAllAxesInputLocked(ref ImPlotAxis axes, int count)
		{
			fixed (ImPlotAxis* paxes = &axes)
			{
				byte ret = ImPlotAllAxesInputLockedNative((ImPlotAxis*)paxes, count);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_AnyAxesHeld")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAnyAxesHeldNative(ImPlotAxis* axes, int count);

		public static bool ImPlotAnyAxesHeld(ImPlotAxisPtr axes, int count)
		{
			byte ret = ImPlotAnyAxesHeldNative(axes, count);
			return ret != 0;
		}

		public static bool ImPlotAnyAxesHeld(ref ImPlotAxis axes, int count)
		{
			fixed (ImPlotAxis* paxes = &axes)
			{
				byte ret = ImPlotAnyAxesHeldNative((ImPlotAxis*)paxes, count);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_AnyAxesHovered")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotAnyAxesHoveredNative(ImPlotAxis* axes, int count);

		public static bool ImPlotAnyAxesHovered(ImPlotAxisPtr axes, int count)
		{
			byte ret = ImPlotAnyAxesHoveredNative(axes, count);
			return ret != 0;
		}

		public static bool ImPlotAnyAxesHovered(ref ImPlotAxis axes, int count)
		{
			fixed (ImPlotAxis* paxes = &axes)
			{
				byte ret = ImPlotAnyAxesHoveredNative((ImPlotAxis*)paxes, count);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FitThisFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotFitThisFrameNative();

		public static bool ImPlotFitThisFrame()
		{
			byte ret = ImPlotFitThisFrameNative();
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FitPointX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFitPointXNative(double x);

		public static void ImPlotFitPointX(double x)
		{
			ImPlotFitPointXNative(x);
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FitPointY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFitPointYNative(double y);

		public static void ImPlotFitPointY(double y)
		{
			ImPlotFitPointYNative(y);
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FitPoint")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFitPointNative(ImPlotPoint p);

		public static void ImPlotFitPoint(ImPlotPoint p)
		{
			ImPlotFitPointNative(p);
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_RangesOverlap")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotRangesOverlapNative(ImPlotRange r1, ImPlotRange r2);

		public static bool ImPlotRangesOverlap(ImPlotRange r1, ImPlotRange r2)
		{
			byte ret = ImPlotRangesOverlapNative(r1, r2);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ShowAxisContextMenu")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotShowAxisContextMenuNative(ImPlotAxis* axis, ImPlotAxis* equalAxis, byte timeAllowed);

		public static void ImPlotShowAxisContextMenu(ImPlotAxisPtr axis, ImPlotAxisPtr equalAxis, bool timeAllowed)
		{
			ImPlotShowAxisContextMenuNative(axis, equalAxis, timeAllowed ? (byte)1 : (byte)0);
		}

		public static void ImPlotShowAxisContextMenu(ref ImPlotAxis axis, ImPlotAxisPtr equalAxis, bool timeAllowed)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				ImPlotShowAxisContextMenuNative((ImPlotAxis*)paxis, equalAxis, timeAllowed ? (byte)1 : (byte)0);
			}
		}

		public static void ImPlotShowAxisContextMenu(ImPlotAxisPtr axis, ref ImPlotAxis equalAxis, bool timeAllowed)
		{
			fixed (ImPlotAxis* pequalAxis = &equalAxis)
			{
				ImPlotShowAxisContextMenuNative(axis, (ImPlotAxis*)pequalAxis, timeAllowed ? (byte)1 : (byte)0);
			}
		}

		public static void ImPlotShowAxisContextMenu(ref ImPlotAxis axis, ref ImPlotAxis equalAxis, bool timeAllowed)
		{
			fixed (ImPlotAxis* paxis = &axis)
			{
				fixed (ImPlotAxis* pequalAxis = &equalAxis)
				{
					ImPlotShowAxisContextMenuNative((ImPlotAxis*)paxis, (ImPlotAxis*)pequalAxis, timeAllowed ? (byte)1 : (byte)0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetLocationPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotGetLocationPosNative(Vector2* output, ImRect outerRect, Vector2 innerSize, ImPlotLocation location, Vector2 pad);

		public static Vector2 ImPlotGetLocationPos(ImRect outerRect, Vector2 innerSize, ImPlotLocation location, Vector2 pad)
		{
			Vector2 ret;
			ImPlotGetLocationPosNative(&ret, outerRect, innerSize, location, pad);
			return ret;
		}

		public static void ImPlotGetLocationPos(Vector2* output, ImRect outerRect, Vector2 innerSize, ImPlotLocation location, Vector2 pad)
		{
			ImPlotGetLocationPosNative(output, outerRect, innerSize, location, pad);
		}

		public static void ImPlotGetLocationPos(ref Vector2 output, ImRect outerRect, Vector2 innerSize, ImPlotLocation location, Vector2 pad)
		{
			fixed (Vector2* poutput = &output)
			{
				ImPlotGetLocationPosNative((Vector2*)poutput, outerRect, innerSize, location, pad);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalcLegendSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalcLegendSizeNative(Vector2* output, ImPlotItemGroup* items, Vector2 pad, Vector2 spacing, byte vertical);

		public static Vector2 ImPlotCalcLegendSize(ImPlotItemGroupPtr items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			Vector2 ret;
			ImPlotCalcLegendSizeNative(&ret, items, pad, spacing, vertical ? (byte)1 : (byte)0);
			return ret;
		}

		public static void ImPlotCalcLegendSize(Vector2* output, ImPlotItemGroupPtr items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			ImPlotCalcLegendSizeNative(output, items, pad, spacing, vertical ? (byte)1 : (byte)0);
		}

		public static void ImPlotCalcLegendSize(ref Vector2 output, ImPlotItemGroupPtr items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			fixed (Vector2* poutput = &output)
			{
				ImPlotCalcLegendSizeNative((Vector2*)poutput, items, pad, spacing, vertical ? (byte)1 : (byte)0);
			}
		}

		public static Vector2 ImPlotCalcLegendSize(ref ImPlotItemGroup items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			fixed (ImPlotItemGroup* pitems = &items)
			{
				Vector2 ret;
				ImPlotCalcLegendSizeNative(&ret, (ImPlotItemGroup*)pitems, pad, spacing, vertical ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public static void ImPlotCalcLegendSize(Vector2* output, ref ImPlotItemGroup items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			fixed (ImPlotItemGroup* pitems = &items)
			{
				ImPlotCalcLegendSizeNative(output, (ImPlotItemGroup*)pitems, pad, spacing, vertical ? (byte)1 : (byte)0);
			}
		}

		public static void ImPlotCalcLegendSize(ref Vector2 output, ref ImPlotItemGroup items, Vector2 pad, Vector2 spacing, bool vertical)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImPlotItemGroup* pitems = &items)
				{
					ImPlotCalcLegendSizeNative((Vector2*)poutput, (ImPlotItemGroup*)pitems, pad, spacing, vertical ? (byte)1 : (byte)0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ClampLegendRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotClampLegendRectNative(ImRect* legendRect, ImRect outerRect, Vector2 pad);

		public static bool ImPlotClampLegendRect(ImRectPtr legendRect, ImRect outerRect, Vector2 pad)
		{
			byte ret = ImPlotClampLegendRectNative(legendRect, outerRect, pad);
			return ret != 0;
		}

		public static bool ImPlotClampLegendRect(ref ImRect legendRect, ImRect outerRect, Vector2 pad)
		{
			fixed (ImRect* plegendRect = &legendRect)
			{
				byte ret = ImPlotClampLegendRectNative((ImRect*)plegendRect, outerRect, pad);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ShowLegendEntries")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotShowLegendEntriesNative(ImPlotItemGroup* items, ImRect legendBb, byte interactable, Vector2 pad, Vector2 spacing, byte vertical, ImDrawList* drawList);

		public static bool ImPlotShowLegendEntries(ImPlotItemGroupPtr items, ImRect legendBb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ImDrawListPtr drawList)
		{
			byte ret = ImPlotShowLegendEntriesNative(items, legendBb, interactable ? (byte)1 : (byte)0, pad, spacing, vertical ? (byte)1 : (byte)0, drawList);
			return ret != 0;
		}

		public static bool ImPlotShowLegendEntries(ref ImPlotItemGroup items, ImRect legendBb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ImDrawListPtr drawList)
		{
			fixed (ImPlotItemGroup* pitems = &items)
			{
				byte ret = ImPlotShowLegendEntriesNative((ImPlotItemGroup*)pitems, legendBb, interactable ? (byte)1 : (byte)0, pad, spacing, vertical ? (byte)1 : (byte)0, drawList);
				return ret != 0;
			}
		}

		public static bool ImPlotShowLegendEntries(ImPlotItemGroupPtr items, ImRect legendBb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte ret = ImPlotShowLegendEntriesNative(items, legendBb, interactable ? (byte)1 : (byte)0, pad, spacing, vertical ? (byte)1 : (byte)0, (ImDrawList*)pdrawList);
				return ret != 0;
			}
		}

		public static bool ImPlotShowLegendEntries(ref ImPlotItemGroup items, ImRect legendBb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ref ImDrawList drawList)
		{
			fixed (ImPlotItemGroup* pitems = &items)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte ret = ImPlotShowLegendEntriesNative((ImPlotItemGroup*)pitems, legendBb, interactable ? (byte)1 : (byte)0, pad, spacing, vertical ? (byte)1 : (byte)0, (ImDrawList*)pdrawList);
					return ret != 0;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ShowAltLegend")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotShowAltLegendNative(byte* titleId, byte vertical, Vector2 size, byte interactable);

		public static void ImPlotShowAltLegend(byte* titleId, bool vertical, Vector2 size, bool interactable)
		{
			ImPlotShowAltLegendNative(titleId, vertical ? (byte)1 : (byte)0, size, interactable ? (byte)1 : (byte)0);
		}

		public static void ImPlotShowAltLegend(ref byte titleId, bool vertical, Vector2 size, bool interactable)
		{
			fixed (byte* ptitleId = &titleId)
			{
				ImPlotShowAltLegendNative((byte*)ptitleId, vertical ? (byte)1 : (byte)0, size, interactable ? (byte)1 : (byte)0);
			}
		}

		public static void ImPlotShowAltLegend(string titleId, bool vertical, Vector2 size, bool interactable)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (titleId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(titleId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(titleId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotShowAltLegendNative(pStr0, vertical ? (byte)1 : (byte)0, size, interactable ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ShowLegendContextMenu")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotShowLegendContextMenuNative(ImPlotLegend* legend, byte visible);

		public static bool ImPlotShowLegendContextMenu(ImPlotLegendPtr legend, bool visible)
		{
			byte ret = ImPlotShowLegendContextMenuNative(legend, visible ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool ImPlotShowLegendContextMenu(ref ImPlotLegend legend, bool visible)
		{
			fixed (ImPlotLegend* plegend = &legend)
			{
				byte ret = ImPlotShowLegendContextMenuNative((ImPlotLegend*)plegend, visible ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_LabelAxisValue")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotLabelAxisValueNative(ImPlotAxis axis, double value, byte* buff, int size, byte round);

		public static void ImPlotLabelAxisValue(ImPlotAxis axis, double value, byte* buff, int size, bool round)
		{
			ImPlotLabelAxisValueNative(axis, value, buff, size, round ? (byte)1 : (byte)0);
		}

		public static void ImPlotLabelAxisValue(ImPlotAxis axis, double value, ref byte buff, int size, bool round)
		{
			fixed (byte* pbuff = &buff)
			{
				ImPlotLabelAxisValueNative(axis, value, (byte*)pbuff, size, round ? (byte)1 : (byte)0);
			}
		}

		public static void ImPlotLabelAxisValue(ImPlotAxis axis, double value, ref string buff, int size, bool round)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotLabelAxisValueNative(axis, value, pStr0, size, round ? (byte)1 : (byte)0);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetItemData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImPlotNextItemData* ImPlotGetItemDataNative();

		public static ImPlotNextItemDataPtr ImPlotGetItemData()
		{
			ImPlotNextItemDataPtr ret = ImPlotGetItemDataNative();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_IsColorAuto_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotIsColorAutoVec4Native(Vector4 col);

		public static bool ImPlotIsColorAutoVec4(Vector4 col)
		{
			byte ret = ImPlotIsColorAutoVec4Native(col);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_IsColorAuto_PlotCol")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotIsColorAutoPlotColNative(ImPlotCol idx);

		public static bool ImPlotIsColorAutoPlotCol(ImPlotCol idx)
		{
			byte ret = ImPlotIsColorAutoPlotColNative(idx);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetAutoColor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotGetAutoColorNative(Vector4* output, ImPlotCol idx);

		public static Vector4 ImPlotGetAutoColor(ImPlotCol idx)
		{
			Vector4 ret;
			ImPlotGetAutoColorNative(&ret, idx);
			return ret;
		}

		public static void ImPlotGetAutoColor(Vector4* output, ImPlotCol idx)
		{
			ImPlotGetAutoColorNative(output, idx);
		}

		public static void ImPlotGetAutoColor(ref Vector4 output, ImPlotCol idx)
		{
			fixed (Vector4* poutput = &output)
			{
				ImPlotGetAutoColorNative((Vector4*)poutput, idx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetStyleColorVec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotGetStyleColorVec4Native(Vector4* output, ImPlotCol idx);

		public static Vector4 ImPlotGetStyleColorVec4(ImPlotCol idx)
		{
			Vector4 ret;
			ImPlotGetStyleColorVec4Native(&ret, idx);
			return ret;
		}

		public static void ImPlotGetStyleColorVec4(Vector4* output, ImPlotCol idx)
		{
			ImPlotGetStyleColorVec4Native(output, idx);
		}

		public static void ImPlotGetStyleColorVec4(ref Vector4 output, ImPlotCol idx)
		{
			fixed (Vector4* poutput = &output)
			{
				ImPlotGetStyleColorVec4Native((Vector4*)poutput, idx);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetStyleColorU32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImPlotGetStyleColorU32Native(ImPlotCol idx);

		public static uint ImPlotGetStyleColorU32(ImPlotCol idx)
		{
			uint ret = ImPlotGetStyleColorU32Native(idx);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_AddTextVertical")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAddTextVerticalNative(ImDrawList* drawList, Vector2 pos, uint col, byte* textBegin, byte* textEnd);

		public static void ImPlotAddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			ImPlotAddTextVerticalNative(drawList, pos, col, textBegin, textEnd);
		}

		public static void ImPlotAddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImPlotAddTextVerticalNative((ImDrawList*)pdrawList, pos, col, textBegin, textEnd);
			}
		}

		public static void ImPlotAddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImPlotAddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		public static void ImPlotAddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotAddTextVerticalNative(drawList, pos, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImPlotAddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImPlotAddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		public static void ImPlotAddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotAddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImPlotAddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImPlotAddTextVerticalNative(drawList, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		public static void ImPlotAddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotAddTextVerticalNative(drawList, pos, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImPlotAddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImPlotAddTextVerticalNative((ImDrawList*)pdrawList, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		public static void ImPlotAddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotAddTextVerticalNative((ImDrawList*)pdrawList, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImPlotAddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImPlotAddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		public static void ImPlotAddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImPlotAddTextVerticalNative(drawList, pos, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImPlotAddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImPlotAddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void ImPlotAddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImPlotAddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_AddTextCentered")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAddTextCenteredNative(ImDrawList* drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd);

		public static void ImPlotAddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd)
		{
			ImPlotAddTextCenteredNative(drawList, topCenter, col, textBegin, textEnd);
		}

		public static void ImPlotAddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImPlotAddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, textEnd);
			}
		}

		public static void ImPlotAddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImPlotAddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, textEnd);
			}
		}

		public static void ImPlotAddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotAddTextCenteredNative(drawList, topCenter, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImPlotAddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImPlotAddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		public static void ImPlotAddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotAddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImPlotAddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImPlotAddTextCenteredNative(drawList, topCenter, col, textBegin, (byte*)ptextEnd);
			}
		}

		public static void ImPlotAddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImPlotAddTextCenteredNative(drawList, topCenter, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImPlotAddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImPlotAddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		public static void ImPlotAddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotAddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImPlotAddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImPlotAddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		public static void ImPlotAddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImPlotAddTextCenteredNative(drawList, topCenter, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImPlotAddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImPlotAddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void ImPlotAddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImPlotAddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalcTextSizeVertical")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalcTextSizeVerticalNative(Vector2* output, byte* text);

		public static Vector2 ImPlotCalcTextSizeVertical(byte* text)
		{
			Vector2 ret;
			ImPlotCalcTextSizeVerticalNative(&ret, text);
			return ret;
		}

		public static void ImPlotCalcTextSizeVertical(Vector2* output, byte* text)
		{
			ImPlotCalcTextSizeVerticalNative(output, text);
		}

		public static void ImPlotCalcTextSizeVertical(ref Vector2 output, byte* text)
		{
			fixed (Vector2* poutput = &output)
			{
				ImPlotCalcTextSizeVerticalNative((Vector2*)poutput, text);
			}
		}

		public static Vector2 ImPlotCalcTextSizeVertical(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				Vector2 ret;
				ImPlotCalcTextSizeVerticalNative(&ret, (byte*)ptext);
				return ret;
			}
		}

		public static Vector2 ImPlotCalcTextSizeVertical(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			ImPlotCalcTextSizeVerticalNative(&ret, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void ImPlotCalcTextSizeVertical(ref Vector2 output, ref byte text)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					ImPlotCalcTextSizeVerticalNative((Vector2*)poutput, (byte*)ptext);
				}
			}
		}

		public static void ImPlotCalcTextSizeVertical(ref Vector2 output, string text)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImPlotCalcTextSizeVerticalNative((Vector2*)poutput, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalcTextColor_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImPlotCalcTextColorVec4Native(Vector4 bg);

		public static uint ImPlotCalcTextColorVec4(Vector4 bg)
		{
			uint ret = ImPlotCalcTextColorVec4Native(bg);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalcTextColor_U32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImPlotCalcTextColorU32Native(uint bg);

		public static uint ImPlotCalcTextColorU32(uint bg)
		{
			uint ret = ImPlotCalcTextColorU32Native(bg);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalcHoverColor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImPlotCalcHoverColorNative(uint col);

		public static uint ImPlotCalcHoverColor(uint col)
		{
			uint ret = ImPlotCalcHoverColorNative(col);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ClampLabelPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotClampLabelPosNative(Vector2* output, Vector2 pos, Vector2 size, Vector2 min, Vector2 max);

		public static Vector2 ImPlotClampLabelPos(Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			Vector2 ret;
			ImPlotClampLabelPosNative(&ret, pos, size, min, max);
			return ret;
		}

		public static void ImPlotClampLabelPos(Vector2* output, Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			ImPlotClampLabelPosNative(output, pos, size, min, max);
		}

		public static void ImPlotClampLabelPos(ref Vector2 output, Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			fixed (Vector2* poutput = &output)
			{
				ImPlotClampLabelPosNative((Vector2*)poutput, pos, size, min, max);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetColormapColorU32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImPlotGetColormapColorU32Native(int idx, ImPlotColormap cmap);

		public static uint ImPlotGetColormapColorU32(int idx, ImPlotColormap cmap)
		{
			uint ret = ImPlotGetColormapColorU32Native(idx, cmap);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_NextColormapColorU32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImPlotNextColormapColorU32Native();

		public static uint ImPlotNextColormapColorU32()
		{
			uint ret = ImPlotNextColormapColorU32Native();
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_SampleColormapU32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImPlotSampleColormapU32Native(float t, ImPlotColormap cmap);

		public static uint ImPlotSampleColormapU32(float t, ImPlotColormap cmap)
		{
			uint ret = ImPlotSampleColormapU32Native(t, cmap);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_RenderColorBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotRenderColorBarNative(uint* colors, int size, ImDrawList* drawList, ImRect bounds, byte vert, byte reversed, byte continuous);

		public static void ImPlotRenderColorBar(uint* colors, int size, ImDrawListPtr drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			ImPlotRenderColorBarNative(colors, size, drawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
		}

		public static void ImPlotRenderColorBar(ref uint colors, int size, ImDrawListPtr drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (uint* pcolors = &colors)
			{
				ImPlotRenderColorBarNative((uint*)pcolors, size, drawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
			}
		}

		public static void ImPlotRenderColorBar(uint* colors, int size, ref ImDrawList drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImPlotRenderColorBarNative(colors, size, (ImDrawList*)pdrawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
			}
		}

		public static void ImPlotRenderColorBar(ref uint colors, int size, ref ImDrawList drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (uint* pcolors = &colors)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImPlotRenderColorBarNative((uint*)pcolors, size, (ImDrawList*)pdrawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_NiceNum")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPlotNiceNumNative(double x, byte round);

		public static double ImPlotNiceNum(double x, bool round)
		{
			double ret = ImPlotNiceNumNative(x, round ? (byte)1 : (byte)0);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_OrderOfMagnitude")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotOrderOfMagnitudeNative(double val);

		public static int ImPlotOrderOfMagnitude(double val)
		{
			int ret = ImPlotOrderOfMagnitudeNative(val);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_OrderToPrecision")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotOrderToPrecisionNative(int order);

		public static int ImPlotOrderToPrecision(int order)
		{
			int ret = ImPlotOrderToPrecisionNative(order);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Precision")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotPrecisionNative(double val);

		public static int ImPlotPrecision(double val)
		{
			int ret = ImPlotPrecisionNative(val);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_RoundTo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPlotRoundToNative(double val, int prec);

		public static double ImPlotRoundTo(double val, int prec)
		{
			double ret = ImPlotRoundToNative(val, prec);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Intersection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotIntersectionNative(Vector2* output, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2);

		public static Vector2 ImPlotIntersection(Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			Vector2 ret;
			ImPlotIntersectionNative(&ret, a1, a2, b1, b2);
			return ret;
		}

		public static void ImPlotIntersection(Vector2* output, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			ImPlotIntersectionNative(output, a1, a2, b1, b2);
		}

		public static void ImPlotIntersection(ref Vector2 output, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			fixed (Vector2* poutput = &output)
			{
				ImPlotIntersectionNative((Vector2*)poutput, a1, a2, b1, b2);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_Float_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorFloatPtrNative(ImVectorFloat* buffer, int n, float vmin, float vmax);

		public static void ImPlotFillRangeVectorFloatPtr(ImVectorFloat* buffer, int n, float vmin, float vmax)
		{
			ImPlotFillRangeVectorFloatPtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorFloatPtr(ref ImVectorFloat buffer, int n, float vmin, float vmax)
		{
			fixed (ImVectorFloat* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorFloatPtrNative((ImVectorFloat*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_double_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorDoublePtrNative(ImVectorDouble* buffer, int n, double vmin, double vmax);

		public static void ImPlotFillRangeVectorDoublePtr(ImVectorDoublePtr buffer, int n, double vmin, double vmax)
		{
			ImPlotFillRangeVectorDoublePtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorDoublePtr(ref ImVectorDouble buffer, int n, double vmin, double vmax)
		{
			fixed (ImVectorDouble* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorDoublePtrNative((ImVectorDouble*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_S8_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorS8PtrNative(ImVectorImS8* buffer, int n, sbyte vmin, sbyte vmax);

		public static void ImPlotFillRangeVectorS8Ptr(ImVectorImS8Ptr buffer, int n, sbyte vmin, sbyte vmax)
		{
			ImPlotFillRangeVectorS8PtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorS8Ptr(ref ImVectorImS8 buffer, int n, sbyte vmin, sbyte vmax)
		{
			fixed (ImVectorImS8* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorS8PtrNative((ImVectorImS8*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_U8_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorU8PtrNative(ImVectorImU8* buffer, int n, byte vmin, byte vmax);

		public static void ImPlotFillRangeVectorU8Ptr(ImVectorImU8Ptr buffer, int n, byte vmin, byte vmax)
		{
			ImPlotFillRangeVectorU8PtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorU8Ptr(ref ImVectorImU8 buffer, int n, byte vmin, byte vmax)
		{
			fixed (ImVectorImU8* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorU8PtrNative((ImVectorImU8*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_S16_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorS16PtrNative(ImVectorImS16* buffer, int n, short vmin, short vmax);

		public static void ImPlotFillRangeVectorS16Ptr(ImVectorImS16Ptr buffer, int n, short vmin, short vmax)
		{
			ImPlotFillRangeVectorS16PtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorS16Ptr(ref ImVectorImS16 buffer, int n, short vmin, short vmax)
		{
			fixed (ImVectorImS16* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorS16PtrNative((ImVectorImS16*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_U16_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorU16PtrNative(ImVectorImU16* buffer, int n, ushort vmin, ushort vmax);

		public static void ImPlotFillRangeVectorU16Ptr(ImVectorImU16Ptr buffer, int n, ushort vmin, ushort vmax)
		{
			ImPlotFillRangeVectorU16PtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorU16Ptr(ref ImVectorImU16 buffer, int n, ushort vmin, ushort vmax)
		{
			fixed (ImVectorImU16* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorU16PtrNative((ImVectorImU16*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_S32_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorS32PtrNative(ImVectorImS32* buffer, int n, int vmin, int vmax);

		public static void ImPlotFillRangeVectorS32Ptr(ImVectorImS32Ptr buffer, int n, int vmin, int vmax)
		{
			ImPlotFillRangeVectorS32PtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorS32Ptr(ref ImVectorImS32 buffer, int n, int vmin, int vmax)
		{
			fixed (ImVectorImS32* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorS32PtrNative((ImVectorImS32*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_U32_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorU32PtrNative(ImVectorImU32* buffer, int n, uint vmin, uint vmax);

		public static void ImPlotFillRangeVectorU32Ptr(ImVectorImU32* buffer, int n, uint vmin, uint vmax)
		{
			ImPlotFillRangeVectorU32PtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorU32Ptr(ref ImVectorImU32 buffer, int n, uint vmin, uint vmax)
		{
			fixed (ImVectorImU32* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorU32PtrNative((ImVectorImU32*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_S64_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorS64PtrNative(ImVectorImS64* buffer, int n, long vmin, long vmax);

		public static void ImPlotFillRangeVectorS64Ptr(ImVectorImS64Ptr buffer, int n, long vmin, long vmax)
		{
			ImPlotFillRangeVectorS64PtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorS64Ptr(ref ImVectorImS64 buffer, int n, long vmin, long vmax)
		{
			fixed (ImVectorImS64* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorS64PtrNative((ImVectorImS64*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FillRange_Vector_U64_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFillRangeVectorU64PtrNative(ImVectorImU64* buffer, int n, ulong vmin, ulong vmax);

		public static void ImPlotFillRangeVectorU64Ptr(ImVectorImU64Ptr buffer, int n, ulong vmin, ulong vmax)
		{
			ImPlotFillRangeVectorU64PtrNative(buffer, n, vmin, vmax);
		}

		public static void ImPlotFillRangeVectorU64Ptr(ref ImVectorImU64 buffer, int n, ulong vmin, ulong vmax)
		{
			fixed (ImVectorImU64* pbuffer = &buffer)
			{
				ImPlotFillRangeVectorU64PtrNative((ImVectorImU64*)pbuffer, n, vmin, vmax);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_FloatPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsFloatPtrNative(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsFloatPtr(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsFloatPtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsFloatPtr(ref float values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (float* pvalues = &values)
			{
				ImPlotCalculateBinsFloatPtrNative((float*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsFloatPtr(float* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsFloatPtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsFloatPtr(ref float values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsFloatPtrNative((float*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsFloatPtr(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsFloatPtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsFloatPtr(ref float values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsFloatPtrNative((float*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsFloatPtr(float* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsFloatPtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsFloatPtr(ref float values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsFloatPtrNative((float*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_doublePtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsDoublePtrNative(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsDoublePtr(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsDoublePtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsDoublePtr(ref double values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (double* pvalues = &values)
			{
				ImPlotCalculateBinsDoublePtrNative((double*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsDoublePtr(double* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsDoublePtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsDoublePtr(ref double values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsDoublePtrNative((double*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsDoublePtr(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsDoublePtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsDoublePtr(ref double values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsDoublePtrNative((double*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsDoublePtr(double* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsDoublePtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsDoublePtr(ref double values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsDoublePtrNative((double*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_S8Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsS8PtrNative(sbyte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsS8Ptr(sbyte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsS8PtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsS8Ptr(ref sbyte values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (sbyte* pvalues = &values)
			{
				ImPlotCalculateBinsS8PtrNative((sbyte*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsS8Ptr(sbyte* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsS8PtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsS8Ptr(ref sbyte values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (sbyte* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsS8PtrNative((sbyte*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS8Ptr(sbyte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsS8PtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsS8Ptr(ref sbyte values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (sbyte* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsS8PtrNative((sbyte*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS8Ptr(sbyte* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsS8PtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS8Ptr(ref sbyte values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (sbyte* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsS8PtrNative((sbyte*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_U8Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsU8PtrNative(byte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsU8Ptr(byte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsU8PtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsU8Ptr(ref byte values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (byte* pvalues = &values)
			{
				ImPlotCalculateBinsU8PtrNative((byte*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsU8Ptr(byte* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsU8PtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsU8Ptr(ref byte values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsU8PtrNative((byte*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU8Ptr(byte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsU8PtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsU8Ptr(ref byte values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsU8PtrNative((byte*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU8Ptr(byte* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsU8PtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU8Ptr(ref byte values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsU8PtrNative((byte*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_S16Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsS16PtrNative(short* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsS16Ptr(short* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsS16PtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsS16Ptr(ref short values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (short* pvalues = &values)
			{
				ImPlotCalculateBinsS16PtrNative((short*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsS16Ptr(short* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsS16PtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsS16Ptr(ref short values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsS16PtrNative((short*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS16Ptr(short* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsS16PtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsS16Ptr(ref short values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsS16PtrNative((short*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS16Ptr(short* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsS16PtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS16Ptr(ref short values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsS16PtrNative((short*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_U16Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsU16PtrNative(ushort* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsU16Ptr(ushort* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsU16PtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsU16Ptr(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (ushort* pvalues = &values)
			{
				ImPlotCalculateBinsU16PtrNative((ushort*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsU16Ptr(ushort* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsU16PtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsU16Ptr(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsU16PtrNative((ushort*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU16Ptr(ushort* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsU16PtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsU16Ptr(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsU16PtrNative((ushort*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU16Ptr(ushort* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsU16PtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU16Ptr(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsU16PtrNative((ushort*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_S32Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsS32PtrNative(int* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsS32Ptr(int* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsS32PtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsS32Ptr(ref int values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (int* pvalues = &values)
			{
				ImPlotCalculateBinsS32PtrNative((int*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsS32Ptr(int* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsS32PtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsS32Ptr(ref int values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsS32PtrNative((int*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS32Ptr(int* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsS32PtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsS32Ptr(ref int values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsS32PtrNative((int*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS32Ptr(int* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsS32PtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS32Ptr(ref int values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsS32PtrNative((int*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_U32Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsU32PtrNative(uint* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsU32Ptr(uint* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsU32PtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsU32Ptr(ref uint values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				ImPlotCalculateBinsU32PtrNative((uint*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsU32Ptr(uint* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsU32PtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsU32Ptr(ref uint values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsU32PtrNative((uint*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU32Ptr(uint* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsU32PtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsU32Ptr(ref uint values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsU32PtrNative((uint*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU32Ptr(uint* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsU32PtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU32Ptr(ref uint values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsU32PtrNative((uint*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_S64Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsS64PtrNative(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsS64Ptr(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsS64PtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsS64Ptr(ref long values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (long* pvalues = &values)
			{
				ImPlotCalculateBinsS64PtrNative((long*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsS64Ptr(long* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsS64PtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsS64Ptr(ref long values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsS64PtrNative((long*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS64Ptr(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsS64PtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsS64Ptr(ref long values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsS64PtrNative((long*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS64Ptr(long* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsS64PtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsS64Ptr(ref long values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsS64PtrNative((long*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CalculateBins_U64Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCalculateBinsU64PtrNative(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut);

		public static void ImPlotCalculateBinsU64Ptr(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			ImPlotCalculateBinsU64PtrNative(values, count, meth, range, binsOut, widthOut);
		}

		public static void ImPlotCalculateBinsU64Ptr(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				ImPlotCalculateBinsU64PtrNative((ulong*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsU64Ptr(ulong* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				ImPlotCalculateBinsU64PtrNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		public static void ImPlotCalculateBinsU64Ptr(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					ImPlotCalculateBinsU64PtrNative((ulong*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU64Ptr(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				ImPlotCalculateBinsU64PtrNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		public static void ImPlotCalculateBinsU64Ptr(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsU64PtrNative((ulong*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU64Ptr(ulong* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					ImPlotCalculateBinsU64PtrNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		public static void ImPlotCalculateBinsU64Ptr(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						ImPlotCalculateBinsU64PtrNative((ulong*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_IsLeapYear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotIsLeapYearNative(int year);

		public static bool ImPlotIsLeapYear(int year)
		{
			byte ret = ImPlotIsLeapYearNative(year);
			return ret != 0;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetDaysInMonth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotGetDaysInMonthNative(int year, int month);

		public static int ImPlotGetDaysInMonth(int year, int month)
		{
			int ret = ImPlotGetDaysInMonthNative(year, month);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_MkGmtTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotMkGmtTimeNative(ImPlotTime* output, Tm* ptm);

		public static ImPlotTime ImPlotMkGmtTime(Tm* ptm)
		{
			ImPlotTime ret;
			ImPlotMkGmtTimeNative(&ret, ptm);
			return ret;
		}

		public static void ImPlotMkGmtTime(ImPlotTimePtr output, Tm* ptm)
		{
			ImPlotMkGmtTimeNative(output, ptm);
		}

		public static void ImPlotMkGmtTime(ref ImPlotTime output, Tm* ptm)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				ImPlotMkGmtTimeNative((ImPlotTime*)poutput, ptm);
			}
		}

		public static ImPlotTime ImPlotMkGmtTime(ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotTime ret;
				ImPlotMkGmtTimeNative(&ret, (Tm*)pptm);
				return ret;
			}
		}

		public static void ImPlotMkGmtTime(ImPlotTimePtr output, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotMkGmtTimeNative(output, (Tm*)pptm);
			}
		}

		public static void ImPlotMkGmtTime(ref ImPlotTime output, ref Tm ptm)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				fixed (Tm* pptm = &ptm)
				{
					ImPlotMkGmtTimeNative((ImPlotTime*)poutput, (Tm*)pptm);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetGmtTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Tm* ImPlotGetGmtTimeNative(ImPlotTime t, Tm* ptm);

		public static Tm* ImPlotGetGmtTime(ImPlotTime t, Tm* ptm)
		{
			Tm* ret = ImPlotGetGmtTimeNative(t, ptm);
			return ret;
		}

		public static Tm* ImPlotGetGmtTime(ImPlotTime t, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				Tm* ret = ImPlotGetGmtTimeNative(t, (Tm*)pptm);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_MkLocTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotMkLocTimeNative(ImPlotTime* output, Tm* ptm);

		public static ImPlotTime ImPlotMkLocTime(Tm* ptm)
		{
			ImPlotTime ret;
			ImPlotMkLocTimeNative(&ret, ptm);
			return ret;
		}

		public static void ImPlotMkLocTime(ImPlotTimePtr output, Tm* ptm)
		{
			ImPlotMkLocTimeNative(output, ptm);
		}

		public static void ImPlotMkLocTime(ref ImPlotTime output, Tm* ptm)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				ImPlotMkLocTimeNative((ImPlotTime*)poutput, ptm);
			}
		}

		public static ImPlotTime ImPlotMkLocTime(ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotTime ret;
				ImPlotMkLocTimeNative(&ret, (Tm*)pptm);
				return ret;
			}
		}

		public static void ImPlotMkLocTime(ImPlotTimePtr output, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotMkLocTimeNative(output, (Tm*)pptm);
			}
		}

		public static void ImPlotMkLocTime(ref ImPlotTime output, ref Tm ptm)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				fixed (Tm* pptm = &ptm)
				{
					ImPlotMkLocTimeNative((ImPlotTime*)poutput, (Tm*)pptm);
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetLocTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Tm* ImPlotGetLocTimeNative(ImPlotTime t, Tm* ptm);

		public static Tm* ImPlotGetLocTime(ImPlotTime t, Tm* ptm)
		{
			Tm* ret = ImPlotGetLocTimeNative(t, ptm);
			return ret;
		}

		public static Tm* ImPlotGetLocTime(ImPlotTime t, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				Tm* ret = ImPlotGetLocTimeNative(t, (Tm*)pptm);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_MakeTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotMakeTimeNative(ImPlotTime* output, int year, int month, int day, int hour, int min, int sec, int us);

		public static ImPlotTime ImPlotMakeTime(int year, int month, int day, int hour, int min, int sec, int us)
		{
			ImPlotTime ret;
			ImPlotMakeTimeNative(&ret, year, month, day, hour, min, sec, us);
			return ret;
		}

		public static void ImPlotMakeTime(ImPlotTimePtr output, int year, int month, int day, int hour, int min, int sec, int us)
		{
			ImPlotMakeTimeNative(output, year, month, day, hour, min, sec, us);
		}

		public static void ImPlotMakeTime(ref ImPlotTime output, int year, int month, int day, int hour, int min, int sec, int us)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				ImPlotMakeTimeNative((ImPlotTime*)poutput, year, month, day, hour, min, sec, us);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_GetYear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotGetYearNative(ImPlotTime t);

		public static int ImPlotGetYear(ImPlotTime t)
		{
			int ret = ImPlotGetYearNative(t);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_AddTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotAddTimeNative(ImPlotTime* output, ImPlotTime t, ImPlotTimeUnit unit, int count);

		public static ImPlotTime ImPlotAddTime(ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			ImPlotTime ret;
			ImPlotAddTimeNative(&ret, t, unit, count);
			return ret;
		}

		public static void ImPlotAddTime(ImPlotTimePtr output, ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			ImPlotAddTimeNative(output, t, unit, count);
		}

		public static void ImPlotAddTime(ref ImPlotTime output, ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				ImPlotAddTimeNative((ImPlotTime*)poutput, t, unit, count);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FloorTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotFloorTimeNative(ImPlotTime* output, ImPlotTime t, ImPlotTimeUnit unit);

		public static ImPlotTime ImPlotFloorTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			ImPlotFloorTimeNative(&ret, t, unit);
			return ret;
		}

		public static void ImPlotFloorTime(ImPlotTimePtr output, ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotFloorTimeNative(output, t, unit);
		}

		public static void ImPlotFloorTime(ref ImPlotTime output, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				ImPlotFloorTimeNative((ImPlotTime*)poutput, t, unit);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CeilTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCeilTimeNative(ImPlotTime* output, ImPlotTime t, ImPlotTimeUnit unit);

		public static ImPlotTime ImPlotCeilTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			ImPlotCeilTimeNative(&ret, t, unit);
			return ret;
		}

		public static void ImPlotCeilTime(ImPlotTimePtr output, ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotCeilTimeNative(output, t, unit);
		}

		public static void ImPlotCeilTime(ref ImPlotTime output, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				ImPlotCeilTimeNative((ImPlotTime*)poutput, t, unit);
			}
		}
	}
}
