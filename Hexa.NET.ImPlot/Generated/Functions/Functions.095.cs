// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;
using Hexa.NET.ImGui;

namespace Hexa.NET.ImPlot
{
	public unsafe partial class ImPlot
	{

		[LibraryImport(LibName, EntryPoint = "ImPlot_RoundTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotRoundTimeNative(ImPlotTime* output, ImPlotTime t, ImPlotTimeUnit unit);

		public static ImPlotTime ImPlotRoundTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			ImPlotRoundTimeNative(&ret, t, unit);
			return ret;
		}

		public static void ImPlotRoundTime(ImPlotTimePtr output, ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotRoundTimeNative(output, t, unit);
		}

		public static void ImPlotRoundTime(ref ImPlotTime output, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				ImPlotRoundTimeNative((ImPlotTime*)poutput, t, unit);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_CombineDateTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotCombineDateTimeNative(ImPlotTime* output, ImPlotTime datePart, ImPlotTime timePart);

		public static ImPlotTime ImPlotCombineDateTime(ImPlotTime datePart, ImPlotTime timePart)
		{
			ImPlotTime ret;
			ImPlotCombineDateTimeNative(&ret, datePart, timePart);
			return ret;
		}

		public static void ImPlotCombineDateTime(ImPlotTimePtr output, ImPlotTime datePart, ImPlotTime timePart)
		{
			ImPlotCombineDateTimeNative(output, datePart, timePart);
		}

		public static void ImPlotCombineDateTime(ref ImPlotTime output, ImPlotTime datePart, ImPlotTime timePart)
		{
			fixed (ImPlotTime* poutput = &output)
			{
				ImPlotCombineDateTimeNative((ImPlotTime*)poutput, datePart, timePart);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FormatTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotFormatTimeNative(ImPlotTime t, byte* buffer, int size, ImPlotTimeFmt fmt, byte use24HrClk);

		public static int ImPlotFormatTime(ImPlotTime t, byte* buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			int ret = ImPlotFormatTimeNative(t, buffer, size, fmt, use24HrClk ? (byte)1 : (byte)0);
			return ret;
		}

		public static int ImPlotFormatTime(ImPlotTime t, ref byte buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = ImPlotFormatTimeNative(t, (byte*)pbuffer, size, fmt, use24HrClk ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public static int ImPlotFormatTime(ImPlotTime t, ref string buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImPlotFormatTimeNative(t, pStr0, size, fmt, use24HrClk ? (byte)1 : (byte)0);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FormatDate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotFormatDateNative(ImPlotTime t, byte* buffer, int size, ImPlotDateFmt fmt, byte useIso8601);

		public static int ImPlotFormatDate(ImPlotTime t, byte* buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			int ret = ImPlotFormatDateNative(t, buffer, size, fmt, useIso8601 ? (byte)1 : (byte)0);
			return ret;
		}

		public static int ImPlotFormatDate(ImPlotTime t, ref byte buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = ImPlotFormatDateNative(t, (byte*)pbuffer, size, fmt, useIso8601 ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public static int ImPlotFormatDate(ImPlotTime t, ref string buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImPlotFormatDateNative(t, pStr0, size, fmt, useIso8601 ? (byte)1 : (byte)0);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_FormatDateTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotFormatDateTimeNative(ImPlotTime t, byte* buffer, int size, ImPlotDateTimeSpec fmt);

		public static int ImPlotFormatDateTime(ImPlotTime t, byte* buffer, int size, ImPlotDateTimeSpec fmt)
		{
			int ret = ImPlotFormatDateTimeNative(t, buffer, size, fmt);
			return ret;
		}

		public static int ImPlotFormatDateTime(ImPlotTime t, ref byte buffer, int size, ImPlotDateTimeSpec fmt)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = ImPlotFormatDateTimeNative(t, (byte*)pbuffer, size, fmt);
				return ret;
			}
		}

		public static int ImPlotFormatDateTime(ImPlotTime t, ref string buffer, int size, ImPlotDateTimeSpec fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImPlotFormatDateTimeNative(t, pStr0, size, fmt);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ShowDatePicker")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotShowDatePickerNative(byte* id, int* level, ImPlotTime* t, ImPlotTime* t1, ImPlotTime* t2);

		public static bool ImPlotShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte ret = ImPlotShowDatePickerNative(id, level, t, t1, t2);
			return ret != 0;
		}

		public static bool ImPlotShowDatePicker(ref byte id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ImPlotShowDatePickerNative((byte*)pid, level, t, t1, t2);
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(string id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImPlotShowDatePickerNative(pStr0, level, t, t1, t2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImPlotShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				byte ret = ImPlotShowDatePickerNative(id, (int*)plevel, t, t1, t2);
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ImPlotShowDatePickerNative((byte*)pid, (int*)plevel, t, t1, t2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				byte ret = ImPlotShowDatePickerNative(pStr0, (int*)plevel, t, t1, t2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ImPlotShowDatePickerNative(id, level, (ImPlotTime*)pt, t1, t2);
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ImPlotShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, t1, t2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ImPlotShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, t1, t2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ImPlotShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, t1, t2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ImPlotShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, t1, t2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ImPlotShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, t1, t2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (ImPlotTime* pt1 = &t1)
			{
				byte ret = ImPlotShowDatePickerNative(id, level, t, (ImPlotTime*)pt1, t2);
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, int* level, ImPlotTimePtr t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ImPlotShowDatePickerNative((byte*)pid, level, t, (ImPlotTime*)pt1, t2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, int* level, ImPlotTimePtr t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt1 = &t1)
			{
				byte ret = ImPlotShowDatePickerNative(pStr0, level, t, (ImPlotTime*)pt1, t2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ImPlotShowDatePickerNative(id, (int*)plevel, t, (ImPlotTime*)pt1, t2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ImPlotShowDatePickerNative((byte*)pid, (int*)plevel, t, (ImPlotTime*)pt1, t2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ImPlotShowDatePickerNative(pStr0, (int*)plevel, t, (ImPlotTime*)pt1, t2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ImPlotShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, t2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ImPlotShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, t2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					byte ret = ImPlotShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, t2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ImPlotShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, t2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							byte ret = ImPlotShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, t2);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						byte ret = ImPlotShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, t2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			fixed (ImPlotTime* pt2 = &t2)
			{
				byte ret = ImPlotShowDatePickerNative(id, level, t, t1, (ImPlotTime*)pt2);
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ImPlotShowDatePickerNative((byte*)pid, level, t, t1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt2 = &t2)
			{
				byte ret = ImPlotShowDatePickerNative(pStr0, level, t, t1, (ImPlotTime*)pt2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ImPlotShowDatePickerNative(id, (int*)plevel, t, t1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative((byte*)pid, (int*)plevel, t, t1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ImPlotShowDatePickerNative(pStr0, (int*)plevel, t, t1, (ImPlotTime*)pt2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ImPlotShowDatePickerNative(id, level, (ImPlotTime*)pt, t1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, t1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ImPlotShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, t1, (ImPlotTime*)pt2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, t1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ImPlotShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, t1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, t1, (ImPlotTime*)pt2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (ImPlotTime* pt1 = &t1)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ImPlotShowDatePickerNative(id, level, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, int* level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative((byte*)pid, level, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, int* level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt1 = &t1)
			{
				fixed (ImPlotTime* pt2 = &t2)
				{
					byte ret = ImPlotShowDatePickerNative(pStr0, level, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative(id, (int*)plevel, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ImPlotShowDatePickerNative((byte*)pid, (int*)plevel, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative(pStr0, (int*)plevel, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ImPlotShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ImPlotShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ImPlotShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(ref byte id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							fixed (ImPlotTime* pt2 = &t2)
							{
								byte ret = ImPlotShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		public static bool ImPlotShowDatePicker(string id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ImPlotShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
							return ret != 0;
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_ShowTimePicker")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImPlotShowTimePickerNative(byte* id, ImPlotTime* t);

		public static bool ImPlotShowTimePicker(byte* id, ImPlotTimePtr t)
		{
			byte ret = ImPlotShowTimePickerNative(id, t);
			return ret != 0;
		}

		public static bool ImPlotShowTimePicker(ref byte id, ImPlotTimePtr t)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ImPlotShowTimePickerNative((byte*)pid, t);
				return ret != 0;
			}
		}

		public static bool ImPlotShowTimePicker(string id, ImPlotTimePtr t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImPlotShowTimePickerNative(pStr0, t);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImPlotShowTimePicker(byte* id, ref ImPlotTime t)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ImPlotShowTimePickerNative(id, (ImPlotTime*)pt);
				return ret != 0;
			}
		}

		public static bool ImPlotShowTimePicker(ref byte id, ref ImPlotTime t)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ImPlotShowTimePickerNative((byte*)pid, (ImPlotTime*)pt);
					return ret != 0;
				}
			}
		}

		public static bool ImPlotShowTimePicker(string id, ref ImPlotTime t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ImPlotShowTimePickerNative(pStr0, (ImPlotTime*)pt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_TransformForward_Log10")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPlotTransformForwardLog10Native(double v, void* noname1);

		public static double ImPlotTransformForwardLog10(double v, void* noname1)
		{
			double ret = ImPlotTransformForwardLog10Native(v, noname1);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_TransformInverse_Log10")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPlotTransformInverseLog10Native(double v, void* noname1);

		public static double ImPlotTransformInverseLog10(double v, void* noname1)
		{
			double ret = ImPlotTransformInverseLog10Native(v, noname1);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_TransformForward_SymLog")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPlotTransformForwardSymLogNative(double v, void* noname1);

		public static double ImPlotTransformForwardSymLog(double v, void* noname1)
		{
			double ret = ImPlotTransformForwardSymLogNative(v, noname1);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_TransformInverse_SymLog")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPlotTransformInverseSymLogNative(double v, void* noname1);

		public static double ImPlotTransformInverseSymLog(double v, void* noname1)
		{
			double ret = ImPlotTransformInverseSymLogNative(v, noname1);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_TransformForward_Logit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPlotTransformForwardLogitNative(double v, void* noname1);

		public static double ImPlotTransformForwardLogit(double v, void* noname1)
		{
			double ret = ImPlotTransformForwardLogitNative(v, noname1);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_TransformInverse_Logit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPlotTransformInverseLogitNative(double v, void* noname1);

		public static double ImPlotTransformInverseLogit(double v, void* noname1)
		{
			double ret = ImPlotTransformInverseLogitNative(v, noname1);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Formatter_Default")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotFormatterDefaultNative(double value, byte* buff, int size, void* data);

		public static int ImPlotFormatterDefault(double value, byte* buff, int size, void* data)
		{
			int ret = ImPlotFormatterDefaultNative(value, buff, size, data);
			return ret;
		}

		public static int ImPlotFormatterDefault(double value, ref byte buff, int size, void* data)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = ImPlotFormatterDefaultNative(value, (byte*)pbuff, size, data);
				return ret;
			}
		}

		public static int ImPlotFormatterDefault(double value, ref string buff, int size, void* data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImPlotFormatterDefaultNative(value, pStr0, size, data);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Formatter_Logit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotFormatterLogitNative(double value, byte* buff, int size, void* noname1);

		public static int ImPlotFormatterLogit(double value, byte* buff, int size, void* noname1)
		{
			int ret = ImPlotFormatterLogitNative(value, buff, size, noname1);
			return ret;
		}

		public static int ImPlotFormatterLogit(double value, ref byte buff, int size, void* noname1)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = ImPlotFormatterLogitNative(value, (byte*)pbuff, size, noname1);
				return ret;
			}
		}

		public static int ImPlotFormatterLogit(double value, ref string buff, int size, void* noname1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImPlotFormatterLogitNative(value, pStr0, size, noname1);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Formatter_Time")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImPlotFormatterTimeNative(double noname1, byte* buff, int size, void* data);

		public static int ImPlotFormatterTime(double noname1, byte* buff, int size, void* data)
		{
			int ret = ImPlotFormatterTimeNative(noname1, buff, size, data);
			return ret;
		}

		public static int ImPlotFormatterTime(double noname1, ref byte buff, int size, void* data)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = ImPlotFormatterTimeNative(noname1, (byte*)pbuff, size, data);
				return ret;
			}
		}

		public static int ImPlotFormatterTime(double noname1, ref string buff, int size, void* data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImPlotFormatterTimeNative(noname1, pStr0, size, data);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Locator_Default")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotLocatorDefaultNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, ImPlotFormatter formatter, void* formatterData);

		public static void ImPlotLocatorDefault(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			ImPlotLocatorDefaultNative(ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		public static void ImPlotLocatorDefault(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				ImPlotLocatorDefaultNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Locator_Time")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotLocatorTimeNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, ImPlotFormatter formatter, void* formatterData);

		public static void ImPlotLocatorTime(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			ImPlotLocatorTimeNative(ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		public static void ImPlotLocatorTime(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				ImPlotLocatorTimeNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Locator_Log10")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotLocatorLog10Native(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, ImPlotFormatter formatter, void* formatterData);

		public static void ImPlotLocatorLog10(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			ImPlotLocatorLog10Native(ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		public static void ImPlotLocatorLog10(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				ImPlotLocatorLog10Native((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		[LibraryImport(LibName, EntryPoint = "ImPlot_Locator_SymLog")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImPlotLocatorSymLogNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, ImPlotFormatter formatter, void* formatterData);

		public static void ImPlotLocatorSymLog(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			ImPlotLocatorSymLogNative(ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		public static void ImPlotLocatorSymLog(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				ImPlotLocatorSymLogNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

	}
}
