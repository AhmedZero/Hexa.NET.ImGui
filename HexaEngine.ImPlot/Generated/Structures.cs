// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;
using HexaEngine.ImGui;

namespace HexaEngine.ImPlot
{
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotContext
	{
		public ImPoolImPlotPlot Plots;
		public ImPoolImPlotSubplot Subplots;
		public unsafe ImPlotPlot* CurrentPlot;
		public unsafe ImPlotSubplot* CurrentSubplot;
		public unsafe ImPlotItemGroup* CurrentItems;
		public unsafe ImPlotItem* CurrentItem;
		public unsafe ImPlotItem* PreviousItem;
		public ImPlotTicker CTicker;
		public ImPlotAnnotationCollection Annotations;
		public ImPlotTagCollection Tags;
		public bool ChildWindowMade;
		public ImPlotStyle Style;
		public ImVectorImGuiColorMod ColorModifiers;
		public ImVectorImGuiStyleMod StyleModifiers;
		public ImPlotColormapData ColormapData;
		public ImVectorImPlotColormap ColormapModifiers;
		public Tm Tm;
		public ImVectorDouble TempDouble1;
		public ImVectorDouble TempDouble2;
		public ImVectorInt TempInt1;
		public int DigitalPlotItemCnt;
		public int DigitalPlotOffset;
		public ImPlotNextPlotData NextPlotData;
		public ImPlotNextItemData NextItemData;
		public ImPlotInputMap InputMap;
		public bool OpenContextThisFrame;
		public ImGuiTextBuffer MousePosStringBuilder;
		public unsafe ImPlotItemGroup* SortItems;
		public ImPoolImPlotAlignmentData AlignmentData;
		public unsafe ImPlotAlignmentData* CurrentAlignmentH;
		public unsafe ImPlotAlignmentData* CurrentAlignmentV;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImPlotPlot
	{
		public ImVectorImPlotPlot Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotPlot
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotPlot* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotPlot
	{
		public int ID;
		public ImPlotFlags Flags;
		public ImPlotFlags PreviousFlags;
		public ImPlotLocation MouseTextLocation;
		public ImPlotMouseTextFlags MouseTextFlags;
		public ImPlotAxis Axes_0;
		public ImPlotAxis Axes_1;
		public ImPlotAxis Axes_2;
		public ImPlotAxis Axes_3;
		public ImPlotAxis Axes_4;
		public ImPlotAxis Axes_5;
		public ImGuiTextBuffer TextBuffer;
		public ImPlotItemGroup Items;
		public ImAxis CurrentX;
		public ImAxis CurrentY;
		public ImRect FrameRect;
		public ImRect CanvasRect;
		public ImRect PlotRect;
		public ImRect AxesRect;
		public ImRect SelectRect;
		public Vector2 SelectStart;
		public int TitleOffset;
		public bool JustCreated;
		public bool Initialized;
		public bool SetupLocked;
		public bool FitThisFrame;
		public bool Hovered;
		public bool Held;
		public bool Selecting;
		public bool Selected;
		public bool ContextLocked;

		public unsafe Span<ImPlotAxis> Axes
		
		{
			get
			{
				fixed (ImPlotAxis* p = &this.Axes_0)
				{
					return new Span<ImPlotAxis>(p, 6);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotAxis
	{
		public int ID;
		public ImPlotAxisFlags Flags;
		public ImPlotAxisFlags PreviousFlags;
		public ImPlotRange Range;
		public ImPlotCond RangeCond;
		public ImPlotScale Scale;
		public ImPlotRange FitExtents;
		public unsafe ImPlotAxis* OrthoAxis;
		public ImPlotRange ConstraintRange;
		public ImPlotRange ConstraintZoom;
		public ImPlotTicker Ticker;
		public unsafe delegate*<double, byte*, int, void*, int> Formatter;
		public unsafe void* FormatterData;
		public unsafe fixed byte FormatSpec[16];
		public unsafe delegate*<ImPlotTicker*, ImPlotRange, float, bool, delegate*<double, byte*, int, void*>, void*, void> Locator;
		public unsafe double* LinkedMin;
		public unsafe double* LinkedMax;
		public int PickerLevel;
		public ImPlotTime PickerTimeMin;
		public ImPlotTime PickerTimeMax;
		public unsafe delegate*<double, void*, double> TransformForward;
		public unsafe delegate*<double, void*, double> TransformInverse;
		public unsafe void* TransformData;
		public float PixelMin;
		public float PixelMax;
		public double ScaleMin;
		public double ScaleMax;
		public double ScaleToPixel;
		public float Datum1;
		public float Datum2;
		public ImRect HoverRect;
		public int LabelOffset;
		public uint ColorMaj;
		public uint ColorMin;
		public uint ColorTick;
		public uint ColorTxt;
		public uint ColorBg;
		public uint ColorHov;
		public uint ColorAct;
		public uint ColorHiLi;
		public bool Enabled;
		public bool Vertical;
		public bool FitThisFrame;
		public bool HasRange;
		public bool HasFormatSpec;
		public bool ShowDefaultTicks;
		public bool Hovered;
		public bool Held;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotRange
	{
		public double Min;
		public double Max;


		public unsafe double Clamp(double value)
		{
			fixed (ImPlotRange* @this = &this)
			{
				double ret = ImPlot.Clamp(@this, value);
				return ret;
			}
		}

		public unsafe bool Contains(double value)
		{
			fixed (ImPlotRange* @this = &this)
			{
				bool ret = ImPlot.Contains(@this, value);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImPlotRange* @this = &this)
			{
				ImPlot.Destroy(@this);
			}
		}

		public unsafe double Size()
		{
			fixed (ImPlotRange* @this = &this)
			{
				double ret = ImPlot.Size(@this);
				return ret;
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotTicker
	{
		public ImVectorImPlotTick Ticks;
		public ImGuiTextBuffer TextBuffer;
		public Vector2 MaxSize;
		public Vector2 LateSize;
		public int Levels;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotTick
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotTick* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotTick
	{
		public double PlotPos;
		public float PixelPos;
		public Vector2 LabelSize;
		public int TextOffset;
		public bool Major;
		public bool ShowLabel;
		public int Level;
		public int Idx;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotTime
	{
		public long S;
		public int Us;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotItemGroup
	{
		public int ID;
		public ImPlotLegend Legend;
		public ImPoolImPlotItem ItemPool;
		public int ColormapIdx;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotLegend
	{
		public ImPlotLegendFlags Flags;
		public ImPlotLegendFlags PreviousFlags;
		public ImPlotLocation Location;
		public ImPlotLocation PreviousLocation;
		public ImVectorInt Indices;
		public ImGuiTextBuffer Labels;
		public ImRect Rect;
		public bool Hovered;
		public bool Held;
		public bool CanGoInside;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImPlotItem
	{
		public ImVectorImPlotItem Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotItem
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotItem* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotItem
	{
		public int ID;
		public uint Color;
		public ImRect LegendHoverRect;
		public int NameOffset;
		public bool Show;
		public bool LegendHovered;
		public bool SeenThisFrame;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImPlotSubplot
	{
		public ImVectorImPlotSubplot Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotSubplot
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotSubplot* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotSubplot
	{
		public int ID;
		public ImPlotSubplotFlags Flags;
		public ImPlotSubplotFlags PreviousFlags;
		public ImPlotItemGroup Items;
		public int Rows;
		public int Cols;
		public int CurrentIdx;
		public ImRect FrameRect;
		public ImRect GridRect;
		public Vector2 CellSize;
		public ImVectorImPlotAlignmentData RowAlignmentData;
		public ImVectorImPlotAlignmentData ColAlignmentData;
		public ImVectorFloat RowRatios;
		public ImVectorFloat ColRatios;
		public ImVectorImPlotRange RowLinkData;
		public ImVectorImPlotRange ColLinkData;
		public unsafe fixed float TempSizes[2];
		public bool FrameHovered;
		public bool HasTitle;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotAlignmentData
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotAlignmentData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotAlignmentData
	{
		public bool Vertical;
		public float PadA;
		public float PadB;
		public float PadAMax;
		public float PadBMax;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotRange
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotRange* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotAnnotationCollection
	{
		public ImVectorImPlotAnnotation Annotations;
		public ImGuiTextBuffer TextBuffer;
		public int Size;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotAnnotation
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotAnnotation* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotAnnotation
	{
		public Vector2 Pos;
		public Vector2 Offset;
		public uint ColorBg;
		public uint ColorFg;
		public int TextOffset;
		public bool Clamp;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotTagCollection
	{
		public ImVectorImPlotTag Tags;
		public ImGuiTextBuffer TextBuffer;
		public int Size;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotTag
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotTag* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotTag
	{
		public ImAxis Axis;
		public double Value;
		public uint ColorBg;
		public uint ColorFg;
		public int TextOffset;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotStyle
	{
		public float LineWeight;
		public int Marker;
		public float MarkerSize;
		public float MarkerWeight;
		public float FillAlpha;
		public float ErrorBarSize;
		public float ErrorBarWeight;
		public float DigitalBitHeight;
		public float DigitalBitGap;
		public float PlotBorderSize;
		public float MinorAlpha;
		public Vector2 MajorTickLen;
		public Vector2 MinorTickLen;
		public Vector2 MajorTickSize;
		public Vector2 MinorTickSize;
		public Vector2 MajorGridSize;
		public Vector2 MinorGridSize;
		public Vector2 PlotPadding;
		public Vector2 LabelPadding;
		public Vector2 LegendPadding;
		public Vector2 LegendInnerPadding;
		public Vector2 LegendSpacing;
		public Vector2 MousePosPadding;
		public Vector2 AnnotationPadding;
		public Vector2 FitPadding;
		public Vector2 PlotDefaultSize;
		public Vector2 PlotMinSize;
		public Vector4 Colors_0;
		public Vector4 Colors_1;
		public Vector4 Colors_2;
		public Vector4 Colors_3;
		public Vector4 Colors_4;
		public Vector4 Colors_5;
		public Vector4 Colors_6;
		public Vector4 Colors_7;
		public Vector4 Colors_8;
		public Vector4 Colors_9;
		public Vector4 Colors_10;
		public Vector4 Colors_11;
		public Vector4 Colors_12;
		public Vector4 Colors_13;
		public Vector4 Colors_14;
		public Vector4 Colors_15;
		public Vector4 Colors_16;
		public Vector4 Colors_17;
		public Vector4 Colors_18;
		public Vector4 Colors_19;
		public Vector4 Colors_20;
		public ImPlotColormap Colormap;
		public bool UseLocalTime;
		public bool UseISO8601;
		public bool Use24HourClock;

		public unsafe Span<Vector4> Colors
		
		{
			get
			{
				fixed (Vector4* p = &this.Colors_0)
				{
					return new Span<Vector4>(p, 21);
				}
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImPlotStyle* @this = &this)
			{
				ImPlot.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotColormapData
	{
		public ImVectorImU32 Keys;
		public ImVectorInt KeyCounts;
		public ImVectorInt KeyOffsets;
		public ImVectorImU32 Tables;
		public ImVectorInt TableSizes;
		public ImVectorInt TableOffsets;
		public ImGuiTextBuffer Text;
		public ImVectorInt TextOffsets;
		public ImVectorBool Quals;
		public ImGuiStorage Map;
		public int Count;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorBool
	{
		public int Size;
		public int Capacity;
		public unsafe bool* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImPlotColormap
	{
		public int Size;
		public int Capacity;
		public unsafe ImPlotColormap* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorDouble
	{
		public int Size;
		public int Capacity;
		public unsafe double* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotNextPlotData
	{
		public unsafe fixed int RangeCond[6];
		public ImPlotRange Range_0;
		public ImPlotRange Range_1;
		public ImPlotRange Range_2;
		public ImPlotRange Range_3;
		public ImPlotRange Range_4;
		public ImPlotRange Range_5;
		public unsafe fixed bool HasRange[6];
		public unsafe fixed bool Fit[6];
		public unsafe double* LinkedMin_0;
		public unsafe double* LinkedMin_1;
		public unsafe double* LinkedMin_2;
		public unsafe double* LinkedMin_3;
		public unsafe double* LinkedMin_4;
		public unsafe double* LinkedMin_5;
		public unsafe double* LinkedMax_0;
		public unsafe double* LinkedMax_1;
		public unsafe double* LinkedMax_2;
		public unsafe double* LinkedMax_3;
		public unsafe double* LinkedMax_4;
		public unsafe double* LinkedMax_5;

		public unsafe Span<ImPlotRange> Range
		
		{
			get
			{
				fixed (ImPlotRange* p = &this.Range_0)
				{
					return new Span<ImPlotRange>(p, 6);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotNextItemData
	{
		public Vector4 Colors_0;
		public Vector4 Colors_1;
		public Vector4 Colors_2;
		public Vector4 Colors_3;
		public Vector4 Colors_4;
		public float LineWeight;
		public ImPlotMarker Marker;
		public float MarkerSize;
		public float MarkerWeight;
		public float FillAlpha;
		public float ErrorBarSize;
		public float ErrorBarWeight;
		public float DigitalBitHeight;
		public float DigitalBitGap;
		public bool RenderLine;
		public bool RenderFill;
		public bool RenderMarkerLine;
		public bool RenderMarkerFill;
		public bool HasHidden;
		public bool Hidden;
		public ImPlotCond HiddenCond;

		public unsafe Span<Vector4> Colors
		
		{
			get
			{
				fixed (Vector4* p = &this.Colors_0)
				{
					return new Span<Vector4>(p, 5);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotInputMap
	{
		public ImGuiMouseButton Pan;
		public int PanMod;
		public ImGuiMouseButton Fit;
		public ImGuiMouseButton Select;
		public ImGuiMouseButton SelectCancel;
		public int SelectMod;
		public int SelectHorzMod;
		public int SelectVertMod;
		public ImGuiMouseButton Menu;
		public int OverrideMod;
		public int ZoomMod;
		public float ZoomRate;


		public unsafe void Destroy()
		{
			fixed (ImPlotInputMap* @this = &this)
			{
				ImPlot.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImPlotAlignmentData
	{
		public ImVectorImPlotAlignmentData Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotAxisColor
	{

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImS16
	{
		public int Size;
		public int Capacity;
		public unsafe short* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImS32
	{
		public int Size;
		public int Capacity;
		public unsafe int* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImS64
	{
		public int Size;
		public int Capacity;
		public unsafe long* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImS8
	{
		public int Size;
		public int Capacity;
		public unsafe sbyte* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImU16
	{
		public int Size;
		public int Capacity;
		public unsafe ushort* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImU64
	{
		public int Size;
		public int Capacity;
		public unsafe ulong* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImU8
	{
		public int Size;
		public int Capacity;
		public unsafe byte* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotPoint
	{
		public double X;
		public double Y;


		public unsafe void Destroy()
		{
			fixed (ImPlotPoint* @this = &this)
			{
				ImPlot.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotRect
	{
		public ImPlotRange X;
		public ImPlotRange Y;


		public unsafe void Clamp(ref ImPlotPoint output, ImPlotRect* self, ImPlotPoint p)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				ImPlot.Clamp(poutput, self, p);
			}
		}

		public unsafe void Clamp(ImPlotPoint* output, ref ImPlotRect self, ImPlotPoint p)
		{
			fixed (ImPlotRect* pself = &self)
			{
				ImPlot.Clamp(output, pself, p);
			}
		}

		public unsafe void Clamp(ref ImPlotPoint output, ref ImPlotRect self, ImPlotPoint p)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				fixed (ImPlotRect* pself = &self)
				{
					ImPlot.Clamp(poutput, pself, p);
				}
			}
		}

		public unsafe void Clamp(ImPlotPoint* output, ImPlotRect* self, ImPlotPoint p)
		{
			ImPlot.Clamp(output, self, p);
		}

		public unsafe void Clamp(ref ImPlotPoint output, ImPlotRect* self, double x, double y)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				ImPlot.Clamp(poutput, self, x, y);
			}
		}

		public unsafe void Clamp(ImPlotPoint* output, ref ImPlotRect self, double x, double y)
		{
			fixed (ImPlotRect* pself = &self)
			{
				ImPlot.Clamp(output, pself, x, y);
			}
		}

		public unsafe void Clamp(ref ImPlotPoint output, ref ImPlotRect self, double x, double y)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				fixed (ImPlotRect* pself = &self)
				{
					ImPlot.Clamp(poutput, pself, x, y);
				}
			}
		}

		public unsafe void Clamp(ImPlotPoint* output, ImPlotRect* self, double x, double y)
		{
			ImPlot.Clamp(output, self, x, y);
		}

		public unsafe bool Contains(ImPlotPoint p)
		{
			fixed (ImPlotRect* @this = &this)
			{
				bool ret = ImPlot.Contains(@this, p);
				return ret;
			}
		}

		public unsafe bool Contains(double x, double y)
		{
			fixed (ImPlotRect* @this = &this)
			{
				bool ret = ImPlot.Contains(@this, x, y);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImPlotRect* @this = &this)
			{
				ImPlot.Destroy(@this);
			}
		}

		public unsafe void Max(ref ImPlotPoint output, ImPlotRect* self)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				ImPlot.Max(poutput, self);
			}
		}

		public unsafe void Max(ImPlotPoint* output, ref ImPlotRect self)
		{
			fixed (ImPlotRect* pself = &self)
			{
				ImPlot.Max(output, pself);
			}
		}

		public unsafe void Max(ref ImPlotPoint output, ref ImPlotRect self)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				fixed (ImPlotRect* pself = &self)
				{
					ImPlot.Max(poutput, pself);
				}
			}
		}

		public unsafe void Max(ImPlotPoint* output, ImPlotRect* self)
		{
			ImPlot.Max(output, self);
		}

		public unsafe void Min(ref ImPlotPoint output, ImPlotRect* self)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				ImPlot.Min(poutput, self);
			}
		}

		public unsafe void Min(ImPlotPoint* output, ref ImPlotRect self)
		{
			fixed (ImPlotRect* pself = &self)
			{
				ImPlot.Min(output, pself);
			}
		}

		public unsafe void Min(ref ImPlotPoint output, ref ImPlotRect self)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				fixed (ImPlotRect* pself = &self)
				{
					ImPlot.Min(poutput, pself);
				}
			}
		}

		public unsafe void Min(ImPlotPoint* output, ImPlotRect* self)
		{
			ImPlot.Min(output, self);
		}

		public unsafe void Size(ref ImPlotPoint output, ImPlotRect* self)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				ImPlot.Size(poutput, self);
			}
		}

		public unsafe void Size(ImPlotPoint* output, ref ImPlotRect self)
		{
			fixed (ImPlotRect* pself = &self)
			{
				ImPlot.Size(output, pself);
			}
		}

		public unsafe void Size(ref ImPlotPoint output, ref ImPlotRect self)
		{
			fixed (ImPlotPoint* poutput = &output)
			{
				fixed (ImPlotRect* pself = &self)
				{
					ImPlot.Size(poutput, pself);
				}
			}
		}

		public unsafe void Size(ImPlotPoint* output, ImPlotRect* self)
		{
			ImPlot.Size(output, self);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotDateTimeSpec
	{
		public ImPlotDateFmt Date;
		public ImPlotTimeFmt Time;
		public bool UseISO8601;
		public bool Use24HourClock;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotPointError
	{
		public double X;
		public double Y;
		public double Neg;
		public double Pos;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct FormatterTimeData
	{
		public ImPlotTime Time;
		public ImPlotDateTimeSpec Spec;
		public unsafe delegate*<double, byte*, int, void*, int> UserFormatter;
		public unsafe void* UserFormatterData;

	}

}
