// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

namespace HexaEngine.ImGui
{
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawChannel
	{
		public ImVectorImDrawCmd CmdBuffer;
		public ImVectorImDrawIdx IdxBuffer;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawCmd
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawCmd* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmd
	{
		public Vector4 ClipRect;
		public ImTextureID TextureId;
		public uint VtxOffset;
		public uint IdxOffset;
		public uint ElemCount;
		public unsafe delegate*<ImDrawList*, ImDrawCmd*, void> UserCallback;
		public unsafe void* UserCallbackData;


		public unsafe void Destroy()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe ImTextureID GetTexID()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImTextureID ret = ImGui.GetTexID(@this);
				return ret;
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawList
	{
		public ImVectorImDrawCmd CmdBuffer;
		public ImVectorImDrawIdx IdxBuffer;
		public ImVectorImDrawVert VtxBuffer;
		public ImDrawListFlags Flags;
		public uint VtxCurrentIdx;
		public unsafe ImDrawListSharedData* Data;
		public unsafe byte* OwnerName;
		public unsafe ImDrawVert* VtxWritePtr;
		public unsafe ushort* IdxWritePtr;
		public ImVectorImVec4 ClipRectStack;
		public ImVectorImTextureID TextureIdStack;
		public ImVectorImVec2 Path;
		public ImDrawCmdHeader CmdHeader;
		public ImDrawListSplitter Splitter;
		public float FringeScale;


		public unsafe int _CalcCircleAutoSegmentCount(float radius)
		{
			fixed (ImDrawList* @this = &this)
			{
				int ret = ImGui._CalcCircleAutoSegmentCount(@this, radius);
				return ret;
			}
		}

		public unsafe void _ClearFreeMemory()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ClearFreeMemory(@this);
			}
		}

		public unsafe void _OnChangedClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedClipRect(@this);
			}
		}

		public unsafe void _OnChangedTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedTextureID(@this);
			}
		}

		public unsafe void _OnChangedVtxOffset()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedVtxOffset(@this);
			}
		}

		public unsafe void _PathArcToFastEx(Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToFastEx(@this, center, radius, aMinSample, aMaxSample, aStep);
			}
		}

		public unsafe void _PathArcToN(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToN(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void _PopUnusedDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PopUnusedDrawCmd(@this);
			}
		}

		public unsafe void _ResetForNewFrame()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ResetForNewFrame(@this);
			}
		}

		public unsafe void _TryMergeDrawCmds()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._TryMergeDrawCmds(@this);
			}
		}

		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubic(@this, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}

		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadratic(@this, p1, p2, p3, col, thickness, numSegments);
			}
		}

		public unsafe void AddCallback(delegate*<ImDrawList*, ImDrawCmd*> callback, void* callbackData)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCallback(@this, callback, callbackData);
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircle(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilled(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddConvexPolyFilled(ref Vector2 points, int numPoints, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddConvexPolyFilled(@this, ppoints, numPoints, col);
				}
			}
		}

		public unsafe void AddConvexPolyFilled(Vector2* points, int numPoints, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddConvexPolyFilled(@this, points, numPoints, col);
			}
		}

		public unsafe void AddDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddDrawCmd(@this);
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImage(@this, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuad(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRounded(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLine(@this, p1, p2, col, thickness);
			}
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgon(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddNgonFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonFilled(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddPolyline(ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddPolyline(@this, ppoints, numPoints, col, flags, thickness);
				}
			}
		}

		public unsafe void AddPolyline(Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddPolyline(@this, points, numPoints, col, flags, thickness);
			}
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuad(@this, p1, p2, p3, p4, col, thickness);
			}
		}

		public unsafe void AddQuadFilled(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadFilled(@this, p1, p2, p3, p4, col);
			}
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRect(@this, pMin, pMax, col, rounding, flags, thickness);
			}
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilled(@this, pMin, pMax, col, rounding, flags);
			}
		}

		public unsafe void AddRectFilledMultiColor(Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledMultiColor(@this, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddText(@this, pos, col, ptextBegin, textEnd);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddText(@this, pos, col, pStr0, textEnd);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddText(@this, pos, col, textBegin, ptextEnd);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddText(@this, pos, col, textBegin, pStr0);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddText(@this, pos, col, ptextBegin, ptextEnd);
					}
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddText(@this, pos, col, pStr0, pStr1);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddText(@this, pos, col, textBegin, textEnd);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddText(@this, pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddText(@this, font, fontSize, pos, col, ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddText(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddText(@this, pfont, fontSize, pos, col, ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddText(@this, pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddText(@this, font, fontSize, pos, col, textBegin, ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddText(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddText(@this, pfont, fontSize, pos, col, textBegin, ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddText(@this, pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddText(@this, font, fontSize, pos, col, ptextBegin, ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddText(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddText(@this, pfont, fontSize, pos, col, ptextBegin, ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddText(@this, pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
					Marshal.FreeHGlobal((nint)pStr1);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddText(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddText(@this, pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddText(@this, font, fontSize, pos, col, ptextBegin, textEnd, wrapWidth, pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddText(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, pcpuFineClipRect);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddText(@this, pfont, fontSize, pos, col, ptextBegin, textEnd, wrapWidth, pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddText(@this, pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, pcpuFineClipRect);
						Marshal.FreeHGlobal((nint)pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddText(@this, font, fontSize, pos, col, textBegin, ptextEnd, wrapWidth, pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddText(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, pcpuFineClipRect);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddText(@this, pfont, fontSize, pos, col, textBegin, ptextEnd, wrapWidth, pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddText(@this, pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, pcpuFineClipRect);
						Marshal.FreeHGlobal((nint)pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddText(@this, font, fontSize, pos, col, ptextBegin, ptextEnd, wrapWidth, pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddText(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, pcpuFineClipRect);
					Marshal.FreeHGlobal((nint)pStr1);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddText(@this, pfont, fontSize, pos, col, ptextBegin, ptextEnd, wrapWidth, pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddText(@this, pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, pcpuFineClipRect);
						Marshal.FreeHGlobal((nint)pStr1);
						Marshal.FreeHGlobal((nint)pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddText(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangle(@this, p1, p2, p3, col, thickness);
			}
		}

		public unsafe void AddTriangleFilled(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleFilled(@this, p1, p2, p3, col);
			}
		}

		public unsafe void ChannelsMerge()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsMerge(@this);
			}
		}

		public unsafe void ChannelsSetCurrent(int n)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSetCurrent(@this, n);
			}
		}

		public unsafe void ChannelsSplit(int count)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSplit(@this, count);
			}
		}

		public unsafe ImDrawList* CloneOutput()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImDrawList* ret = ImGui.CloneOutput(@this);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe void GetClipRectMax(ref Vector2 output, ImDrawList* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGui.GetClipRectMax(poutput, self);
			}
		}

		public unsafe void GetClipRectMax(Vector2* output, ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGui.GetClipRectMax(output, pself);
			}
		}

		public unsafe void GetClipRectMax(ref Vector2 output, ref ImDrawList self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImDrawList* pself = &self)
				{
					ImGui.GetClipRectMax(poutput, pself);
				}
			}
		}

		public unsafe void GetClipRectMax(Vector2* output, ImDrawList* self)
		{
			ImGui.GetClipRectMax(output, self);
		}

		public unsafe void GetClipRectMin(ref Vector2 output, ImDrawList* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGui.GetClipRectMin(poutput, self);
			}
		}

		public unsafe void GetClipRectMin(Vector2* output, ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGui.GetClipRectMin(output, pself);
			}
		}

		public unsafe void GetClipRectMin(ref Vector2 output, ref ImDrawList self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImDrawList* pself = &self)
				{
					ImGui.GetClipRectMin(poutput, pself);
				}
			}
		}

		public unsafe void GetClipRectMin(Vector2* output, ImDrawList* self)
		{
			ImGui.GetClipRectMin(output, self);
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcTo(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void PathArcToFast(Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToFast(@this, center, radius, aMinOf12, aMaxOf12);
			}
		}

		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveTo(@this, p2, p3, p4, numSegments);
			}
		}

		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveTo(@this, p2, p3, numSegments);
			}
		}

		public unsafe void PathClear()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathClear(@this);
			}
		}

		public unsafe void PathFillConvex(uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathFillConvex(@this, col);
			}
		}

		public unsafe void PathLineTo(Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineTo(@this, pos);
			}
		}

		public unsafe void PathLineToMergeDuplicate(Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToMergeDuplicate(@this, pos);
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRect(@this, rectMin, rectMax, rounding, flags);
			}
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStroke(@this, col, flags, thickness);
			}
		}

		public unsafe void PopClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopClipRect(@this);
			}
		}

		public unsafe void PopTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopTextureID(@this);
			}
		}

		public unsafe void PrimQuadUV(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimQuadUV(@this, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}

		public unsafe void PrimRect(Vector2 a, Vector2 b, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRect(@this, a, b, col);
			}
		}

		public unsafe void PrimRectUV(Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectUV(@this, a, b, uvA, uvB, col);
			}
		}

		public unsafe void PrimReserve(int idxCount, int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimReserve(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimUnreserve(int idxCount, int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimUnreserve(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimVtx(Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimVtx(@this, pos, uv, col);
			}
		}

		public unsafe void PrimWriteIdx(ushort idx)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteIdx(@this, idx);
			}
		}

		public unsafe void PrimWriteVtx(Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteVtx(@this, pos, uv, col);
			}
		}

		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRect(@this, clipRectMin, clipRectMax, intersectWithCurrentClipRect);
			}
		}

		public unsafe void PushClipRectFullScreen()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectFullScreen(@this);
			}
		}

		public unsafe void PushTextureID(ImTextureID textureId)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushTextureID(@this, textureId);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawIdx
	{
		public int Size;
		public int Capacity;
		public unsafe ushort* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawVert
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawVert* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawVert
	{
		public Vector2 Pos;
		public Vector2 Uv;
		public uint Col;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSharedData
	{
		public Vector2 TexUvWhitePixel;
		public unsafe ImFont* Font;
		public float FontSize;
		public float CurveTessellationTol;
		public float CircleSegmentMaxError;
		public Vector4 ClipRectFullscreen;
		public ImDrawListFlags InitialFlags;
		public ImVectorImVec2 TempBuffer;
		public Vector2 ArcFastVtx_0;
		public Vector2 ArcFastVtx_1;
		public Vector2 ArcFastVtx_2;
		public Vector2 ArcFastVtx_3;
		public Vector2 ArcFastVtx_4;
		public Vector2 ArcFastVtx_5;
		public Vector2 ArcFastVtx_6;
		public Vector2 ArcFastVtx_7;
		public Vector2 ArcFastVtx_8;
		public Vector2 ArcFastVtx_9;
		public Vector2 ArcFastVtx_10;
		public Vector2 ArcFastVtx_11;
		public Vector2 ArcFastVtx_12;
		public Vector2 ArcFastVtx_13;
		public Vector2 ArcFastVtx_14;
		public Vector2 ArcFastVtx_15;
		public Vector2 ArcFastVtx_16;
		public Vector2 ArcFastVtx_17;
		public Vector2 ArcFastVtx_18;
		public Vector2 ArcFastVtx_19;
		public Vector2 ArcFastVtx_20;
		public Vector2 ArcFastVtx_21;
		public Vector2 ArcFastVtx_22;
		public Vector2 ArcFastVtx_23;
		public Vector2 ArcFastVtx_24;
		public Vector2 ArcFastVtx_25;
		public Vector2 ArcFastVtx_26;
		public Vector2 ArcFastVtx_27;
		public Vector2 ArcFastVtx_28;
		public Vector2 ArcFastVtx_29;
		public Vector2 ArcFastVtx_30;
		public Vector2 ArcFastVtx_31;
		public Vector2 ArcFastVtx_32;
		public Vector2 ArcFastVtx_33;
		public Vector2 ArcFastVtx_34;
		public Vector2 ArcFastVtx_35;
		public Vector2 ArcFastVtx_36;
		public Vector2 ArcFastVtx_37;
		public Vector2 ArcFastVtx_38;
		public Vector2 ArcFastVtx_39;
		public Vector2 ArcFastVtx_40;
		public Vector2 ArcFastVtx_41;
		public Vector2 ArcFastVtx_42;
		public Vector2 ArcFastVtx_43;
		public Vector2 ArcFastVtx_44;
		public Vector2 ArcFastVtx_45;
		public Vector2 ArcFastVtx_46;
		public Vector2 ArcFastVtx_47;
		public float ArcFastRadiusCutoff;
		public unsafe fixed byte CircleSegmentCounts[64];
		public unsafe Vector4* TexUvLines;

		public unsafe Span<Vector2> ArcFastVtx
		
		{
			get
			{
				fixed (Vector2* p = &this.ArcFastVtx_0)
				{
					return new Span<Vector2>(p, 48);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFont
	{
		public ImVectorFloat IndexAdvanceX;
		public float FallbackAdvanceX;
		public float FontSize;
		public ImVectorImWchar IndexLookup;
		public ImVectorImFontGlyph Glyphs;
		public unsafe ImFontGlyph* FallbackGlyph;
		public unsafe ImFontAtlas* ContainerAtlas;
		public unsafe ImFontConfig* ConfigData;
		public short ConfigDataCount;
		public char FallbackChar;
		public char EllipsisChar;
		public short EllipsisCharCount;
		public float EllipsisWidth;
		public float EllipsisCharStep;
		public bool DirtyLookupTables;
		public float Scale;
		public float Ascent;
		public float Descent;
		public int MetricsTotalSurface;
		public unsafe fixed byte Used4kPagesMap[2];


		public unsafe void AddGlyph(ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImFontConfig* psrcCfg = &srcCfg)
				{
					ImGui.AddGlyph(@this, psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
				}
			}
		}

		public unsafe void AddGlyph(ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddGlyph(@this, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public unsafe void AddRemapChar(char dst, char src, bool overwriteDst)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapChar(@this, dst, src, overwriteDst);
			}
		}

		public unsafe void BuildLookupTable()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.BuildLookupTable(@this);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, ptextBegin, textEnd, remaining);
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
			Marshal.FreeHGlobal((nint)pStr0);
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, ptextBegin, textEnd, remaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, ptextBegin, textEnd, remaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, ptextBegin, textEnd, remaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, ptextEnd, remaining);
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
			Marshal.FreeHGlobal((nint)pStr0);
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, textBegin, ptextEnd, remaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, textBegin, ptextEnd, remaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, textBegin, ptextEnd, remaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, ptextBegin, ptextEnd, remaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
			Marshal.FreeHGlobal((nint)pStr1);
			Marshal.FreeHGlobal((nint)pStr0);
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, ptextBegin, ptextEnd, remaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, ptextBegin, ptextEnd, remaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, ptextBegin, ptextEnd, remaining);
						}
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
					Marshal.FreeHGlobal((nint)pStr1);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (byte** premaining = &remaining)
			{
				ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, textEnd, premaining);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, textBegin, textEnd, premaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, textBegin, textEnd, premaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, textBegin, textEnd, premaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, ptextBegin, textEnd, premaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, textEnd, premaining);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, ptextBegin, textEnd, premaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, pStr0, textEnd, premaining);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, ptextBegin, textEnd, premaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, pStr0, textEnd, premaining);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte** premaining = &remaining)
						{
							ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, ptextBegin, textEnd, premaining);
						}
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, pStr0, textEnd, premaining);
						Marshal.FreeHGlobal((nint)pStr0);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, ptextEnd, premaining);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, pStr0, premaining);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, textBegin, ptextEnd, premaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, textBegin, pStr0, premaining);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, textBegin, ptextEnd, premaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, textBegin, pStr0, premaining);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, textBegin, ptextEnd, premaining);
						}
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, textBegin, pStr0, premaining);
						Marshal.FreeHGlobal((nint)pStr0);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, ptextBegin, ptextEnd, premaining);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, pStr1, premaining);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, ptextBegin, ptextEnd, premaining);
						}
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(poutput, self, size, maxWidth, wrapWidth, pStr0, pStr1, premaining);
					Marshal.FreeHGlobal((nint)pStr1);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, ptextBegin, ptextEnd, premaining);
						}
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					ImGui.CalcTextSizeA(output, pself, size, maxWidth, wrapWidth, pStr0, pStr1, premaining);
					Marshal.FreeHGlobal((nint)pStr1);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (byte** premaining = &remaining)
							{
								ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, ptextBegin, ptextEnd, premaining);
							}
						}
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						ImGui.CalcTextSizeA(poutput, pself, size, maxWidth, wrapWidth, pStr0, pStr1, premaining);
						Marshal.FreeHGlobal((nint)pStr1);
						Marshal.FreeHGlobal((nint)pStr0);
					}
				}
			}
		}

		public unsafe void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			ImGui.CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImGui.CalcWordWrapPositionA(@this, scale, ptext, textEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte* ret = ImGui.CalcWordWrapPositionA(@this, scale, ptext, textEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)ImGui.CalcWordWrapPositionA(@this, scale, pStr0, textEnd, wrapWidth));
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionA(@this, scale, pStr0, textEnd, wrapWidth);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImGui.CalcWordWrapPositionA(@this, scale, text, ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = ImGui.CalcWordWrapPositionA(@this, scale, text, ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)ImGui.CalcWordWrapPositionA(@this, scale, text, pStr0, wrapWidth));
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionA(@this, scale, text, pStr0, wrapWidth);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						string ret = Marshal.PtrToStringAnsi((nint)ImGui.CalcWordWrapPositionA(@this, scale, ptext, ptextEnd, wrapWidth));
						return ret;
					}
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte* ret = ImGui.CalcWordWrapPositionA(@this, scale, ptext, ptextEnd, wrapWidth);
						return ret;
					}
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)ImGui.CalcWordWrapPositionA(@this, scale, pStr0, pStr1, wrapWidth));
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionA(@this, scale, pStr0, pStr1, wrapWidth);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGui.CalcWordWrapPositionA(@this, scale, text, textEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.CalcWordWrapPositionA(@this, scale, text, textEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe void ClearOutputData()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.ClearOutputData(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe ImFontGlyph* FindGlyph(char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyph(@this, c);
				return ret;
			}
		}

		public unsafe ImFontGlyph* FindGlyphNoFallback(char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNoFallback(@this, c);
				return ret;
			}
		}

		public unsafe float GetCharAdvance(char c)
		{
			fixed (ImFont* @this = &this)
			{
				float ret = ImGui.GetCharAdvance(@this, c);
				return ret;
			}
		}

		public unsafe string GetDebugNameS()
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGui.GetDebugName(@this));
				return ret;
			}
		}

		public unsafe byte* GetDebugName()
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.GetDebugName(@this);
				return ret;
			}
		}

		public unsafe void GrowIndex(int newSize)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.GrowIndex(@this, newSize);
			}
		}

		public unsafe bool IsGlyphRangeUnused(uint cBegin, uint cLast)
		{
			fixed (ImFont* @this = &this)
			{
				bool ret = ImGui.IsGlyphRangeUnused(@this, cBegin, cLast);
				return ret;
			}
		}

		public unsafe bool IsLoaded()
		{
			fixed (ImFont* @this = &this)
			{
				bool ret = ImGui.IsLoaded(@this);
				return ret;
			}
		}

		public unsafe void RenderChar(ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderChar(@this, pdrawList, size, pos, col, c);
				}
			}
		}

		public unsafe void RenderChar(ImDrawList* drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderChar(@this, drawList, size, pos, col, c);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderText(@this, pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public unsafe void RenderText(ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderText(@this, drawList, size, pos, col, clipRect, ptextBegin, textEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public unsafe void RenderText(ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderText(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderText(@this, pdrawList, size, pos, col, clipRect, ptextBegin, textEnd, wrapWidth, cpuFineClip);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderText(@this, pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderText(@this, drawList, size, pos, col, clipRect, textBegin, ptextEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public unsafe void RenderText(ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderText(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderText(@this, pdrawList, size, pos, col, clipRect, textBegin, ptextEnd, wrapWidth, cpuFineClip);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderText(@this, pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderText(@this, drawList, size, pos, col, clipRect, ptextBegin, ptextEnd, wrapWidth, cpuFineClip);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderText(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderText(@this, pdrawList, size, pos, col, clipRect, ptextBegin, ptextEnd, wrapWidth, cpuFineClip);
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderText(@this, pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip);
					Marshal.FreeHGlobal((nint)pStr1);
					Marshal.FreeHGlobal((nint)pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderText(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip);
			}
		}

		public unsafe void SetGlyphVisible(char c, bool visible)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.SetGlyphVisible(@this, c, visible);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorFloat
	{
		public int Size;
		public int Capacity;
		public unsafe float* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImWchar
	{
		public int Size;
		public int Capacity;
		public unsafe char* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontGlyph
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontGlyph* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyph
	{
		public uint Colored;
		public uint Visible;
		public uint Codepoint;
		public float AdvanceX;
		public float X0;
		public float Y0;
		public float X1;
		public float Y1;
		public float U0;
		public float V0;
		public float U1;
		public float V1;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlas
	{
		public ImFontAtlasFlags Flags;
		public ImTextureID TexID;
		public int TexDesiredWidth;
		public int TexGlyphPadding;
		public bool Locked;
		public unsafe void* UserData;
		public bool TexReady;
		public bool TexPixelsUseColors;
		public unsafe byte* TexPixelsAlpha8;
		public unsafe uint* TexPixelsRGBA32;
		public int TexWidth;
		public int TexHeight;
		public Vector2 TexUvScale;
		public Vector2 TexUvWhitePixel;
		public ImVectorImFontPtr Fonts;
		public ImVectorImFontAtlasCustomRect CustomRects;
		public ImVectorImFontConfig ConfigData;
		public Vector4 TexUvLines_0;
		public Vector4 TexUvLines_1;
		public Vector4 TexUvLines_2;
		public Vector4 TexUvLines_3;
		public Vector4 TexUvLines_4;
		public Vector4 TexUvLines_5;
		public Vector4 TexUvLines_6;
		public Vector4 TexUvLines_7;
		public Vector4 TexUvLines_8;
		public Vector4 TexUvLines_9;
		public Vector4 TexUvLines_10;
		public Vector4 TexUvLines_11;
		public Vector4 TexUvLines_12;
		public Vector4 TexUvLines_13;
		public Vector4 TexUvLines_14;
		public Vector4 TexUvLines_15;
		public Vector4 TexUvLines_16;
		public Vector4 TexUvLines_17;
		public Vector4 TexUvLines_18;
		public Vector4 TexUvLines_19;
		public Vector4 TexUvLines_20;
		public Vector4 TexUvLines_21;
		public Vector4 TexUvLines_22;
		public Vector4 TexUvLines_23;
		public Vector4 TexUvLines_24;
		public Vector4 TexUvLines_25;
		public Vector4 TexUvLines_26;
		public Vector4 TexUvLines_27;
		public Vector4 TexUvLines_28;
		public Vector4 TexUvLines_29;
		public Vector4 TexUvLines_30;
		public Vector4 TexUvLines_31;
		public Vector4 TexUvLines_32;
		public Vector4 TexUvLines_33;
		public Vector4 TexUvLines_34;
		public Vector4 TexUvLines_35;
		public Vector4 TexUvLines_36;
		public Vector4 TexUvLines_37;
		public Vector4 TexUvLines_38;
		public Vector4 TexUvLines_39;
		public Vector4 TexUvLines_40;
		public Vector4 TexUvLines_41;
		public Vector4 TexUvLines_42;
		public Vector4 TexUvLines_43;
		public Vector4 TexUvLines_44;
		public Vector4 TexUvLines_45;
		public Vector4 TexUvLines_46;
		public Vector4 TexUvLines_47;
		public Vector4 TexUvLines_48;
		public Vector4 TexUvLines_49;
		public Vector4 TexUvLines_50;
		public Vector4 TexUvLines_51;
		public Vector4 TexUvLines_52;
		public Vector4 TexUvLines_53;
		public Vector4 TexUvLines_54;
		public Vector4 TexUvLines_55;
		public Vector4 TexUvLines_56;
		public Vector4 TexUvLines_57;
		public Vector4 TexUvLines_58;
		public Vector4 TexUvLines_59;
		public Vector4 TexUvLines_60;
		public Vector4 TexUvLines_61;
		public Vector4 TexUvLines_62;
		public Vector4 TexUvLines_63;
		public unsafe ImFontBuilderIO* FontBuilderIO;
		public uint FontBuilderFlags;
		public int PackIdMouseCursors;
		public int PackIdLines;

		public unsafe Span<Vector4> TexUvLines
		
		{
			get
			{
				fixed (Vector4* p = &this.TexUvLines_0)
				{
					return new Span<Vector4>(p, 64);
				}
			}
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyph(@this, pfont, id, width, height, advanceX, offset);
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectFontGlyph(ImFont* font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyph(@this, font, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public unsafe int AddCustomRectRegular(int width, int height)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectRegular(@this, width, height);
				return ret;
			}
		}

		public unsafe ImFont* AddFont(ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFont(@this, pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFont(ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFont(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFont* AddFontDefault(ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontDefault(@this, pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontDefault(ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontDefault(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTF(@this, pfilename, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTF(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTF(@this, filename, sizePixels, pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromFileTTF(@this, pfilename, sizePixels, pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTF(@this, pStr0, sizePixels, pfontCfg, glyphRanges);
					Marshal.FreeHGlobal((nint)pStr0);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTF(@this, filename, sizePixels, fontCfg, pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTF(@this, pfilename, sizePixels, fontCfg, pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTF(@this, pStr0, sizePixels, fontCfg, pglyphRanges);
					Marshal.FreeHGlobal((nint)pStr0);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTF(@this, filename, sizePixels, pfontCfg, pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFont* ret = ImGui.AddFontFromFileTTF(@this, pfilename, sizePixels, pfontCfg, pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTF(@this, pStr0, sizePixels, pfontCfg, pglyphRanges);
						Marshal.FreeHGlobal((nint)pStr0);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTF(@this, filename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, compressedFontDataBase85, sizePixels, pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, pcompressedFontDataBase85, sizePixels, pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, pStr0, sizePixels, pfontCfg, glyphRanges);
					Marshal.FreeHGlobal((nint)pStr0);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, compressedFontDataBase85, sizePixels, fontCfg, pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, pcompressedFontDataBase85, sizePixels, fontCfg, pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, pStr0, sizePixels, fontCfg, pglyphRanges);
					Marshal.FreeHGlobal((nint)pStr0);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, compressedFontDataBase85, sizePixels, pfontCfg, pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, pcompressedFontDataBase85, sizePixels, pfontCfg, pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, pStr0, sizePixels, pfontCfg, pglyphRanges);
						Marshal.FreeHGlobal((nint)pStr0);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTF(@this, compressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTF(@this, compressedFontData, compressedFontSize, sizePixels, pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTF(@this, compressedFontData, compressedFontSize, sizePixels, fontCfg, pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedTTF(@this, compressedFontData, compressedFontSize, sizePixels, pfontCfg, pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTF(@this, compressedFontData, compressedFontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTF(@this, fontData, fontSize, sizePixels, pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTF(@this, fontData, fontSize, sizePixels, fontCfg, pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryTTF(@this, fontData, fontSize, sizePixels, pfontCfg, pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTF(@this, fontData, fontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe bool Build()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				bool ret = ImGui.Build(@this);
				return ret;
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					ImGui.CalcCustomRectUV(@this, prect, outUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGui.CalcCustomRectUV(@this, rect, poutUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						ImGui.CalcCustomRectUV(@this, prect, poutUvMin, outUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUV(@this, rect, outUvMin, poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUV(@this, prect, outUvMin, poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUV(@this, rect, poutUvMin, poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						fixed (Vector2* poutUvMax = &outUvMax)
						{
							ImGui.CalcCustomRectUV(@this, prect, poutUvMin, poutUvMax);
						}
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.CalcCustomRectUV(@this, rect, outUvMin, outUvMax);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.Clear(@this);
			}
		}

		public unsafe void ClearFonts()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearFonts(@this);
			}
		}

		public unsafe void ClearInputData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearInputData(@this);
			}
		}

		public unsafe void ClearTexData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearTexData(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe ImFontAtlasCustomRect* GetCustomRectByIndex(int index)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontAtlasCustomRect* ret = ImGui.GetCustomRectByIndex(@this, index);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesChineseFull()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseFull(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesChineseSimplifiedCommon()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseSimplifiedCommon(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesCyrillic()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesCyrillic(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesDefault(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesGreek()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesGreek(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesJapanese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesJapanese(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesKorean()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesKorean(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesThai()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesThai(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesVietnamese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesVietnamese(@this);
				return ret;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					bool ret = ImGui.GetMouseCursorTexData(@this, cursor, poutOffset, outSize, outUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					bool ret = ImGui.GetMouseCursorTexData(@this, cursor, outOffset, poutSize, outUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						bool ret = ImGui.GetMouseCursorTexData(@this, cursor, poutOffset, poutSize, outUvBorder, outUvFill);
						return ret;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					bool ret = ImGui.GetMouseCursorTexData(@this, cursor, outOffset, outSize, poutUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						bool ret = ImGui.GetMouseCursorTexData(@this, cursor, poutOffset, outSize, poutUvBorder, outUvFill);
						return ret;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						bool ret = ImGui.GetMouseCursorTexData(@this, cursor, outOffset, poutSize, poutUvBorder, outUvFill);
						return ret;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							bool ret = ImGui.GetMouseCursorTexData(@this, cursor, poutOffset, poutSize, poutUvBorder, outUvFill);
							return ret;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					bool ret = ImGui.GetMouseCursorTexData(@this, cursor, outOffset, outSize, outUvBorder, poutUvFill);
					return ret;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = ImGui.GetMouseCursorTexData(@this, cursor, poutOffset, outSize, outUvBorder, poutUvFill);
						return ret;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = ImGui.GetMouseCursorTexData(@this, cursor, outOffset, poutSize, outUvBorder, poutUvFill);
						return ret;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							bool ret = ImGui.GetMouseCursorTexData(@this, cursor, poutOffset, poutSize, outUvBorder, poutUvFill);
							return ret;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = ImGui.GetMouseCursorTexData(@this, cursor, outOffset, outSize, poutUvBorder, poutUvFill);
						return ret;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							bool ret = ImGui.GetMouseCursorTexData(@this, cursor, poutOffset, outSize, poutUvBorder, poutUvFill);
							return ret;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							bool ret = ImGui.GetMouseCursorTexData(@this, cursor, outOffset, poutSize, poutUvBorder, poutUvFill);
							return ret;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								bool ret = ImGui.GetMouseCursorTexData(@this, cursor, poutOffset, poutSize, poutUvBorder, poutUvFill);
								return ret;
							}
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				bool ret = ImGui.GetMouseCursorTexData(@this, cursor, outOffset, outSize, outUvBorder, outUvFill);
				return ret;
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8(@this, poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8(@this, outPixels, poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8(@this, poutPixels, poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8(@this, outPixels, outWidth, poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8(@this, poutPixels, outWidth, poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8(@this, outPixels, poutWidth, poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8(@this, poutPixels, poutWidth, poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8(@this, outPixels, outWidth, outHeight, poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8(@this, poutPixels, outWidth, outHeight, poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8(@this, outPixels, poutWidth, outHeight, poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8(@this, poutPixels, poutWidth, outHeight, poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8(@this, outPixels, outWidth, poutHeight, poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8(@this, poutPixels, outWidth, poutHeight, poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8(@this, outPixels, poutWidth, poutHeight, poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsAlpha8(@this, poutPixels, poutWidth, poutHeight, poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32(@this, poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32(@this, outPixels, poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32(@this, poutPixels, poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32(@this, outPixels, outWidth, poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32(@this, poutPixels, outWidth, poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32(@this, outPixels, poutWidth, poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32(@this, poutPixels, poutWidth, poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32(@this, outPixels, outWidth, outHeight, poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32(@this, poutPixels, outWidth, outHeight, poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32(@this, outPixels, poutWidth, outHeight, poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32(@this, poutPixels, poutWidth, outHeight, poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32(@this, outPixels, outWidth, poutHeight, poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32(@this, poutPixels, outWidth, poutHeight, poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32(@this, outPixels, poutWidth, poutHeight, poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsRGBA32(@this, poutPixels, poutWidth, poutHeight, poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe bool IsBuilt()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				bool ret = ImGui.IsBuilt(@this);
				return ret;
			}
		}

		public unsafe void SetTexID(ImTextureID id)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.SetTexID(@this, id);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImFont** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontAtlasCustomRect
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontAtlasCustomRect* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlasCustomRect
	{
		public ushort Width;
		public ushort Height;
		public ushort X;
		public ushort Y;
		public uint GlyphID;
		public float GlyphAdvanceX;
		public Vector2 GlyphOffset;
		public unsafe ImFont* Font;


		public unsafe void Destroy()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe bool IsPacked()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				bool ret = ImGui.IsPacked(@this);
				return ret;
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontConfig
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontConfig* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontConfig
	{
		public unsafe void* FontData;
		public int FontDataSize;
		public bool FontDataOwnedByAtlas;
		public int FontNo;
		public float SizePixels;
		public int OversampleH;
		public int OversampleV;
		public bool PixelSnapH;
		public Vector2 GlyphExtraSpacing;
		public Vector2 GlyphOffset;
		public unsafe char* GlyphRanges;
		public float GlyphMinAdvanceX;
		public float GlyphMaxAdvanceX;
		public bool MergeMode;
		public uint FontBuilderFlags;
		public float RasterizerMultiply;
		public char EllipsisChar;
		public unsafe fixed byte Name[40];
		public unsafe ImFont* DstFont;


		public unsafe void Destroy()
		{
			fixed (ImFontConfig* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontBuilderIO
	{
		public unsafe delegate*<ImFontAtlas*, bool>* FontBuilderBuild;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImVec2
	{
		public int Size;
		public int Capacity;
		public unsafe Vector2* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImVec4
	{
		public int Size;
		public int Capacity;
		public unsafe Vector4* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImTextureID
	{
		public int Size;
		public int Capacity;
		public unsafe ImTextureID* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmdHeader
	{
		public Vector4 ClipRect;
		public ImTextureID TextureId;
		public uint VtxOffset;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSplitter
	{
		public int Current;
		public int Count;
		public ImVectorImDrawChannel Channels;


		public unsafe void Clear()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.Clear(@this);
			}
		}

		public unsafe void ClearFreeMemory()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.ClearFreeMemory(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe void Merge(ref ImDrawList drawList)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.Merge(@this, pdrawList);
				}
			}
		}

		public unsafe void Merge(ImDrawList* drawList)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.Merge(@this, drawList);
			}
		}

		public unsafe void SetCurrentChannel(ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.SetCurrentChannel(@this, pdrawList, channelIdx);
				}
			}
		}

		public unsafe void SetCurrentChannel(ImDrawList* drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.SetCurrentChannel(@this, drawList, channelIdx);
			}
		}

		public unsafe void Split(ref ImDrawList drawList, int count)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.Split(@this, pdrawList, count);
				}
			}
		}

		public unsafe void Split(ImDrawList* drawList, int count)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.Split(@this, drawList, count);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawChannel
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawChannel* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawData
	{
		public bool Valid;
		public int CmdListsCount;
		public int TotalIdxCount;
		public int TotalVtxCount;
		public unsafe ImDrawList** CmdLists;
		public Vector2 DisplayPos;
		public Vector2 DisplaySize;
		public Vector2 FramebufferScale;
		public unsafe ImGuiViewport* OwnerViewport;


		public unsafe void Clear()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.Clear(@this);
			}
		}

		public unsafe void DeIndexAllBuffers()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DeIndexAllBuffers(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe void ScaleClipRects(Vector2 fbScale)
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ScaleClipRects(@this, fbScale);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiViewport
	{
		public int ID;
		public ImGuiViewportFlags Flags;
		public Vector2 Pos;
		public Vector2 Size;
		public Vector2 WorkPos;
		public Vector2 WorkSize;
		public float DpiScale;
		public int ParentViewportId;
		public unsafe ImDrawData* DrawData;
		public unsafe void* RendererUserData;
		public unsafe void* PlatformUserData;
		public unsafe void* PlatformHandle;
		public unsafe void* PlatformHandleRaw;
		public bool PlatformWindowCreated;
		public bool PlatformRequestMove;
		public bool PlatformRequestResize;
		public bool PlatformRequestClose;


		public unsafe void Destroy()
		{
			fixed (ImGuiViewport* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe void GetCenter(ref Vector2 output, ImGuiViewport* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGui.GetCenter(poutput, self);
			}
		}

		public unsafe void GetCenter(Vector2* output, ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				ImGui.GetCenter(output, pself);
			}
		}

		public unsafe void GetCenter(ref Vector2 output, ref ImGuiViewport self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewport* pself = &self)
				{
					ImGui.GetCenter(poutput, pself);
				}
			}
		}

		public unsafe void GetCenter(Vector2* output, ImGuiViewport* self)
		{
			ImGui.GetCenter(output, self);
		}

		public unsafe void GetWorkCenter(ref Vector2 output, ImGuiViewport* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGui.GetWorkCenter(poutput, self);
			}
		}

		public unsafe void GetWorkCenter(Vector2* output, ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				ImGui.GetWorkCenter(output, pself);
			}
		}

		public unsafe void GetWorkCenter(ref Vector2 output, ref ImGuiViewport self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewport* pself = &self)
				{
					ImGui.GetWorkCenter(poutput, pself);
				}
			}
		}

		public unsafe void GetWorkCenter(Vector2* output, ImGuiViewport* self)
		{
			ImGui.GetWorkCenter(output, self);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyphRangesBuilder
	{
		public ImVectorImU32 UsedChars;


		public unsafe void AddChar(char c)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddChar(@this, c);
			}
		}

		public unsafe void AddRanges(ref char ranges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (char* pranges = &ranges)
				{
					ImGui.AddRanges(@this, pranges);
				}
			}
		}

		public unsafe void AddRanges(char* ranges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddRanges(@this, ranges);
			}
		}

		public unsafe void AddText(ref byte text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.AddText(@this, ptext, textEnd);
				}
			}
		}

		public unsafe void AddText(string text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddText(@this, pStr0, textEnd);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(byte* text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddText(@this, text, ptextEnd);
				}
			}
		}

		public unsafe void AddText(byte* text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddText(@this, text, pStr0);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(ref byte text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddText(@this, ptext, ptextEnd);
					}
				}
			}
		}

		public unsafe void AddText(string text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddText(@this, pStr0, pStr1);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddText(byte* text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddText(@this, text, textEnd);
			}
		}

		public unsafe void BuildRanges(ref ImVectorImWchar outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (ImVectorImWchar* poutRanges = &outRanges)
				{
					ImGui.BuildRanges(@this, poutRanges);
				}
			}
		}

		public unsafe void BuildRanges(ImVectorImWchar* outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.BuildRanges(@this, outRanges);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.Clear(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe bool GetBit(nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				bool ret = ImGui.GetBit(@this, n);
				return ret;
			}
		}

		public unsafe void SetBit(nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.SetBit(@this, n);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImU32
	{
		public int Size;
		public int Capacity;
		public unsafe uint* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImColor
	{
		public Vector4 Value;


		public unsafe void Destroy()
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe void HSV(float h, float s, float v, float a)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.HSV(@this, h, s, v, a);
			}
		}

		public unsafe void SetHSV(float h, float s, float v, float a)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.SetHSV(@this, h, s, v, a);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiContext
	{
		public bool Initialized;
		public bool FontAtlasOwnedByContext;
		public ImGuiIO IO;
		public ImGuiPlatformIO PlatformIO;
		public ImGuiStyle Style;
		public ImGuiConfigFlags ConfigFlagsCurrFrame;
		public ImGuiConfigFlags ConfigFlagsLastFrame;
		public unsafe ImFont* Font;
		public float FontSize;
		public float FontBaseSize;
		public ImDrawListSharedData DrawListSharedData;
		public double Time;
		public int FrameCount;
		public int FrameCountEnded;
		public int FrameCountPlatformEnded;
		public int FrameCountRendered;
		public bool WithinFrameScope;
		public bool WithinFrameScopeWithImplicitWindow;
		public bool WithinEndChild;
		public bool GcCompactAll;
		public bool TestEngineHookItems;
		public unsafe void* TestEngine;
		public ImVectorImGuiInputEvent InputEventsQueue;
		public ImVectorImGuiInputEvent InputEventsTrail;
		public ImGuiMouseSource InputEventsNextMouseSource;
		public uint InputEventsNextEventId;
		public ImVectorImGuiWindowPtr Windows;
		public ImVectorImGuiWindowPtr WindowsFocusOrder;
		public ImVectorImGuiWindowPtr WindowsTempSortBuffer;
		public ImVectorImGuiWindowStackData CurrentWindowStack;
		public ImGuiStorage WindowsById;
		public int WindowsActiveCount;
		public Vector2 WindowsHoverPadding;
		public unsafe ImGuiWindow* CurrentWindow;
		public unsafe ImGuiWindow* HoveredWindow;
		public unsafe ImGuiWindow* HoveredWindowUnderMovingWindow;
		public unsafe ImGuiWindow* MovingWindow;
		public unsafe ImGuiWindow* WheelingWindow;
		public Vector2 WheelingWindowRefMousePos;
		public int WheelingWindowStartFrame;
		public float WheelingWindowReleaseTimer;
		public Vector2 WheelingWindowWheelRemainder;
		public Vector2 WheelingAxisAvg;
		public int DebugHookIdInfo;
		public int HoveredId;
		public int HoveredIdPreviousFrame;
		public bool HoveredIdAllowOverlap;
		public bool HoveredIdDisabled;
		public float HoveredIdTimer;
		public float HoveredIdNotActiveTimer;
		public int ActiveId;
		public int ActiveIdIsAlive;
		public float ActiveIdTimer;
		public bool ActiveIdIsJustActivated;
		public bool ActiveIdAllowOverlap;
		public bool ActiveIdNoClearOnFocusLoss;
		public bool ActiveIdHasBeenPressedBefore;
		public bool ActiveIdHasBeenEditedBefore;
		public bool ActiveIdHasBeenEditedThisFrame;
		public Vector2 ActiveIdClickOffset;
		public unsafe ImGuiWindow* ActiveIdWindow;
		public ImGuiInputSource ActiveIdSource;
		public int ActiveIdMouseButton;
		public int ActiveIdPreviousFrame;
		public bool ActiveIdPreviousFrameIsAlive;
		public bool ActiveIdPreviousFrameHasBeenEditedBefore;
		public unsafe ImGuiWindow* ActiveIdPreviousFrameWindow;
		public int LastActiveId;
		public float LastActiveIdTimer;
		public ImGuiKeyOwnerData KeysOwnerData_0;
		public ImGuiKeyOwnerData KeysOwnerData_1;
		public ImGuiKeyOwnerData KeysOwnerData_2;
		public ImGuiKeyOwnerData KeysOwnerData_3;
		public ImGuiKeyOwnerData KeysOwnerData_4;
		public ImGuiKeyOwnerData KeysOwnerData_5;
		public ImGuiKeyOwnerData KeysOwnerData_6;
		public ImGuiKeyOwnerData KeysOwnerData_7;
		public ImGuiKeyOwnerData KeysOwnerData_8;
		public ImGuiKeyOwnerData KeysOwnerData_9;
		public ImGuiKeyOwnerData KeysOwnerData_10;
		public ImGuiKeyOwnerData KeysOwnerData_11;
		public ImGuiKeyOwnerData KeysOwnerData_12;
		public ImGuiKeyOwnerData KeysOwnerData_13;
		public ImGuiKeyOwnerData KeysOwnerData_14;
		public ImGuiKeyOwnerData KeysOwnerData_15;
		public ImGuiKeyOwnerData KeysOwnerData_16;
		public ImGuiKeyOwnerData KeysOwnerData_17;
		public ImGuiKeyOwnerData KeysOwnerData_18;
		public ImGuiKeyOwnerData KeysOwnerData_19;
		public ImGuiKeyOwnerData KeysOwnerData_20;
		public ImGuiKeyOwnerData KeysOwnerData_21;
		public ImGuiKeyOwnerData KeysOwnerData_22;
		public ImGuiKeyOwnerData KeysOwnerData_23;
		public ImGuiKeyOwnerData KeysOwnerData_24;
		public ImGuiKeyOwnerData KeysOwnerData_25;
		public ImGuiKeyOwnerData KeysOwnerData_26;
		public ImGuiKeyOwnerData KeysOwnerData_27;
		public ImGuiKeyOwnerData KeysOwnerData_28;
		public ImGuiKeyOwnerData KeysOwnerData_29;
		public ImGuiKeyOwnerData KeysOwnerData_30;
		public ImGuiKeyOwnerData KeysOwnerData_31;
		public ImGuiKeyOwnerData KeysOwnerData_32;
		public ImGuiKeyOwnerData KeysOwnerData_33;
		public ImGuiKeyOwnerData KeysOwnerData_34;
		public ImGuiKeyOwnerData KeysOwnerData_35;
		public ImGuiKeyOwnerData KeysOwnerData_36;
		public ImGuiKeyOwnerData KeysOwnerData_37;
		public ImGuiKeyOwnerData KeysOwnerData_38;
		public ImGuiKeyOwnerData KeysOwnerData_39;
		public ImGuiKeyOwnerData KeysOwnerData_40;
		public ImGuiKeyOwnerData KeysOwnerData_41;
		public ImGuiKeyOwnerData KeysOwnerData_42;
		public ImGuiKeyOwnerData KeysOwnerData_43;
		public ImGuiKeyOwnerData KeysOwnerData_44;
		public ImGuiKeyOwnerData KeysOwnerData_45;
		public ImGuiKeyOwnerData KeysOwnerData_46;
		public ImGuiKeyOwnerData KeysOwnerData_47;
		public ImGuiKeyOwnerData KeysOwnerData_48;
		public ImGuiKeyOwnerData KeysOwnerData_49;
		public ImGuiKeyOwnerData KeysOwnerData_50;
		public ImGuiKeyOwnerData KeysOwnerData_51;
		public ImGuiKeyOwnerData KeysOwnerData_52;
		public ImGuiKeyOwnerData KeysOwnerData_53;
		public ImGuiKeyOwnerData KeysOwnerData_54;
		public ImGuiKeyOwnerData KeysOwnerData_55;
		public ImGuiKeyOwnerData KeysOwnerData_56;
		public ImGuiKeyOwnerData KeysOwnerData_57;
		public ImGuiKeyOwnerData KeysOwnerData_58;
		public ImGuiKeyOwnerData KeysOwnerData_59;
		public ImGuiKeyOwnerData KeysOwnerData_60;
		public ImGuiKeyOwnerData KeysOwnerData_61;
		public ImGuiKeyOwnerData KeysOwnerData_62;
		public ImGuiKeyOwnerData KeysOwnerData_63;
		public ImGuiKeyOwnerData KeysOwnerData_64;
		public ImGuiKeyOwnerData KeysOwnerData_65;
		public ImGuiKeyOwnerData KeysOwnerData_66;
		public ImGuiKeyOwnerData KeysOwnerData_67;
		public ImGuiKeyOwnerData KeysOwnerData_68;
		public ImGuiKeyOwnerData KeysOwnerData_69;
		public ImGuiKeyOwnerData KeysOwnerData_70;
		public ImGuiKeyOwnerData KeysOwnerData_71;
		public ImGuiKeyOwnerData KeysOwnerData_72;
		public ImGuiKeyOwnerData KeysOwnerData_73;
		public ImGuiKeyOwnerData KeysOwnerData_74;
		public ImGuiKeyOwnerData KeysOwnerData_75;
		public ImGuiKeyOwnerData KeysOwnerData_76;
		public ImGuiKeyOwnerData KeysOwnerData_77;
		public ImGuiKeyOwnerData KeysOwnerData_78;
		public ImGuiKeyOwnerData KeysOwnerData_79;
		public ImGuiKeyOwnerData KeysOwnerData_80;
		public ImGuiKeyOwnerData KeysOwnerData_81;
		public ImGuiKeyOwnerData KeysOwnerData_82;
		public ImGuiKeyOwnerData KeysOwnerData_83;
		public ImGuiKeyOwnerData KeysOwnerData_84;
		public ImGuiKeyOwnerData KeysOwnerData_85;
		public ImGuiKeyOwnerData KeysOwnerData_86;
		public ImGuiKeyOwnerData KeysOwnerData_87;
		public ImGuiKeyOwnerData KeysOwnerData_88;
		public ImGuiKeyOwnerData KeysOwnerData_89;
		public ImGuiKeyOwnerData KeysOwnerData_90;
		public ImGuiKeyOwnerData KeysOwnerData_91;
		public ImGuiKeyOwnerData KeysOwnerData_92;
		public ImGuiKeyOwnerData KeysOwnerData_93;
		public ImGuiKeyOwnerData KeysOwnerData_94;
		public ImGuiKeyOwnerData KeysOwnerData_95;
		public ImGuiKeyOwnerData KeysOwnerData_96;
		public ImGuiKeyOwnerData KeysOwnerData_97;
		public ImGuiKeyOwnerData KeysOwnerData_98;
		public ImGuiKeyOwnerData KeysOwnerData_99;
		public ImGuiKeyOwnerData KeysOwnerData_100;
		public ImGuiKeyOwnerData KeysOwnerData_101;
		public ImGuiKeyOwnerData KeysOwnerData_102;
		public ImGuiKeyOwnerData KeysOwnerData_103;
		public ImGuiKeyOwnerData KeysOwnerData_104;
		public ImGuiKeyOwnerData KeysOwnerData_105;
		public ImGuiKeyOwnerData KeysOwnerData_106;
		public ImGuiKeyOwnerData KeysOwnerData_107;
		public ImGuiKeyOwnerData KeysOwnerData_108;
		public ImGuiKeyOwnerData KeysOwnerData_109;
		public ImGuiKeyOwnerData KeysOwnerData_110;
		public ImGuiKeyOwnerData KeysOwnerData_111;
		public ImGuiKeyOwnerData KeysOwnerData_112;
		public ImGuiKeyOwnerData KeysOwnerData_113;
		public ImGuiKeyOwnerData KeysOwnerData_114;
		public ImGuiKeyOwnerData KeysOwnerData_115;
		public ImGuiKeyOwnerData KeysOwnerData_116;
		public ImGuiKeyOwnerData KeysOwnerData_117;
		public ImGuiKeyOwnerData KeysOwnerData_118;
		public ImGuiKeyOwnerData KeysOwnerData_119;
		public ImGuiKeyOwnerData KeysOwnerData_120;
		public ImGuiKeyOwnerData KeysOwnerData_121;
		public ImGuiKeyOwnerData KeysOwnerData_122;
		public ImGuiKeyOwnerData KeysOwnerData_123;
		public ImGuiKeyOwnerData KeysOwnerData_124;
		public ImGuiKeyOwnerData KeysOwnerData_125;
		public ImGuiKeyOwnerData KeysOwnerData_126;
		public ImGuiKeyOwnerData KeysOwnerData_127;
		public ImGuiKeyOwnerData KeysOwnerData_128;
		public ImGuiKeyOwnerData KeysOwnerData_129;
		public ImGuiKeyOwnerData KeysOwnerData_130;
		public ImGuiKeyOwnerData KeysOwnerData_131;
		public ImGuiKeyOwnerData KeysOwnerData_132;
		public ImGuiKeyOwnerData KeysOwnerData_133;
		public ImGuiKeyOwnerData KeysOwnerData_134;
		public ImGuiKeyOwnerData KeysOwnerData_135;
		public ImGuiKeyOwnerData KeysOwnerData_136;
		public ImGuiKeyOwnerData KeysOwnerData_137;
		public ImGuiKeyOwnerData KeysOwnerData_138;
		public ImGuiKeyOwnerData KeysOwnerData_139;
		public ImGuiKeyRoutingTable KeysRoutingTable;
		public uint ActiveIdUsingNavDirMask;
		public bool ActiveIdUsingAllKeyboardKeys;
		public uint ActiveIdUsingNavInputMask;
		public int CurrentFocusScopeId;
		public ImGuiItemFlags CurrentItemFlags;
		public int DebugLocateId;
		public ImGuiNextItemData NextItemData;
		public ImGuiLastItemData LastItemData;
		public ImGuiNextWindowData NextWindowData;
		public ImVectorImGuiColorMod ColorStack;
		public ImVectorImGuiStyleMod StyleVarStack;
		public ImVectorImFontPtr FontStack;
		public ImVectorImGuiID FocusScopeStack;
		public ImVectorImGuiItemFlags ItemFlagsStack;
		public ImVectorImGuiGroupData GroupStack;
		public ImVectorImGuiPopupData OpenPopupStack;
		public ImVectorImGuiPopupData BeginPopupStack;
		public int BeginMenuCount;
		public ImVectorImGuiViewportPPtr Viewports;
		public float CurrentDpiScale;
		public unsafe ImGuiViewportP* CurrentViewport;
		public unsafe ImGuiViewportP* MouseViewport;
		public unsafe ImGuiViewportP* MouseLastHoveredViewport;
		public int PlatformLastFocusedViewportId;
		public ImGuiPlatformMonitor FallbackMonitor;
		public int ViewportFocusedStampCount;
		public unsafe ImGuiWindow* NavWindow;
		public int NavId;
		public int NavFocusScopeId;
		public int NavActivateId;
		public int NavActivateDownId;
		public int NavActivatePressedId;
		public ImGuiActivateFlags NavActivateFlags;
		public int NavJustMovedToId;
		public int NavJustMovedToFocusScopeId;
		public int NavJustMovedToKeyMods;
		public int NavNextActivateId;
		public ImGuiActivateFlags NavNextActivateFlags;
		public ImGuiInputSource NavInputSource;
		public ImGuiNavLayer NavLayer;
		public bool NavIdIsAlive;
		public bool NavMousePosDirty;
		public bool NavDisableHighlight;
		public bool NavDisableMouseHover;
		public bool NavAnyRequest;
		public bool NavInitRequest;
		public bool NavInitRequestFromMove;
		public int NavInitResultId;
		public ImRect NavInitResultRectRel;
		public bool NavMoveSubmitted;
		public bool NavMoveScoringItems;
		public bool NavMoveForwardToNextFrame;
		public ImGuiNavMoveFlags NavMoveFlags;
		public ImGuiScrollFlags NavMoveScrollFlags;
		public int NavMoveKeyMods;
		public ImGuiDir NavMoveDir;
		public ImGuiDir NavMoveDirForDebug;
		public ImGuiDir NavMoveClipDir;
		public ImRect NavScoringRect;
		public ImRect NavScoringNoClipRect;
		public int NavScoringDebugCount;
		public int NavTabbingDir;
		public int NavTabbingCounter;
		public ImGuiNavItemData NavMoveResultLocal;
		public ImGuiNavItemData NavMoveResultLocalVisible;
		public ImGuiNavItemData NavMoveResultOther;
		public ImGuiNavItemData NavTabbingResultFirst;
		public int ConfigNavWindowingKeyNext;
		public int ConfigNavWindowingKeyPrev;
		public unsafe ImGuiWindow* NavWindowingTarget;
		public unsafe ImGuiWindow* NavWindowingTargetAnim;
		public unsafe ImGuiWindow* NavWindowingListWindow;
		public float NavWindowingTimer;
		public float NavWindowingHighlightAlpha;
		public bool NavWindowingToggleLayer;
		public Vector2 NavWindowingAccumDeltaPos;
		public Vector2 NavWindowingAccumDeltaSize;
		public float DimBgRatio;
		public ImGuiMouseCursor MouseCursor;
		public bool DragDropActive;
		public bool DragDropWithinSource;
		public bool DragDropWithinTarget;
		public ImGuiDragDropFlags DragDropSourceFlags;
		public int DragDropSourceFrameCount;
		public int DragDropMouseButton;
		public ImGuiPayload DragDropPayload;
		public ImRect DragDropTargetRect;
		public int DragDropTargetId;
		public ImGuiDragDropFlags DragDropAcceptFlags;
		public float DragDropAcceptIdCurrRectSurface;
		public int DragDropAcceptIdCurr;
		public int DragDropAcceptIdPrev;
		public int DragDropAcceptFrameCount;
		public int DragDropHoldJustPressedId;
		public ImVectorUnsignedChar DragDropPayloadBufHeap;
		public unsafe fixed byte DragDropPayloadBufLocal[16];
		public int ClipperTempDataStacked;
		public ImVectorImGuiListClipperData ClipperTempData;
		public unsafe ImGuiTable* CurrentTable;
		public int TablesTempDataStacked;
		public ImVectorImGuiTableTempData TablesTempData;
		public ImPoolImGuiTable Tables;
		public ImVectorFloat TablesLastTimeActive;
		public ImVectorImDrawChannel DrawChannelsTempMergeBuffer;
		public unsafe ImGuiTabBar* CurrentTabBar;
		public ImPoolImGuiTabBar TabBars;
		public ImVectorImGuiPtrOrIndex CurrentTabBarStack;
		public ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer;
		public int HoverDelayId;
		public int HoverDelayIdPreviousFrame;
		public float HoverDelayTimer;
		public float HoverDelayClearTimer;
		public Vector2 MouseLastValidPos;
		public ImGuiInputTextState InputTextState;
		public ImGuiInputTextDeactivatedState InputTextDeactivatedState;
		public ImFont InputTextPasswordFont;
		public int TempInputId;
		public ImGuiColorEditFlags ColorEditOptions;
		public int ColorEditCurrentID;
		public int ColorEditSavedID;
		public float ColorEditSavedHue;
		public float ColorEditSavedSat;
		public uint ColorEditSavedColor;
		public Vector4 ColorPickerRef;
		public ImGuiComboPreviewData ComboPreviewData;
		public float SliderGrabClickOffset;
		public float SliderCurrentAccum;
		public bool SliderCurrentAccumDirty;
		public bool DragCurrentAccumDirty;
		public float DragCurrentAccum;
		public float DragSpeedDefaultRatio;
		public float ScrollbarClickDeltaToGrabCenter;
		public float DisabledAlphaBackup;
		public short DisabledStackSize;
		public short TooltipOverrideCount;
		public ImVectorChar ClipboardHandlerData;
		public ImVectorImGuiID MenusIdSubmittedThisFrame;
		public ImGuiPlatformImeData PlatformImeData;
		public ImGuiPlatformImeData PlatformImeDataPrev;
		public int PlatformImeViewport;
		public byte PlatformLocaleDecimalPoint;
		public ImGuiDockContext DockContext;
		public unsafe delegate*<ImGuiContext*, ImGuiDockNode*, ImGuiTabBar*, void>* DockNodeWindowMenuHandler;
		public bool SettingsLoaded;
		public float SettingsDirtyTimer;
		public ImGuiTextBuffer SettingsIniData;
		public ImVectorImGuiSettingsHandler SettingsHandlers;
		public ImChunkStreamImGuiWindowSettings SettingsWindows;
		public ImChunkStreamImGuiTableSettings SettingsTables;
		public ImVectorImGuiContextHook Hooks;
		public int HookIdNext;
		public unsafe byte* LocalizationTable_0;
		public unsafe byte* LocalizationTable_1;
		public unsafe byte* LocalizationTable_2;
		public unsafe byte* LocalizationTable_3;
		public unsafe byte* LocalizationTable_4;
		public unsafe byte* LocalizationTable_5;
		public unsafe byte* LocalizationTable_6;
		public unsafe byte* LocalizationTable_7;
		public bool LogEnabled;
		public ImGuiLogType LogType;
		public ImFileHandle LogFile;
		public ImGuiTextBuffer LogBuffer;
		public unsafe byte* LogNextPrefix;
		public unsafe byte* LogNextSuffix;
		public float LogLinePosY;
		public bool LogLineFirstItem;
		public int LogDepthRef;
		public int LogDepthToExpand;
		public int LogDepthToExpandDefault;
		public ImGuiDebugLogFlags DebugLogFlags;
		public ImGuiTextBuffer DebugLogBuf;
		public ImGuiTextIndex DebugLogIndex;
		public byte DebugLogClipperAutoDisableFrames;
		public byte DebugLocateFrames;
		public sbyte DebugBeginReturnValueCullDepth;
		public bool DebugItemPickerActive;
		public byte DebugItemPickerMouseButton;
		public int DebugItemPickerBreakId;
		public ImGuiMetricsConfig DebugMetricsConfig;
		public ImGuiStackTool DebugStackTool;
		public unsafe ImGuiDockNode* DebugHoveredDockNode;
		public unsafe fixed float FramerateSecPerFrame[60];
		public int FramerateSecPerFrameIdx;
		public int FramerateSecPerFrameCount;
		public float FramerateSecPerFrameAccum;
		public int WantCaptureMouseNextFrame;
		public int WantCaptureKeyboardNextFrame;
		public int WantTextInputNextFrame;
		public ImVectorChar TempBuffer;

		public unsafe Span<ImGuiKeyOwnerData> KeysOwnerData
		
		{
			get
			{
				fixed (ImGuiKeyOwnerData* p = &this.KeysOwnerData_0)
				{
					return new Span<ImGuiKeyOwnerData>(p, 140);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiIO
	{
		public ImGuiConfigFlags ConfigFlags;
		public ImGuiBackendFlags BackendFlags;
		public Vector2 DisplaySize;
		public float DeltaTime;
		public float IniSavingRate;
		public unsafe byte* IniFilename;
		public unsafe byte* LogFilename;
		public float MouseDoubleClickTime;
		public float MouseDoubleClickMaxDist;
		public float MouseDragThreshold;
		public float KeyRepeatDelay;
		public float KeyRepeatRate;
		public float HoverDelayNormal;
		public float HoverDelayShort;
		public unsafe void* UserData;
		public unsafe ImFontAtlas* Fonts;
		public float FontGlobalScale;
		public bool FontAllowUserScaling;
		public unsafe ImFont* FontDefault;
		public Vector2 DisplayFramebufferScale;
		public bool ConfigDockingNoSplit;
		public bool ConfigDockingWithShift;
		public bool ConfigDockingAlwaysTabBar;
		public bool ConfigDockingTransparentPayload;
		public bool ConfigViewportsNoAutoMerge;
		public bool ConfigViewportsNoTaskBarIcon;
		public bool ConfigViewportsNoDecoration;
		public bool ConfigViewportsNoDefaultParent;
		public bool MouseDrawCursor;
		public bool ConfigMacOSXBehaviors;
		public bool ConfigInputTrickleEventQueue;
		public bool ConfigInputTextCursorBlink;
		public bool ConfigInputTextEnterKeepActive;
		public bool ConfigDragClickToInputText;
		public bool ConfigWindowsResizeFromEdges;
		public bool ConfigWindowsMoveFromTitleBarOnly;
		public float ConfigMemoryCompactTimer;
		public bool ConfigDebugBeginReturnValueOnce;
		public bool ConfigDebugBeginReturnValueLoop;
		public bool ConfigDebugIgnoreFocusLoss;
		public unsafe byte* BackendPlatformName;
		public unsafe byte* BackendRendererName;
		public unsafe void* BackendPlatformUserData;
		public unsafe void* BackendRendererUserData;
		public unsafe void* BackendLanguageUserData;
		public unsafe delegate*<void*, byte*>* GetClipboardTextFn;
		public unsafe delegate*<void*, byte*, void>* SetClipboardTextFn;
		public unsafe void* ClipboardUserData;
		public unsafe delegate*<ImGuiViewport*, ImGuiPlatformImeData*, void>* SetPlatformImeDataFn;
		public unsafe void* UnusedPadding;
		public bool WantCaptureMouse;
		public bool WantCaptureKeyboard;
		public bool WantTextInput;
		public bool WantSetMousePos;
		public bool WantSaveIniSettings;
		public bool NavActive;
		public bool NavVisible;
		public float Framerate;
		public int MetricsRenderVertices;
		public int MetricsRenderIndices;
		public int MetricsRenderWindows;
		public int MetricsActiveWindows;
		public int MetricsActiveAllocations;
		public Vector2 MouseDelta;
		public unsafe fixed int KeyMap[652];
		public unsafe fixed bool KeysDown[652];
		public unsafe fixed float NavInputs[16];
		public unsafe ImGuiContext* Ctx;
		public Vector2 MousePos;
		public unsafe fixed bool MouseDown[5];
		public float MouseWheel;
		public float MouseWheelH;
		public ImGuiMouseSource MouseSource;
		public int MouseHoveredViewport;
		public bool KeyCtrl;
		public bool KeyShift;
		public bool KeyAlt;
		public bool KeySuper;
		public int KeyMods;
		public ImGuiKeyData KeysData_0;
		public ImGuiKeyData KeysData_1;
		public ImGuiKeyData KeysData_2;
		public ImGuiKeyData KeysData_3;
		public ImGuiKeyData KeysData_4;
		public ImGuiKeyData KeysData_5;
		public ImGuiKeyData KeysData_6;
		public ImGuiKeyData KeysData_7;
		public ImGuiKeyData KeysData_8;
		public ImGuiKeyData KeysData_9;
		public ImGuiKeyData KeysData_10;
		public ImGuiKeyData KeysData_11;
		public ImGuiKeyData KeysData_12;
		public ImGuiKeyData KeysData_13;
		public ImGuiKeyData KeysData_14;
		public ImGuiKeyData KeysData_15;
		public ImGuiKeyData KeysData_16;
		public ImGuiKeyData KeysData_17;
		public ImGuiKeyData KeysData_18;
		public ImGuiKeyData KeysData_19;
		public ImGuiKeyData KeysData_20;
		public ImGuiKeyData KeysData_21;
		public ImGuiKeyData KeysData_22;
		public ImGuiKeyData KeysData_23;
		public ImGuiKeyData KeysData_24;
		public ImGuiKeyData KeysData_25;
		public ImGuiKeyData KeysData_26;
		public ImGuiKeyData KeysData_27;
		public ImGuiKeyData KeysData_28;
		public ImGuiKeyData KeysData_29;
		public ImGuiKeyData KeysData_30;
		public ImGuiKeyData KeysData_31;
		public ImGuiKeyData KeysData_32;
		public ImGuiKeyData KeysData_33;
		public ImGuiKeyData KeysData_34;
		public ImGuiKeyData KeysData_35;
		public ImGuiKeyData KeysData_36;
		public ImGuiKeyData KeysData_37;
		public ImGuiKeyData KeysData_38;
		public ImGuiKeyData KeysData_39;
		public ImGuiKeyData KeysData_40;
		public ImGuiKeyData KeysData_41;
		public ImGuiKeyData KeysData_42;
		public ImGuiKeyData KeysData_43;
		public ImGuiKeyData KeysData_44;
		public ImGuiKeyData KeysData_45;
		public ImGuiKeyData KeysData_46;
		public ImGuiKeyData KeysData_47;
		public ImGuiKeyData KeysData_48;
		public ImGuiKeyData KeysData_49;
		public ImGuiKeyData KeysData_50;
		public ImGuiKeyData KeysData_51;
		public ImGuiKeyData KeysData_52;
		public ImGuiKeyData KeysData_53;
		public ImGuiKeyData KeysData_54;
		public ImGuiKeyData KeysData_55;
		public ImGuiKeyData KeysData_56;
		public ImGuiKeyData KeysData_57;
		public ImGuiKeyData KeysData_58;
		public ImGuiKeyData KeysData_59;
		public ImGuiKeyData KeysData_60;
		public ImGuiKeyData KeysData_61;
		public ImGuiKeyData KeysData_62;
		public ImGuiKeyData KeysData_63;
		public ImGuiKeyData KeysData_64;
		public ImGuiKeyData KeysData_65;
		public ImGuiKeyData KeysData_66;
		public ImGuiKeyData KeysData_67;
		public ImGuiKeyData KeysData_68;
		public ImGuiKeyData KeysData_69;
		public ImGuiKeyData KeysData_70;
		public ImGuiKeyData KeysData_71;
		public ImGuiKeyData KeysData_72;
		public ImGuiKeyData KeysData_73;
		public ImGuiKeyData KeysData_74;
		public ImGuiKeyData KeysData_75;
		public ImGuiKeyData KeysData_76;
		public ImGuiKeyData KeysData_77;
		public ImGuiKeyData KeysData_78;
		public ImGuiKeyData KeysData_79;
		public ImGuiKeyData KeysData_80;
		public ImGuiKeyData KeysData_81;
		public ImGuiKeyData KeysData_82;
		public ImGuiKeyData KeysData_83;
		public ImGuiKeyData KeysData_84;
		public ImGuiKeyData KeysData_85;
		public ImGuiKeyData KeysData_86;
		public ImGuiKeyData KeysData_87;
		public ImGuiKeyData KeysData_88;
		public ImGuiKeyData KeysData_89;
		public ImGuiKeyData KeysData_90;
		public ImGuiKeyData KeysData_91;
		public ImGuiKeyData KeysData_92;
		public ImGuiKeyData KeysData_93;
		public ImGuiKeyData KeysData_94;
		public ImGuiKeyData KeysData_95;
		public ImGuiKeyData KeysData_96;
		public ImGuiKeyData KeysData_97;
		public ImGuiKeyData KeysData_98;
		public ImGuiKeyData KeysData_99;
		public ImGuiKeyData KeysData_100;
		public ImGuiKeyData KeysData_101;
		public ImGuiKeyData KeysData_102;
		public ImGuiKeyData KeysData_103;
		public ImGuiKeyData KeysData_104;
		public ImGuiKeyData KeysData_105;
		public ImGuiKeyData KeysData_106;
		public ImGuiKeyData KeysData_107;
		public ImGuiKeyData KeysData_108;
		public ImGuiKeyData KeysData_109;
		public ImGuiKeyData KeysData_110;
		public ImGuiKeyData KeysData_111;
		public ImGuiKeyData KeysData_112;
		public ImGuiKeyData KeysData_113;
		public ImGuiKeyData KeysData_114;
		public ImGuiKeyData KeysData_115;
		public ImGuiKeyData KeysData_116;
		public ImGuiKeyData KeysData_117;
		public ImGuiKeyData KeysData_118;
		public ImGuiKeyData KeysData_119;
		public ImGuiKeyData KeysData_120;
		public ImGuiKeyData KeysData_121;
		public ImGuiKeyData KeysData_122;
		public ImGuiKeyData KeysData_123;
		public ImGuiKeyData KeysData_124;
		public ImGuiKeyData KeysData_125;
		public ImGuiKeyData KeysData_126;
		public ImGuiKeyData KeysData_127;
		public ImGuiKeyData KeysData_128;
		public ImGuiKeyData KeysData_129;
		public ImGuiKeyData KeysData_130;
		public ImGuiKeyData KeysData_131;
		public ImGuiKeyData KeysData_132;
		public ImGuiKeyData KeysData_133;
		public ImGuiKeyData KeysData_134;
		public ImGuiKeyData KeysData_135;
		public ImGuiKeyData KeysData_136;
		public ImGuiKeyData KeysData_137;
		public ImGuiKeyData KeysData_138;
		public ImGuiKeyData KeysData_139;
		public ImGuiKeyData KeysData_140;
		public ImGuiKeyData KeysData_141;
		public ImGuiKeyData KeysData_142;
		public ImGuiKeyData KeysData_143;
		public ImGuiKeyData KeysData_144;
		public ImGuiKeyData KeysData_145;
		public ImGuiKeyData KeysData_146;
		public ImGuiKeyData KeysData_147;
		public ImGuiKeyData KeysData_148;
		public ImGuiKeyData KeysData_149;
		public ImGuiKeyData KeysData_150;
		public ImGuiKeyData KeysData_151;
		public ImGuiKeyData KeysData_152;
		public ImGuiKeyData KeysData_153;
		public ImGuiKeyData KeysData_154;
		public ImGuiKeyData KeysData_155;
		public ImGuiKeyData KeysData_156;
		public ImGuiKeyData KeysData_157;
		public ImGuiKeyData KeysData_158;
		public ImGuiKeyData KeysData_159;
		public ImGuiKeyData KeysData_160;
		public ImGuiKeyData KeysData_161;
		public ImGuiKeyData KeysData_162;
		public ImGuiKeyData KeysData_163;
		public ImGuiKeyData KeysData_164;
		public ImGuiKeyData KeysData_165;
		public ImGuiKeyData KeysData_166;
		public ImGuiKeyData KeysData_167;
		public ImGuiKeyData KeysData_168;
		public ImGuiKeyData KeysData_169;
		public ImGuiKeyData KeysData_170;
		public ImGuiKeyData KeysData_171;
		public ImGuiKeyData KeysData_172;
		public ImGuiKeyData KeysData_173;
		public ImGuiKeyData KeysData_174;
		public ImGuiKeyData KeysData_175;
		public ImGuiKeyData KeysData_176;
		public ImGuiKeyData KeysData_177;
		public ImGuiKeyData KeysData_178;
		public ImGuiKeyData KeysData_179;
		public ImGuiKeyData KeysData_180;
		public ImGuiKeyData KeysData_181;
		public ImGuiKeyData KeysData_182;
		public ImGuiKeyData KeysData_183;
		public ImGuiKeyData KeysData_184;
		public ImGuiKeyData KeysData_185;
		public ImGuiKeyData KeysData_186;
		public ImGuiKeyData KeysData_187;
		public ImGuiKeyData KeysData_188;
		public ImGuiKeyData KeysData_189;
		public ImGuiKeyData KeysData_190;
		public ImGuiKeyData KeysData_191;
		public ImGuiKeyData KeysData_192;
		public ImGuiKeyData KeysData_193;
		public ImGuiKeyData KeysData_194;
		public ImGuiKeyData KeysData_195;
		public ImGuiKeyData KeysData_196;
		public ImGuiKeyData KeysData_197;
		public ImGuiKeyData KeysData_198;
		public ImGuiKeyData KeysData_199;
		public ImGuiKeyData KeysData_200;
		public ImGuiKeyData KeysData_201;
		public ImGuiKeyData KeysData_202;
		public ImGuiKeyData KeysData_203;
		public ImGuiKeyData KeysData_204;
		public ImGuiKeyData KeysData_205;
		public ImGuiKeyData KeysData_206;
		public ImGuiKeyData KeysData_207;
		public ImGuiKeyData KeysData_208;
		public ImGuiKeyData KeysData_209;
		public ImGuiKeyData KeysData_210;
		public ImGuiKeyData KeysData_211;
		public ImGuiKeyData KeysData_212;
		public ImGuiKeyData KeysData_213;
		public ImGuiKeyData KeysData_214;
		public ImGuiKeyData KeysData_215;
		public ImGuiKeyData KeysData_216;
		public ImGuiKeyData KeysData_217;
		public ImGuiKeyData KeysData_218;
		public ImGuiKeyData KeysData_219;
		public ImGuiKeyData KeysData_220;
		public ImGuiKeyData KeysData_221;
		public ImGuiKeyData KeysData_222;
		public ImGuiKeyData KeysData_223;
		public ImGuiKeyData KeysData_224;
		public ImGuiKeyData KeysData_225;
		public ImGuiKeyData KeysData_226;
		public ImGuiKeyData KeysData_227;
		public ImGuiKeyData KeysData_228;
		public ImGuiKeyData KeysData_229;
		public ImGuiKeyData KeysData_230;
		public ImGuiKeyData KeysData_231;
		public ImGuiKeyData KeysData_232;
		public ImGuiKeyData KeysData_233;
		public ImGuiKeyData KeysData_234;
		public ImGuiKeyData KeysData_235;
		public ImGuiKeyData KeysData_236;
		public ImGuiKeyData KeysData_237;
		public ImGuiKeyData KeysData_238;
		public ImGuiKeyData KeysData_239;
		public ImGuiKeyData KeysData_240;
		public ImGuiKeyData KeysData_241;
		public ImGuiKeyData KeysData_242;
		public ImGuiKeyData KeysData_243;
		public ImGuiKeyData KeysData_244;
		public ImGuiKeyData KeysData_245;
		public ImGuiKeyData KeysData_246;
		public ImGuiKeyData KeysData_247;
		public ImGuiKeyData KeysData_248;
		public ImGuiKeyData KeysData_249;
		public ImGuiKeyData KeysData_250;
		public ImGuiKeyData KeysData_251;
		public ImGuiKeyData KeysData_252;
		public ImGuiKeyData KeysData_253;
		public ImGuiKeyData KeysData_254;
		public ImGuiKeyData KeysData_255;
		public ImGuiKeyData KeysData_256;
		public ImGuiKeyData KeysData_257;
		public ImGuiKeyData KeysData_258;
		public ImGuiKeyData KeysData_259;
		public ImGuiKeyData KeysData_260;
		public ImGuiKeyData KeysData_261;
		public ImGuiKeyData KeysData_262;
		public ImGuiKeyData KeysData_263;
		public ImGuiKeyData KeysData_264;
		public ImGuiKeyData KeysData_265;
		public ImGuiKeyData KeysData_266;
		public ImGuiKeyData KeysData_267;
		public ImGuiKeyData KeysData_268;
		public ImGuiKeyData KeysData_269;
		public ImGuiKeyData KeysData_270;
		public ImGuiKeyData KeysData_271;
		public ImGuiKeyData KeysData_272;
		public ImGuiKeyData KeysData_273;
		public ImGuiKeyData KeysData_274;
		public ImGuiKeyData KeysData_275;
		public ImGuiKeyData KeysData_276;
		public ImGuiKeyData KeysData_277;
		public ImGuiKeyData KeysData_278;
		public ImGuiKeyData KeysData_279;
		public ImGuiKeyData KeysData_280;
		public ImGuiKeyData KeysData_281;
		public ImGuiKeyData KeysData_282;
		public ImGuiKeyData KeysData_283;
		public ImGuiKeyData KeysData_284;
		public ImGuiKeyData KeysData_285;
		public ImGuiKeyData KeysData_286;
		public ImGuiKeyData KeysData_287;
		public ImGuiKeyData KeysData_288;
		public ImGuiKeyData KeysData_289;
		public ImGuiKeyData KeysData_290;
		public ImGuiKeyData KeysData_291;
		public ImGuiKeyData KeysData_292;
		public ImGuiKeyData KeysData_293;
		public ImGuiKeyData KeysData_294;
		public ImGuiKeyData KeysData_295;
		public ImGuiKeyData KeysData_296;
		public ImGuiKeyData KeysData_297;
		public ImGuiKeyData KeysData_298;
		public ImGuiKeyData KeysData_299;
		public ImGuiKeyData KeysData_300;
		public ImGuiKeyData KeysData_301;
		public ImGuiKeyData KeysData_302;
		public ImGuiKeyData KeysData_303;
		public ImGuiKeyData KeysData_304;
		public ImGuiKeyData KeysData_305;
		public ImGuiKeyData KeysData_306;
		public ImGuiKeyData KeysData_307;
		public ImGuiKeyData KeysData_308;
		public ImGuiKeyData KeysData_309;
		public ImGuiKeyData KeysData_310;
		public ImGuiKeyData KeysData_311;
		public ImGuiKeyData KeysData_312;
		public ImGuiKeyData KeysData_313;
		public ImGuiKeyData KeysData_314;
		public ImGuiKeyData KeysData_315;
		public ImGuiKeyData KeysData_316;
		public ImGuiKeyData KeysData_317;
		public ImGuiKeyData KeysData_318;
		public ImGuiKeyData KeysData_319;
		public ImGuiKeyData KeysData_320;
		public ImGuiKeyData KeysData_321;
		public ImGuiKeyData KeysData_322;
		public ImGuiKeyData KeysData_323;
		public ImGuiKeyData KeysData_324;
		public ImGuiKeyData KeysData_325;
		public ImGuiKeyData KeysData_326;
		public ImGuiKeyData KeysData_327;
		public ImGuiKeyData KeysData_328;
		public ImGuiKeyData KeysData_329;
		public ImGuiKeyData KeysData_330;
		public ImGuiKeyData KeysData_331;
		public ImGuiKeyData KeysData_332;
		public ImGuiKeyData KeysData_333;
		public ImGuiKeyData KeysData_334;
		public ImGuiKeyData KeysData_335;
		public ImGuiKeyData KeysData_336;
		public ImGuiKeyData KeysData_337;
		public ImGuiKeyData KeysData_338;
		public ImGuiKeyData KeysData_339;
		public ImGuiKeyData KeysData_340;
		public ImGuiKeyData KeysData_341;
		public ImGuiKeyData KeysData_342;
		public ImGuiKeyData KeysData_343;
		public ImGuiKeyData KeysData_344;
		public ImGuiKeyData KeysData_345;
		public ImGuiKeyData KeysData_346;
		public ImGuiKeyData KeysData_347;
		public ImGuiKeyData KeysData_348;
		public ImGuiKeyData KeysData_349;
		public ImGuiKeyData KeysData_350;
		public ImGuiKeyData KeysData_351;
		public ImGuiKeyData KeysData_352;
		public ImGuiKeyData KeysData_353;
		public ImGuiKeyData KeysData_354;
		public ImGuiKeyData KeysData_355;
		public ImGuiKeyData KeysData_356;
		public ImGuiKeyData KeysData_357;
		public ImGuiKeyData KeysData_358;
		public ImGuiKeyData KeysData_359;
		public ImGuiKeyData KeysData_360;
		public ImGuiKeyData KeysData_361;
		public ImGuiKeyData KeysData_362;
		public ImGuiKeyData KeysData_363;
		public ImGuiKeyData KeysData_364;
		public ImGuiKeyData KeysData_365;
		public ImGuiKeyData KeysData_366;
		public ImGuiKeyData KeysData_367;
		public ImGuiKeyData KeysData_368;
		public ImGuiKeyData KeysData_369;
		public ImGuiKeyData KeysData_370;
		public ImGuiKeyData KeysData_371;
		public ImGuiKeyData KeysData_372;
		public ImGuiKeyData KeysData_373;
		public ImGuiKeyData KeysData_374;
		public ImGuiKeyData KeysData_375;
		public ImGuiKeyData KeysData_376;
		public ImGuiKeyData KeysData_377;
		public ImGuiKeyData KeysData_378;
		public ImGuiKeyData KeysData_379;
		public ImGuiKeyData KeysData_380;
		public ImGuiKeyData KeysData_381;
		public ImGuiKeyData KeysData_382;
		public ImGuiKeyData KeysData_383;
		public ImGuiKeyData KeysData_384;
		public ImGuiKeyData KeysData_385;
		public ImGuiKeyData KeysData_386;
		public ImGuiKeyData KeysData_387;
		public ImGuiKeyData KeysData_388;
		public ImGuiKeyData KeysData_389;
		public ImGuiKeyData KeysData_390;
		public ImGuiKeyData KeysData_391;
		public ImGuiKeyData KeysData_392;
		public ImGuiKeyData KeysData_393;
		public ImGuiKeyData KeysData_394;
		public ImGuiKeyData KeysData_395;
		public ImGuiKeyData KeysData_396;
		public ImGuiKeyData KeysData_397;
		public ImGuiKeyData KeysData_398;
		public ImGuiKeyData KeysData_399;
		public ImGuiKeyData KeysData_400;
		public ImGuiKeyData KeysData_401;
		public ImGuiKeyData KeysData_402;
		public ImGuiKeyData KeysData_403;
		public ImGuiKeyData KeysData_404;
		public ImGuiKeyData KeysData_405;
		public ImGuiKeyData KeysData_406;
		public ImGuiKeyData KeysData_407;
		public ImGuiKeyData KeysData_408;
		public ImGuiKeyData KeysData_409;
		public ImGuiKeyData KeysData_410;
		public ImGuiKeyData KeysData_411;
		public ImGuiKeyData KeysData_412;
		public ImGuiKeyData KeysData_413;
		public ImGuiKeyData KeysData_414;
		public ImGuiKeyData KeysData_415;
		public ImGuiKeyData KeysData_416;
		public ImGuiKeyData KeysData_417;
		public ImGuiKeyData KeysData_418;
		public ImGuiKeyData KeysData_419;
		public ImGuiKeyData KeysData_420;
		public ImGuiKeyData KeysData_421;
		public ImGuiKeyData KeysData_422;
		public ImGuiKeyData KeysData_423;
		public ImGuiKeyData KeysData_424;
		public ImGuiKeyData KeysData_425;
		public ImGuiKeyData KeysData_426;
		public ImGuiKeyData KeysData_427;
		public ImGuiKeyData KeysData_428;
		public ImGuiKeyData KeysData_429;
		public ImGuiKeyData KeysData_430;
		public ImGuiKeyData KeysData_431;
		public ImGuiKeyData KeysData_432;
		public ImGuiKeyData KeysData_433;
		public ImGuiKeyData KeysData_434;
		public ImGuiKeyData KeysData_435;
		public ImGuiKeyData KeysData_436;
		public ImGuiKeyData KeysData_437;
		public ImGuiKeyData KeysData_438;
		public ImGuiKeyData KeysData_439;
		public ImGuiKeyData KeysData_440;
		public ImGuiKeyData KeysData_441;
		public ImGuiKeyData KeysData_442;
		public ImGuiKeyData KeysData_443;
		public ImGuiKeyData KeysData_444;
		public ImGuiKeyData KeysData_445;
		public ImGuiKeyData KeysData_446;
		public ImGuiKeyData KeysData_447;
		public ImGuiKeyData KeysData_448;
		public ImGuiKeyData KeysData_449;
		public ImGuiKeyData KeysData_450;
		public ImGuiKeyData KeysData_451;
		public ImGuiKeyData KeysData_452;
		public ImGuiKeyData KeysData_453;
		public ImGuiKeyData KeysData_454;
		public ImGuiKeyData KeysData_455;
		public ImGuiKeyData KeysData_456;
		public ImGuiKeyData KeysData_457;
		public ImGuiKeyData KeysData_458;
		public ImGuiKeyData KeysData_459;
		public ImGuiKeyData KeysData_460;
		public ImGuiKeyData KeysData_461;
		public ImGuiKeyData KeysData_462;
		public ImGuiKeyData KeysData_463;
		public ImGuiKeyData KeysData_464;
		public ImGuiKeyData KeysData_465;
		public ImGuiKeyData KeysData_466;
		public ImGuiKeyData KeysData_467;
		public ImGuiKeyData KeysData_468;
		public ImGuiKeyData KeysData_469;
		public ImGuiKeyData KeysData_470;
		public ImGuiKeyData KeysData_471;
		public ImGuiKeyData KeysData_472;
		public ImGuiKeyData KeysData_473;
		public ImGuiKeyData KeysData_474;
		public ImGuiKeyData KeysData_475;
		public ImGuiKeyData KeysData_476;
		public ImGuiKeyData KeysData_477;
		public ImGuiKeyData KeysData_478;
		public ImGuiKeyData KeysData_479;
		public ImGuiKeyData KeysData_480;
		public ImGuiKeyData KeysData_481;
		public ImGuiKeyData KeysData_482;
		public ImGuiKeyData KeysData_483;
		public ImGuiKeyData KeysData_484;
		public ImGuiKeyData KeysData_485;
		public ImGuiKeyData KeysData_486;
		public ImGuiKeyData KeysData_487;
		public ImGuiKeyData KeysData_488;
		public ImGuiKeyData KeysData_489;
		public ImGuiKeyData KeysData_490;
		public ImGuiKeyData KeysData_491;
		public ImGuiKeyData KeysData_492;
		public ImGuiKeyData KeysData_493;
		public ImGuiKeyData KeysData_494;
		public ImGuiKeyData KeysData_495;
		public ImGuiKeyData KeysData_496;
		public ImGuiKeyData KeysData_497;
		public ImGuiKeyData KeysData_498;
		public ImGuiKeyData KeysData_499;
		public ImGuiKeyData KeysData_500;
		public ImGuiKeyData KeysData_501;
		public ImGuiKeyData KeysData_502;
		public ImGuiKeyData KeysData_503;
		public ImGuiKeyData KeysData_504;
		public ImGuiKeyData KeysData_505;
		public ImGuiKeyData KeysData_506;
		public ImGuiKeyData KeysData_507;
		public ImGuiKeyData KeysData_508;
		public ImGuiKeyData KeysData_509;
		public ImGuiKeyData KeysData_510;
		public ImGuiKeyData KeysData_511;
		public ImGuiKeyData KeysData_512;
		public ImGuiKeyData KeysData_513;
		public ImGuiKeyData KeysData_514;
		public ImGuiKeyData KeysData_515;
		public ImGuiKeyData KeysData_516;
		public ImGuiKeyData KeysData_517;
		public ImGuiKeyData KeysData_518;
		public ImGuiKeyData KeysData_519;
		public ImGuiKeyData KeysData_520;
		public ImGuiKeyData KeysData_521;
		public ImGuiKeyData KeysData_522;
		public ImGuiKeyData KeysData_523;
		public ImGuiKeyData KeysData_524;
		public ImGuiKeyData KeysData_525;
		public ImGuiKeyData KeysData_526;
		public ImGuiKeyData KeysData_527;
		public ImGuiKeyData KeysData_528;
		public ImGuiKeyData KeysData_529;
		public ImGuiKeyData KeysData_530;
		public ImGuiKeyData KeysData_531;
		public ImGuiKeyData KeysData_532;
		public ImGuiKeyData KeysData_533;
		public ImGuiKeyData KeysData_534;
		public ImGuiKeyData KeysData_535;
		public ImGuiKeyData KeysData_536;
		public ImGuiKeyData KeysData_537;
		public ImGuiKeyData KeysData_538;
		public ImGuiKeyData KeysData_539;
		public ImGuiKeyData KeysData_540;
		public ImGuiKeyData KeysData_541;
		public ImGuiKeyData KeysData_542;
		public ImGuiKeyData KeysData_543;
		public ImGuiKeyData KeysData_544;
		public ImGuiKeyData KeysData_545;
		public ImGuiKeyData KeysData_546;
		public ImGuiKeyData KeysData_547;
		public ImGuiKeyData KeysData_548;
		public ImGuiKeyData KeysData_549;
		public ImGuiKeyData KeysData_550;
		public ImGuiKeyData KeysData_551;
		public ImGuiKeyData KeysData_552;
		public ImGuiKeyData KeysData_553;
		public ImGuiKeyData KeysData_554;
		public ImGuiKeyData KeysData_555;
		public ImGuiKeyData KeysData_556;
		public ImGuiKeyData KeysData_557;
		public ImGuiKeyData KeysData_558;
		public ImGuiKeyData KeysData_559;
		public ImGuiKeyData KeysData_560;
		public ImGuiKeyData KeysData_561;
		public ImGuiKeyData KeysData_562;
		public ImGuiKeyData KeysData_563;
		public ImGuiKeyData KeysData_564;
		public ImGuiKeyData KeysData_565;
		public ImGuiKeyData KeysData_566;
		public ImGuiKeyData KeysData_567;
		public ImGuiKeyData KeysData_568;
		public ImGuiKeyData KeysData_569;
		public ImGuiKeyData KeysData_570;
		public ImGuiKeyData KeysData_571;
		public ImGuiKeyData KeysData_572;
		public ImGuiKeyData KeysData_573;
		public ImGuiKeyData KeysData_574;
		public ImGuiKeyData KeysData_575;
		public ImGuiKeyData KeysData_576;
		public ImGuiKeyData KeysData_577;
		public ImGuiKeyData KeysData_578;
		public ImGuiKeyData KeysData_579;
		public ImGuiKeyData KeysData_580;
		public ImGuiKeyData KeysData_581;
		public ImGuiKeyData KeysData_582;
		public ImGuiKeyData KeysData_583;
		public ImGuiKeyData KeysData_584;
		public ImGuiKeyData KeysData_585;
		public ImGuiKeyData KeysData_586;
		public ImGuiKeyData KeysData_587;
		public ImGuiKeyData KeysData_588;
		public ImGuiKeyData KeysData_589;
		public ImGuiKeyData KeysData_590;
		public ImGuiKeyData KeysData_591;
		public ImGuiKeyData KeysData_592;
		public ImGuiKeyData KeysData_593;
		public ImGuiKeyData KeysData_594;
		public ImGuiKeyData KeysData_595;
		public ImGuiKeyData KeysData_596;
		public ImGuiKeyData KeysData_597;
		public ImGuiKeyData KeysData_598;
		public ImGuiKeyData KeysData_599;
		public ImGuiKeyData KeysData_600;
		public ImGuiKeyData KeysData_601;
		public ImGuiKeyData KeysData_602;
		public ImGuiKeyData KeysData_603;
		public ImGuiKeyData KeysData_604;
		public ImGuiKeyData KeysData_605;
		public ImGuiKeyData KeysData_606;
		public ImGuiKeyData KeysData_607;
		public ImGuiKeyData KeysData_608;
		public ImGuiKeyData KeysData_609;
		public ImGuiKeyData KeysData_610;
		public ImGuiKeyData KeysData_611;
		public ImGuiKeyData KeysData_612;
		public ImGuiKeyData KeysData_613;
		public ImGuiKeyData KeysData_614;
		public ImGuiKeyData KeysData_615;
		public ImGuiKeyData KeysData_616;
		public ImGuiKeyData KeysData_617;
		public ImGuiKeyData KeysData_618;
		public ImGuiKeyData KeysData_619;
		public ImGuiKeyData KeysData_620;
		public ImGuiKeyData KeysData_621;
		public ImGuiKeyData KeysData_622;
		public ImGuiKeyData KeysData_623;
		public ImGuiKeyData KeysData_624;
		public ImGuiKeyData KeysData_625;
		public ImGuiKeyData KeysData_626;
		public ImGuiKeyData KeysData_627;
		public ImGuiKeyData KeysData_628;
		public ImGuiKeyData KeysData_629;
		public ImGuiKeyData KeysData_630;
		public ImGuiKeyData KeysData_631;
		public ImGuiKeyData KeysData_632;
		public ImGuiKeyData KeysData_633;
		public ImGuiKeyData KeysData_634;
		public ImGuiKeyData KeysData_635;
		public ImGuiKeyData KeysData_636;
		public ImGuiKeyData KeysData_637;
		public ImGuiKeyData KeysData_638;
		public ImGuiKeyData KeysData_639;
		public ImGuiKeyData KeysData_640;
		public ImGuiKeyData KeysData_641;
		public ImGuiKeyData KeysData_642;
		public ImGuiKeyData KeysData_643;
		public ImGuiKeyData KeysData_644;
		public ImGuiKeyData KeysData_645;
		public ImGuiKeyData KeysData_646;
		public ImGuiKeyData KeysData_647;
		public ImGuiKeyData KeysData_648;
		public ImGuiKeyData KeysData_649;
		public ImGuiKeyData KeysData_650;
		public ImGuiKeyData KeysData_651;
		public bool WantCaptureMouseUnlessPopupClose;
		public Vector2 MousePosPrev;
		public Vector2 MouseClickedPos_0;
		public Vector2 MouseClickedPos_1;
		public Vector2 MouseClickedPos_2;
		public Vector2 MouseClickedPos_3;
		public Vector2 MouseClickedPos_4;
		public unsafe fixed double MouseClickedTime[5];
		public unsafe fixed bool MouseClicked[5];
		public unsafe fixed bool MouseDoubleClicked[5];
		public unsafe fixed ushort MouseClickedCount[5];
		public unsafe fixed ushort MouseClickedLastCount[5];
		public unsafe fixed bool MouseReleased[5];
		public unsafe fixed bool MouseDownOwned[5];
		public unsafe fixed bool MouseDownOwnedUnlessPopupClose[5];
		public bool MouseWheelRequestAxisSwap;
		public unsafe fixed float MouseDownDuration[5];
		public unsafe fixed float MouseDownDurationPrev[5];
		public Vector2 MouseDragMaxDistanceAbs_0;
		public Vector2 MouseDragMaxDistanceAbs_1;
		public Vector2 MouseDragMaxDistanceAbs_2;
		public Vector2 MouseDragMaxDistanceAbs_3;
		public Vector2 MouseDragMaxDistanceAbs_4;
		public unsafe fixed float MouseDragMaxDistanceSqr[5];
		public float PenPressure;
		public bool AppFocusLost;
		public bool AppAcceptingEvents;
		public sbyte BackendUsingLegacyKeyArrays;
		public bool BackendUsingLegacyNavInputArray;
		public char InputQueueSurrogate;
		public ImVectorImWchar InputQueueCharacters;

		public unsafe Span<ImGuiKeyData> KeysData
		
		{
			get
			{
				fixed (ImGuiKeyData* p = &this.KeysData_0)
				{
					return new Span<ImGuiKeyData>(p, 652);
				}
			}
		}
		public unsafe Span<Vector2> MouseClickedPos
		
		{
			get
			{
				fixed (Vector2* p = &this.MouseClickedPos_0)
				{
					return new Span<Vector2>(p, 5);
				}
			}
		}
		public unsafe Span<Vector2> MouseDragMaxDistanceAbs
		
		{
			get
			{
				fixed (Vector2* p = &this.MouseDragMaxDistanceAbs_0)
				{
					return new Span<Vector2>(p, 5);
				}
			}
		}

		public unsafe void AddFocusEvent(bool focused)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddFocusEvent(@this, focused);
			}
		}

		public unsafe void AddInputCharacter(uint c)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharacter(@this, c);
			}
		}

		public unsafe void AddInputCharactersUTF8(ref byte str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.AddInputCharactersUTF8(@this, pstr);
				}
			}
		}

		public unsafe void AddInputCharactersUTF8(string str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddInputCharactersUTF8(@this, pStr0);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void AddInputCharactersUTF8(byte* str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharactersUTF8(@this, str);
			}
		}

		public unsafe void AddInputCharacterUTF16(char c)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharacterUTF16(@this, c);
			}
		}

		public unsafe void AddKeyAnalogEvent(ImGuiKey key, bool down, float v)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddKeyAnalogEvent(@this, key, down, v);
			}
		}

		public unsafe void AddKeyEvent(ImGuiKey key, bool down)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddKeyEvent(@this, key, down);
			}
		}

		public unsafe void AddMouseButtonEvent(int button, bool down)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseButtonEvent(@this, button, down);
			}
		}

		public unsafe void AddMousePosEvent(float x, float y)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMousePosEvent(@this, x, y);
			}
		}

		public unsafe void AddMouseSourceEvent(ImGuiMouseSource source)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseSourceEvent(@this, source);
			}
		}

		public unsafe void AddMouseViewportEvent(int id)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseViewportEvent(@this, id);
			}
		}

		public unsafe void AddMouseWheelEvent(float wheelX, float wheelY)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseWheelEvent(@this, wheelX, wheelY);
			}
		}

		public unsafe void ClearInputCharacters()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.ClearInputCharacters(@this);
			}
		}

		public unsafe void ClearInputKeys()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.ClearInputKeys(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe void SetAppAcceptingEvents(bool acceptingEvents)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetAppAcceptingEvents(@this, acceptingEvents);
			}
		}

		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetKeyEventNativeData(@this, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformImeData
	{
		public bool WantVisible;
		public Vector2 InputPos;
		public float InputLineHeight;


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformImeData* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyData
	{
		public bool Down;
		public float DownDuration;
		public float DownDurationPrev;
		public float AnalogValue;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformIO
	{
		public unsafe delegate*<ImGuiViewport*, void>* PlatformCreateWindow;
		public unsafe delegate*<ImGuiViewport*, void>* PlatformDestroyWindow;
		public unsafe delegate*<ImGuiViewport*, void>* PlatformShowWindow;
		public unsafe delegate*<ImGuiViewport*, Vector2, void>* PlatformSetWindowPos;
		public unsafe delegate*<ImGuiViewport*, Vector2>* PlatformGetWindowPos;
		public unsafe delegate*<ImGuiViewport*, Vector2, void>* PlatformSetWindowSize;
		public unsafe delegate*<ImGuiViewport*, Vector2>* PlatformGetWindowSize;
		public unsafe delegate*<ImGuiViewport*, void>* PlatformSetWindowFocus;
		public unsafe delegate*<ImGuiViewport*, bool>* PlatformGetWindowFocus;
		public unsafe delegate*<ImGuiViewport*, bool>* PlatformGetWindowMinimized;
		public unsafe delegate*<ImGuiViewport*, byte*, void>* PlatformSetWindowTitle;
		public unsafe delegate*<ImGuiViewport*, float, void>* PlatformSetWindowAlpha;
		public unsafe delegate*<ImGuiViewport*, void>* PlatformUpdateWindow;
		public unsafe delegate*<ImGuiViewport*, void*, void>* PlatformRenderWindow;
		public unsafe delegate*<ImGuiViewport*, void*, void>* PlatformSwapBuffers;
		public unsafe delegate*<ImGuiViewport*, float>* PlatformGetWindowDpiScale;
		public unsafe delegate*<ImGuiViewport*, void>* PlatformOnChangedViewport;
		public unsafe delegate*<ImGuiViewport*, ulong, void*, ulong*, int>* PlatformCreateVkSurface;
		public unsafe delegate*<ImGuiViewport*, void>* RendererCreateWindow;
		public unsafe delegate*<ImGuiViewport*, void>* RendererDestroyWindow;
		public unsafe delegate*<ImGuiViewport*, Vector2, void>* RendererSetWindowSize;
		public unsafe delegate*<ImGuiViewport*, void*, void>* RendererRenderWindow;
		public unsafe delegate*<ImGuiViewport*, void*, void>* RendererSwapBuffers;
		public ImVectorImGuiPlatformMonitor Monitors;
		public ImVectorImGuiViewportPtr Viewports;


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformIO* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPlatformMonitor
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPlatformMonitor* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformMonitor
	{
		public Vector2 MainPos;
		public Vector2 MainSize;
		public Vector2 WorkPos;
		public Vector2 WorkSize;
		public float DpiScale;
		public unsafe void* PlatformHandle;


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformMonitor* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiViewport** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyle
	{
		public float Alpha;
		public float DisabledAlpha;
		public Vector2 WindowPadding;
		public float WindowRounding;
		public float WindowBorderSize;
		public Vector2 WindowMinSize;
		public Vector2 WindowTitleAlign;
		public ImGuiDir WindowMenuButtonPosition;
		public float ChildRounding;
		public float ChildBorderSize;
		public float PopupRounding;
		public float PopupBorderSize;
		public Vector2 FramePadding;
		public float FrameRounding;
		public float FrameBorderSize;
		public Vector2 ItemSpacing;
		public Vector2 ItemInnerSpacing;
		public Vector2 CellPadding;
		public Vector2 TouchExtraPadding;
		public float IndentSpacing;
		public float ColumnsMinSpacing;
		public float ScrollbarSize;
		public float ScrollbarRounding;
		public float GrabMinSize;
		public float GrabRounding;
		public float LogSliderDeadzone;
		public float TabRounding;
		public float TabBorderSize;
		public float TabMinWidthForCloseButton;
		public ImGuiDir ColorButtonPosition;
		public Vector2 ButtonTextAlign;
		public Vector2 SelectableTextAlign;
		public float SeparatorTextBorderSize;
		public Vector2 SeparatorTextAlign;
		public Vector2 SeparatorTextPadding;
		public Vector2 DisplayWindowPadding;
		public Vector2 DisplaySafeAreaPadding;
		public float MouseCursorScale;
		public bool AntiAliasedLines;
		public bool AntiAliasedLinesUseTex;
		public bool AntiAliasedFill;
		public float CurveTessellationTol;
		public float CircleTessellationMaxError;
		public Vector4 Colors_0;
		public Vector4 Colors_1;
		public Vector4 Colors_2;
		public Vector4 Colors_3;
		public Vector4 Colors_4;
		public Vector4 Colors_5;
		public Vector4 Colors_6;
		public Vector4 Colors_7;
		public Vector4 Colors_8;
		public Vector4 Colors_9;
		public Vector4 Colors_10;
		public Vector4 Colors_11;
		public Vector4 Colors_12;
		public Vector4 Colors_13;
		public Vector4 Colors_14;
		public Vector4 Colors_15;
		public Vector4 Colors_16;
		public Vector4 Colors_17;
		public Vector4 Colors_18;
		public Vector4 Colors_19;
		public Vector4 Colors_20;
		public Vector4 Colors_21;
		public Vector4 Colors_22;
		public Vector4 Colors_23;
		public Vector4 Colors_24;
		public Vector4 Colors_25;
		public Vector4 Colors_26;
		public Vector4 Colors_27;
		public Vector4 Colors_28;
		public Vector4 Colors_29;
		public Vector4 Colors_30;
		public Vector4 Colors_31;
		public Vector4 Colors_32;
		public Vector4 Colors_33;
		public Vector4 Colors_34;
		public Vector4 Colors_35;
		public Vector4 Colors_36;
		public Vector4 Colors_37;
		public Vector4 Colors_38;
		public Vector4 Colors_39;
		public Vector4 Colors_40;
		public Vector4 Colors_41;
		public Vector4 Colors_42;
		public Vector4 Colors_43;
		public Vector4 Colors_44;
		public Vector4 Colors_45;
		public Vector4 Colors_46;
		public Vector4 Colors_47;
		public Vector4 Colors_48;
		public Vector4 Colors_49;
		public Vector4 Colors_50;
		public Vector4 Colors_51;
		public Vector4 Colors_52;
		public Vector4 Colors_53;
		public Vector4 Colors_54;

		public unsafe Span<Vector4> Colors
		
		{
			get
			{
				fixed (Vector4* p = &this.Colors_0)
				{
					return new Span<Vector4>(p, 55);
				}
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiStyle* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe void ScaleAllSizes(float scaleFactor)
		{
			fixed (ImGuiStyle* @this = &this)
			{
				ImGui.ScaleAllSizes(@this, scaleFactor);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiInputEvent
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiInputEvent* Data;

	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiInputEventUnion
	{
		[FieldOffset(0)]
		public ImGuiInputEventMousePos MousePos;
		[FieldOffset(0)]
		public ImGuiInputEventMouseWheel MouseWheel;
		[FieldOffset(0)]
		public ImGuiInputEventMouseButton MouseButton;
		[FieldOffset(0)]
		public ImGuiInputEventMouseViewport MouseViewport;
		[FieldOffset(0)]
		public ImGuiInputEventKey Key;
		[FieldOffset(0)]
		public ImGuiInputEventText Text;
		[FieldOffset(0)]
		public ImGuiInputEventAppFocused AppFocused;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEvent
	{
		public ImGuiInputEventType Type;
		public ImGuiInputSource Source;
		public uint EventId;
		public ImGuiInputEventUnion ImGuiInputEventUnion;
		public bool AddedByTestEngine;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMousePos
	{
		public float PosX;
		public float PosY;
		public ImGuiMouseSource MouseSource;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseWheel
	{
		public float WheelX;
		public float WheelY;
		public ImGuiMouseSource MouseSource;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseButton
	{
		public int Button;
		public bool Down;
		public ImGuiMouseSource MouseSource;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseViewport
	{
		public int HoveredViewportID;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventKey
	{
		public ImGuiKey Key;
		public bool Down;
		public float AnalogValue;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventText
	{
		public uint Char;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventAppFocused
	{
		public bool Focused;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiWindow** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindow
	{
		public unsafe ImGuiContext* Ctx;
		public unsafe byte* Name;
		public int ID;
		public ImGuiWindowFlags Flags;
		public ImGuiWindowFlags FlagsPreviousFrame;
		public ImGuiWindowClass WindowClass;
		public unsafe ImGuiViewportP* Viewport;
		public int ViewportId;
		public Vector2 ViewportPos;
		public int ViewportAllowPlatformMonitorExtend;
		public Vector2 Pos;
		public Vector2 Size;
		public Vector2 SizeFull;
		public Vector2 ContentSize;
		public Vector2 ContentSizeIdeal;
		public Vector2 ContentSizeExplicit;
		public Vector2 WindowPadding;
		public float WindowRounding;
		public float WindowBorderSize;
		public float DecoOuterSizeX1;
		public float DecoOuterSizeY1;
		public float DecoOuterSizeX2;
		public float DecoOuterSizeY2;
		public float DecoInnerSizeX1;
		public float DecoInnerSizeY1;
		public int NameBufLen;
		public int MoveId;
		public int TabId;
		public int ChildId;
		public Vector2 Scroll;
		public Vector2 ScrollMax;
		public Vector2 ScrollTarget;
		public Vector2 ScrollTargetCenterRatio;
		public Vector2 ScrollTargetEdgeSnapDist;
		public Vector2 ScrollbarSizes;
		public bool ScrollbarX;
		public bool ScrollbarY;
		public bool ViewportOwned;
		public bool Active;
		public bool WasActive;
		public bool WriteAccessed;
		public bool Collapsed;
		public bool WantCollapseToggle;
		public bool SkipItems;
		public bool Appearing;
		public bool Hidden;
		public bool IsFallbackWindow;
		public bool IsExplicitChild;
		public bool HasCloseButton;
		public byte ResizeBorderHeld;
		public short BeginCount;
		public short BeginCountPreviousFrame;
		public short BeginOrderWithinParent;
		public short BeginOrderWithinContext;
		public short FocusOrder;
		public int PopupId;
		public sbyte AutoFitFramesX;
		public sbyte AutoFitFramesY;
		public sbyte AutoFitChildAxises;
		public bool AutoFitOnlyGrows;
		public ImGuiDir AutoPosLastDirection;
		public sbyte HiddenFramesCanSkipItems;
		public sbyte HiddenFramesCannotSkipItems;
		public sbyte HiddenFramesForRenderOnly;
		public sbyte DisableInputsFrames;
		public ImGuiCond SetWindowPosAllowFlags;
		public ImGuiCond SetWindowSizeAllowFlags;
		public ImGuiCond SetWindowCollapsedAllowFlags;
		public ImGuiCond SetWindowDockAllowFlags;
		public Vector2 SetWindowPosVal;
		public Vector2 SetWindowPosPivot;
		public ImVectorImGuiID IDStack;
		public ImGuiWindowTempData DC;
		public ImRect OuterRectClipped;
		public ImRect InnerRect;
		public ImRect InnerClipRect;
		public ImRect WorkRect;
		public ImRect ParentWorkRect;
		public ImRect ClipRect;
		public ImRect ContentRegionRect;
		public ImVec2ih HitTestHoleSize;
		public ImVec2ih HitTestHoleOffset;
		public int LastFrameActive;
		public int LastFrameJustFocused;
		public float LastTimeActive;
		public float ItemWidthDefault;
		public ImGuiStorage StateStorage;
		public ImVectorImGuiOldColumns ColumnsStorage;
		public float FontWindowScale;
		public float FontDpiScale;
		public int SettingsOffset;
		public unsafe ImDrawList* DrawList;
		public ImDrawList DrawListInst;
		public unsafe ImGuiWindow* ParentWindow;
		public unsafe ImGuiWindow* ParentWindowInBeginStack;
		public unsafe ImGuiWindow* RootWindow;
		public unsafe ImGuiWindow* RootWindowPopupTree;
		public unsafe ImGuiWindow* RootWindowDockTree;
		public unsafe ImGuiWindow* RootWindowForTitleBarHighlight;
		public unsafe ImGuiWindow* RootWindowForNav;
		public unsafe ImGuiWindow* NavLastChildNavWindow;
		public unsafe fixed uint NavLastIds[2];
		public ImRect NavRectRel_0;
		public ImRect NavRectRel_1;
		public Vector2 NavPreferredScoringPosRel_0;
		public Vector2 NavPreferredScoringPosRel_1;
		public int NavRootFocusScopeId;
		public int MemoryDrawListIdxCapacity;
		public int MemoryDrawListVtxCapacity;
		public bool MemoryCompacted;
		public bool DockIsActive;
		public bool DockNodeIsVisible;
		public bool DockTabIsVisible;
		public bool DockTabWantClose;
		public short DockOrder;
		public ImGuiWindowDockStyle DockStyle;
		public unsafe ImGuiDockNode* DockNode;
		public unsafe ImGuiDockNode* DockNodeAsHost;
		public int DockId;
		public ImGuiItemStatusFlags DockTabItemStatusFlags;
		public ImRect DockTabItemRect;

		public unsafe Span<ImRect> NavRectRel
		
		{
			get
			{
				fixed (ImRect* p = &this.NavRectRel_0)
				{
					return new Span<ImRect>(p, 2);
				}
			}
		}
		public unsafe Span<Vector2> NavPreferredScoringPosRel
		
		{
			get
			{
				fixed (Vector2* p = &this.NavPreferredScoringPosRel_0)
				{
					return new Span<Vector2>(p, 2);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowClass
	{
		public int ClassId;
		public int ParentViewportId;
		public ImGuiViewportFlags ViewportFlagsOverrideSet;
		public ImGuiViewportFlags ViewportFlagsOverrideClear;
		public ImGuiTabItemFlags TabItemFlagsOverrideSet;
		public ImGuiDockNodeFlags DockNodeFlagsOverrideSet;
		public bool DockingAlwaysTabBar;
		public bool DockingAllowUnclassed;


		public unsafe void Destroy()
		{
			fixed (ImGuiWindowClass* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiViewportP
	{
		public ImGuiViewport ImGuiViewport;
		public unsafe ImGuiWindow* Window;
		public int Idx;
		public int LastFrameActive;
		public int LastFocusedStampCount;
		public int LastNameHash;
		public Vector2 LastPos;
		public float Alpha;
		public float LastAlpha;
		public bool LastFocusedHadNavWindow;
		public short PlatformMonitor;
		public unsafe fixed int DrawListsLastFrame[2];
		public unsafe ImDrawList* DrawLists_0;
		public unsafe ImDrawList* DrawLists_1;
		public ImDrawData DrawDataP;
		public ImDrawDataBuilder DrawDataBuilder;
		public Vector2 LastPlatformPos;
		public Vector2 LastPlatformSize;
		public Vector2 LastRendererSize;
		public Vector2 WorkOffsetMin;
		public Vector2 WorkOffsetMax;
		public Vector2 BuildWorkOffsetMin;
		public Vector2 BuildWorkOffsetMax;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawDataBuilder
	{
		public ImVectorImDrawListPtr Layers_0;
		public ImVectorImDrawListPtr Layers_1;

		public unsafe Span<ImVectorImDrawListPtr> Layers
		
		{
			get
			{
				fixed (ImVectorImDrawListPtr* p = &this.Layers_0)
				{
					return new Span<ImVectorImDrawListPtr>(p, 2);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawListPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawList** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiID
	{
		public int Size;
		public int Capacity;
		public unsafe int* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowTempData
	{
		public Vector2 CursorPos;
		public Vector2 CursorPosPrevLine;
		public Vector2 CursorStartPos;
		public Vector2 CursorMaxPos;
		public Vector2 IdealMaxPos;
		public Vector2 CurrLineSize;
		public Vector2 PrevLineSize;
		public float CurrLineTextBaseOffset;
		public float PrevLineTextBaseOffset;
		public bool IsSameLine;
		public bool IsSetPos;
		public ImVec1 Indent;
		public ImVec1 ColumnsOffset;
		public ImVec1 GroupOffset;
		public Vector2 CursorStartPosLossyness;
		public ImGuiNavLayer NavLayerCurrent;
		public short NavLayersActiveMask;
		public short NavLayersActiveMaskNext;
		public bool NavIsScrollPushableX;
		public bool NavHideHighlightOneFrame;
		public bool NavWindowHasScrollY;
		public bool MenuBarAppending;
		public Vector2 MenuBarOffset;
		public ImGuiMenuColumns MenuColumns;
		public int TreeDepth;
		public uint TreeJumpToParentOnPopMask;
		public ImVectorImGuiWindowPtr ChildWindows;
		public unsafe ImGuiStorage* StateStorage;
		public unsafe ImGuiOldColumns* CurrentColumns;
		public int CurrentTableIdx;
		public ImGuiLayoutType LayoutType;
		public ImGuiLayoutType ParentLayoutType;
		public float ItemWidth;
		public float TextWrapPos;
		public ImVectorFloat ItemWidthStack;
		public ImVectorFloat TextWrapPosStack;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec1
	{
		public float X;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMenuColumns
	{
		public uint TotalWidth;
		public uint NextTotalWidth;
		public ushort Spacing;
		public ushort OffsetIcon;
		public ushort OffsetLabel;
		public ushort OffsetShortcut;
		public ushort OffsetMark;
		public unsafe fixed ushort Widths[4];

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStorage
	{
		public ImVectorImGuiStoragePair Data;


		public unsafe void BuildSortByKey()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.BuildSortByKey(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.Clear(@this);
			}
		}

		public unsafe bool GetBool(int key, bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				bool ret = ImGui.GetBool(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe bool* GetBoolRef(int key, bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				bool* ret = ImGui.GetBoolRef(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float GetFloat(int key, float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloat(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float* GetFloatRef(int key, float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRef(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int GetInt(int key, int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetInt(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int* GetIntRef(int key, int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRef(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe void* GetVoidPtr(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void* ret = ImGui.GetVoidPtr(@this, key);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef(int key, void* defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRef(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe void SetAllInt(int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetAllInt(@this, val);
			}
		}

		public unsafe void SetBool(int key, bool val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetBool(@this, key, val);
			}
		}

		public unsafe void SetFloat(int key, float val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetFloat(@this, key, val);
			}
		}

		public unsafe void SetInt(int key, int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetInt(@this, key, val);
			}
		}

		public unsafe void SetVoidPtr(int key, void* val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetVoidPtr(@this, key, val);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStoragePair
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStoragePair* Data;

	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiStoragePairUnion
	{
		[FieldOffset(0)]
		public int ValI;
		[FieldOffset(0)]
		public float ValF;
		[FieldOffset(0)]
		public unsafe void* ValP;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStoragePair
	{
		public int Key;
		public ImGuiStoragePairUnion ImGuiStoragePairUnion;


		public unsafe void Destroy()
		{
			fixed (ImGuiStoragePair* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumns
	{
		public int ID;
		public ImGuiOldColumnFlags Flags;
		public bool IsFirstFrame;
		public bool IsBeingResized;
		public int Current;
		public int Count;
		public float OffMinX;
		public float OffMaxX;
		public float LineMinY;
		public float LineMaxY;
		public float HostCursorPosY;
		public float HostCursorMaxPosX;
		public ImRect HostInitialClipRect;
		public ImRect HostBackupClipRect;
		public ImRect HostBackupParentWorkRect;
		public ImVectorImGuiOldColumnData Columns;
		public ImDrawListSplitter Splitter;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImRect
	{
		public Vector2 Min;
		public Vector2 Max;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumnData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiOldColumnData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumnData
	{
		public float OffsetNorm;
		public float OffsetNormBeforeResize;
		public ImGuiOldColumnFlags Flags;
		public ImRect ClipRect;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec2ih
	{
		public short X;
		public short Y;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumns
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiOldColumns* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowDockStyle
	{
		public unsafe fixed uint Colors[6];

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNode
	{
		public int ID;
		public ImGuiDockNodeFlags SharedFlags;
		public ImGuiDockNodeFlags LocalFlags;
		public ImGuiDockNodeFlags LocalFlagsInWindows;
		public ImGuiDockNodeFlags MergedFlags;
		public ImGuiDockNodeState State;
		public unsafe ImGuiDockNode* ParentNode;
		public unsafe ImGuiDockNode* ChildNodes_0;
		public unsafe ImGuiDockNode* ChildNodes_1;
		public ImVectorImGuiWindowPtr Windows;
		public unsafe ImGuiTabBar* TabBar;
		public Vector2 Pos;
		public Vector2 Size;
		public Vector2 SizeRef;
		public ImGuiAxis SplitAxis;
		public ImGuiWindowClass WindowClass;
		public uint LastBgColor;
		public unsafe ImGuiWindow* HostWindow;
		public unsafe ImGuiWindow* VisibleWindow;
		public unsafe ImGuiDockNode* CentralNode;
		public unsafe ImGuiDockNode* OnlyNodeWithWindows;
		public int CountNodeWithWindows;
		public int LastFrameAlive;
		public int LastFrameActive;
		public int LastFrameFocused;
		public int LastFocusedNodeId;
		public int SelectedTabId;
		public int WantCloseTabId;
		public ImGuiDataAuthority AuthorityForPos;
		public ImGuiDataAuthority AuthorityForSize;
		public ImGuiDataAuthority AuthorityForViewport;
		public bool IsVisible;
		public bool IsFocused;
		public bool IsBgDrawnThisFrame;
		public bool HasCloseButton;
		public bool HasWindowMenuButton;
		public bool HasCentralNodeChild;
		public bool WantCloseAll;
		public bool WantLockSizeOnce;
		public bool WantMouseMove;
		public bool WantHiddenTabBarUpdate;
		public bool WantHiddenTabBarToggle;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabBar
	{
		public ImVectorImGuiTabItem Tabs;
		public ImGuiTabBarFlags Flags;
		public int ID;
		public int SelectedTabId;
		public int NextSelectedTabId;
		public int VisibleTabId;
		public int CurrFrameVisible;
		public int PrevFrameVisible;
		public ImRect BarRect;
		public float CurrTabsContentsHeight;
		public float PrevTabsContentsHeight;
		public float WidthAllTabs;
		public float WidthAllTabsIdeal;
		public float ScrollingAnim;
		public float ScrollingTarget;
		public float ScrollingTargetDistToVisibility;
		public float ScrollingSpeed;
		public float ScrollingRectMinX;
		public float ScrollingRectMaxX;
		public int ReorderRequestTabId;
		public short ReorderRequestOffset;
		public sbyte BeginCount;
		public bool WantLayout;
		public bool VisibleTabWasSubmitted;
		public bool TabsAddedNew;
		public short TabsActiveCount;
		public short LastTabItemIdx;
		public float ItemSpacingY;
		public Vector2 FramePadding;
		public Vector2 BackupCursorPos;
		public ImGuiTextBuffer TabsNames;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabItem
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTabItem* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabItem
	{
		public int ID;
		public ImGuiTabItemFlags Flags;
		public unsafe ImGuiWindow* Window;
		public int LastFrameVisible;
		public int LastFrameSelected;
		public float Offset;
		public float Width;
		public float ContentWidth;
		public float RequestedWidth;
		public int NameOffset;
		public short BeginOrder;
		public short IndexDuringLayout;
		public bool WantClose;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextBuffer
	{
		public ImVectorChar Buf;


		public unsafe void append(ref byte str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.append(@this, pstr, strEnd);
				}
			}
		}

		public unsafe void append(string str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.append(@this, pStr0, strEnd);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void append(byte* str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					ImGui.append(@this, str, pstrEnd);
				}
			}
		}

		public unsafe void append(byte* str, string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.append(@this, str, pStr0);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void append(ref byte str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						ImGui.append(@this, pstr, pstrEnd);
					}
				}
			}
		}

		public unsafe void append(string str, string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.append(@this, pStr0, pStr1);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void append(byte* str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.append(@this, str, strEnd);
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		public unsafe void appendf(ref byte fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendf(@this, pfmt);
				}
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		public unsafe void appendf(string fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendf(@this, pStr0);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		public unsafe void appendf(byte* fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendf(@this, fmt);
			}
		}

		public unsafe void appendfv(ref byte fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfv(@this, pfmt, args);
				}
			}
		}

		public unsafe void appendfv(string fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfv(@this, pStr0, args);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void appendfv(byte* fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfv(@this, fmt, args);
			}
		}

		public unsafe string beginS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGui.begin(@this));
				return ret;
			}
		}

		public unsafe byte* begin()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.begin(@this);
				return ret;
			}
		}

		public unsafe string c_strS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGui.c_str(@this));
				return ret;
			}
		}

		public unsafe byte* c_str()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.c_str(@this);
				return ret;
			}
		}

		public unsafe void clear()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.clear(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				bool ret = ImGui.empty(@this);
				return ret;
			}
		}

		public unsafe string endS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGui.end(@this));
				return ret;
			}
		}

		public unsafe byte* end()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.end(@this);
				return ret;
			}
		}

		public unsafe void reserve(int capacity)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.reserve(@this, capacity);
			}
		}

		public unsafe int size()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				int ret = ImGui.size(@this);
				return ret;
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorChar
	{
		public int Size;
		public int Capacity;
		public unsafe byte* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowStackData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiWindowStackData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowStackData
	{
		public unsafe ImGuiWindow* Window;
		public ImGuiLastItemData ParentLastItemDataBackup;
		public ImGuiStackSizes StackSizesOnBegin;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLastItemData
	{
		public int ID;
		public ImGuiItemFlags InFlags;
		public ImGuiItemStatusFlags StatusFlags;
		public ImRect Rect;
		public ImRect NavRect;
		public ImRect DisplayRect;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackSizes
	{
		public short SizeOfIDStack;
		public short SizeOfColorStack;
		public short SizeOfStyleVarStack;
		public short SizeOfFontStack;
		public short SizeOfFocusScopeStack;
		public short SizeOfGroupStack;
		public short SizeOfItemFlagsStack;
		public short SizeOfBeginPopupStack;
		public short SizeOfDisabledStack;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyOwnerData
	{
		public int OwnerCurr;
		public int OwnerNext;
		public bool LockThisFrame;
		public bool LockUntilRelease;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingTable
	{
		public unsafe fixed short Index[140];
		public ImVectorImGuiKeyRoutingData Entries;
		public ImVectorImGuiKeyRoutingData EntriesNext;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiKeyRoutingData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiKeyRoutingData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingData
	{
		public short NextEntryIndex;
		public ushort Mods;
		public byte RoutingNextScore;
		public int RoutingCurr;
		public int RoutingNext;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextItemData
	{
		public ImGuiNextItemDataFlags Flags;
		public float Width;
		public int FocusScopeId;
		public ImGuiCond OpenCond;
		public bool OpenVal;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextWindowData
	{
		public ImGuiNextWindowDataFlags Flags;
		public ImGuiCond PosCond;
		public ImGuiCond SizeCond;
		public ImGuiCond CollapsedCond;
		public ImGuiCond DockCond;
		public Vector2 PosVal;
		public Vector2 PosPivotVal;
		public Vector2 SizeVal;
		public Vector2 ContentSizeVal;
		public Vector2 ScrollVal;
		public bool PosUndock;
		public bool CollapsedVal;
		public ImRect SizeConstraintRect;
		public unsafe delegate*<ImGuiSizeCallbackData*, void> SizeCallback;
		public unsafe void* SizeCallbackUserData;
		public float BgAlphaVal;
		public int ViewportId;
		public int DockId;
		public ImGuiWindowClass WindowClass;
		public Vector2 MenuBarOffsetMinVal;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiSizeCallbackData
	{
		public unsafe void* UserData;
		public Vector2 Pos;
		public Vector2 CurrentSize;
		public Vector2 DesiredSize;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiColorMod
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiColorMod* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiColorMod
	{
		public ImGuiCol Col;
		public Vector4 BackupValue;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStyleMod
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStyleMod* Data;

	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiStyleModUnion
	{
		[FieldOffset(0)]
		public unsafe fixed int BackupInt[2];
		[FieldOffset(0)]
		public unsafe fixed float BackupFloat[2];

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyleMod
	{
		public ImGuiStyleVar VarIdx;
		public ImGuiStyleModUnion ImGuiStyleModUnion;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiItemFlags
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiItemFlags* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiGroupData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiGroupData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiGroupData
	{
		public int WindowID;
		public Vector2 BackupCursorPos;
		public Vector2 BackupCursorMaxPos;
		public ImVec1 BackupIndent;
		public ImVec1 BackupGroupOffset;
		public Vector2 BackupCurrLineSize;
		public float BackupCurrLineTextBaseOffset;
		public int BackupActiveIdIsAlive;
		public bool BackupActiveIdPreviousFrameIsAlive;
		public bool BackupHoveredIdIsAlive;
		public bool EmitItem;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPopupData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPopupData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPopupData
	{
		public int PopupId;
		public unsafe ImGuiWindow* Window;
		public unsafe ImGuiWindow* BackupNavWindow;
		public int ParentNavLayer;
		public int OpenFrameCount;
		public int OpenParentId;
		public Vector2 OpenPopupPos;
		public Vector2 OpenMousePos;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiViewportP** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNavItemData
	{
		public unsafe ImGuiWindow* Window;
		public int ID;
		public int FocusScopeId;
		public ImRect RectRel;
		public ImGuiItemFlags InFlags;
		public float DistBox;
		public float DistCenter;
		public float DistAxial;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPayload
	{
		public unsafe void* Data;
		public int DataSize;
		public int SourceId;
		public int SourceParentId;
		public int DataFrameCount;
		public unsafe fixed byte DataType[33];
		public bool Preview;
		public bool Delivery;


		public unsafe void Clear()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.Clear(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe bool IsDataType(ref byte type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				fixed (byte* ptype = &type)
				{
					bool ret = ImGui.IsDataType(@this, ptype);
					return ret;
				}
			}
		}

		public unsafe bool IsDataType(string type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = ImGui.IsDataType(@this, pStr0);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe bool IsDataType(byte* type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				bool ret = ImGui.IsDataType(@this, type);
				return ret;
			}
		}

		public unsafe bool IsDelivery()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				bool ret = ImGui.IsDelivery(@this);
				return ret;
			}
		}

		public unsafe bool IsPreview()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				bool ret = ImGui.IsPreview(@this);
				return ret;
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorUnsignedChar
	{
		public int Size;
		public int Capacity;
		public unsafe byte* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiListClipperData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperData
	{
		public unsafe ImGuiListClipper* ListClipper;
		public float LossynessOffset;
		public int StepNo;
		public int ItemsFrozen;
		public ImVectorImGuiListClipperRange Ranges;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipper
	{
		public unsafe ImGuiContext* Ctx;
		public int DisplayStart;
		public int DisplayEnd;
		public int ItemsCount;
		public float ItemsHeight;
		public float StartPosY;
		public unsafe void* TempData;


		public unsafe void Begin(int itemsCount, float itemsHeight)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.Begin(@this, itemsCount, itemsHeight);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe void End()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.End(@this);
			}
		}

		public unsafe void ForceDisplayRangeByIndices(int itemMin, int itemMax)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.ForceDisplayRangeByIndices(@this, itemMin, itemMax);
			}
		}

		public unsafe bool Step()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				bool ret = ImGui.Step(@this);
				return ret;
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperRange
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiListClipperRange* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperRange
	{
		public int Min;
		public int Max;
		public bool PosToIndexConvert;
		public sbyte PosToIndexOffsetMin;
		public sbyte PosToIndexOffsetMax;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTable
	{
		public int ID;
		public ImGuiTableFlags Flags;
		public unsafe void* RawData;
		public unsafe ImGuiTableTempData* TempData;
		public ImSpanImGuiTableColumn Columns;
		public ImSpanImGuiTableColumnIdx DisplayOrderToIndex;
		public ImSpanImGuiTableCellData RowCellData;
		public ImBitArrayPtr EnabledMaskByDisplayOrder;
		public ImBitArrayPtr EnabledMaskByIndex;
		public ImBitArrayPtr VisibleMaskByIndex;
		public ImGuiTableFlags SettingsLoadedFlags;
		public int SettingsOffset;
		public int LastFrameActive;
		public int ColumnsCount;
		public int CurrentRow;
		public int CurrentColumn;
		public short InstanceCurrent;
		public short InstanceInteracted;
		public float RowPosY1;
		public float RowPosY2;
		public float RowMinHeight;
		public float RowTextBaseline;
		public float RowIndentOffsetX;
		public ImGuiTableRowFlags RowFlags;
		public ImGuiTableRowFlags LastRowFlags;
		public int RowBgColorCounter;
		public unsafe fixed uint RowBgColor[2];
		public uint BorderColorStrong;
		public uint BorderColorLight;
		public float BorderX1;
		public float BorderX2;
		public float HostIndentX;
		public float MinColumnWidth;
		public float OuterPaddingX;
		public float CellPaddingX;
		public float CellPaddingY;
		public float CellSpacingX1;
		public float CellSpacingX2;
		public float InnerWidth;
		public float ColumnsGivenWidth;
		public float ColumnsAutoFitWidth;
		public float ColumnsStretchSumWeights;
		public float ResizedColumnNextWidth;
		public float ResizeLockMinContentsX2;
		public float RefScale;
		public ImRect OuterRect;
		public ImRect InnerRect;
		public ImRect WorkRect;
		public ImRect InnerClipRect;
		public ImRect BgClipRect;
		public ImRect Bg0ClipRectForDrawCmd;
		public ImRect Bg2ClipRectForDrawCmd;
		public ImRect HostClipRect;
		public ImRect HostBackupInnerClipRect;
		public unsafe ImGuiWindow* OuterWindow;
		public unsafe ImGuiWindow* InnerWindow;
		public ImGuiTextBuffer ColumnsNames;
		public unsafe ImDrawListSplitter* DrawSplitter;
		public ImGuiTableInstanceData InstanceDataFirst;
		public ImVectorImGuiTableInstanceData InstanceDataExtra;
		public ImGuiTableColumnSortSpecs SortSpecsSingle;
		public ImVectorImGuiTableColumnSortSpecs SortSpecsMulti;
		public ImGuiTableSortSpecs SortSpecs;
		public sbyte SortSpecsCount;
		public sbyte ColumnsEnabledCount;
		public sbyte ColumnsEnabledFixedCount;
		public sbyte DeclColumnsCount;
		public sbyte HoveredColumnBody;
		public sbyte HoveredColumnBorder;
		public sbyte AutoFitSingleColumn;
		public sbyte ResizedColumn;
		public sbyte LastResizedColumn;
		public sbyte HeldHeaderColumn;
		public sbyte ReorderColumn;
		public sbyte ReorderColumnDir;
		public sbyte LeftMostEnabledColumn;
		public sbyte RightMostEnabledColumn;
		public sbyte LeftMostStretchedColumn;
		public sbyte RightMostStretchedColumn;
		public sbyte ContextPopupColumn;
		public sbyte FreezeRowsRequest;
		public sbyte FreezeRowsCount;
		public sbyte FreezeColumnsRequest;
		public sbyte FreezeColumnsCount;
		public sbyte RowCellDataCurrent;
		public byte DummyDrawChannel;
		public byte Bg2DrawChannelCurrent;
		public byte Bg2DrawChannelUnfrozen;
		public bool IsLayoutLocked;
		public bool IsInsideRow;
		public bool IsInitializing;
		public bool IsSortSpecsDirty;
		public bool IsUsingHeaders;
		public bool IsContextPopupOpen;
		public bool IsSettingsRequestLoad;
		public bool IsSettingsDirty;
		public bool IsDefaultDisplayOrder;
		public bool IsResetAllRequest;
		public bool IsResetDisplayOrderRequest;
		public bool IsUnfrozenRows;
		public bool IsDefaultSizingPolicy;
		public bool HasScrollbarYCurr;
		public bool HasScrollbarYPrev;
		public bool MemoryCompacted;
		public bool HostSkipItems;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableTempData
	{
		public int TableIndex;
		public float LastTimeActive;
		public Vector2 UserOuterSize;
		public ImDrawListSplitter DrawSplitter;
		public ImRect HostBackupWorkRect;
		public ImRect HostBackupParentWorkRect;
		public Vector2 HostBackupPrevLineSize;
		public Vector2 HostBackupCurrLineSize;
		public Vector2 HostBackupCursorMaxPos;
		public ImVec1 HostBackupColumnsOffset;
		public float HostBackupItemWidth;
		public int HostBackupItemWidthStackSize;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableColumn
	{
		public unsafe ImGuiTableColumn* Data;
		public unsafe ImGuiTableColumn* DataEnd;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumn
	{
		public ImGuiTableColumnFlags Flags;
		public float WidthGiven;
		public float MinX;
		public float MaxX;
		public float WidthRequest;
		public float WidthAuto;
		public float StretchWeight;
		public float InitStretchWeightOrWidth;
		public ImRect ClipRect;
		public int UserID;
		public float WorkMinX;
		public float WorkMaxX;
		public float ItemWidth;
		public float ContentMaxXFrozen;
		public float ContentMaxXUnfrozen;
		public float ContentMaxXHeadersUsed;
		public float ContentMaxXHeadersIdeal;
		public short NameOffset;
		public sbyte DisplayOrder;
		public sbyte IndexWithinEnabledSet;
		public sbyte PrevEnabledColumn;
		public sbyte NextEnabledColumn;
		public sbyte SortOrder;
		public byte DrawChannelCurrent;
		public byte DrawChannelFrozen;
		public byte DrawChannelUnfrozen;
		public bool IsEnabled;
		public bool IsUserEnabled;
		public bool IsUserEnabledNextFrame;
		public bool IsVisibleX;
		public bool IsVisibleY;
		public bool IsRequestOutput;
		public bool IsSkipItems;
		public bool IsPreserveWidthAuto;
		public sbyte NavLayerCurrent;
		public byte AutoFitQueue;
		public byte CannotSkipItemsQueue;
		public byte SortDirection;
		public byte SortDirectionsAvailCount;
		public byte SortDirectionsAvailMask;
		public byte SortDirectionsAvailList;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableColumnIdx
	{
		public unsafe sbyte* Data;
		public unsafe sbyte* DataEnd;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableCellData
	{
		public unsafe ImGuiTableCellData* Data;
		public unsafe ImGuiTableCellData* DataEnd;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableCellData
	{
		public uint BgColor;
		public sbyte Column;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableInstanceData
	{
		public int TableInstanceID;
		public float LastOuterHeight;
		public float LastFirstRowHeight;
		public float LastFrozenHeight;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableInstanceData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableInstanceData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnSortSpecs
	{
		public int ColumnUserID;
		public short ColumnIndex;
		public short SortOrder;
		public ImGuiSortDirection SortDirection;


		public unsafe void Destroy()
		{
			fixed (ImGuiTableColumnSortSpecs* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableColumnSortSpecs
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableColumnSortSpecs* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableSortSpecs
	{
		public unsafe ImGuiTableColumnSortSpecs* Specs;
		public int SpecsCount;
		public bool SpecsDirty;


		public unsafe void Destroy()
		{
			fixed (ImGuiTableSortSpecs* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableTempData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableTempData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImGuiTable
	{
		public ImVectorImGuiTable Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTable
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTable* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImGuiTabBar
	{
		public ImVectorImGuiTabBar Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabBar
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTabBar* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPtrOrIndex
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPtrOrIndex* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPtrOrIndex
	{
		public unsafe void* Ptr;
		public int Index;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiShrinkWidthItem
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiShrinkWidthItem* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiShrinkWidthItem
	{
		public int Index;
		public float Width;
		public float InitialWidth;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextState
	{
		public unsafe ImGuiContext* Ctx;
		public int ID;
		public int CurLenW;
		public int CurLenA;
		public ImVectorImWchar TextW;
		public ImVectorChar TextA;
		public ImVectorChar InitialTextA;
		public bool TextAIsValid;
		public int BufCapacityA;
		public float ScrollX;
		public STBTexteditState Stb;
		public float CursorAnim;
		public bool CursorFollow;
		public bool SelectedAllMouseLock;
		public bool Edited;
		public ImGuiInputTextFlags Flags;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct STBTexteditState
	{
		public int Cursor;
		public int SelectStart;
		public int SelectEnd;
		public byte InsertMode;
		public int RowCountPerPage;
		public byte CursorAtEndOfLine;
		public byte Initialized;
		public byte HasPreferredX;
		public byte SingleLine;
		public byte Padding1;
		public byte Padding2;
		public byte Padding3;
		public float PreferredX;
		public StbUndoState Undostate;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbUndoState
	{
		public StbUndoRecord UndoRec_0;
		public StbUndoRecord UndoRec_1;
		public StbUndoRecord UndoRec_2;
		public StbUndoRecord UndoRec_3;
		public StbUndoRecord UndoRec_4;
		public StbUndoRecord UndoRec_5;
		public StbUndoRecord UndoRec_6;
		public StbUndoRecord UndoRec_7;
		public StbUndoRecord UndoRec_8;
		public StbUndoRecord UndoRec_9;
		public StbUndoRecord UndoRec_10;
		public StbUndoRecord UndoRec_11;
		public StbUndoRecord UndoRec_12;
		public StbUndoRecord UndoRec_13;
		public StbUndoRecord UndoRec_14;
		public StbUndoRecord UndoRec_15;
		public StbUndoRecord UndoRec_16;
		public StbUndoRecord UndoRec_17;
		public StbUndoRecord UndoRec_18;
		public StbUndoRecord UndoRec_19;
		public StbUndoRecord UndoRec_20;
		public StbUndoRecord UndoRec_21;
		public StbUndoRecord UndoRec_22;
		public StbUndoRecord UndoRec_23;
		public StbUndoRecord UndoRec_24;
		public StbUndoRecord UndoRec_25;
		public StbUndoRecord UndoRec_26;
		public StbUndoRecord UndoRec_27;
		public StbUndoRecord UndoRec_28;
		public StbUndoRecord UndoRec_29;
		public StbUndoRecord UndoRec_30;
		public StbUndoRecord UndoRec_31;
		public StbUndoRecord UndoRec_32;
		public StbUndoRecord UndoRec_33;
		public StbUndoRecord UndoRec_34;
		public StbUndoRecord UndoRec_35;
		public StbUndoRecord UndoRec_36;
		public StbUndoRecord UndoRec_37;
		public StbUndoRecord UndoRec_38;
		public StbUndoRecord UndoRec_39;
		public StbUndoRecord UndoRec_40;
		public StbUndoRecord UndoRec_41;
		public StbUndoRecord UndoRec_42;
		public StbUndoRecord UndoRec_43;
		public StbUndoRecord UndoRec_44;
		public StbUndoRecord UndoRec_45;
		public StbUndoRecord UndoRec_46;
		public StbUndoRecord UndoRec_47;
		public StbUndoRecord UndoRec_48;
		public StbUndoRecord UndoRec_49;
		public StbUndoRecord UndoRec_50;
		public StbUndoRecord UndoRec_51;
		public StbUndoRecord UndoRec_52;
		public StbUndoRecord UndoRec_53;
		public StbUndoRecord UndoRec_54;
		public StbUndoRecord UndoRec_55;
		public StbUndoRecord UndoRec_56;
		public StbUndoRecord UndoRec_57;
		public StbUndoRecord UndoRec_58;
		public StbUndoRecord UndoRec_59;
		public StbUndoRecord UndoRec_60;
		public StbUndoRecord UndoRec_61;
		public StbUndoRecord UndoRec_62;
		public StbUndoRecord UndoRec_63;
		public StbUndoRecord UndoRec_64;
		public StbUndoRecord UndoRec_65;
		public StbUndoRecord UndoRec_66;
		public StbUndoRecord UndoRec_67;
		public StbUndoRecord UndoRec_68;
		public StbUndoRecord UndoRec_69;
		public StbUndoRecord UndoRec_70;
		public StbUndoRecord UndoRec_71;
		public StbUndoRecord UndoRec_72;
		public StbUndoRecord UndoRec_73;
		public StbUndoRecord UndoRec_74;
		public StbUndoRecord UndoRec_75;
		public StbUndoRecord UndoRec_76;
		public StbUndoRecord UndoRec_77;
		public StbUndoRecord UndoRec_78;
		public StbUndoRecord UndoRec_79;
		public StbUndoRecord UndoRec_80;
		public StbUndoRecord UndoRec_81;
		public StbUndoRecord UndoRec_82;
		public StbUndoRecord UndoRec_83;
		public StbUndoRecord UndoRec_84;
		public StbUndoRecord UndoRec_85;
		public StbUndoRecord UndoRec_86;
		public StbUndoRecord UndoRec_87;
		public StbUndoRecord UndoRec_88;
		public StbUndoRecord UndoRec_89;
		public StbUndoRecord UndoRec_90;
		public StbUndoRecord UndoRec_91;
		public StbUndoRecord UndoRec_92;
		public StbUndoRecord UndoRec_93;
		public StbUndoRecord UndoRec_94;
		public StbUndoRecord UndoRec_95;
		public StbUndoRecord UndoRec_96;
		public StbUndoRecord UndoRec_97;
		public StbUndoRecord UndoRec_98;
		public unsafe fixed ushort UndoChar[999];
		public short UndoPoint;
		public short RedoPoint;
		public int UndoCharPoint;
		public int RedoCharPoint;

		public unsafe Span<StbUndoRecord> UndoRec
		
		{
			get
			{
				fixed (StbUndoRecord* p = &this.UndoRec_0)
				{
					return new Span<StbUndoRecord>(p, 99);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbUndoRecord
	{
		public int Where;
		public int InsertLength;
		public int DeleteLength;
		public int CharStorage;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextDeactivatedState
	{
		public int ID;
		public ImVectorChar TextA;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiComboPreviewData
	{
		public ImRect PreviewRect;
		public Vector2 BackupCursorPos;
		public Vector2 BackupCursorMaxPos;
		public Vector2 BackupCursorPosPrevLine;
		public float BackupPrevLineTextBaseOffset;
		public ImGuiLayoutType BackupLayout;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockContext
	{
		public ImGuiStorage Nodes;
		public ImVectorImGuiDockRequest Requests;
		public ImVectorImGuiDockNodeSettings NodesSettings;
		public bool WantFullRebuild;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiDockRequest
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiDockRequest* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockRequest
	{

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiDockNodeSettings
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiDockNodeSettings* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNodeSettings
	{

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiSettingsHandler
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiSettingsHandler* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiSettingsHandler
	{
		public unsafe byte* TypeName;
		public int TypeHash;
		public unsafe delegate*<ImGuiContext*, ImGuiSettingsHandler*, void>* ClearAllFn;
		public unsafe delegate*<ImGuiContext*, ImGuiSettingsHandler*, void>* ReadInitFn;
		public unsafe delegate*<ImGuiContext*, ImGuiSettingsHandler*, byte*, void*>* ReadOpenFn;
		public unsafe delegate*<ImGuiContext*, ImGuiSettingsHandler*, void*, byte*, void>* ReadLineFn;
		public unsafe delegate*<ImGuiContext*, ImGuiSettingsHandler*, void>* ApplyAllFn;
		public unsafe delegate*<ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer*, void>* WriteAllFn;
		public unsafe void* UserData;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImChunkStreamImGuiWindowSettings
	{
		public ImVectorChar Buf;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImChunkStreamImGuiTableSettings
	{
		public ImVectorChar Buf;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiContextHook
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiContextHook* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiContextHook
	{
		public int HookId;
		public ImGuiContextHookType Type;
		public int Owner;
		public unsafe delegate*<ImGuiContext*, ImGuiContextHook*, void> Callback;
		public unsafe void* UserData;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextIndex
	{
		public ImVectorInt LineOffsets;
		public int EndOffset;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorInt
	{
		public int Size;
		public int Capacity;
		public unsafe int* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMetricsConfig
	{
		public bool ShowDebugLog;
		public bool ShowStackTool;
		public bool ShowWindowsRects;
		public bool ShowWindowsBeginOrder;
		public bool ShowTablesRects;
		public bool ShowDrawCmdMesh;
		public bool ShowDrawCmdBoundingBoxes;
		public bool ShowAtlasTintedWithTextColor;
		public bool ShowDockingNodes;
		public int ShowWindowsRectsType;
		public int ShowTablesRectsType;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackTool
	{
		public int LastActiveFrame;
		public int StackLevel;
		public int QueryId;
		public ImVectorImGuiStackLevelInfo Results;
		public bool CopyToClipboardOnCtrlC;
		public float CopyToClipboardLastTime;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStackLevelInfo
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStackLevelInfo* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackLevelInfo
	{
		public int ID;
		public sbyte QueryFrameCount;
		public bool QuerySuccess;
		public ImGuiDataType DataType;
		public unsafe fixed byte Desc[57];

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextCallbackData
	{
		public unsafe ImGuiContext* Ctx;
		public ImGuiInputTextFlags EventFlag;
		public ImGuiInputTextFlags Flags;
		public unsafe void* UserData;
		public char EventChar;
		public ImGuiKey EventKey;
		public unsafe byte* Buf;
		public int BufTextLen;
		public int BufSize;
		public bool BufDirty;
		public int CursorPos;
		public int SelectionStart;
		public int SelectionEnd;


		public unsafe void ClearSelection()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.ClearSelection(@this);
			}
		}

		public unsafe void DeleteChars(int pos, int bytesCount)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.DeleteChars(@this, pos, bytesCount);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe bool HasSelection()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				bool ret = ImGui.HasSelection(@this);
				return ret;
			}
		}

		public unsafe void InsertChars(int pos, ref byte text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.InsertChars(@this, pos, ptext, textEnd);
				}
			}
		}

		public unsafe void InsertChars(int pos, string text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertChars(@this, pos, pStr0, textEnd);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void InsertChars(int pos, byte* text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.InsertChars(@this, pos, text, ptextEnd);
				}
			}
		}

		public unsafe void InsertChars(int pos, byte* text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertChars(@this, pos, text, pStr0);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void InsertChars(int pos, ref byte text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.InsertChars(@this, pos, ptext, ptextEnd);
					}
				}
			}
		}

		public unsafe void InsertChars(int pos, string text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.InsertChars(@this, pos, pStr0, pStr1);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
			}
		}

		public unsafe void InsertChars(int pos, byte* text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.InsertChars(@this, pos, text, textEnd);
			}
		}

		public unsafe void SelectAll()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.SelectAll(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOnceUponAFrame
	{
		public int RefFrame;


		public unsafe void Destroy()
		{
			fixed (ImGuiOnceUponAFrame* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextFilter
	{
		public unsafe fixed byte InputBuf[256];
		public ImVectorImGuiTextRange Filters;
		public int CountGrep;


		public unsafe void Build()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.Build(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.Clear(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe bool Draw(ref byte label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					bool ret = ImGui.Draw(@this, plabel, width);
					return ret;
				}
			}
		}

		public unsafe bool Draw(string label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = ImGui.Draw(@this, pStr0, width);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe bool Draw(byte* label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, label, width);
				return ret;
			}
		}

		public unsafe bool IsActive()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.IsActive(@this);
				return ret;
			}
		}

		public unsafe bool PassFilter(ref byte text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					bool ret = ImGui.PassFilter(@this, ptext, textEnd);
					return ret;
				}
			}
		}

		public unsafe bool PassFilter(string text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = ImGui.PassFilter(@this, pStr0, textEnd);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe bool PassFilter(byte* text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					bool ret = ImGui.PassFilter(@this, text, ptextEnd);
					return ret;
				}
			}
		}

		public unsafe bool PassFilter(byte* text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = ImGui.PassFilter(@this, text, pStr0);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe bool PassFilter(ref byte text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						bool ret = ImGui.PassFilter(@this, ptext, ptextEnd);
						return ret;
					}
				}
			}
		}

		public unsafe bool PassFilter(string text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = ImGui.PassFilter(@this, pStr0, pStr1);
				Marshal.FreeHGlobal((nint)pStr1);
				Marshal.FreeHGlobal((nint)pStr0);
				return ret;
			}
		}

		public unsafe bool PassFilter(byte* text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.PassFilter(@this, text, textEnd);
				return ret;
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTextRange
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTextRange* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextRange
	{
		public unsafe byte* B;
		public unsafe byte* E;


		public unsafe void Destroy()
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				ImGui.Destroy(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				bool ret = ImGui.empty(@this);
				return ret;
			}
		}

		public unsafe void split(byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				fixed (ImVectorImGuiTextRange* poutput = &output)
				{
					ImGui.split(@this, separator, poutput);
				}
			}
		}

		public unsafe void split(byte separator, ImVectorImGuiTextRange* output)
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				ImGui.split(@this, separator, output);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImBitVector
	{
		public ImVectorImU32 Storage;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataVarInfo
	{
		public ImGuiDataType Type;
		public uint Count;
		public uint Offset;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataTypeInfo
	{
		public nuint Size;
		public unsafe byte* Name;
		public unsafe byte* PrintFmt;
		public unsafe byte* ScanFmt;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextDeactivateData
	{

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLocEntry
	{
		public ImGuiLocKey Key;
		public unsafe byte* Text;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableSettings
	{
		public int ID;
		public ImGuiTableFlags SaveFlags;
		public float RefScale;
		public sbyte ColumnsCount;
		public sbyte ColumnsCountMax;
		public bool WantApply;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnsSettings
	{

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowSettings
	{
		public int ID;
		public ImVec2ih Pos;
		public ImVec2ih Size;
		public ImVec2ih ViewportPos;
		public int ViewportId;
		public int DockId;
		public int ClassId;
		public short DockOrder;
		public bool Collapsed;
		public bool WantApply;
		public bool WantDelete;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorConstCharPtr
	{
		public int Size;
		public int Capacity;
		public unsafe byte** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbTexteditRow
	{
		public float X0;
		public float X1;
		public float BaselineYDelta;
		public float Ymin;
		public float Ymax;
		public int NumChars;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataTypeTempStorage
	{
		public unsafe fixed byte Data[8];

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImBitArrayImGuiKeyNamedKeyCOUNTLessImGuiKeyNamedKeyBEGIN
	{
		public unsafe fixed uint Storage[5];

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnSettings
	{
		public float WidthOrWeight;
		public int UserID;
		public sbyte Index;
		public sbyte DisplayOrder;
		public sbyte SortOrder;
		public byte SortDirection;
		public byte IsEnabled;
		public byte IsStretch;

	}

}
