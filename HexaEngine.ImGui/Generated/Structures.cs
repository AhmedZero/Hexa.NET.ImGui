// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

namespace HexaEngine.ImGuiNET
{
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawChannel
	{
		public ImVectorImDrawCmd CmdBuffer;
		public ImVectorImDrawIdx IdxBuffer;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawChannelPtr : IEquatable<ImDrawChannelPtr>
	{
		public ImDrawChannelPtr(ImDrawChannel* handle) { Handle = handle; }

		public ImDrawChannel* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawChannelPtr Null => new ImDrawChannelPtr(null);

		public static implicit operator ImDrawChannelPtr(ImDrawChannel* handle) => new ImDrawChannelPtr(handle);

		public static implicit operator ImDrawChannel*(ImDrawChannelPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawChannelPtr left, ImDrawChannelPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawChannelPtr left, ImDrawChannelPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawChannelPtr left, ImDrawChannel* right) => left.Handle == right;

		public static bool operator !=(ImDrawChannelPtr left, ImDrawChannel* right) => left.Handle != right;

		public bool Equals(ImDrawChannelPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawChannelPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawChannelPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImDrawCmd CmdBuffer => ref Unsafe.AsRef<ImVectorImDrawCmd>(&Handle->CmdBuffer);
		public ref ImVectorImDrawIdx IdxBuffer => ref Unsafe.AsRef<ImVectorImDrawIdx>(&Handle->IdxBuffer);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawCmd
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawCmd* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmd
	{
		public Vector4 ClipRect;
		public ImTextureID TextureId;
		public uint VtxOffset;
		public uint IdxOffset;
		public uint ElemCount;
		public unsafe void* UserCallback;
		public unsafe void* UserCallbackData;


		public unsafe void Destroy()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImTextureID GetTexID()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImTextureID ret = ImGui.GetTexIDNative(@this);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawCmdPtr : IEquatable<ImDrawCmdPtr>
	{
		public ImDrawCmdPtr(ImDrawCmd* handle) { Handle = handle; }

		public ImDrawCmd* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawCmdPtr Null => new ImDrawCmdPtr(null);

		public static implicit operator ImDrawCmdPtr(ImDrawCmd* handle) => new ImDrawCmdPtr(handle);

		public static implicit operator ImDrawCmd*(ImDrawCmdPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawCmdPtr left, ImDrawCmdPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawCmdPtr left, ImDrawCmdPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawCmdPtr left, ImDrawCmd* right) => left.Handle == right;

		public static bool operator !=(ImDrawCmdPtr left, ImDrawCmd* right) => left.Handle != right;

		public bool Equals(ImDrawCmdPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawCmdPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawCmdPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref Vector4 ClipRect => ref Unsafe.AsRef<Vector4>(&Handle->ClipRect);
		public ref ImTextureID TextureId => ref Unsafe.AsRef<ImTextureID>(&Handle->TextureId);
		public ref uint VtxOffset => ref Unsafe.AsRef<uint>(&Handle->VtxOffset);
		public ref uint IdxOffset => ref Unsafe.AsRef<uint>(&Handle->IdxOffset);
		public ref uint ElemCount => ref Unsafe.AsRef<uint>(&Handle->ElemCount);
		public void* UserCallback { get => Handle->UserCallback; set => Handle->UserCallback = value; }
		public void* UserCallbackData { get => Handle->UserCallbackData; set => Handle->UserCallbackData = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe ImTextureID GetTexID()
		{
			ImTextureID ret = ImGui.GetTexIDNative(Handle);
			return ret;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawList
	{
		public ImVectorImDrawCmd CmdBuffer;
		public ImVectorImDrawIdx IdxBuffer;
		public ImVectorImDrawVert VtxBuffer;
		public ImDrawListFlags Flags;
		public uint VtxCurrentIdx;
		public unsafe ImDrawListSharedData* Data;
		public unsafe byte* OwnerName;
		public unsafe ImDrawVert* VtxWritePtr;
		public unsafe ushort* IdxWritePtr;
		public ImVectorImVec4 ClipRectStack;
		public ImVectorImTextureID TextureIdStack;
		public ImVectorImVec2 Path;
		public ImDrawCmdHeader CmdHeader;
		public ImDrawListSplitter Splitter;
		public float FringeScale;


		public unsafe int _CalcCircleAutoSegmentCount(float radius)
		{
			fixed (ImDrawList* @this = &this)
			{
				int ret = ImGui._CalcCircleAutoSegmentCountNative(@this, radius);
				return ret;
			}
		}

		public unsafe void _ClearFreeMemory()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void _OnChangedClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedClipRectNative(@this);
			}
		}

		public unsafe void _OnChangedTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedTextureIDNative(@this);
			}
		}

		public unsafe void _OnChangedVtxOffset()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedVtxOffsetNative(@this);
			}
		}

		public unsafe void _PathArcToFastEx(Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToFastExNative(@this, center, radius, aMinSample, aMaxSample, aStep);
			}
		}

		public unsafe void _PathArcToN(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToNNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void _PopUnusedDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PopUnusedDrawCmdNative(@this);
			}
		}

		public unsafe void _ResetForNewFrame()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ResetForNewFrameNative(@this);
			}
		}

		public unsafe void _TryMergeDrawCmds()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._TryMergeDrawCmdsNative(@this);
			}
		}

		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}

		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, (int)(0));
			}
		}

		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, numSegments);
			}
		}

		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, (int)(0));
			}
		}

		public unsafe void AddCallback(ImDrawCallback callback, void* callbackData)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCallbackNative(@this, callback, callbackData);
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), thickness);
			}
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, (int)(0));
			}
		}

		public unsafe void AddConvexPolyFilled(Vector2* points, int numPoints, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddConvexPolyFilledNative(@this, points, numPoints, col);
			}
		}

		public unsafe void AddConvexPolyFilled(ref Vector2 points, int numPoints, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddConvexPolyFilledNative(@this, (Vector2*)ppoints, numPoints, col);
				}
			}
		}

		public unsafe void AddDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddDrawCmdNative(@this);
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, thickness);
			}
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, (float)(1.0f));
			}
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddNgonFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonFilledNative(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddPolyline(Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddPolylineNative(@this, points, numPoints, col, flags, thickness);
			}
		}

		public unsafe void AddPolyline(ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddPolylineNative(@this, (Vector2*)ppoints, numPoints, col, flags, thickness);
				}
			}
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, thickness);
			}
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, (float)(1.0f));
			}
		}

		public unsafe void AddQuadFilled(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadFilledNative(@this, p1, p2, p3, p4, col);
			}
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, thickness);
			}
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, (float)(1.0f));
			}
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
			}
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0), thickness);
			}
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, thickness);
			}
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, flags);
			}
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
			}
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), flags);
			}
		}

		public unsafe void AddRectFilledMultiColor(Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledMultiColorNative(@this, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, textEnd);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)(default));
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, thickness);
			}
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, (float)(1.0f));
			}
		}

		public unsafe void AddTriangleFilled(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleFilledNative(@this, p1, p2, p3, col);
			}
		}

		public unsafe void ChannelsMerge()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsMergeNative(@this);
			}
		}

		public unsafe void ChannelsSetCurrent(int n)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSetCurrentNative(@this, n);
			}
		}

		public unsafe void ChannelsSplit(int count)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSplitNative(@this, count);
			}
		}

		public unsafe ImDrawList* CloneOutput()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImDrawList* ret = ImGui.CloneOutputNative(@this);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, (int)(0));
			}
		}

		public unsafe void PathArcToFast(Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToFastNative(@this, center, radius, aMinOf12, aMaxOf12);
			}
		}

		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, numSegments);
			}
		}

		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, (int)(0));
			}
		}

		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, numSegments);
			}
		}

		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, (int)(0));
			}
		}

		public unsafe void PathClear()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathClearNative(@this);
			}
		}

		public unsafe void PathFillConvex(uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathFillConvexNative(@this, col);
			}
		}

		public unsafe void PathLineTo(Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToNative(@this, pos);
			}
		}

		public unsafe void PathLineToMergeDuplicate(Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToMergeDuplicateNative(@this, pos);
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, flags);
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, (ImDrawFlags)(0));
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), flags);
			}
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, thickness);
			}
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, (float)(1.0f));
			}
		}

		public unsafe void PathStroke(uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		public unsafe void PathStroke(uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (ImDrawFlags)(0), thickness);
			}
		}

		public unsafe void PopClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopClipRectNative(@this);
			}
		}

		public unsafe void PopTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopTextureIDNative(@this);
			}
		}

		public unsafe void PrimQuadUV(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimQuadUVNative(@this, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}

		public unsafe void PrimRect(Vector2 a, Vector2 b, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectNative(@this, a, b, col);
			}
		}

		public unsafe void PrimRectUV(Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectUVNative(@this, a, b, uvA, uvB, col);
			}
		}

		public unsafe void PrimReserve(int idxCount, int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimReserveNative(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimUnreserve(int idxCount, int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimUnreserveNative(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimVtx(Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimVtxNative(@this, pos, uv, col);
			}
		}

		public unsafe void PrimWriteIdx(ushort idx)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteIdxNative(@this, idx);
			}
		}

		public unsafe void PrimWriteVtx(Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteVtxNative(@this, pos, uv, col);
			}
		}

		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
			}
		}

		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, (byte)(0));
			}
		}

		public unsafe void PushClipRectFullScreen()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectFullScreenNative(@this);
			}
		}

		public unsafe void PushTextureID(ImTextureID textureId)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushTextureIDNative(@this, textureId);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawListPtr : IEquatable<ImDrawListPtr>
	{
		public ImDrawListPtr(ImDrawList* handle) { Handle = handle; }

		public ImDrawList* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListPtr Null => new ImDrawListPtr(null);

		public static implicit operator ImDrawListPtr(ImDrawList* handle) => new ImDrawListPtr(handle);

		public static implicit operator ImDrawList*(ImDrawListPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListPtr left, ImDrawListPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListPtr left, ImDrawListPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListPtr left, ImDrawList* right) => left.Handle == right;

		public static bool operator !=(ImDrawListPtr left, ImDrawList* right) => left.Handle != right;

		public bool Equals(ImDrawListPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawListPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImDrawCmd CmdBuffer => ref Unsafe.AsRef<ImVectorImDrawCmd>(&Handle->CmdBuffer);
		public ref ImVectorImDrawIdx IdxBuffer => ref Unsafe.AsRef<ImVectorImDrawIdx>(&Handle->IdxBuffer);
		public ref ImVectorImDrawVert VtxBuffer => ref Unsafe.AsRef<ImVectorImDrawVert>(&Handle->VtxBuffer);
		public ref ImDrawListFlags Flags => ref Unsafe.AsRef<ImDrawListFlags>(&Handle->Flags);
		public ref uint VtxCurrentIdx => ref Unsafe.AsRef<uint>(&Handle->VtxCurrentIdx);
		public ref ImDrawListSharedDataPtr Data => ref Unsafe.AsRef<ImDrawListSharedDataPtr>(&Handle->Data);
		public byte* OwnerName { get => Handle->OwnerName; set => Handle->OwnerName = value; }
		public ref ImDrawVertPtr VtxWritePtr => ref Unsafe.AsRef<ImDrawVertPtr>(&Handle->VtxWritePtr);
		public ushort* IdxWritePtr { get => Handle->IdxWritePtr; set => Handle->IdxWritePtr = value; }
		public ref ImVectorImVec4 ClipRectStack => ref Unsafe.AsRef<ImVectorImVec4>(&Handle->ClipRectStack);
		public ref ImVectorImTextureID TextureIdStack => ref Unsafe.AsRef<ImVectorImTextureID>(&Handle->TextureIdStack);
		public ref ImVectorImVec2 Path => ref Unsafe.AsRef<ImVectorImVec2>(&Handle->Path);
		public ref ImDrawCmdHeader CmdHeader => ref Unsafe.AsRef<ImDrawCmdHeader>(&Handle->CmdHeader);
		public ref ImDrawListSplitter Splitter => ref Unsafe.AsRef<ImDrawListSplitter>(&Handle->Splitter);
		public ref float FringeScale => ref Unsafe.AsRef<float>(&Handle->FringeScale);

		public unsafe int _CalcCircleAutoSegmentCount(float radius)
		{
			int ret = ImGui._CalcCircleAutoSegmentCountNative(Handle, radius);
			return ret;
		}

		public unsafe void _ClearFreeMemory()
		{
			ImGui._ClearFreeMemoryNative(Handle);
		}

		public unsafe void _OnChangedClipRect()
		{
			ImGui._OnChangedClipRectNative(Handle);
		}

		public unsafe void _OnChangedTextureID()
		{
			ImGui._OnChangedTextureIDNative(Handle);
		}

		public unsafe void _OnChangedVtxOffset()
		{
			ImGui._OnChangedVtxOffsetNative(Handle);
		}

		public unsafe void _PathArcToFastEx(Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			ImGui._PathArcToFastExNative(Handle, center, radius, aMinSample, aMaxSample, aStep);
		}

		public unsafe void _PathArcToN(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			ImGui._PathArcToNNative(Handle, center, radius, aMin, aMax, numSegments);
		}

		public unsafe void _PopUnusedDrawCmd()
		{
			ImGui._PopUnusedDrawCmdNative(Handle);
		}

		public unsafe void _ResetForNewFrame()
		{
			ImGui._ResetForNewFrameNative(Handle);
		}

		public unsafe void _TryMergeDrawCmds()
		{
			ImGui._TryMergeDrawCmdsNative(Handle);
		}

		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			ImGui.AddBezierCubicNative(Handle, p1, p2, p3, p4, col, thickness, numSegments);
		}

		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			ImGui.AddBezierCubicNative(Handle, p1, p2, p3, p4, col, thickness, (int)(0));
		}

		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			ImGui.AddBezierQuadraticNative(Handle, p1, p2, p3, col, thickness, numSegments);
		}

		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			ImGui.AddBezierQuadraticNative(Handle, p1, p2, p3, col, thickness, (int)(0));
		}

		public unsafe void AddCallback(ImDrawCallback callback, void* callbackData)
		{
			ImGui.AddCallbackNative(Handle, callback, callbackData);
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, numSegments, thickness);
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, numSegments, (float)(1.0f));
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, (int)(0), (float)(1.0f));
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, float thickness)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, (int)(0), thickness);
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddCircleFilledNative(Handle, center, radius, col, numSegments);
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col)
		{
			ImGui.AddCircleFilledNative(Handle, center, radius, col, (int)(0));
		}

		public unsafe void AddConvexPolyFilled(Vector2* points, int numPoints, uint col)
		{
			ImGui.AddConvexPolyFilledNative(Handle, points, numPoints, col);
		}

		public unsafe void AddConvexPolyFilled(ref Vector2 points, int numPoints, uint col)
		{
			fixed (Vector2* ppoints = &points)
			{
				ImGui.AddConvexPolyFilledNative(Handle, (Vector2*)ppoints, numPoints, col);
			}
		}

		public unsafe void AddDrawCmd()
		{
			ImGui.AddDrawCmdNative(Handle);
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col);
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddImageRoundedNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			ImGui.AddImageRoundedNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			ImGui.AddLineNative(Handle, p1, p2, col, thickness);
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col)
		{
			ImGui.AddLineNative(Handle, p1, p2, col, (float)(1.0f));
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			ImGui.AddNgonNative(Handle, center, radius, col, numSegments, thickness);
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddNgonNative(Handle, center, radius, col, numSegments, (float)(1.0f));
		}

		public unsafe void AddNgonFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddNgonFilledNative(Handle, center, radius, col, numSegments);
		}

		public unsafe void AddPolyline(Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.AddPolylineNative(Handle, points, numPoints, col, flags, thickness);
		}

		public unsafe void AddPolyline(ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (Vector2* ppoints = &points)
			{
				ImGui.AddPolylineNative(Handle, (Vector2*)ppoints, numPoints, col, flags, thickness);
			}
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			ImGui.AddQuadNative(Handle, p1, p2, p3, p4, col, thickness);
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddQuadNative(Handle, p1, p2, p3, p4, col, (float)(1.0f));
		}

		public unsafe void AddQuadFilled(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddQuadFilledNative(Handle, p1, p2, p3, p4, col);
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, flags, thickness);
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, flags, (float)(1.0f));
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0), thickness);
		}

		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), flags, thickness);
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, rounding, flags);
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0));
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
		}

		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, (float)(0.0f), flags);
		}

		public unsafe void AddRectFilledMultiColor(Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			ImGui.AddRectFilledMultiColorNative(Handle, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			ImGui.AddTextNative(Handle, pos, col, textBegin, textEnd);
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin)
		{
			ImGui.AddTextNative(Handle, pos, col, textBegin, (byte*)(default));
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			ImGui.AddTriangleNative(Handle, p1, p2, p3, col, thickness);
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			ImGui.AddTriangleNative(Handle, p1, p2, p3, col, (float)(1.0f));
		}

		public unsafe void AddTriangleFilled(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			ImGui.AddTriangleFilledNative(Handle, p1, p2, p3, col);
		}

		public unsafe void ChannelsMerge()
		{
			ImGui.ChannelsMergeNative(Handle);
		}

		public unsafe void ChannelsSetCurrent(int n)
		{
			ImGui.ChannelsSetCurrentNative(Handle, n);
		}

		public unsafe void ChannelsSplit(int count)
		{
			ImGui.ChannelsSplitNative(Handle, count);
		}

		public unsafe ImDrawList* CloneOutput()
		{
			ImDrawList* ret = ImGui.CloneOutputNative(Handle);
			return ret;
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			ImGui.PathArcToNative(Handle, center, radius, aMin, aMax, numSegments);
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax)
		{
			ImGui.PathArcToNative(Handle, center, radius, aMin, aMax, (int)(0));
		}

		public unsafe void PathArcToFast(Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			ImGui.PathArcToFastNative(Handle, center, radius, aMinOf12, aMaxOf12);
		}

		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			ImGui.PathBezierCubicCurveToNative(Handle, p2, p3, p4, numSegments);
		}

		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4)
		{
			ImGui.PathBezierCubicCurveToNative(Handle, p2, p3, p4, (int)(0));
		}

		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3, int numSegments)
		{
			ImGui.PathBezierQuadraticCurveToNative(Handle, p2, p3, numSegments);
		}

		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3)
		{
			ImGui.PathBezierQuadraticCurveToNative(Handle, p2, p3, (int)(0));
		}

		public unsafe void PathClear()
		{
			ImGui.PathClearNative(Handle);
		}

		public unsafe void PathFillConvex(uint col)
		{
			ImGui.PathFillConvexNative(Handle, col);
		}

		public unsafe void PathLineTo(Vector2 pos)
		{
			ImGui.PathLineToNative(Handle, pos);
		}

		public unsafe void PathLineToMergeDuplicate(Vector2 pos)
		{
			ImGui.PathLineToMergeDuplicateNative(Handle, pos);
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, rounding, flags);
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, rounding, (ImDrawFlags)(0));
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, ImDrawFlags flags)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, (float)(0.0f), flags);
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.PathStrokeNative(Handle, col, flags, thickness);
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags)
		{
			ImGui.PathStrokeNative(Handle, col, flags, (float)(1.0f));
		}

		public unsafe void PathStroke(uint col)
		{
			ImGui.PathStrokeNative(Handle, col, (ImDrawFlags)(0), (float)(1.0f));
		}

		public unsafe void PathStroke(uint col, float thickness)
		{
			ImGui.PathStrokeNative(Handle, col, (ImDrawFlags)(0), thickness);
		}

		public unsafe void PopClipRect()
		{
			ImGui.PopClipRectNative(Handle);
		}

		public unsafe void PopTextureID()
		{
			ImGui.PopTextureIDNative(Handle);
		}

		public unsafe void PrimQuadUV(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			ImGui.PrimQuadUVNative(Handle, a, b, c, d, uvA, uvB, uvC, uvD, col);
		}

		public unsafe void PrimRect(Vector2 a, Vector2 b, uint col)
		{
			ImGui.PrimRectNative(Handle, a, b, col);
		}

		public unsafe void PrimRectUV(Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			ImGui.PrimRectUVNative(Handle, a, b, uvA, uvB, col);
		}

		public unsafe void PrimReserve(int idxCount, int vtxCount)
		{
			ImGui.PrimReserveNative(Handle, idxCount, vtxCount);
		}

		public unsafe void PrimUnreserve(int idxCount, int vtxCount)
		{
			ImGui.PrimUnreserveNative(Handle, idxCount, vtxCount);
		}

		public unsafe void PrimVtx(Vector2 pos, Vector2 uv, uint col)
		{
			ImGui.PrimVtxNative(Handle, pos, uv, col);
		}

		public unsafe void PrimWriteIdx(ushort idx)
		{
			ImGui.PrimWriteIdxNative(Handle, idx);
		}

		public unsafe void PrimWriteVtx(Vector2 pos, Vector2 uv, uint col)
		{
			ImGui.PrimWriteVtxNative(Handle, pos, uv, col);
		}

		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			ImGui.PushClipRectNative(Handle, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax)
		{
			ImGui.PushClipRectNative(Handle, clipRectMin, clipRectMax, (byte)(0));
		}

		public unsafe void PushClipRectFullScreen()
		{
			ImGui.PushClipRectFullScreenNative(Handle);
		}

		public unsafe void PushTextureID(ImTextureID textureId)
		{
			ImGui.PushTextureIDNative(Handle, textureId);
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawListPtrPtr : IEquatable<ImDrawListPtrPtr>
	{
		public ImDrawListPtrPtr(ImDrawList** handle) { Handle = handle; }

		public ImDrawList** Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListPtrPtr Null => new ImDrawListPtrPtr(null);

		public static implicit operator ImDrawListPtrPtr(ImDrawList** handle) => new ImDrawListPtrPtr(handle);

		public static implicit operator ImDrawList**(ImDrawListPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListPtrPtr left, ImDrawListPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListPtrPtr left, ImDrawListPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListPtrPtr left, ImDrawList** right) => left.Handle == right;

		public static bool operator !=(ImDrawListPtrPtr left, ImDrawList** right) => left.Handle != right;

		public bool Equals(ImDrawListPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawListPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImDrawListPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawIdx
	{
		public int Size;
		public int Capacity;
		public unsafe ushort* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawVert
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawVert* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawVert
	{
		public Vector2 Pos;
		public Vector2 Uv;
		public uint Col;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawVertPtr : IEquatable<ImDrawVertPtr>
	{
		public ImDrawVertPtr(ImDrawVert* handle) { Handle = handle; }

		public ImDrawVert* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawVertPtr Null => new ImDrawVertPtr(null);

		public static implicit operator ImDrawVertPtr(ImDrawVert* handle) => new ImDrawVertPtr(handle);

		public static implicit operator ImDrawVert*(ImDrawVertPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawVertPtr left, ImDrawVertPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawVertPtr left, ImDrawVertPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawVertPtr left, ImDrawVert* right) => left.Handle == right;

		public static bool operator !=(ImDrawVertPtr left, ImDrawVert* right) => left.Handle != right;

		public bool Equals(ImDrawVertPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawVertPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawVertPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref Vector2 Pos => ref Unsafe.AsRef<Vector2>(&Handle->Pos);
		public ref Vector2 Uv => ref Unsafe.AsRef<Vector2>(&Handle->Uv);
		public ref uint Col => ref Unsafe.AsRef<uint>(&Handle->Col);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSharedData
	{
		public Vector2 TexUvWhitePixel;
		public unsafe ImFont* Font;
		public float FontSize;
		public float CurveTessellationTol;
		public float CircleSegmentMaxError;
		public Vector4 ClipRectFullscreen;
		public ImDrawListFlags InitialFlags;
		public ImVectorImVec2 TempBuffer;
		public Vector2 ArcFastVtx_0;
		public Vector2 ArcFastVtx_1;
		public Vector2 ArcFastVtx_2;
		public Vector2 ArcFastVtx_3;
		public Vector2 ArcFastVtx_4;
		public Vector2 ArcFastVtx_5;
		public Vector2 ArcFastVtx_6;
		public Vector2 ArcFastVtx_7;
		public Vector2 ArcFastVtx_8;
		public Vector2 ArcFastVtx_9;
		public Vector2 ArcFastVtx_10;
		public Vector2 ArcFastVtx_11;
		public Vector2 ArcFastVtx_12;
		public Vector2 ArcFastVtx_13;
		public Vector2 ArcFastVtx_14;
		public Vector2 ArcFastVtx_15;
		public Vector2 ArcFastVtx_16;
		public Vector2 ArcFastVtx_17;
		public Vector2 ArcFastVtx_18;
		public Vector2 ArcFastVtx_19;
		public Vector2 ArcFastVtx_20;
		public Vector2 ArcFastVtx_21;
		public Vector2 ArcFastVtx_22;
		public Vector2 ArcFastVtx_23;
		public Vector2 ArcFastVtx_24;
		public Vector2 ArcFastVtx_25;
		public Vector2 ArcFastVtx_26;
		public Vector2 ArcFastVtx_27;
		public Vector2 ArcFastVtx_28;
		public Vector2 ArcFastVtx_29;
		public Vector2 ArcFastVtx_30;
		public Vector2 ArcFastVtx_31;
		public Vector2 ArcFastVtx_32;
		public Vector2 ArcFastVtx_33;
		public Vector2 ArcFastVtx_34;
		public Vector2 ArcFastVtx_35;
		public Vector2 ArcFastVtx_36;
		public Vector2 ArcFastVtx_37;
		public Vector2 ArcFastVtx_38;
		public Vector2 ArcFastVtx_39;
		public Vector2 ArcFastVtx_40;
		public Vector2 ArcFastVtx_41;
		public Vector2 ArcFastVtx_42;
		public Vector2 ArcFastVtx_43;
		public Vector2 ArcFastVtx_44;
		public Vector2 ArcFastVtx_45;
		public Vector2 ArcFastVtx_46;
		public Vector2 ArcFastVtx_47;
		public float ArcFastRadiusCutoff;
		public byte CircleSegmentCounts_0;
		public byte CircleSegmentCounts_1;
		public byte CircleSegmentCounts_2;
		public byte CircleSegmentCounts_3;
		public byte CircleSegmentCounts_4;
		public byte CircleSegmentCounts_5;
		public byte CircleSegmentCounts_6;
		public byte CircleSegmentCounts_7;
		public byte CircleSegmentCounts_8;
		public byte CircleSegmentCounts_9;
		public byte CircleSegmentCounts_10;
		public byte CircleSegmentCounts_11;
		public byte CircleSegmentCounts_12;
		public byte CircleSegmentCounts_13;
		public byte CircleSegmentCounts_14;
		public byte CircleSegmentCounts_15;
		public byte CircleSegmentCounts_16;
		public byte CircleSegmentCounts_17;
		public byte CircleSegmentCounts_18;
		public byte CircleSegmentCounts_19;
		public byte CircleSegmentCounts_20;
		public byte CircleSegmentCounts_21;
		public byte CircleSegmentCounts_22;
		public byte CircleSegmentCounts_23;
		public byte CircleSegmentCounts_24;
		public byte CircleSegmentCounts_25;
		public byte CircleSegmentCounts_26;
		public byte CircleSegmentCounts_27;
		public byte CircleSegmentCounts_28;
		public byte CircleSegmentCounts_29;
		public byte CircleSegmentCounts_30;
		public byte CircleSegmentCounts_31;
		public byte CircleSegmentCounts_32;
		public byte CircleSegmentCounts_33;
		public byte CircleSegmentCounts_34;
		public byte CircleSegmentCounts_35;
		public byte CircleSegmentCounts_36;
		public byte CircleSegmentCounts_37;
		public byte CircleSegmentCounts_38;
		public byte CircleSegmentCounts_39;
		public byte CircleSegmentCounts_40;
		public byte CircleSegmentCounts_41;
		public byte CircleSegmentCounts_42;
		public byte CircleSegmentCounts_43;
		public byte CircleSegmentCounts_44;
		public byte CircleSegmentCounts_45;
		public byte CircleSegmentCounts_46;
		public byte CircleSegmentCounts_47;
		public byte CircleSegmentCounts_48;
		public byte CircleSegmentCounts_49;
		public byte CircleSegmentCounts_50;
		public byte CircleSegmentCounts_51;
		public byte CircleSegmentCounts_52;
		public byte CircleSegmentCounts_53;
		public byte CircleSegmentCounts_54;
		public byte CircleSegmentCounts_55;
		public byte CircleSegmentCounts_56;
		public byte CircleSegmentCounts_57;
		public byte CircleSegmentCounts_58;
		public byte CircleSegmentCounts_59;
		public byte CircleSegmentCounts_60;
		public byte CircleSegmentCounts_61;
		public byte CircleSegmentCounts_62;
		public byte CircleSegmentCounts_63;
		public unsafe Vector4* TexUvLines;

		public unsafe Span<Vector2> ArcFastVtx
		
		{
			get
			{
				fixed (Vector2* p = &this.ArcFastVtx_0)
				{
					return new Span<Vector2>(p, 48);
				}
			}
		}
	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawListSharedDataPtr : IEquatable<ImDrawListSharedDataPtr>
	{
		public ImDrawListSharedDataPtr(ImDrawListSharedData* handle) { Handle = handle; }

		public ImDrawListSharedData* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListSharedDataPtr Null => new ImDrawListSharedDataPtr(null);

		public static implicit operator ImDrawListSharedDataPtr(ImDrawListSharedData* handle) => new ImDrawListSharedDataPtr(handle);

		public static implicit operator ImDrawListSharedData*(ImDrawListSharedDataPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListSharedDataPtr left, ImDrawListSharedDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListSharedDataPtr left, ImDrawListSharedDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListSharedDataPtr left, ImDrawListSharedData* right) => left.Handle == right;

		public static bool operator !=(ImDrawListSharedDataPtr left, ImDrawListSharedData* right) => left.Handle != right;

		public bool Equals(ImDrawListSharedDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListSharedDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawListSharedDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref Vector2 TexUvWhitePixel => ref Unsafe.AsRef<Vector2>(&Handle->TexUvWhitePixel);
		public ref ImFontPtr Font => ref Unsafe.AsRef<ImFontPtr>(&Handle->Font);
		public ref float FontSize => ref Unsafe.AsRef<float>(&Handle->FontSize);
		public ref float CurveTessellationTol => ref Unsafe.AsRef<float>(&Handle->CurveTessellationTol);
		public ref float CircleSegmentMaxError => ref Unsafe.AsRef<float>(&Handle->CircleSegmentMaxError);
		public ref Vector4 ClipRectFullscreen => ref Unsafe.AsRef<Vector4>(&Handle->ClipRectFullscreen);
		public ref ImDrawListFlags InitialFlags => ref Unsafe.AsRef<ImDrawListFlags>(&Handle->InitialFlags);
		public ref ImVectorImVec2 TempBuffer => ref Unsafe.AsRef<ImVectorImVec2>(&Handle->TempBuffer);
		public unsafe Span<Vector2> ArcFastVtx
		
		{
			get
			{
				return new Span<Vector2>(&Handle->ArcFastVtx_0, 48);
			}
		}
		public ref float ArcFastRadiusCutoff => ref Unsafe.AsRef<float>(&Handle->ArcFastRadiusCutoff);
		public unsafe Span<byte> CircleSegmentCounts
		
		{
			get
			{
				return new Span<byte>(&Handle->CircleSegmentCounts_0, 64);
			}
		}
		public Vector4* TexUvLines { get => Handle->TexUvLines; set => Handle->TexUvLines = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFont
	{
		public ImVectorFloat IndexAdvanceX;
		public float FallbackAdvanceX;
		public float FontSize;
		public ImVectorImWchar IndexLookup;
		public ImVectorImFontGlyph Glyphs;
		public unsafe ImFontGlyph* FallbackGlyph;
		public unsafe ImFontAtlas* ContainerAtlas;
		public unsafe ImFontConfig* ConfigData;
		public short ConfigDataCount;
		public char FallbackChar;
		public char EllipsisChar;
		public short EllipsisCharCount;
		public float EllipsisWidth;
		public float EllipsisCharStep;
		public byte DirtyLookupTables;
		public float Scale;
		public float Ascent;
		public float Descent;
		public int MetricsTotalSurface;
		public byte Used4kPagesMap_0;
		public byte Used4kPagesMap_1;


		public unsafe void AddGlyph(ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddGlyphNative(@this, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public unsafe void AddGlyph(ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImFontConfig* psrcCfg = &srcCfg)
				{
					ImGui.AddGlyphNative(@this, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
				}
			}
		}

		public unsafe void AddRemapChar(char dst, char src, bool overwriteDst)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapCharNative(@this, dst, src, overwriteDst ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddRemapChar(char dst, char src)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapCharNative(@this, dst, src, (byte)(1));
			}
		}

		public unsafe void BuildLookupTable()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.BuildLookupTableNative(@this);
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, textEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, textEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, textEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, textEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, textEnd, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, textEnd, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, pStr0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, pStr0, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
						return ret;
					}
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
						return ret;
					}
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, pStr1, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, pStr1, wrapWidth));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe void ClearOutputData()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.ClearOutputDataNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImFontGlyph* FindGlyph(char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNative(@this, c);
				return ret;
			}
		}

		public unsafe ImFontGlyph* FindGlyphNoFallback(char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNoFallbackNative(@this, c);
				return ret;
			}
		}

		public unsafe float GetCharAdvance(char c)
		{
			fixed (ImFont* @this = &this)
			{
				float ret = ImGui.GetCharAdvanceNative(@this, c);
				return ret;
			}
		}

		public unsafe byte* GetDebugName()
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.GetDebugNameNative(@this);
				return ret;
			}
		}

		public unsafe string GetDebugNameS()
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.GetDebugNameNative(@this));
				return ret;
			}
		}

		public unsafe void GrowIndex(int newSize)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.GrowIndexNative(@this, newSize);
			}
		}

		public unsafe bool IsGlyphRangeUnused(uint cBegin, uint cLast)
		{
			fixed (ImFont* @this = &this)
			{
				byte ret = ImGui.IsGlyphRangeUnusedNative(@this, cBegin, cLast);
				return ret != 0;
			}
		}

		public unsafe bool IsLoaded()
		{
			fixed (ImFont* @this = &this)
			{
				byte ret = ImGui.IsLoadedNative(@this);
				return ret != 0;
			}
		}

		public unsafe void RenderChar(ImDrawListPtr drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderCharNative(@this, drawList, size, pos, col, c);
			}
		}

		public unsafe void RenderChar(ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderCharNative(@this, (ImDrawList*)pdrawList, size, pos, col, c);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void SetGlyphVisible(char c, bool visible)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.SetGlyphVisibleNative(@this, c, visible ? (byte)1 : (byte)0);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontPtr : IEquatable<ImFontPtr>
	{
		public ImFontPtr(ImFont* handle) { Handle = handle; }

		public ImFont* Handle;

		public bool IsNull => Handle == null;

		public static ImFontPtr Null => new ImFontPtr(null);

		public static implicit operator ImFontPtr(ImFont* handle) => new ImFontPtr(handle);

		public static implicit operator ImFont*(ImFontPtr handle) => handle.Handle;

		public static bool operator ==(ImFontPtr left, ImFontPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontPtr left, ImFontPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontPtr left, ImFont* right) => left.Handle == right;

		public static bool operator !=(ImFontPtr left, ImFont* right) => left.Handle != right;

		public bool Equals(ImFontPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorFloat IndexAdvanceX => ref Unsafe.AsRef<ImVectorFloat>(&Handle->IndexAdvanceX);
		public ref float FallbackAdvanceX => ref Unsafe.AsRef<float>(&Handle->FallbackAdvanceX);
		public ref float FontSize => ref Unsafe.AsRef<float>(&Handle->FontSize);
		public ref ImVectorImWchar IndexLookup => ref Unsafe.AsRef<ImVectorImWchar>(&Handle->IndexLookup);
		public ref ImVectorImFontGlyph Glyphs => ref Unsafe.AsRef<ImVectorImFontGlyph>(&Handle->Glyphs);
		public ref ImFontGlyphPtr FallbackGlyph => ref Unsafe.AsRef<ImFontGlyphPtr>(&Handle->FallbackGlyph);
		public ref ImFontAtlasPtr ContainerAtlas => ref Unsafe.AsRef<ImFontAtlasPtr>(&Handle->ContainerAtlas);
		public ref ImFontConfigPtr ConfigData => ref Unsafe.AsRef<ImFontConfigPtr>(&Handle->ConfigData);
		public ref short ConfigDataCount => ref Unsafe.AsRef<short>(&Handle->ConfigDataCount);
		public ref char FallbackChar => ref Unsafe.AsRef<char>(&Handle->FallbackChar);
		public ref char EllipsisChar => ref Unsafe.AsRef<char>(&Handle->EllipsisChar);
		public ref short EllipsisCharCount => ref Unsafe.AsRef<short>(&Handle->EllipsisCharCount);
		public ref float EllipsisWidth => ref Unsafe.AsRef<float>(&Handle->EllipsisWidth);
		public ref float EllipsisCharStep => ref Unsafe.AsRef<float>(&Handle->EllipsisCharStep);
		public ref bool DirtyLookupTables => ref Unsafe.AsRef<bool>(&Handle->DirtyLookupTables);
		public ref float Scale => ref Unsafe.AsRef<float>(&Handle->Scale);
		public ref float Ascent => ref Unsafe.AsRef<float>(&Handle->Ascent);
		public ref float Descent => ref Unsafe.AsRef<float>(&Handle->Descent);
		public ref int MetricsTotalSurface => ref Unsafe.AsRef<int>(&Handle->MetricsTotalSurface);
		public unsafe Span<byte> Used4kPagesMap
		
		{
			get
			{
				return new Span<byte>(&Handle->Used4kPagesMap_0, 2);
			}
		}

		public unsafe void AddGlyph(ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			ImGui.AddGlyphNative(Handle, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
		}

		public unsafe void AddGlyph(ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFontConfig* psrcCfg = &srcCfg)
			{
				ImGui.AddGlyphNative(Handle, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public unsafe void AddRemapChar(char dst, char src, bool overwriteDst)
		{
			ImGui.AddRemapCharNative(Handle, dst, src, overwriteDst ? (byte)1 : (byte)0);
		}

		public unsafe void AddRemapChar(char dst, char src)
		{
			ImGui.AddRemapCharNative(Handle, dst, src, (byte)(1));
		}

		public unsafe void BuildLookupTable()
		{
			ImGui.BuildLookupTableNative(Handle);
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, text, textEnd, wrapWidth);
			return ret;
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, text, textEnd, wrapWidth));
			return ret;
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, (byte*)ptext, textEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, (byte*)ptext, textEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, pStr0, textEnd, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, pStr0, textEnd, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, text, (byte*)ptextEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, text, (byte*)ptextEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, text, pStr0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, text, pStr0, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, pStr0, pStr1, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, pStr0, pStr1, wrapWidth));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe void ClearOutputData()
		{
			ImGui.ClearOutputDataNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe ImFontGlyph* FindGlyph(char c)
		{
			ImFontGlyph* ret = ImGui.FindGlyphNative(Handle, c);
			return ret;
		}

		public unsafe ImFontGlyph* FindGlyphNoFallback(char c)
		{
			ImFontGlyph* ret = ImGui.FindGlyphNoFallbackNative(Handle, c);
			return ret;
		}

		public unsafe float GetCharAdvance(char c)
		{
			float ret = ImGui.GetCharAdvanceNative(Handle, c);
			return ret;
		}

		public unsafe byte* GetDebugName()
		{
			byte* ret = ImGui.GetDebugNameNative(Handle);
			return ret;
		}

		public unsafe string GetDebugNameS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.GetDebugNameNative(Handle));
			return ret;
		}

		public unsafe void GrowIndex(int newSize)
		{
			ImGui.GrowIndexNative(Handle, newSize);
		}

		public unsafe bool IsGlyphRangeUnused(uint cBegin, uint cLast)
		{
			byte ret = ImGui.IsGlyphRangeUnusedNative(Handle, cBegin, cLast);
			return ret != 0;
		}

		public unsafe bool IsLoaded()
		{
			byte ret = ImGui.IsLoadedNative(Handle);
			return ret != 0;
		}

		public unsafe void RenderChar(ImDrawListPtr drawList, float size, Vector2 pos, uint col, char c)
		{
			ImGui.RenderCharNative(Handle, drawList, size, pos, col, c);
		}

		public unsafe void RenderChar(ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderCharNative(Handle, (ImDrawList*)pdrawList, size, pos, col, c);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, bool cpuFineClip)
		{
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void SetGlyphVisible(char c, bool visible)
		{
			ImGui.SetGlyphVisibleNative(Handle, c, visible ? (byte)1 : (byte)0);
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontPtrPtr : IEquatable<ImFontPtrPtr>
	{
		public ImFontPtrPtr(ImFont** handle) { Handle = handle; }

		public ImFont** Handle;

		public bool IsNull => Handle == null;

		public static ImFontPtrPtr Null => new ImFontPtrPtr(null);

		public static implicit operator ImFontPtrPtr(ImFont** handle) => new ImFontPtrPtr(handle);

		public static implicit operator ImFont**(ImFontPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImFontPtrPtr left, ImFontPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontPtrPtr left, ImFontPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontPtrPtr left, ImFont** right) => left.Handle == right;

		public static bool operator !=(ImFontPtrPtr left, ImFont** right) => left.Handle != right;

		public bool Equals(ImFontPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImFontPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorFloat
	{
		public int Size;
		public int Capacity;
		public unsafe float* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImWchar
	{
		public int Size;
		public int Capacity;
		public unsafe char* Data;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorImWcharPtr : IEquatable<ImVectorImWcharPtr>
	{
		public ImVectorImWcharPtr(ImVectorImWchar* handle) { Handle = handle; }

		public ImVectorImWchar* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorImWcharPtr Null => new ImVectorImWcharPtr(null);

		public static implicit operator ImVectorImWcharPtr(ImVectorImWchar* handle) => new ImVectorImWcharPtr(handle);

		public static implicit operator ImVectorImWchar*(ImVectorImWcharPtr handle) => handle.Handle;

		public static bool operator ==(ImVectorImWcharPtr left, ImVectorImWcharPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorImWcharPtr left, ImVectorImWcharPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorImWcharPtr left, ImVectorImWchar* right) => left.Handle == right;

		public static bool operator !=(ImVectorImWcharPtr left, ImVectorImWchar* right) => left.Handle != right;

		public bool Equals(ImVectorImWcharPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorImWcharPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorImWcharPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public char* Data { get => Handle->Data; set => Handle->Data = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontGlyph
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontGlyph* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyph
	{
		public uint Colored;
		public uint Visible;
		public uint Codepoint;
		public float AdvanceX;
		public float X0;
		public float Y0;
		public float X1;
		public float Y1;
		public float U0;
		public float V0;
		public float U1;
		public float V1;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontGlyphPtr : IEquatable<ImFontGlyphPtr>
	{
		public ImFontGlyphPtr(ImFontGlyph* handle) { Handle = handle; }

		public ImFontGlyph* Handle;

		public bool IsNull => Handle == null;

		public static ImFontGlyphPtr Null => new ImFontGlyphPtr(null);

		public static implicit operator ImFontGlyphPtr(ImFontGlyph* handle) => new ImFontGlyphPtr(handle);

		public static implicit operator ImFontGlyph*(ImFontGlyphPtr handle) => handle.Handle;

		public static bool operator ==(ImFontGlyphPtr left, ImFontGlyphPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontGlyphPtr left, ImFontGlyphPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontGlyphPtr left, ImFontGlyph* right) => left.Handle == right;

		public static bool operator !=(ImFontGlyphPtr left, ImFontGlyph* right) => left.Handle != right;

		public bool Equals(ImFontGlyphPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontGlyphPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontGlyphPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref uint Colored => ref Unsafe.AsRef<uint>(&Handle->Colored);
		public ref uint Visible => ref Unsafe.AsRef<uint>(&Handle->Visible);
		public ref uint Codepoint => ref Unsafe.AsRef<uint>(&Handle->Codepoint);
		public ref float AdvanceX => ref Unsafe.AsRef<float>(&Handle->AdvanceX);
		public ref float X0 => ref Unsafe.AsRef<float>(&Handle->X0);
		public ref float Y0 => ref Unsafe.AsRef<float>(&Handle->Y0);
		public ref float X1 => ref Unsafe.AsRef<float>(&Handle->X1);
		public ref float Y1 => ref Unsafe.AsRef<float>(&Handle->Y1);
		public ref float U0 => ref Unsafe.AsRef<float>(&Handle->U0);
		public ref float V0 => ref Unsafe.AsRef<float>(&Handle->V0);
		public ref float U1 => ref Unsafe.AsRef<float>(&Handle->U1);
		public ref float V1 => ref Unsafe.AsRef<float>(&Handle->V1);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlas
	{
		public ImFontAtlasFlags Flags;
		public ImTextureID TexID;
		public int TexDesiredWidth;
		public int TexGlyphPadding;
		public byte Locked;
		public unsafe void* UserData;
		public byte TexReady;
		public byte TexPixelsUseColors;
		public unsafe byte* TexPixelsAlpha8;
		public unsafe uint* TexPixelsRGBA32;
		public int TexWidth;
		public int TexHeight;
		public Vector2 TexUvScale;
		public Vector2 TexUvWhitePixel;
		public ImVectorImFontPtr Fonts;
		public ImVectorImFontAtlasCustomRect CustomRects;
		public ImVectorImFontConfig ConfigData;
		public Vector4 TexUvLines_0;
		public Vector4 TexUvLines_1;
		public Vector4 TexUvLines_2;
		public Vector4 TexUvLines_3;
		public Vector4 TexUvLines_4;
		public Vector4 TexUvLines_5;
		public Vector4 TexUvLines_6;
		public Vector4 TexUvLines_7;
		public Vector4 TexUvLines_8;
		public Vector4 TexUvLines_9;
		public Vector4 TexUvLines_10;
		public Vector4 TexUvLines_11;
		public Vector4 TexUvLines_12;
		public Vector4 TexUvLines_13;
		public Vector4 TexUvLines_14;
		public Vector4 TexUvLines_15;
		public Vector4 TexUvLines_16;
		public Vector4 TexUvLines_17;
		public Vector4 TexUvLines_18;
		public Vector4 TexUvLines_19;
		public Vector4 TexUvLines_20;
		public Vector4 TexUvLines_21;
		public Vector4 TexUvLines_22;
		public Vector4 TexUvLines_23;
		public Vector4 TexUvLines_24;
		public Vector4 TexUvLines_25;
		public Vector4 TexUvLines_26;
		public Vector4 TexUvLines_27;
		public Vector4 TexUvLines_28;
		public Vector4 TexUvLines_29;
		public Vector4 TexUvLines_30;
		public Vector4 TexUvLines_31;
		public Vector4 TexUvLines_32;
		public Vector4 TexUvLines_33;
		public Vector4 TexUvLines_34;
		public Vector4 TexUvLines_35;
		public Vector4 TexUvLines_36;
		public Vector4 TexUvLines_37;
		public Vector4 TexUvLines_38;
		public Vector4 TexUvLines_39;
		public Vector4 TexUvLines_40;
		public Vector4 TexUvLines_41;
		public Vector4 TexUvLines_42;
		public Vector4 TexUvLines_43;
		public Vector4 TexUvLines_44;
		public Vector4 TexUvLines_45;
		public Vector4 TexUvLines_46;
		public Vector4 TexUvLines_47;
		public Vector4 TexUvLines_48;
		public Vector4 TexUvLines_49;
		public Vector4 TexUvLines_50;
		public Vector4 TexUvLines_51;
		public Vector4 TexUvLines_52;
		public Vector4 TexUvLines_53;
		public Vector4 TexUvLines_54;
		public Vector4 TexUvLines_55;
		public Vector4 TexUvLines_56;
		public Vector4 TexUvLines_57;
		public Vector4 TexUvLines_58;
		public Vector4 TexUvLines_59;
		public Vector4 TexUvLines_60;
		public Vector4 TexUvLines_61;
		public Vector4 TexUvLines_62;
		public Vector4 TexUvLines_63;
		public unsafe ImFontBuilderIO* FontBuilderIO;
		public uint FontBuilderFlags;
		public int PackIdMouseCursors;
		public int PackIdLines;

		public unsafe Span<Vector4> TexUvLines
		
		{
			get
			{
				fixed (Vector4* p = &this.TexUvLines_0)
				{
					return new Span<Vector4>(p, 64);
				}
			}
		}

		public unsafe int AddCustomRectFontGlyph(ImFontPtr font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(@this, font, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph(ImFontPtr font, char id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(@this, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyphNative(@this, (ImFont*)pfont, id, width, height, advanceX, offset);
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyphNative(@this, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectRegular(int width, int height)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectRegularNative(@this, width, height);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFont(ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontNative(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFont(ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontNative(@this, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontDefault(ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontDefaultNative(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontDefaultNative(@this, (ImFontConfig*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontDefault(ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontDefaultNative(@this, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe bool Build()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.BuildNative(@this);
				return ret != 0;
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.CalcCustomRectUVNative(@this, rect, outUvMin, outUvMax);
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGui.CalcCustomRectUVNative(@this, rect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUVNative(@this, rect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(@this, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						fixed (Vector2* poutUvMax = &outUvMax)
						{
							ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
						}
					}
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void ClearFonts()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearFontsNative(@this);
			}
		}

		public unsafe void ClearInputData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearInputDataNative(@this);
			}
		}

		public unsafe void ClearTexData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearTexDataNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImFontAtlasCustomRect* GetCustomRectByIndex(int index)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontAtlasCustomRect* ret = ImGui.GetCustomRectByIndexNative(@this, index);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesChineseFull()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseFullNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesChineseSimplifiedCommon()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseSimplifiedCommonNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesCyrillic()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesCyrillicNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesDefaultNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesGreek()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesGreekNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesJapanese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesJapaneseNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesKorean()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesKoreanNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesThai()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesThaiNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesVietnamese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesVietnameseNative(@this);
				return ret;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		public unsafe bool IsBuilt()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.IsBuiltNative(@this);
				return ret != 0;
			}
		}

		public unsafe void SetTexID(ImTextureID id)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.SetTexIDNative(@this, id);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontAtlasPtr : IEquatable<ImFontAtlasPtr>
	{
		public ImFontAtlasPtr(ImFontAtlas* handle) { Handle = handle; }

		public ImFontAtlas* Handle;

		public bool IsNull => Handle == null;

		public static ImFontAtlasPtr Null => new ImFontAtlasPtr(null);

		public static implicit operator ImFontAtlasPtr(ImFontAtlas* handle) => new ImFontAtlasPtr(handle);

		public static implicit operator ImFontAtlas*(ImFontAtlasPtr handle) => handle.Handle;

		public static bool operator ==(ImFontAtlasPtr left, ImFontAtlasPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontAtlasPtr left, ImFontAtlasPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontAtlasPtr left, ImFontAtlas* right) => left.Handle == right;

		public static bool operator !=(ImFontAtlasPtr left, ImFontAtlas* right) => left.Handle != right;

		public bool Equals(ImFontAtlasPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontAtlasPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontAtlasPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImFontAtlasFlags Flags => ref Unsafe.AsRef<ImFontAtlasFlags>(&Handle->Flags);
		public ref ImTextureID TexID => ref Unsafe.AsRef<ImTextureID>(&Handle->TexID);
		public ref int TexDesiredWidth => ref Unsafe.AsRef<int>(&Handle->TexDesiredWidth);
		public ref int TexGlyphPadding => ref Unsafe.AsRef<int>(&Handle->TexGlyphPadding);
		public ref bool Locked => ref Unsafe.AsRef<bool>(&Handle->Locked);
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
		public ref bool TexReady => ref Unsafe.AsRef<bool>(&Handle->TexReady);
		public ref bool TexPixelsUseColors => ref Unsafe.AsRef<bool>(&Handle->TexPixelsUseColors);
		public byte* TexPixelsAlpha8 { get => Handle->TexPixelsAlpha8; set => Handle->TexPixelsAlpha8 = value; }
		public uint* TexPixelsRGBA32 { get => Handle->TexPixelsRGBA32; set => Handle->TexPixelsRGBA32 = value; }
		public ref int TexWidth => ref Unsafe.AsRef<int>(&Handle->TexWidth);
		public ref int TexHeight => ref Unsafe.AsRef<int>(&Handle->TexHeight);
		public ref Vector2 TexUvScale => ref Unsafe.AsRef<Vector2>(&Handle->TexUvScale);
		public ref Vector2 TexUvWhitePixel => ref Unsafe.AsRef<Vector2>(&Handle->TexUvWhitePixel);
		public ref ImVectorImFontPtr Fonts => ref Unsafe.AsRef<ImVectorImFontPtr>(&Handle->Fonts);
		public ref ImVectorImFontAtlasCustomRect CustomRects => ref Unsafe.AsRef<ImVectorImFontAtlasCustomRect>(&Handle->CustomRects);
		public ref ImVectorImFontConfig ConfigData => ref Unsafe.AsRef<ImVectorImFontConfig>(&Handle->ConfigData);
		public unsafe Span<Vector4> TexUvLines
		
		{
			get
			{
				return new Span<Vector4>(&Handle->TexUvLines_0, 64);
			}
		}
		public ref ImFontBuilderIOPtr FontBuilderIO => ref Unsafe.AsRef<ImFontBuilderIOPtr>(&Handle->FontBuilderIO);
		public ref uint FontBuilderFlags => ref Unsafe.AsRef<uint>(&Handle->FontBuilderFlags);
		public ref int PackIdMouseCursors => ref Unsafe.AsRef<int>(&Handle->PackIdMouseCursors);
		public ref int PackIdLines => ref Unsafe.AsRef<int>(&Handle->PackIdLines);

		public unsafe int AddCustomRectFontGlyph(ImFontPtr font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			int ret = ImGui.AddCustomRectFontGlyphNative(Handle, font, id, width, height, advanceX, offset);
			return ret;
		}

		public unsafe int AddCustomRectFontGlyph(ImFontPtr font, char id, int width, int height, float advanceX)
		{
			int ret = ImGui.AddCustomRectFontGlyphNative(Handle, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
			return ret;
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(Handle, (ImFont*)pfont, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(Handle, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		public unsafe int AddCustomRectRegular(int width, int height)
		{
			int ret = ImGui.AddCustomRectRegularNative(Handle, width, height);
			return ret;
		}

		public unsafe ImFontPtr AddFont(ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontNative(Handle, fontCfg);
			return ret;
		}

		public unsafe ImFontPtr AddFont(ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontNative(Handle, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontDefault(ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontDefaultNative(Handle, fontCfg);
			return ret;
		}

		public unsafe ImFontPtr AddFontDefault()
		{
			ImFontPtr ret = ImGui.AddFontDefaultNative(Handle, (ImFontConfig*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontDefault(ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontDefaultNative(Handle, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels)
		{
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)(default), glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, fontCfg, glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, fontCfg, (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, fontCfg, glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, fontCfg, (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe bool Build()
		{
			byte ret = ImGui.BuildNative(Handle);
			return ret != 0;
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			ImGui.CalcCustomRectUVNative(Handle, rect, outUvMin, outUvMax);
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				ImGui.CalcCustomRectUVNative(Handle, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				ImGui.CalcCustomRectUVNative(Handle, rect, (Vector2*)poutUvMin, outUvMax);
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGui.CalcCustomRectUVNative(Handle, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMax = &outUvMax)
			{
				ImGui.CalcCustomRectUVNative(Handle, rect, outUvMin, (Vector2*)poutUvMax);
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUVNative(Handle, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUVNative(Handle, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(Handle, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void ClearFonts()
		{
			ImGui.ClearFontsNative(Handle);
		}

		public unsafe void ClearInputData()
		{
			ImGui.ClearInputDataNative(Handle);
		}

		public unsafe void ClearTexData()
		{
			ImGui.ClearTexDataNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe ImFontAtlasCustomRect* GetCustomRectByIndex(int index)
		{
			ImFontAtlasCustomRect* ret = ImGui.GetCustomRectByIndexNative(Handle, index);
			return ret;
		}

		public unsafe char* GetGlyphRangesChineseFull()
		{
			char* ret = ImGui.GetGlyphRangesChineseFullNative(Handle);
			return ret;
		}

		public unsafe char* GetGlyphRangesChineseSimplifiedCommon()
		{
			char* ret = ImGui.GetGlyphRangesChineseSimplifiedCommonNative(Handle);
			return ret;
		}

		public unsafe char* GetGlyphRangesCyrillic()
		{
			char* ret = ImGui.GetGlyphRangesCyrillicNative(Handle);
			return ret;
		}

		public unsafe char* GetGlyphRangesDefault()
		{
			char* ret = ImGui.GetGlyphRangesDefaultNative(Handle);
			return ret;
		}

		public unsafe char* GetGlyphRangesGreek()
		{
			char* ret = ImGui.GetGlyphRangesGreekNative(Handle);
			return ret;
		}

		public unsafe char* GetGlyphRangesJapanese()
		{
			char* ret = ImGui.GetGlyphRangesJapaneseNative(Handle);
			return ret;
		}

		public unsafe char* GetGlyphRangesKorean()
		{
			char* ret = ImGui.GetGlyphRangesKoreanNative(Handle);
			return ret;
		}

		public unsafe char* GetGlyphRangesThai()
		{
			char* ret = ImGui.GetGlyphRangesThaiNative(Handle);
			return ret;
		}

		public unsafe char* GetGlyphRangesVietnamese()
		{
			char* ret = ImGui.GetGlyphRangesVietnameseNative(Handle);
			return ret;
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, outSize, outUvBorder, outUvFill);
			return ret != 0;
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvFill = &outUvFill)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, outHeight, outBytesPerPixel);
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight)
		{
			ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, outHeight, (int*)(default));
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, outHeight, outBytesPerPixel);
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight)
		{
			ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, outHeight, (int*)(default));
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe bool IsBuilt()
		{
			byte ret = ImGui.IsBuiltNative(Handle);
			return ret != 0;
		}

		public unsafe void SetTexID(ImTextureID id)
		{
			ImGui.SetTexIDNative(Handle, id);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImFont** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontAtlasCustomRect
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontAtlasCustomRect* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlasCustomRect
	{
		public ushort Width;
		public ushort Height;
		public ushort X;
		public ushort Y;
		public uint GlyphID;
		public float GlyphAdvanceX;
		public Vector2 GlyphOffset;
		public unsafe ImFont* Font;


		public unsafe void Destroy()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsPacked()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				byte ret = ImGui.IsPackedNative(@this);
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontAtlasCustomRectPtr : IEquatable<ImFontAtlasCustomRectPtr>
	{
		public ImFontAtlasCustomRectPtr(ImFontAtlasCustomRect* handle) { Handle = handle; }

		public ImFontAtlasCustomRect* Handle;

		public bool IsNull => Handle == null;

		public static ImFontAtlasCustomRectPtr Null => new ImFontAtlasCustomRectPtr(null);

		public static implicit operator ImFontAtlasCustomRectPtr(ImFontAtlasCustomRect* handle) => new ImFontAtlasCustomRectPtr(handle);

		public static implicit operator ImFontAtlasCustomRect*(ImFontAtlasCustomRectPtr handle) => handle.Handle;

		public static bool operator ==(ImFontAtlasCustomRectPtr left, ImFontAtlasCustomRectPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontAtlasCustomRectPtr left, ImFontAtlasCustomRectPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontAtlasCustomRectPtr left, ImFontAtlasCustomRect* right) => left.Handle == right;

		public static bool operator !=(ImFontAtlasCustomRectPtr left, ImFontAtlasCustomRect* right) => left.Handle != right;

		public bool Equals(ImFontAtlasCustomRectPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontAtlasCustomRectPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontAtlasCustomRectPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ushort Width => ref Unsafe.AsRef<ushort>(&Handle->Width);
		public ref ushort Height => ref Unsafe.AsRef<ushort>(&Handle->Height);
		public ref ushort X => ref Unsafe.AsRef<ushort>(&Handle->X);
		public ref ushort Y => ref Unsafe.AsRef<ushort>(&Handle->Y);
		public ref uint GlyphID => ref Unsafe.AsRef<uint>(&Handle->GlyphID);
		public ref float GlyphAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphAdvanceX);
		public ref Vector2 GlyphOffset => ref Unsafe.AsRef<Vector2>(&Handle->GlyphOffset);
		public ref ImFontPtr Font => ref Unsafe.AsRef<ImFontPtr>(&Handle->Font);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool IsPacked()
		{
			byte ret = ImGui.IsPackedNative(Handle);
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontConfig
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontConfig* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontConfig
	{
		public unsafe void* FontData;
		public int FontDataSize;
		public byte FontDataOwnedByAtlas;
		public int FontNo;
		public float SizePixels;
		public int OversampleH;
		public int OversampleV;
		public byte PixelSnapH;
		public Vector2 GlyphExtraSpacing;
		public Vector2 GlyphOffset;
		public unsafe char* GlyphRanges;
		public float GlyphMinAdvanceX;
		public float GlyphMaxAdvanceX;
		public byte MergeMode;
		public uint FontBuilderFlags;
		public float RasterizerMultiply;
		public char EllipsisChar;
		public byte Name_0;
		public byte Name_1;
		public byte Name_2;
		public byte Name_3;
		public byte Name_4;
		public byte Name_5;
		public byte Name_6;
		public byte Name_7;
		public byte Name_8;
		public byte Name_9;
		public byte Name_10;
		public byte Name_11;
		public byte Name_12;
		public byte Name_13;
		public byte Name_14;
		public byte Name_15;
		public byte Name_16;
		public byte Name_17;
		public byte Name_18;
		public byte Name_19;
		public byte Name_20;
		public byte Name_21;
		public byte Name_22;
		public byte Name_23;
		public byte Name_24;
		public byte Name_25;
		public byte Name_26;
		public byte Name_27;
		public byte Name_28;
		public byte Name_29;
		public byte Name_30;
		public byte Name_31;
		public byte Name_32;
		public byte Name_33;
		public byte Name_34;
		public byte Name_35;
		public byte Name_36;
		public byte Name_37;
		public byte Name_38;
		public byte Name_39;
		public unsafe ImFont* DstFont;


		public unsafe void Destroy()
		{
			fixed (ImFontConfig* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontConfigPtr : IEquatable<ImFontConfigPtr>
	{
		public ImFontConfigPtr(ImFontConfig* handle) { Handle = handle; }

		public ImFontConfig* Handle;

		public bool IsNull => Handle == null;

		public static ImFontConfigPtr Null => new ImFontConfigPtr(null);

		public static implicit operator ImFontConfigPtr(ImFontConfig* handle) => new ImFontConfigPtr(handle);

		public static implicit operator ImFontConfig*(ImFontConfigPtr handle) => handle.Handle;

		public static bool operator ==(ImFontConfigPtr left, ImFontConfigPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontConfigPtr left, ImFontConfigPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontConfigPtr left, ImFontConfig* right) => left.Handle == right;

		public static bool operator !=(ImFontConfigPtr left, ImFontConfig* right) => left.Handle != right;

		public bool Equals(ImFontConfigPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontConfigPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontConfigPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public void* FontData { get => Handle->FontData; set => Handle->FontData = value; }
		public ref int FontDataSize => ref Unsafe.AsRef<int>(&Handle->FontDataSize);
		public ref bool FontDataOwnedByAtlas => ref Unsafe.AsRef<bool>(&Handle->FontDataOwnedByAtlas);
		public ref int FontNo => ref Unsafe.AsRef<int>(&Handle->FontNo);
		public ref float SizePixels => ref Unsafe.AsRef<float>(&Handle->SizePixels);
		public ref int OversampleH => ref Unsafe.AsRef<int>(&Handle->OversampleH);
		public ref int OversampleV => ref Unsafe.AsRef<int>(&Handle->OversampleV);
		public ref bool PixelSnapH => ref Unsafe.AsRef<bool>(&Handle->PixelSnapH);
		public ref Vector2 GlyphExtraSpacing => ref Unsafe.AsRef<Vector2>(&Handle->GlyphExtraSpacing);
		public ref Vector2 GlyphOffset => ref Unsafe.AsRef<Vector2>(&Handle->GlyphOffset);
		public char* GlyphRanges { get => Handle->GlyphRanges; set => Handle->GlyphRanges = value; }
		public ref float GlyphMinAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphMinAdvanceX);
		public ref float GlyphMaxAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphMaxAdvanceX);
		public ref bool MergeMode => ref Unsafe.AsRef<bool>(&Handle->MergeMode);
		public ref uint FontBuilderFlags => ref Unsafe.AsRef<uint>(&Handle->FontBuilderFlags);
		public ref float RasterizerMultiply => ref Unsafe.AsRef<float>(&Handle->RasterizerMultiply);
		public ref char EllipsisChar => ref Unsafe.AsRef<char>(&Handle->EllipsisChar);
		public unsafe Span<byte> Name
		
		{
			get
			{
				return new Span<byte>(&Handle->Name_0, 40);
			}
		}
		public ref ImFontPtr DstFont => ref Unsafe.AsRef<ImFontPtr>(&Handle->DstFont);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontBuilderIO
	{
		public unsafe void* FontBuilderBuild;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontBuilderIOPtr : IEquatable<ImFontBuilderIOPtr>
	{
		public ImFontBuilderIOPtr(ImFontBuilderIO* handle) { Handle = handle; }

		public ImFontBuilderIO* Handle;

		public bool IsNull => Handle == null;

		public static ImFontBuilderIOPtr Null => new ImFontBuilderIOPtr(null);

		public static implicit operator ImFontBuilderIOPtr(ImFontBuilderIO* handle) => new ImFontBuilderIOPtr(handle);

		public static implicit operator ImFontBuilderIO*(ImFontBuilderIOPtr handle) => handle.Handle;

		public static bool operator ==(ImFontBuilderIOPtr left, ImFontBuilderIOPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontBuilderIOPtr left, ImFontBuilderIOPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontBuilderIOPtr left, ImFontBuilderIO* right) => left.Handle == right;

		public static bool operator !=(ImFontBuilderIOPtr left, ImFontBuilderIO* right) => left.Handle != right;

		public bool Equals(ImFontBuilderIOPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontBuilderIOPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontBuilderIOPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public void* FontBuilderBuild { get => Handle->FontBuilderBuild; set => Handle->FontBuilderBuild = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImVec2
	{
		public int Size;
		public int Capacity;
		public unsafe Vector2* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImVec4
	{
		public int Size;
		public int Capacity;
		public unsafe Vector4* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImTextureID
	{
		public int Size;
		public int Capacity;
		public unsafe ImTextureID* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmdHeader
	{
		public Vector4 ClipRect;
		public ImTextureID TextureId;
		public uint VtxOffset;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSplitter
	{
		public int Current;
		public int Count;
		public ImVectorImDrawChannel Channels;


		public unsafe void Clear()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void ClearFreeMemory()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void Merge(ImDrawListPtr drawList)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.MergeNative(@this, drawList);
			}
		}

		public unsafe void Merge(ref ImDrawList drawList)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.MergeNative(@this, (ImDrawList*)pdrawList);
				}
			}
		}

		public unsafe void SetCurrentChannel(ImDrawListPtr drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.SetCurrentChannelNative(@this, drawList, channelIdx);
			}
		}

		public unsafe void SetCurrentChannel(ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.SetCurrentChannelNative(@this, (ImDrawList*)pdrawList, channelIdx);
				}
			}
		}

		public unsafe void Split(ImDrawListPtr drawList, int count)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.SplitNative(@this, drawList, count);
			}
		}

		public unsafe void Split(ref ImDrawList drawList, int count)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.SplitNative(@this, (ImDrawList*)pdrawList, count);
				}
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawListSplitterPtr : IEquatable<ImDrawListSplitterPtr>
	{
		public ImDrawListSplitterPtr(ImDrawListSplitter* handle) { Handle = handle; }

		public ImDrawListSplitter* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListSplitterPtr Null => new ImDrawListSplitterPtr(null);

		public static implicit operator ImDrawListSplitterPtr(ImDrawListSplitter* handle) => new ImDrawListSplitterPtr(handle);

		public static implicit operator ImDrawListSplitter*(ImDrawListSplitterPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListSplitterPtr left, ImDrawListSplitterPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListSplitterPtr left, ImDrawListSplitterPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListSplitterPtr left, ImDrawListSplitter* right) => left.Handle == right;

		public static bool operator !=(ImDrawListSplitterPtr left, ImDrawListSplitter* right) => left.Handle != right;

		public bool Equals(ImDrawListSplitterPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListSplitterPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawListSplitterPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Current => ref Unsafe.AsRef<int>(&Handle->Current);
		public ref int Count => ref Unsafe.AsRef<int>(&Handle->Count);
		public ref ImVectorImDrawChannel Channels => ref Unsafe.AsRef<ImVectorImDrawChannel>(&Handle->Channels);

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void ClearFreeMemory()
		{
			ImGui.ClearFreeMemoryNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void Merge(ImDrawListPtr drawList)
		{
			ImGui.MergeNative(Handle, drawList);
		}

		public unsafe void Merge(ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.MergeNative(Handle, (ImDrawList*)pdrawList);
			}
		}

		public unsafe void SetCurrentChannel(ImDrawListPtr drawList, int channelIdx)
		{
			ImGui.SetCurrentChannelNative(Handle, drawList, channelIdx);
		}

		public unsafe void SetCurrentChannel(ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.SetCurrentChannelNative(Handle, (ImDrawList*)pdrawList, channelIdx);
			}
		}

		public unsafe void Split(ImDrawListPtr drawList, int count)
		{
			ImGui.SplitNative(Handle, drawList, count);
		}

		public unsafe void Split(ref ImDrawList drawList, int count)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.SplitNative(Handle, (ImDrawList*)pdrawList, count);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawChannel
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawChannel* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawData
	{
		public byte Valid;
		public int CmdListsCount;
		public int TotalIdxCount;
		public int TotalVtxCount;
		public unsafe ImDrawList** CmdLists;
		public Vector2 DisplayPos;
		public Vector2 DisplaySize;
		public Vector2 FramebufferScale;
		public unsafe ImGuiViewport* OwnerViewport;


		public unsafe void Clear()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void DeIndexAllBuffers()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DeIndexAllBuffersNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void ScaleClipRects(Vector2 fbScale)
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ScaleClipRectsNative(@this, fbScale);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawDataPtr : IEquatable<ImDrawDataPtr>
	{
		public ImDrawDataPtr(ImDrawData* handle) { Handle = handle; }

		public ImDrawData* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawDataPtr Null => new ImDrawDataPtr(null);

		public static implicit operator ImDrawDataPtr(ImDrawData* handle) => new ImDrawDataPtr(handle);

		public static implicit operator ImDrawData*(ImDrawDataPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawDataPtr left, ImDrawDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawDataPtr left, ImDrawDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawDataPtr left, ImDrawData* right) => left.Handle == right;

		public static bool operator !=(ImDrawDataPtr left, ImDrawData* right) => left.Handle != right;

		public bool Equals(ImDrawDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref bool Valid => ref Unsafe.AsRef<bool>(&Handle->Valid);
		public ref int CmdListsCount => ref Unsafe.AsRef<int>(&Handle->CmdListsCount);
		public ref int TotalIdxCount => ref Unsafe.AsRef<int>(&Handle->TotalIdxCount);
		public ref int TotalVtxCount => ref Unsafe.AsRef<int>(&Handle->TotalVtxCount);
		public ref ImDrawListPtrPtr CmdLists => ref Unsafe.AsRef<ImDrawListPtrPtr>(&Handle->CmdLists);
		public ref Vector2 DisplayPos => ref Unsafe.AsRef<Vector2>(&Handle->DisplayPos);
		public ref Vector2 DisplaySize => ref Unsafe.AsRef<Vector2>(&Handle->DisplaySize);
		public ref Vector2 FramebufferScale => ref Unsafe.AsRef<Vector2>(&Handle->FramebufferScale);
		public ref ImGuiViewportPtr OwnerViewport => ref Unsafe.AsRef<ImGuiViewportPtr>(&Handle->OwnerViewport);

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void DeIndexAllBuffers()
		{
			ImGui.DeIndexAllBuffersNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void ScaleClipRects(Vector2 fbScale)
		{
			ImGui.ScaleClipRectsNative(Handle, fbScale);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiViewport
	{
		public int ID;
		public ImGuiViewportFlags Flags;
		public Vector2 Pos;
		public Vector2 Size;
		public Vector2 WorkPos;
		public Vector2 WorkSize;
		public float DpiScale;
		public int ParentViewportId;
		public unsafe ImDrawData* DrawData;
		public unsafe void* RendererUserData;
		public unsafe void* PlatformUserData;
		public unsafe void* PlatformHandle;
		public unsafe void* PlatformHandleRaw;
		public byte PlatformWindowCreated;
		public byte PlatformRequestMove;
		public byte PlatformRequestResize;
		public byte PlatformRequestClose;


		public unsafe void Destroy()
		{
			fixed (ImGuiViewport* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiViewportPtr : IEquatable<ImGuiViewportPtr>
	{
		public ImGuiViewportPtr(ImGuiViewport* handle) { Handle = handle; }

		public ImGuiViewport* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiViewportPtr Null => new ImGuiViewportPtr(null);

		public static implicit operator ImGuiViewportPtr(ImGuiViewport* handle) => new ImGuiViewportPtr(handle);

		public static implicit operator ImGuiViewport*(ImGuiViewportPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiViewportPtr left, ImGuiViewportPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiViewportPtr left, ImGuiViewportPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiViewportPtr left, ImGuiViewport* right) => left.Handle == right;

		public static bool operator !=(ImGuiViewportPtr left, ImGuiViewport* right) => left.Handle != right;

		public bool Equals(ImGuiViewportPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiViewportPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiViewportPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiViewportFlags Flags => ref Unsafe.AsRef<ImGuiViewportFlags>(&Handle->Flags);
		public ref Vector2 Pos => ref Unsafe.AsRef<Vector2>(&Handle->Pos);
		public ref Vector2 Size => ref Unsafe.AsRef<Vector2>(&Handle->Size);
		public ref Vector2 WorkPos => ref Unsafe.AsRef<Vector2>(&Handle->WorkPos);
		public ref Vector2 WorkSize => ref Unsafe.AsRef<Vector2>(&Handle->WorkSize);
		public ref float DpiScale => ref Unsafe.AsRef<float>(&Handle->DpiScale);
		public ref int ParentViewportId => ref Unsafe.AsRef<int>(&Handle->ParentViewportId);
		public ref ImDrawDataPtr DrawData => ref Unsafe.AsRef<ImDrawDataPtr>(&Handle->DrawData);
		public void* RendererUserData { get => Handle->RendererUserData; set => Handle->RendererUserData = value; }
		public void* PlatformUserData { get => Handle->PlatformUserData; set => Handle->PlatformUserData = value; }
		public void* PlatformHandle { get => Handle->PlatformHandle; set => Handle->PlatformHandle = value; }
		public void* PlatformHandleRaw { get => Handle->PlatformHandleRaw; set => Handle->PlatformHandleRaw = value; }
		public ref bool PlatformWindowCreated => ref Unsafe.AsRef<bool>(&Handle->PlatformWindowCreated);
		public ref bool PlatformRequestMove => ref Unsafe.AsRef<bool>(&Handle->PlatformRequestMove);
		public ref bool PlatformRequestResize => ref Unsafe.AsRef<bool>(&Handle->PlatformRequestResize);
		public ref bool PlatformRequestClose => ref Unsafe.AsRef<bool>(&Handle->PlatformRequestClose);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiViewportPtrPtr : IEquatable<ImGuiViewportPtrPtr>
	{
		public ImGuiViewportPtrPtr(ImGuiViewport** handle) { Handle = handle; }

		public ImGuiViewport** Handle;

		public bool IsNull => Handle == null;

		public static ImGuiViewportPtrPtr Null => new ImGuiViewportPtrPtr(null);

		public static implicit operator ImGuiViewportPtrPtr(ImGuiViewport** handle) => new ImGuiViewportPtrPtr(handle);

		public static implicit operator ImGuiViewport**(ImGuiViewportPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiViewportPtrPtr left, ImGuiViewportPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiViewportPtrPtr left, ImGuiViewportPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiViewportPtrPtr left, ImGuiViewport** right) => left.Handle == right;

		public static bool operator !=(ImGuiViewportPtrPtr left, ImGuiViewport** right) => left.Handle != right;

		public bool Equals(ImGuiViewportPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiViewportPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiViewportPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImGuiViewportPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyphRangesBuilder
	{
		public ImVectorImU32 UsedChars;


		public unsafe void AddChar(char c)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddCharNative(@this, c);
			}
		}

		public unsafe void AddRanges(char* ranges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddRangesNative(@this, ranges);
			}
		}

		public unsafe void AddRanges(ref char ranges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (char* pranges = &ranges)
				{
					ImGui.AddRangesNative(@this, (char*)pranges);
				}
			}
		}

		public unsafe void AddText(byte* text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddTextNative(@this, text, textEnd);
			}
		}

		public unsafe void AddText(byte* text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddTextNative(@this, text, (byte*)(default));
			}
		}

		public unsafe void AddText(ref byte text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.AddTextNative(@this, (byte*)ptext, textEnd);
				}
			}
		}

		public unsafe void AddText(ref byte text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.AddTextNative(@this, (byte*)ptext, (byte*)(default));
				}
			}
		}

		public unsafe void AddText(string text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(string text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(byte* text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, text, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText(byte* text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref byte text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void AddText(string text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void BuildRanges(ImVectorImWcharPtr outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.BuildRangesNative(@this, outRanges);
			}
		}

		public unsafe void BuildRanges(ref ImVectorImWchar outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (ImVectorImWchar* poutRanges = &outRanges)
				{
					ImGui.BuildRangesNative(@this, (ImVectorImWchar*)poutRanges);
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool GetBit(nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte ret = ImGui.GetBitNative(@this, n);
				return ret != 0;
			}
		}

		public unsafe void SetBit(nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.SetBitNative(@this, n);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontGlyphRangesBuilderPtr : IEquatable<ImFontGlyphRangesBuilderPtr>
	{
		public ImFontGlyphRangesBuilderPtr(ImFontGlyphRangesBuilder* handle) { Handle = handle; }

		public ImFontGlyphRangesBuilder* Handle;

		public bool IsNull => Handle == null;

		public static ImFontGlyphRangesBuilderPtr Null => new ImFontGlyphRangesBuilderPtr(null);

		public static implicit operator ImFontGlyphRangesBuilderPtr(ImFontGlyphRangesBuilder* handle) => new ImFontGlyphRangesBuilderPtr(handle);

		public static implicit operator ImFontGlyphRangesBuilder*(ImFontGlyphRangesBuilderPtr handle) => handle.Handle;

		public static bool operator ==(ImFontGlyphRangesBuilderPtr left, ImFontGlyphRangesBuilderPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontGlyphRangesBuilderPtr left, ImFontGlyphRangesBuilderPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontGlyphRangesBuilderPtr left, ImFontGlyphRangesBuilder* right) => left.Handle == right;

		public static bool operator !=(ImFontGlyphRangesBuilderPtr left, ImFontGlyphRangesBuilder* right) => left.Handle != right;

		public bool Equals(ImFontGlyphRangesBuilderPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontGlyphRangesBuilderPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontGlyphRangesBuilderPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImU32 UsedChars => ref Unsafe.AsRef<ImVectorImU32>(&Handle->UsedChars);

		public unsafe void AddChar(char c)
		{
			ImGui.AddCharNative(Handle, c);
		}

		public unsafe void AddRanges(char* ranges)
		{
			ImGui.AddRangesNative(Handle, ranges);
		}

		public unsafe void AddRanges(ref char ranges)
		{
			fixed (char* pranges = &ranges)
			{
				ImGui.AddRangesNative(Handle, (char*)pranges);
			}
		}

		public unsafe void AddText(byte* text, byte* textEnd)
		{
			ImGui.AddTextNative(Handle, text, textEnd);
		}

		public unsafe void AddText(byte* text)
		{
			ImGui.AddTextNative(Handle, text, (byte*)(default));
		}

		public unsafe void AddText(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				ImGui.AddTextNative(Handle, (byte*)ptext, textEnd);
			}
		}

		public unsafe void AddText(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				ImGui.AddTextNative(Handle, (byte*)ptext, (byte*)(default));
			}
		}

		public unsafe void AddText(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, text, (byte*)ptextEnd);
			}
		}

		public unsafe void AddText(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void BuildRanges(ImVectorImWcharPtr outRanges)
		{
			ImGui.BuildRangesNative(Handle, outRanges);
		}

		public unsafe void BuildRanges(ref ImVectorImWchar outRanges)
		{
			fixed (ImVectorImWchar* poutRanges = &outRanges)
			{
				ImGui.BuildRangesNative(Handle, (ImVectorImWchar*)poutRanges);
			}
		}

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool GetBit(nuint n)
		{
			byte ret = ImGui.GetBitNative(Handle, n);
			return ret != 0;
		}

		public unsafe void SetBit(nuint n)
		{
			ImGui.SetBitNative(Handle, n);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImU32
	{
		public int Size;
		public int Capacity;
		public unsafe uint* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImColor
	{
		public Vector4 Value;


		public unsafe void Destroy()
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void HSV(float h, float s, float v, float a)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.HSVNative(@this, h, s, v, a);
			}
		}

		public unsafe void HSV(float h, float s, float v)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.HSVNative(@this, h, s, v, (float)(1.0f));
			}
		}

		public unsafe void SetHSV(float h, float s, float v, float a)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.SetHSVNative(@this, h, s, v, a);
			}
		}

		public unsafe void SetHSV(float h, float s, float v)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.SetHSVNative(@this, h, s, v, (float)(1.0f));
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImColorPtr : IEquatable<ImColorPtr>
	{
		public ImColorPtr(ImColor* handle) { Handle = handle; }

		public ImColor* Handle;

		public bool IsNull => Handle == null;

		public static ImColorPtr Null => new ImColorPtr(null);

		public static implicit operator ImColorPtr(ImColor* handle) => new ImColorPtr(handle);

		public static implicit operator ImColor*(ImColorPtr handle) => handle.Handle;

		public static bool operator ==(ImColorPtr left, ImColorPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImColorPtr left, ImColorPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImColorPtr left, ImColor* right) => left.Handle == right;

		public static bool operator !=(ImColorPtr left, ImColor* right) => left.Handle != right;

		public bool Equals(ImColorPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImColorPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImColorPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref Vector4 Value => ref Unsafe.AsRef<Vector4>(&Handle->Value);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void HSV(float h, float s, float v, float a)
		{
			ImGui.HSVNative(Handle, h, s, v, a);
		}

		public unsafe void HSV(float h, float s, float v)
		{
			ImGui.HSVNative(Handle, h, s, v, (float)(1.0f));
		}

		public unsafe void SetHSV(float h, float s, float v, float a)
		{
			ImGui.SetHSVNative(Handle, h, s, v, a);
		}

		public unsafe void SetHSV(float h, float s, float v)
		{
			ImGui.SetHSVNative(Handle, h, s, v, (float)(1.0f));
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiContext
	{
		public byte Initialized;
		public byte FontAtlasOwnedByContext;
		public ImGuiIO IO;
		public ImGuiPlatformIO PlatformIO;
		public ImGuiStyle Style;
		public ImGuiConfigFlags ConfigFlagsCurrFrame;
		public ImGuiConfigFlags ConfigFlagsLastFrame;
		public unsafe ImFont* Font;
		public float FontSize;
		public float FontBaseSize;
		public ImDrawListSharedData DrawListSharedData;
		public double Time;
		public int FrameCount;
		public int FrameCountEnded;
		public int FrameCountPlatformEnded;
		public int FrameCountRendered;
		public byte WithinFrameScope;
		public byte WithinFrameScopeWithImplicitWindow;
		public byte WithinEndChild;
		public byte GcCompactAll;
		public byte TestEngineHookItems;
		public unsafe void* TestEngine;
		public ImVectorImGuiInputEvent InputEventsQueue;
		public ImVectorImGuiInputEvent InputEventsTrail;
		public ImGuiMouseSource InputEventsNextMouseSource;
		public uint InputEventsNextEventId;
		public ImVectorImGuiWindowPtr Windows;
		public ImVectorImGuiWindowPtr WindowsFocusOrder;
		public ImVectorImGuiWindowPtr WindowsTempSortBuffer;
		public ImVectorImGuiWindowStackData CurrentWindowStack;
		public ImGuiStorage WindowsById;
		public int WindowsActiveCount;
		public Vector2 WindowsHoverPadding;
		public unsafe ImGuiWindow* CurrentWindow;
		public unsafe ImGuiWindow* HoveredWindow;
		public unsafe ImGuiWindow* HoveredWindowUnderMovingWindow;
		public unsafe ImGuiWindow* MovingWindow;
		public unsafe ImGuiWindow* WheelingWindow;
		public Vector2 WheelingWindowRefMousePos;
		public int WheelingWindowStartFrame;
		public float WheelingWindowReleaseTimer;
		public Vector2 WheelingWindowWheelRemainder;
		public Vector2 WheelingAxisAvg;
		public int DebugHookIdInfo;
		public int HoveredId;
		public int HoveredIdPreviousFrame;
		public byte HoveredIdAllowOverlap;
		public byte HoveredIdDisabled;
		public float HoveredIdTimer;
		public float HoveredIdNotActiveTimer;
		public int ActiveId;
		public int ActiveIdIsAlive;
		public float ActiveIdTimer;
		public byte ActiveIdIsJustActivated;
		public byte ActiveIdAllowOverlap;
		public byte ActiveIdNoClearOnFocusLoss;
		public byte ActiveIdHasBeenPressedBefore;
		public byte ActiveIdHasBeenEditedBefore;
		public byte ActiveIdHasBeenEditedThisFrame;
		public Vector2 ActiveIdClickOffset;
		public unsafe ImGuiWindow* ActiveIdWindow;
		public ImGuiInputSource ActiveIdSource;
		public int ActiveIdMouseButton;
		public int ActiveIdPreviousFrame;
		public byte ActiveIdPreviousFrameIsAlive;
		public byte ActiveIdPreviousFrameHasBeenEditedBefore;
		public unsafe ImGuiWindow* ActiveIdPreviousFrameWindow;
		public int LastActiveId;
		public float LastActiveIdTimer;
		public ImGuiKeyOwnerData KeysOwnerData_0;
		public ImGuiKeyOwnerData KeysOwnerData_1;
		public ImGuiKeyOwnerData KeysOwnerData_2;
		public ImGuiKeyOwnerData KeysOwnerData_3;
		public ImGuiKeyOwnerData KeysOwnerData_4;
		public ImGuiKeyOwnerData KeysOwnerData_5;
		public ImGuiKeyOwnerData KeysOwnerData_6;
		public ImGuiKeyOwnerData KeysOwnerData_7;
		public ImGuiKeyOwnerData KeysOwnerData_8;
		public ImGuiKeyOwnerData KeysOwnerData_9;
		public ImGuiKeyOwnerData KeysOwnerData_10;
		public ImGuiKeyOwnerData KeysOwnerData_11;
		public ImGuiKeyOwnerData KeysOwnerData_12;
		public ImGuiKeyOwnerData KeysOwnerData_13;
		public ImGuiKeyOwnerData KeysOwnerData_14;
		public ImGuiKeyOwnerData KeysOwnerData_15;
		public ImGuiKeyOwnerData KeysOwnerData_16;
		public ImGuiKeyOwnerData KeysOwnerData_17;
		public ImGuiKeyOwnerData KeysOwnerData_18;
		public ImGuiKeyOwnerData KeysOwnerData_19;
		public ImGuiKeyOwnerData KeysOwnerData_20;
		public ImGuiKeyOwnerData KeysOwnerData_21;
		public ImGuiKeyOwnerData KeysOwnerData_22;
		public ImGuiKeyOwnerData KeysOwnerData_23;
		public ImGuiKeyOwnerData KeysOwnerData_24;
		public ImGuiKeyOwnerData KeysOwnerData_25;
		public ImGuiKeyOwnerData KeysOwnerData_26;
		public ImGuiKeyOwnerData KeysOwnerData_27;
		public ImGuiKeyOwnerData KeysOwnerData_28;
		public ImGuiKeyOwnerData KeysOwnerData_29;
		public ImGuiKeyOwnerData KeysOwnerData_30;
		public ImGuiKeyOwnerData KeysOwnerData_31;
		public ImGuiKeyOwnerData KeysOwnerData_32;
		public ImGuiKeyOwnerData KeysOwnerData_33;
		public ImGuiKeyOwnerData KeysOwnerData_34;
		public ImGuiKeyOwnerData KeysOwnerData_35;
		public ImGuiKeyOwnerData KeysOwnerData_36;
		public ImGuiKeyOwnerData KeysOwnerData_37;
		public ImGuiKeyOwnerData KeysOwnerData_38;
		public ImGuiKeyOwnerData KeysOwnerData_39;
		public ImGuiKeyOwnerData KeysOwnerData_40;
		public ImGuiKeyOwnerData KeysOwnerData_41;
		public ImGuiKeyOwnerData KeysOwnerData_42;
		public ImGuiKeyOwnerData KeysOwnerData_43;
		public ImGuiKeyOwnerData KeysOwnerData_44;
		public ImGuiKeyOwnerData KeysOwnerData_45;
		public ImGuiKeyOwnerData KeysOwnerData_46;
		public ImGuiKeyOwnerData KeysOwnerData_47;
		public ImGuiKeyOwnerData KeysOwnerData_48;
		public ImGuiKeyOwnerData KeysOwnerData_49;
		public ImGuiKeyOwnerData KeysOwnerData_50;
		public ImGuiKeyOwnerData KeysOwnerData_51;
		public ImGuiKeyOwnerData KeysOwnerData_52;
		public ImGuiKeyOwnerData KeysOwnerData_53;
		public ImGuiKeyOwnerData KeysOwnerData_54;
		public ImGuiKeyOwnerData KeysOwnerData_55;
		public ImGuiKeyOwnerData KeysOwnerData_56;
		public ImGuiKeyOwnerData KeysOwnerData_57;
		public ImGuiKeyOwnerData KeysOwnerData_58;
		public ImGuiKeyOwnerData KeysOwnerData_59;
		public ImGuiKeyOwnerData KeysOwnerData_60;
		public ImGuiKeyOwnerData KeysOwnerData_61;
		public ImGuiKeyOwnerData KeysOwnerData_62;
		public ImGuiKeyOwnerData KeysOwnerData_63;
		public ImGuiKeyOwnerData KeysOwnerData_64;
		public ImGuiKeyOwnerData KeysOwnerData_65;
		public ImGuiKeyOwnerData KeysOwnerData_66;
		public ImGuiKeyOwnerData KeysOwnerData_67;
		public ImGuiKeyOwnerData KeysOwnerData_68;
		public ImGuiKeyOwnerData KeysOwnerData_69;
		public ImGuiKeyOwnerData KeysOwnerData_70;
		public ImGuiKeyOwnerData KeysOwnerData_71;
		public ImGuiKeyOwnerData KeysOwnerData_72;
		public ImGuiKeyOwnerData KeysOwnerData_73;
		public ImGuiKeyOwnerData KeysOwnerData_74;
		public ImGuiKeyOwnerData KeysOwnerData_75;
		public ImGuiKeyOwnerData KeysOwnerData_76;
		public ImGuiKeyOwnerData KeysOwnerData_77;
		public ImGuiKeyOwnerData KeysOwnerData_78;
		public ImGuiKeyOwnerData KeysOwnerData_79;
		public ImGuiKeyOwnerData KeysOwnerData_80;
		public ImGuiKeyOwnerData KeysOwnerData_81;
		public ImGuiKeyOwnerData KeysOwnerData_82;
		public ImGuiKeyOwnerData KeysOwnerData_83;
		public ImGuiKeyOwnerData KeysOwnerData_84;
		public ImGuiKeyOwnerData KeysOwnerData_85;
		public ImGuiKeyOwnerData KeysOwnerData_86;
		public ImGuiKeyOwnerData KeysOwnerData_87;
		public ImGuiKeyOwnerData KeysOwnerData_88;
		public ImGuiKeyOwnerData KeysOwnerData_89;
		public ImGuiKeyOwnerData KeysOwnerData_90;
		public ImGuiKeyOwnerData KeysOwnerData_91;
		public ImGuiKeyOwnerData KeysOwnerData_92;
		public ImGuiKeyOwnerData KeysOwnerData_93;
		public ImGuiKeyOwnerData KeysOwnerData_94;
		public ImGuiKeyOwnerData KeysOwnerData_95;
		public ImGuiKeyOwnerData KeysOwnerData_96;
		public ImGuiKeyOwnerData KeysOwnerData_97;
		public ImGuiKeyOwnerData KeysOwnerData_98;
		public ImGuiKeyOwnerData KeysOwnerData_99;
		public ImGuiKeyOwnerData KeysOwnerData_100;
		public ImGuiKeyOwnerData KeysOwnerData_101;
		public ImGuiKeyOwnerData KeysOwnerData_102;
		public ImGuiKeyOwnerData KeysOwnerData_103;
		public ImGuiKeyOwnerData KeysOwnerData_104;
		public ImGuiKeyOwnerData KeysOwnerData_105;
		public ImGuiKeyOwnerData KeysOwnerData_106;
		public ImGuiKeyOwnerData KeysOwnerData_107;
		public ImGuiKeyOwnerData KeysOwnerData_108;
		public ImGuiKeyOwnerData KeysOwnerData_109;
		public ImGuiKeyOwnerData KeysOwnerData_110;
		public ImGuiKeyOwnerData KeysOwnerData_111;
		public ImGuiKeyOwnerData KeysOwnerData_112;
		public ImGuiKeyOwnerData KeysOwnerData_113;
		public ImGuiKeyOwnerData KeysOwnerData_114;
		public ImGuiKeyOwnerData KeysOwnerData_115;
		public ImGuiKeyOwnerData KeysOwnerData_116;
		public ImGuiKeyOwnerData KeysOwnerData_117;
		public ImGuiKeyOwnerData KeysOwnerData_118;
		public ImGuiKeyOwnerData KeysOwnerData_119;
		public ImGuiKeyOwnerData KeysOwnerData_120;
		public ImGuiKeyOwnerData KeysOwnerData_121;
		public ImGuiKeyOwnerData KeysOwnerData_122;
		public ImGuiKeyOwnerData KeysOwnerData_123;
		public ImGuiKeyOwnerData KeysOwnerData_124;
		public ImGuiKeyOwnerData KeysOwnerData_125;
		public ImGuiKeyOwnerData KeysOwnerData_126;
		public ImGuiKeyOwnerData KeysOwnerData_127;
		public ImGuiKeyOwnerData KeysOwnerData_128;
		public ImGuiKeyOwnerData KeysOwnerData_129;
		public ImGuiKeyOwnerData KeysOwnerData_130;
		public ImGuiKeyOwnerData KeysOwnerData_131;
		public ImGuiKeyOwnerData KeysOwnerData_132;
		public ImGuiKeyOwnerData KeysOwnerData_133;
		public ImGuiKeyOwnerData KeysOwnerData_134;
		public ImGuiKeyOwnerData KeysOwnerData_135;
		public ImGuiKeyOwnerData KeysOwnerData_136;
		public ImGuiKeyOwnerData KeysOwnerData_137;
		public ImGuiKeyOwnerData KeysOwnerData_138;
		public ImGuiKeyOwnerData KeysOwnerData_139;
		public ImGuiKeyRoutingTable KeysRoutingTable;
		public uint ActiveIdUsingNavDirMask;
		public byte ActiveIdUsingAllKeyboardKeys;
		public uint ActiveIdUsingNavInputMask;
		public int CurrentFocusScopeId;
		public ImGuiItemFlags CurrentItemFlags;
		public int DebugLocateId;
		public ImGuiNextItemData NextItemData;
		public ImGuiLastItemData LastItemData;
		public ImGuiNextWindowData NextWindowData;
		public ImVectorImGuiColorMod ColorStack;
		public ImVectorImGuiStyleMod StyleVarStack;
		public ImVectorImFontPtr FontStack;
		public ImVectorImGuiID FocusScopeStack;
		public ImVectorImGuiItemFlags ItemFlagsStack;
		public ImVectorImGuiGroupData GroupStack;
		public ImVectorImGuiPopupData OpenPopupStack;
		public ImVectorImGuiPopupData BeginPopupStack;
		public int BeginMenuCount;
		public ImVectorImGuiViewportPPtr Viewports;
		public float CurrentDpiScale;
		public unsafe ImGuiViewportP* CurrentViewport;
		public unsafe ImGuiViewportP* MouseViewport;
		public unsafe ImGuiViewportP* MouseLastHoveredViewport;
		public int PlatformLastFocusedViewportId;
		public ImGuiPlatformMonitor FallbackMonitor;
		public int ViewportCreatedCount;
		public int PlatformWindowsCreatedCount;
		public int ViewportFocusedStampCount;
		public unsafe ImGuiWindow* NavWindow;
		public int NavId;
		public int NavFocusScopeId;
		public int NavActivateId;
		public int NavActivateDownId;
		public int NavActivatePressedId;
		public ImGuiActivateFlags NavActivateFlags;
		public int NavJustMovedToId;
		public int NavJustMovedToFocusScopeId;
		public int NavJustMovedToKeyMods;
		public int NavNextActivateId;
		public ImGuiActivateFlags NavNextActivateFlags;
		public ImGuiInputSource NavInputSource;
		public ImGuiNavLayer NavLayer;
		public byte NavIdIsAlive;
		public byte NavMousePosDirty;
		public byte NavDisableHighlight;
		public byte NavDisableMouseHover;
		public byte NavAnyRequest;
		public byte NavInitRequest;
		public byte NavInitRequestFromMove;
		public ImGuiNavItemData NavInitResult;
		public byte NavMoveSubmitted;
		public byte NavMoveScoringItems;
		public byte NavMoveForwardToNextFrame;
		public ImGuiNavMoveFlags NavMoveFlags;
		public ImGuiScrollFlags NavMoveScrollFlags;
		public int NavMoveKeyMods;
		public ImGuiDir NavMoveDir;
		public ImGuiDir NavMoveDirForDebug;
		public ImGuiDir NavMoveClipDir;
		public ImRect NavScoringRect;
		public ImRect NavScoringNoClipRect;
		public int NavScoringDebugCount;
		public int NavTabbingDir;
		public int NavTabbingCounter;
		public ImGuiNavItemData NavMoveResultLocal;
		public ImGuiNavItemData NavMoveResultLocalVisible;
		public ImGuiNavItemData NavMoveResultOther;
		public ImGuiNavItemData NavTabbingResultFirst;
		public int ConfigNavWindowingKeyNext;
		public int ConfigNavWindowingKeyPrev;
		public unsafe ImGuiWindow* NavWindowingTarget;
		public unsafe ImGuiWindow* NavWindowingTargetAnim;
		public unsafe ImGuiWindow* NavWindowingListWindow;
		public float NavWindowingTimer;
		public float NavWindowingHighlightAlpha;
		public byte NavWindowingToggleLayer;
		public Vector2 NavWindowingAccumDeltaPos;
		public Vector2 NavWindowingAccumDeltaSize;
		public float DimBgRatio;
		public byte DragDropActive;
		public byte DragDropWithinSource;
		public byte DragDropWithinTarget;
		public ImGuiDragDropFlags DragDropSourceFlags;
		public int DragDropSourceFrameCount;
		public int DragDropMouseButton;
		public ImGuiPayload DragDropPayload;
		public ImRect DragDropTargetRect;
		public int DragDropTargetId;
		public ImGuiDragDropFlags DragDropAcceptFlags;
		public float DragDropAcceptIdCurrRectSurface;
		public int DragDropAcceptIdCurr;
		public int DragDropAcceptIdPrev;
		public int DragDropAcceptFrameCount;
		public int DragDropHoldJustPressedId;
		public ImVectorUnsignedChar DragDropPayloadBufHeap;
		public byte DragDropPayloadBufLocal_0;
		public byte DragDropPayloadBufLocal_1;
		public byte DragDropPayloadBufLocal_2;
		public byte DragDropPayloadBufLocal_3;
		public byte DragDropPayloadBufLocal_4;
		public byte DragDropPayloadBufLocal_5;
		public byte DragDropPayloadBufLocal_6;
		public byte DragDropPayloadBufLocal_7;
		public byte DragDropPayloadBufLocal_8;
		public byte DragDropPayloadBufLocal_9;
		public byte DragDropPayloadBufLocal_10;
		public byte DragDropPayloadBufLocal_11;
		public byte DragDropPayloadBufLocal_12;
		public byte DragDropPayloadBufLocal_13;
		public byte DragDropPayloadBufLocal_14;
		public byte DragDropPayloadBufLocal_15;
		public int ClipperTempDataStacked;
		public ImVectorImGuiListClipperData ClipperTempData;
		public unsafe ImGuiTable* CurrentTable;
		public int TablesTempDataStacked;
		public ImVectorImGuiTableTempData TablesTempData;
		public ImPoolImGuiTable Tables;
		public ImVectorFloat TablesLastTimeActive;
		public ImVectorImDrawChannel DrawChannelsTempMergeBuffer;
		public unsafe ImGuiTabBar* CurrentTabBar;
		public ImPoolImGuiTabBar TabBars;
		public ImVectorImGuiPtrOrIndex CurrentTabBarStack;
		public ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer;
		public int HoverItemDelayId;
		public int HoverItemDelayIdPreviousFrame;
		public float HoverItemDelayTimer;
		public float HoverItemDelayClearTimer;
		public int HoverItemUnlockedStationaryId;
		public int HoverWindowUnlockedStationaryId;
		public ImGuiMouseCursor MouseCursor;
		public float MouseStationaryTimer;
		public Vector2 MouseLastValidPos;
		public ImGuiInputTextState InputTextState;
		public ImGuiInputTextDeactivatedState InputTextDeactivatedState;
		public ImFont InputTextPasswordFont;
		public int TempInputId;
		public ImGuiColorEditFlags ColorEditOptions;
		public int ColorEditCurrentID;
		public int ColorEditSavedID;
		public float ColorEditSavedHue;
		public float ColorEditSavedSat;
		public uint ColorEditSavedColor;
		public Vector4 ColorPickerRef;
		public ImGuiComboPreviewData ComboPreviewData;
		public float SliderGrabClickOffset;
		public float SliderCurrentAccum;
		public byte SliderCurrentAccumDirty;
		public byte DragCurrentAccumDirty;
		public float DragCurrentAccum;
		public float DragSpeedDefaultRatio;
		public float ScrollbarClickDeltaToGrabCenter;
		public float DisabledAlphaBackup;
		public short DisabledStackSize;
		public short TooltipOverrideCount;
		public ImVectorChar ClipboardHandlerData;
		public ImVectorImGuiID MenusIdSubmittedThisFrame;
		public ImGuiPlatformImeData PlatformImeData;
		public ImGuiPlatformImeData PlatformImeDataPrev;
		public int PlatformImeViewport;
		public byte PlatformLocaleDecimalPoint;
		public ImGuiDockContext DockContext;
		public unsafe void* DockNodeWindowMenuHandler;
		public byte SettingsLoaded;
		public float SettingsDirtyTimer;
		public ImGuiTextBuffer SettingsIniData;
		public ImVectorImGuiSettingsHandler SettingsHandlers;
		public ImChunkStreamImGuiWindowSettings SettingsWindows;
		public ImChunkStreamImGuiTableSettings SettingsTables;
		public ImVectorImGuiContextHook Hooks;
		public int HookIdNext;
		public unsafe byte* LocalizationTable_0;
		public unsafe byte* LocalizationTable_1;
		public unsafe byte* LocalizationTable_2;
		public unsafe byte* LocalizationTable_3;
		public unsafe byte* LocalizationTable_4;
		public unsafe byte* LocalizationTable_5;
		public unsafe byte* LocalizationTable_6;
		public unsafe byte* LocalizationTable_7;
		public unsafe byte* LocalizationTable_8;
		public byte LogEnabled;
		public ImGuiLogType LogType;
		public ImFileHandle LogFile;
		public ImGuiTextBuffer LogBuffer;
		public unsafe byte* LogNextPrefix;
		public unsafe byte* LogNextSuffix;
		public float LogLinePosY;
		public byte LogLineFirstItem;
		public int LogDepthRef;
		public int LogDepthToExpand;
		public int LogDepthToExpandDefault;
		public ImGuiDebugLogFlags DebugLogFlags;
		public ImGuiTextBuffer DebugLogBuf;
		public ImGuiTextIndex DebugLogIndex;
		public byte DebugLogClipperAutoDisableFrames;
		public byte DebugLocateFrames;
		public sbyte DebugBeginReturnValueCullDepth;
		public byte DebugItemPickerActive;
		public byte DebugItemPickerMouseButton;
		public int DebugItemPickerBreakId;
		public ImGuiMetricsConfig DebugMetricsConfig;
		public ImGuiStackTool DebugStackTool;
		public unsafe ImGuiDockNode* DebugHoveredDockNode;
		public float FramerateSecPerFrame_0;
		public float FramerateSecPerFrame_1;
		public float FramerateSecPerFrame_2;
		public float FramerateSecPerFrame_3;
		public float FramerateSecPerFrame_4;
		public float FramerateSecPerFrame_5;
		public float FramerateSecPerFrame_6;
		public float FramerateSecPerFrame_7;
		public float FramerateSecPerFrame_8;
		public float FramerateSecPerFrame_9;
		public float FramerateSecPerFrame_10;
		public float FramerateSecPerFrame_11;
		public float FramerateSecPerFrame_12;
		public float FramerateSecPerFrame_13;
		public float FramerateSecPerFrame_14;
		public float FramerateSecPerFrame_15;
		public float FramerateSecPerFrame_16;
		public float FramerateSecPerFrame_17;
		public float FramerateSecPerFrame_18;
		public float FramerateSecPerFrame_19;
		public float FramerateSecPerFrame_20;
		public float FramerateSecPerFrame_21;
		public float FramerateSecPerFrame_22;
		public float FramerateSecPerFrame_23;
		public float FramerateSecPerFrame_24;
		public float FramerateSecPerFrame_25;
		public float FramerateSecPerFrame_26;
		public float FramerateSecPerFrame_27;
		public float FramerateSecPerFrame_28;
		public float FramerateSecPerFrame_29;
		public float FramerateSecPerFrame_30;
		public float FramerateSecPerFrame_31;
		public float FramerateSecPerFrame_32;
		public float FramerateSecPerFrame_33;
		public float FramerateSecPerFrame_34;
		public float FramerateSecPerFrame_35;
		public float FramerateSecPerFrame_36;
		public float FramerateSecPerFrame_37;
		public float FramerateSecPerFrame_38;
		public float FramerateSecPerFrame_39;
		public float FramerateSecPerFrame_40;
		public float FramerateSecPerFrame_41;
		public float FramerateSecPerFrame_42;
		public float FramerateSecPerFrame_43;
		public float FramerateSecPerFrame_44;
		public float FramerateSecPerFrame_45;
		public float FramerateSecPerFrame_46;
		public float FramerateSecPerFrame_47;
		public float FramerateSecPerFrame_48;
		public float FramerateSecPerFrame_49;
		public float FramerateSecPerFrame_50;
		public float FramerateSecPerFrame_51;
		public float FramerateSecPerFrame_52;
		public float FramerateSecPerFrame_53;
		public float FramerateSecPerFrame_54;
		public float FramerateSecPerFrame_55;
		public float FramerateSecPerFrame_56;
		public float FramerateSecPerFrame_57;
		public float FramerateSecPerFrame_58;
		public float FramerateSecPerFrame_59;
		public int FramerateSecPerFrameIdx;
		public int FramerateSecPerFrameCount;
		public float FramerateSecPerFrameAccum;
		public int WantCaptureMouseNextFrame;
		public int WantCaptureKeyboardNextFrame;
		public int WantTextInputNextFrame;
		public ImVectorChar TempBuffer;

		public unsafe Span<ImGuiKeyOwnerData> KeysOwnerData
		
		{
			get
			{
				fixed (ImGuiKeyOwnerData* p = &this.KeysOwnerData_0)
				{
					return new Span<ImGuiKeyOwnerData>(p, 140);
				}
			}
		}
	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiContextPtr : IEquatable<ImGuiContextPtr>
	{
		public ImGuiContextPtr(ImGuiContext* handle) { Handle = handle; }

		public ImGuiContext* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiContextPtr Null => new ImGuiContextPtr(null);

		public static implicit operator ImGuiContextPtr(ImGuiContext* handle) => new ImGuiContextPtr(handle);

		public static implicit operator ImGuiContext*(ImGuiContextPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiContextPtr left, ImGuiContextPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiContextPtr left, ImGuiContextPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiContextPtr left, ImGuiContext* right) => left.Handle == right;

		public static bool operator !=(ImGuiContextPtr left, ImGuiContext* right) => left.Handle != right;

		public bool Equals(ImGuiContextPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiContextPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiContextPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref bool Initialized => ref Unsafe.AsRef<bool>(&Handle->Initialized);
		public ref bool FontAtlasOwnedByContext => ref Unsafe.AsRef<bool>(&Handle->FontAtlasOwnedByContext);
		public ref ImGuiIO IO => ref Unsafe.AsRef<ImGuiIO>(&Handle->IO);
		public ref ImGuiPlatformIO PlatformIO => ref Unsafe.AsRef<ImGuiPlatformIO>(&Handle->PlatformIO);
		public ref ImGuiStyle Style => ref Unsafe.AsRef<ImGuiStyle>(&Handle->Style);
		public ref ImGuiConfigFlags ConfigFlagsCurrFrame => ref Unsafe.AsRef<ImGuiConfigFlags>(&Handle->ConfigFlagsCurrFrame);
		public ref ImGuiConfigFlags ConfigFlagsLastFrame => ref Unsafe.AsRef<ImGuiConfigFlags>(&Handle->ConfigFlagsLastFrame);
		public ref ImFontPtr Font => ref Unsafe.AsRef<ImFontPtr>(&Handle->Font);
		public ref float FontSize => ref Unsafe.AsRef<float>(&Handle->FontSize);
		public ref float FontBaseSize => ref Unsafe.AsRef<float>(&Handle->FontBaseSize);
		public ref ImDrawListSharedData DrawListSharedData => ref Unsafe.AsRef<ImDrawListSharedData>(&Handle->DrawListSharedData);
		public ref double Time => ref Unsafe.AsRef<double>(&Handle->Time);
		public ref int FrameCount => ref Unsafe.AsRef<int>(&Handle->FrameCount);
		public ref int FrameCountEnded => ref Unsafe.AsRef<int>(&Handle->FrameCountEnded);
		public ref int FrameCountPlatformEnded => ref Unsafe.AsRef<int>(&Handle->FrameCountPlatformEnded);
		public ref int FrameCountRendered => ref Unsafe.AsRef<int>(&Handle->FrameCountRendered);
		public ref bool WithinFrameScope => ref Unsafe.AsRef<bool>(&Handle->WithinFrameScope);
		public ref bool WithinFrameScopeWithImplicitWindow => ref Unsafe.AsRef<bool>(&Handle->WithinFrameScopeWithImplicitWindow);
		public ref bool WithinEndChild => ref Unsafe.AsRef<bool>(&Handle->WithinEndChild);
		public ref bool GcCompactAll => ref Unsafe.AsRef<bool>(&Handle->GcCompactAll);
		public ref bool TestEngineHookItems => ref Unsafe.AsRef<bool>(&Handle->TestEngineHookItems);
		public void* TestEngine { get => Handle->TestEngine; set => Handle->TestEngine = value; }
		public ref ImVectorImGuiInputEvent InputEventsQueue => ref Unsafe.AsRef<ImVectorImGuiInputEvent>(&Handle->InputEventsQueue);
		public ref ImVectorImGuiInputEvent InputEventsTrail => ref Unsafe.AsRef<ImVectorImGuiInputEvent>(&Handle->InputEventsTrail);
		public ref ImGuiMouseSource InputEventsNextMouseSource => ref Unsafe.AsRef<ImGuiMouseSource>(&Handle->InputEventsNextMouseSource);
		public ref uint InputEventsNextEventId => ref Unsafe.AsRef<uint>(&Handle->InputEventsNextEventId);
		public ref ImVectorImGuiWindowPtr Windows => ref Unsafe.AsRef<ImVectorImGuiWindowPtr>(&Handle->Windows);
		public ref ImVectorImGuiWindowPtr WindowsFocusOrder => ref Unsafe.AsRef<ImVectorImGuiWindowPtr>(&Handle->WindowsFocusOrder);
		public ref ImVectorImGuiWindowPtr WindowsTempSortBuffer => ref Unsafe.AsRef<ImVectorImGuiWindowPtr>(&Handle->WindowsTempSortBuffer);
		public ref ImVectorImGuiWindowStackData CurrentWindowStack => ref Unsafe.AsRef<ImVectorImGuiWindowStackData>(&Handle->CurrentWindowStack);
		public ref ImGuiStorage WindowsById => ref Unsafe.AsRef<ImGuiStorage>(&Handle->WindowsById);
		public ref int WindowsActiveCount => ref Unsafe.AsRef<int>(&Handle->WindowsActiveCount);
		public ref Vector2 WindowsHoverPadding => ref Unsafe.AsRef<Vector2>(&Handle->WindowsHoverPadding);
		public ref ImGuiWindowPtr CurrentWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->CurrentWindow);
		public ref ImGuiWindowPtr HoveredWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->HoveredWindow);
		public ref ImGuiWindowPtr HoveredWindowUnderMovingWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->HoveredWindowUnderMovingWindow);
		public ref ImGuiWindowPtr MovingWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->MovingWindow);
		public ref ImGuiWindowPtr WheelingWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->WheelingWindow);
		public ref Vector2 WheelingWindowRefMousePos => ref Unsafe.AsRef<Vector2>(&Handle->WheelingWindowRefMousePos);
		public ref int WheelingWindowStartFrame => ref Unsafe.AsRef<int>(&Handle->WheelingWindowStartFrame);
		public ref float WheelingWindowReleaseTimer => ref Unsafe.AsRef<float>(&Handle->WheelingWindowReleaseTimer);
		public ref Vector2 WheelingWindowWheelRemainder => ref Unsafe.AsRef<Vector2>(&Handle->WheelingWindowWheelRemainder);
		public ref Vector2 WheelingAxisAvg => ref Unsafe.AsRef<Vector2>(&Handle->WheelingAxisAvg);
		public ref int DebugHookIdInfo => ref Unsafe.AsRef<int>(&Handle->DebugHookIdInfo);
		public ref int HoveredId => ref Unsafe.AsRef<int>(&Handle->HoveredId);
		public ref int HoveredIdPreviousFrame => ref Unsafe.AsRef<int>(&Handle->HoveredIdPreviousFrame);
		public ref bool HoveredIdAllowOverlap => ref Unsafe.AsRef<bool>(&Handle->HoveredIdAllowOverlap);
		public ref bool HoveredIdDisabled => ref Unsafe.AsRef<bool>(&Handle->HoveredIdDisabled);
		public ref float HoveredIdTimer => ref Unsafe.AsRef<float>(&Handle->HoveredIdTimer);
		public ref float HoveredIdNotActiveTimer => ref Unsafe.AsRef<float>(&Handle->HoveredIdNotActiveTimer);
		public ref int ActiveId => ref Unsafe.AsRef<int>(&Handle->ActiveId);
		public ref int ActiveIdIsAlive => ref Unsafe.AsRef<int>(&Handle->ActiveIdIsAlive);
		public ref float ActiveIdTimer => ref Unsafe.AsRef<float>(&Handle->ActiveIdTimer);
		public ref bool ActiveIdIsJustActivated => ref Unsafe.AsRef<bool>(&Handle->ActiveIdIsJustActivated);
		public ref bool ActiveIdAllowOverlap => ref Unsafe.AsRef<bool>(&Handle->ActiveIdAllowOverlap);
		public ref bool ActiveIdNoClearOnFocusLoss => ref Unsafe.AsRef<bool>(&Handle->ActiveIdNoClearOnFocusLoss);
		public ref bool ActiveIdHasBeenPressedBefore => ref Unsafe.AsRef<bool>(&Handle->ActiveIdHasBeenPressedBefore);
		public ref bool ActiveIdHasBeenEditedBefore => ref Unsafe.AsRef<bool>(&Handle->ActiveIdHasBeenEditedBefore);
		public ref bool ActiveIdHasBeenEditedThisFrame => ref Unsafe.AsRef<bool>(&Handle->ActiveIdHasBeenEditedThisFrame);
		public ref Vector2 ActiveIdClickOffset => ref Unsafe.AsRef<Vector2>(&Handle->ActiveIdClickOffset);
		public ref ImGuiWindowPtr ActiveIdWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->ActiveIdWindow);
		public ref ImGuiInputSource ActiveIdSource => ref Unsafe.AsRef<ImGuiInputSource>(&Handle->ActiveIdSource);
		public ref int ActiveIdMouseButton => ref Unsafe.AsRef<int>(&Handle->ActiveIdMouseButton);
		public ref int ActiveIdPreviousFrame => ref Unsafe.AsRef<int>(&Handle->ActiveIdPreviousFrame);
		public ref bool ActiveIdPreviousFrameIsAlive => ref Unsafe.AsRef<bool>(&Handle->ActiveIdPreviousFrameIsAlive);
		public ref bool ActiveIdPreviousFrameHasBeenEditedBefore => ref Unsafe.AsRef<bool>(&Handle->ActiveIdPreviousFrameHasBeenEditedBefore);
		public ref ImGuiWindowPtr ActiveIdPreviousFrameWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->ActiveIdPreviousFrameWindow);
		public ref int LastActiveId => ref Unsafe.AsRef<int>(&Handle->LastActiveId);
		public ref float LastActiveIdTimer => ref Unsafe.AsRef<float>(&Handle->LastActiveIdTimer);
		public unsafe Span<ImGuiKeyOwnerData> KeysOwnerData
		
		{
			get
			{
				return new Span<ImGuiKeyOwnerData>(&Handle->KeysOwnerData_0, 140);
			}
		}
		public ref ImGuiKeyRoutingTable KeysRoutingTable => ref Unsafe.AsRef<ImGuiKeyRoutingTable>(&Handle->KeysRoutingTable);
		public ref uint ActiveIdUsingNavDirMask => ref Unsafe.AsRef<uint>(&Handle->ActiveIdUsingNavDirMask);
		public ref bool ActiveIdUsingAllKeyboardKeys => ref Unsafe.AsRef<bool>(&Handle->ActiveIdUsingAllKeyboardKeys);
		public ref uint ActiveIdUsingNavInputMask => ref Unsafe.AsRef<uint>(&Handle->ActiveIdUsingNavInputMask);
		public ref int CurrentFocusScopeId => ref Unsafe.AsRef<int>(&Handle->CurrentFocusScopeId);
		public ref ImGuiItemFlags CurrentItemFlags => ref Unsafe.AsRef<ImGuiItemFlags>(&Handle->CurrentItemFlags);
		public ref int DebugLocateId => ref Unsafe.AsRef<int>(&Handle->DebugLocateId);
		public ref ImGuiNextItemData NextItemData => ref Unsafe.AsRef<ImGuiNextItemData>(&Handle->NextItemData);
		public ref ImGuiLastItemData LastItemData => ref Unsafe.AsRef<ImGuiLastItemData>(&Handle->LastItemData);
		public ref ImGuiNextWindowData NextWindowData => ref Unsafe.AsRef<ImGuiNextWindowData>(&Handle->NextWindowData);
		public ref ImVectorImGuiColorMod ColorStack => ref Unsafe.AsRef<ImVectorImGuiColorMod>(&Handle->ColorStack);
		public ref ImVectorImGuiStyleMod StyleVarStack => ref Unsafe.AsRef<ImVectorImGuiStyleMod>(&Handle->StyleVarStack);
		public ref ImVectorImFontPtr FontStack => ref Unsafe.AsRef<ImVectorImFontPtr>(&Handle->FontStack);
		public ref ImVectorImGuiID FocusScopeStack => ref Unsafe.AsRef<ImVectorImGuiID>(&Handle->FocusScopeStack);
		public ref ImVectorImGuiItemFlags ItemFlagsStack => ref Unsafe.AsRef<ImVectorImGuiItemFlags>(&Handle->ItemFlagsStack);
		public ref ImVectorImGuiGroupData GroupStack => ref Unsafe.AsRef<ImVectorImGuiGroupData>(&Handle->GroupStack);
		public ref ImVectorImGuiPopupData OpenPopupStack => ref Unsafe.AsRef<ImVectorImGuiPopupData>(&Handle->OpenPopupStack);
		public ref ImVectorImGuiPopupData BeginPopupStack => ref Unsafe.AsRef<ImVectorImGuiPopupData>(&Handle->BeginPopupStack);
		public ref int BeginMenuCount => ref Unsafe.AsRef<int>(&Handle->BeginMenuCount);
		public ref ImVectorImGuiViewportPPtr Viewports => ref Unsafe.AsRef<ImVectorImGuiViewportPPtr>(&Handle->Viewports);
		public ref float CurrentDpiScale => ref Unsafe.AsRef<float>(&Handle->CurrentDpiScale);
		public ref ImGuiViewportPPtr CurrentViewport => ref Unsafe.AsRef<ImGuiViewportPPtr>(&Handle->CurrentViewport);
		public ref ImGuiViewportPPtr MouseViewport => ref Unsafe.AsRef<ImGuiViewportPPtr>(&Handle->MouseViewport);
		public ref ImGuiViewportPPtr MouseLastHoveredViewport => ref Unsafe.AsRef<ImGuiViewportPPtr>(&Handle->MouseLastHoveredViewport);
		public ref int PlatformLastFocusedViewportId => ref Unsafe.AsRef<int>(&Handle->PlatformLastFocusedViewportId);
		public ref ImGuiPlatformMonitor FallbackMonitor => ref Unsafe.AsRef<ImGuiPlatformMonitor>(&Handle->FallbackMonitor);
		public ref int ViewportCreatedCount => ref Unsafe.AsRef<int>(&Handle->ViewportCreatedCount);
		public ref int PlatformWindowsCreatedCount => ref Unsafe.AsRef<int>(&Handle->PlatformWindowsCreatedCount);
		public ref int ViewportFocusedStampCount => ref Unsafe.AsRef<int>(&Handle->ViewportFocusedStampCount);
		public ref ImGuiWindowPtr NavWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavWindow);
		public ref int NavId => ref Unsafe.AsRef<int>(&Handle->NavId);
		public ref int NavFocusScopeId => ref Unsafe.AsRef<int>(&Handle->NavFocusScopeId);
		public ref int NavActivateId => ref Unsafe.AsRef<int>(&Handle->NavActivateId);
		public ref int NavActivateDownId => ref Unsafe.AsRef<int>(&Handle->NavActivateDownId);
		public ref int NavActivatePressedId => ref Unsafe.AsRef<int>(&Handle->NavActivatePressedId);
		public ref ImGuiActivateFlags NavActivateFlags => ref Unsafe.AsRef<ImGuiActivateFlags>(&Handle->NavActivateFlags);
		public ref int NavJustMovedToId => ref Unsafe.AsRef<int>(&Handle->NavJustMovedToId);
		public ref int NavJustMovedToFocusScopeId => ref Unsafe.AsRef<int>(&Handle->NavJustMovedToFocusScopeId);
		public ref int NavJustMovedToKeyMods => ref Unsafe.AsRef<int>(&Handle->NavJustMovedToKeyMods);
		public ref int NavNextActivateId => ref Unsafe.AsRef<int>(&Handle->NavNextActivateId);
		public ref ImGuiActivateFlags NavNextActivateFlags => ref Unsafe.AsRef<ImGuiActivateFlags>(&Handle->NavNextActivateFlags);
		public ref ImGuiInputSource NavInputSource => ref Unsafe.AsRef<ImGuiInputSource>(&Handle->NavInputSource);
		public ref ImGuiNavLayer NavLayer => ref Unsafe.AsRef<ImGuiNavLayer>(&Handle->NavLayer);
		public ref bool NavIdIsAlive => ref Unsafe.AsRef<bool>(&Handle->NavIdIsAlive);
		public ref bool NavMousePosDirty => ref Unsafe.AsRef<bool>(&Handle->NavMousePosDirty);
		public ref bool NavDisableHighlight => ref Unsafe.AsRef<bool>(&Handle->NavDisableHighlight);
		public ref bool NavDisableMouseHover => ref Unsafe.AsRef<bool>(&Handle->NavDisableMouseHover);
		public ref bool NavAnyRequest => ref Unsafe.AsRef<bool>(&Handle->NavAnyRequest);
		public ref bool NavInitRequest => ref Unsafe.AsRef<bool>(&Handle->NavInitRequest);
		public ref bool NavInitRequestFromMove => ref Unsafe.AsRef<bool>(&Handle->NavInitRequestFromMove);
		public ref ImGuiNavItemData NavInitResult => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavInitResult);
		public ref bool NavMoveSubmitted => ref Unsafe.AsRef<bool>(&Handle->NavMoveSubmitted);
		public ref bool NavMoveScoringItems => ref Unsafe.AsRef<bool>(&Handle->NavMoveScoringItems);
		public ref bool NavMoveForwardToNextFrame => ref Unsafe.AsRef<bool>(&Handle->NavMoveForwardToNextFrame);
		public ref ImGuiNavMoveFlags NavMoveFlags => ref Unsafe.AsRef<ImGuiNavMoveFlags>(&Handle->NavMoveFlags);
		public ref ImGuiScrollFlags NavMoveScrollFlags => ref Unsafe.AsRef<ImGuiScrollFlags>(&Handle->NavMoveScrollFlags);
		public ref int NavMoveKeyMods => ref Unsafe.AsRef<int>(&Handle->NavMoveKeyMods);
		public ref ImGuiDir NavMoveDir => ref Unsafe.AsRef<ImGuiDir>(&Handle->NavMoveDir);
		public ref ImGuiDir NavMoveDirForDebug => ref Unsafe.AsRef<ImGuiDir>(&Handle->NavMoveDirForDebug);
		public ref ImGuiDir NavMoveClipDir => ref Unsafe.AsRef<ImGuiDir>(&Handle->NavMoveClipDir);
		public ref ImRect NavScoringRect => ref Unsafe.AsRef<ImRect>(&Handle->NavScoringRect);
		public ref ImRect NavScoringNoClipRect => ref Unsafe.AsRef<ImRect>(&Handle->NavScoringNoClipRect);
		public ref int NavScoringDebugCount => ref Unsafe.AsRef<int>(&Handle->NavScoringDebugCount);
		public ref int NavTabbingDir => ref Unsafe.AsRef<int>(&Handle->NavTabbingDir);
		public ref int NavTabbingCounter => ref Unsafe.AsRef<int>(&Handle->NavTabbingCounter);
		public ref ImGuiNavItemData NavMoveResultLocal => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavMoveResultLocal);
		public ref ImGuiNavItemData NavMoveResultLocalVisible => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavMoveResultLocalVisible);
		public ref ImGuiNavItemData NavMoveResultOther => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavMoveResultOther);
		public ref ImGuiNavItemData NavTabbingResultFirst => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavTabbingResultFirst);
		public ref int ConfigNavWindowingKeyNext => ref Unsafe.AsRef<int>(&Handle->ConfigNavWindowingKeyNext);
		public ref int ConfigNavWindowingKeyPrev => ref Unsafe.AsRef<int>(&Handle->ConfigNavWindowingKeyPrev);
		public ref ImGuiWindowPtr NavWindowingTarget => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavWindowingTarget);
		public ref ImGuiWindowPtr NavWindowingTargetAnim => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavWindowingTargetAnim);
		public ref ImGuiWindowPtr NavWindowingListWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavWindowingListWindow);
		public ref float NavWindowingTimer => ref Unsafe.AsRef<float>(&Handle->NavWindowingTimer);
		public ref float NavWindowingHighlightAlpha => ref Unsafe.AsRef<float>(&Handle->NavWindowingHighlightAlpha);
		public ref bool NavWindowingToggleLayer => ref Unsafe.AsRef<bool>(&Handle->NavWindowingToggleLayer);
		public ref Vector2 NavWindowingAccumDeltaPos => ref Unsafe.AsRef<Vector2>(&Handle->NavWindowingAccumDeltaPos);
		public ref Vector2 NavWindowingAccumDeltaSize => ref Unsafe.AsRef<Vector2>(&Handle->NavWindowingAccumDeltaSize);
		public ref float DimBgRatio => ref Unsafe.AsRef<float>(&Handle->DimBgRatio);
		public ref bool DragDropActive => ref Unsafe.AsRef<bool>(&Handle->DragDropActive);
		public ref bool DragDropWithinSource => ref Unsafe.AsRef<bool>(&Handle->DragDropWithinSource);
		public ref bool DragDropWithinTarget => ref Unsafe.AsRef<bool>(&Handle->DragDropWithinTarget);
		public ref ImGuiDragDropFlags DragDropSourceFlags => ref Unsafe.AsRef<ImGuiDragDropFlags>(&Handle->DragDropSourceFlags);
		public ref int DragDropSourceFrameCount => ref Unsafe.AsRef<int>(&Handle->DragDropSourceFrameCount);
		public ref int DragDropMouseButton => ref Unsafe.AsRef<int>(&Handle->DragDropMouseButton);
		public ref ImGuiPayload DragDropPayload => ref Unsafe.AsRef<ImGuiPayload>(&Handle->DragDropPayload);
		public ref ImRect DragDropTargetRect => ref Unsafe.AsRef<ImRect>(&Handle->DragDropTargetRect);
		public ref int DragDropTargetId => ref Unsafe.AsRef<int>(&Handle->DragDropTargetId);
		public ref ImGuiDragDropFlags DragDropAcceptFlags => ref Unsafe.AsRef<ImGuiDragDropFlags>(&Handle->DragDropAcceptFlags);
		public ref float DragDropAcceptIdCurrRectSurface => ref Unsafe.AsRef<float>(&Handle->DragDropAcceptIdCurrRectSurface);
		public ref int DragDropAcceptIdCurr => ref Unsafe.AsRef<int>(&Handle->DragDropAcceptIdCurr);
		public ref int DragDropAcceptIdPrev => ref Unsafe.AsRef<int>(&Handle->DragDropAcceptIdPrev);
		public ref int DragDropAcceptFrameCount => ref Unsafe.AsRef<int>(&Handle->DragDropAcceptFrameCount);
		public ref int DragDropHoldJustPressedId => ref Unsafe.AsRef<int>(&Handle->DragDropHoldJustPressedId);
		public ref ImVectorUnsignedChar DragDropPayloadBufHeap => ref Unsafe.AsRef<ImVectorUnsignedChar>(&Handle->DragDropPayloadBufHeap);
		public unsafe Span<byte> DragDropPayloadBufLocal
		
		{
			get
			{
				return new Span<byte>(&Handle->DragDropPayloadBufLocal_0, 16);
			}
		}
		public ref int ClipperTempDataStacked => ref Unsafe.AsRef<int>(&Handle->ClipperTempDataStacked);
		public ref ImVectorImGuiListClipperData ClipperTempData => ref Unsafe.AsRef<ImVectorImGuiListClipperData>(&Handle->ClipperTempData);
		public ref ImGuiTablePtr CurrentTable => ref Unsafe.AsRef<ImGuiTablePtr>(&Handle->CurrentTable);
		public ref int TablesTempDataStacked => ref Unsafe.AsRef<int>(&Handle->TablesTempDataStacked);
		public ref ImVectorImGuiTableTempData TablesTempData => ref Unsafe.AsRef<ImVectorImGuiTableTempData>(&Handle->TablesTempData);
		public ref ImPoolImGuiTable Tables => ref Unsafe.AsRef<ImPoolImGuiTable>(&Handle->Tables);
		public ref ImVectorFloat TablesLastTimeActive => ref Unsafe.AsRef<ImVectorFloat>(&Handle->TablesLastTimeActive);
		public ref ImVectorImDrawChannel DrawChannelsTempMergeBuffer => ref Unsafe.AsRef<ImVectorImDrawChannel>(&Handle->DrawChannelsTempMergeBuffer);
		public ref ImGuiTabBarPtr CurrentTabBar => ref Unsafe.AsRef<ImGuiTabBarPtr>(&Handle->CurrentTabBar);
		public ref ImPoolImGuiTabBar TabBars => ref Unsafe.AsRef<ImPoolImGuiTabBar>(&Handle->TabBars);
		public ref ImVectorImGuiPtrOrIndex CurrentTabBarStack => ref Unsafe.AsRef<ImVectorImGuiPtrOrIndex>(&Handle->CurrentTabBarStack);
		public ref ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer => ref Unsafe.AsRef<ImVectorImGuiShrinkWidthItem>(&Handle->ShrinkWidthBuffer);
		public ref int HoverItemDelayId => ref Unsafe.AsRef<int>(&Handle->HoverItemDelayId);
		public ref int HoverItemDelayIdPreviousFrame => ref Unsafe.AsRef<int>(&Handle->HoverItemDelayIdPreviousFrame);
		public ref float HoverItemDelayTimer => ref Unsafe.AsRef<float>(&Handle->HoverItemDelayTimer);
		public ref float HoverItemDelayClearTimer => ref Unsafe.AsRef<float>(&Handle->HoverItemDelayClearTimer);
		public ref int HoverItemUnlockedStationaryId => ref Unsafe.AsRef<int>(&Handle->HoverItemUnlockedStationaryId);
		public ref int HoverWindowUnlockedStationaryId => ref Unsafe.AsRef<int>(&Handle->HoverWindowUnlockedStationaryId);
		public ref ImGuiMouseCursor MouseCursor => ref Unsafe.AsRef<ImGuiMouseCursor>(&Handle->MouseCursor);
		public ref float MouseStationaryTimer => ref Unsafe.AsRef<float>(&Handle->MouseStationaryTimer);
		public ref Vector2 MouseLastValidPos => ref Unsafe.AsRef<Vector2>(&Handle->MouseLastValidPos);
		public ref ImGuiInputTextState InputTextState => ref Unsafe.AsRef<ImGuiInputTextState>(&Handle->InputTextState);
		public ref ImGuiInputTextDeactivatedState InputTextDeactivatedState => ref Unsafe.AsRef<ImGuiInputTextDeactivatedState>(&Handle->InputTextDeactivatedState);
		public ref ImFont InputTextPasswordFont => ref Unsafe.AsRef<ImFont>(&Handle->InputTextPasswordFont);
		public ref int TempInputId => ref Unsafe.AsRef<int>(&Handle->TempInputId);
		public ref ImGuiColorEditFlags ColorEditOptions => ref Unsafe.AsRef<ImGuiColorEditFlags>(&Handle->ColorEditOptions);
		public ref int ColorEditCurrentID => ref Unsafe.AsRef<int>(&Handle->ColorEditCurrentID);
		public ref int ColorEditSavedID => ref Unsafe.AsRef<int>(&Handle->ColorEditSavedID);
		public ref float ColorEditSavedHue => ref Unsafe.AsRef<float>(&Handle->ColorEditSavedHue);
		public ref float ColorEditSavedSat => ref Unsafe.AsRef<float>(&Handle->ColorEditSavedSat);
		public ref uint ColorEditSavedColor => ref Unsafe.AsRef<uint>(&Handle->ColorEditSavedColor);
		public ref Vector4 ColorPickerRef => ref Unsafe.AsRef<Vector4>(&Handle->ColorPickerRef);
		public ref ImGuiComboPreviewData ComboPreviewData => ref Unsafe.AsRef<ImGuiComboPreviewData>(&Handle->ComboPreviewData);
		public ref float SliderGrabClickOffset => ref Unsafe.AsRef<float>(&Handle->SliderGrabClickOffset);
		public ref float SliderCurrentAccum => ref Unsafe.AsRef<float>(&Handle->SliderCurrentAccum);
		public ref bool SliderCurrentAccumDirty => ref Unsafe.AsRef<bool>(&Handle->SliderCurrentAccumDirty);
		public ref bool DragCurrentAccumDirty => ref Unsafe.AsRef<bool>(&Handle->DragCurrentAccumDirty);
		public ref float DragCurrentAccum => ref Unsafe.AsRef<float>(&Handle->DragCurrentAccum);
		public ref float DragSpeedDefaultRatio => ref Unsafe.AsRef<float>(&Handle->DragSpeedDefaultRatio);
		public ref float ScrollbarClickDeltaToGrabCenter => ref Unsafe.AsRef<float>(&Handle->ScrollbarClickDeltaToGrabCenter);
		public ref float DisabledAlphaBackup => ref Unsafe.AsRef<float>(&Handle->DisabledAlphaBackup);
		public ref short DisabledStackSize => ref Unsafe.AsRef<short>(&Handle->DisabledStackSize);
		public ref short TooltipOverrideCount => ref Unsafe.AsRef<short>(&Handle->TooltipOverrideCount);
		public ref ImVectorChar ClipboardHandlerData => ref Unsafe.AsRef<ImVectorChar>(&Handle->ClipboardHandlerData);
		public ref ImVectorImGuiID MenusIdSubmittedThisFrame => ref Unsafe.AsRef<ImVectorImGuiID>(&Handle->MenusIdSubmittedThisFrame);
		public ref ImGuiPlatformImeData PlatformImeData => ref Unsafe.AsRef<ImGuiPlatformImeData>(&Handle->PlatformImeData);
		public ref ImGuiPlatformImeData PlatformImeDataPrev => ref Unsafe.AsRef<ImGuiPlatformImeData>(&Handle->PlatformImeDataPrev);
		public ref int PlatformImeViewport => ref Unsafe.AsRef<int>(&Handle->PlatformImeViewport);
		public ref byte PlatformLocaleDecimalPoint => ref Unsafe.AsRef<byte>(&Handle->PlatformLocaleDecimalPoint);
		public ref ImGuiDockContext DockContext => ref Unsafe.AsRef<ImGuiDockContext>(&Handle->DockContext);
		public void* DockNodeWindowMenuHandler { get => Handle->DockNodeWindowMenuHandler; set => Handle->DockNodeWindowMenuHandler = value; }
		public ref bool SettingsLoaded => ref Unsafe.AsRef<bool>(&Handle->SettingsLoaded);
		public ref float SettingsDirtyTimer => ref Unsafe.AsRef<float>(&Handle->SettingsDirtyTimer);
		public ref ImGuiTextBuffer SettingsIniData => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->SettingsIniData);
		public ref ImVectorImGuiSettingsHandler SettingsHandlers => ref Unsafe.AsRef<ImVectorImGuiSettingsHandler>(&Handle->SettingsHandlers);
		public ref ImChunkStreamImGuiWindowSettings SettingsWindows => ref Unsafe.AsRef<ImChunkStreamImGuiWindowSettings>(&Handle->SettingsWindows);
		public ref ImChunkStreamImGuiTableSettings SettingsTables => ref Unsafe.AsRef<ImChunkStreamImGuiTableSettings>(&Handle->SettingsTables);
		public ref ImVectorImGuiContextHook Hooks => ref Unsafe.AsRef<ImVectorImGuiContextHook>(&Handle->Hooks);
		public ref int HookIdNext => ref Unsafe.AsRef<int>(&Handle->HookIdNext);
		public ref bool LogEnabled => ref Unsafe.AsRef<bool>(&Handle->LogEnabled);
		public ref ImGuiLogType LogType => ref Unsafe.AsRef<ImGuiLogType>(&Handle->LogType);
		public ref ImFileHandle LogFile => ref Unsafe.AsRef<ImFileHandle>(&Handle->LogFile);
		public ref ImGuiTextBuffer LogBuffer => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->LogBuffer);
		public byte* LogNextPrefix { get => Handle->LogNextPrefix; set => Handle->LogNextPrefix = value; }
		public byte* LogNextSuffix { get => Handle->LogNextSuffix; set => Handle->LogNextSuffix = value; }
		public ref float LogLinePosY => ref Unsafe.AsRef<float>(&Handle->LogLinePosY);
		public ref bool LogLineFirstItem => ref Unsafe.AsRef<bool>(&Handle->LogLineFirstItem);
		public ref int LogDepthRef => ref Unsafe.AsRef<int>(&Handle->LogDepthRef);
		public ref int LogDepthToExpand => ref Unsafe.AsRef<int>(&Handle->LogDepthToExpand);
		public ref int LogDepthToExpandDefault => ref Unsafe.AsRef<int>(&Handle->LogDepthToExpandDefault);
		public ref ImGuiDebugLogFlags DebugLogFlags => ref Unsafe.AsRef<ImGuiDebugLogFlags>(&Handle->DebugLogFlags);
		public ref ImGuiTextBuffer DebugLogBuf => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->DebugLogBuf);
		public ref ImGuiTextIndex DebugLogIndex => ref Unsafe.AsRef<ImGuiTextIndex>(&Handle->DebugLogIndex);
		public ref byte DebugLogClipperAutoDisableFrames => ref Unsafe.AsRef<byte>(&Handle->DebugLogClipperAutoDisableFrames);
		public ref byte DebugLocateFrames => ref Unsafe.AsRef<byte>(&Handle->DebugLocateFrames);
		public ref sbyte DebugBeginReturnValueCullDepth => ref Unsafe.AsRef<sbyte>(&Handle->DebugBeginReturnValueCullDepth);
		public ref bool DebugItemPickerActive => ref Unsafe.AsRef<bool>(&Handle->DebugItemPickerActive);
		public ref byte DebugItemPickerMouseButton => ref Unsafe.AsRef<byte>(&Handle->DebugItemPickerMouseButton);
		public ref int DebugItemPickerBreakId => ref Unsafe.AsRef<int>(&Handle->DebugItemPickerBreakId);
		public ref ImGuiMetricsConfig DebugMetricsConfig => ref Unsafe.AsRef<ImGuiMetricsConfig>(&Handle->DebugMetricsConfig);
		public ref ImGuiStackTool DebugStackTool => ref Unsafe.AsRef<ImGuiStackTool>(&Handle->DebugStackTool);
		public ref ImGuiDockNodePtr DebugHoveredDockNode => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->DebugHoveredDockNode);
		public unsafe Span<float> FramerateSecPerFrame
		
		{
			get
			{
				return new Span<float>(&Handle->FramerateSecPerFrame_0, 60);
			}
		}
		public ref int FramerateSecPerFrameIdx => ref Unsafe.AsRef<int>(&Handle->FramerateSecPerFrameIdx);
		public ref int FramerateSecPerFrameCount => ref Unsafe.AsRef<int>(&Handle->FramerateSecPerFrameCount);
		public ref float FramerateSecPerFrameAccum => ref Unsafe.AsRef<float>(&Handle->FramerateSecPerFrameAccum);
		public ref int WantCaptureMouseNextFrame => ref Unsafe.AsRef<int>(&Handle->WantCaptureMouseNextFrame);
		public ref int WantCaptureKeyboardNextFrame => ref Unsafe.AsRef<int>(&Handle->WantCaptureKeyboardNextFrame);
		public ref int WantTextInputNextFrame => ref Unsafe.AsRef<int>(&Handle->WantTextInputNextFrame);
		public ref ImVectorChar TempBuffer => ref Unsafe.AsRef<ImVectorChar>(&Handle->TempBuffer);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiIO
	{
		public ImGuiConfigFlags ConfigFlags;
		public ImGuiBackendFlags BackendFlags;
		public Vector2 DisplaySize;
		public float DeltaTime;
		public float IniSavingRate;
		public unsafe byte* IniFilename;
		public unsafe byte* LogFilename;
		public unsafe void* UserData;
		public unsafe ImFontAtlas* Fonts;
		public float FontGlobalScale;
		public byte FontAllowUserScaling;
		public unsafe ImFont* FontDefault;
		public Vector2 DisplayFramebufferScale;
		public byte ConfigDockingNoSplit;
		public byte ConfigDockingWithShift;
		public byte ConfigDockingAlwaysTabBar;
		public byte ConfigDockingTransparentPayload;
		public byte ConfigViewportsNoAutoMerge;
		public byte ConfigViewportsNoTaskBarIcon;
		public byte ConfigViewportsNoDecoration;
		public byte ConfigViewportsNoDefaultParent;
		public byte MouseDrawCursor;
		public byte ConfigMacOSXBehaviors;
		public byte ConfigInputTrickleEventQueue;
		public byte ConfigInputTextCursorBlink;
		public byte ConfigInputTextEnterKeepActive;
		public byte ConfigDragClickToInputText;
		public byte ConfigWindowsResizeFromEdges;
		public byte ConfigWindowsMoveFromTitleBarOnly;
		public float ConfigMemoryCompactTimer;
		public float MouseDoubleClickTime;
		public float MouseDoubleClickMaxDist;
		public float MouseDragThreshold;
		public float KeyRepeatDelay;
		public float KeyRepeatRate;
		public byte ConfigDebugBeginReturnValueOnce;
		public byte ConfigDebugBeginReturnValueLoop;
		public byte ConfigDebugIgnoreFocusLoss;
		public byte ConfigDebugIniSettings;
		public unsafe byte* BackendPlatformName;
		public unsafe byte* BackendRendererName;
		public unsafe void* BackendPlatformUserData;
		public unsafe void* BackendRendererUserData;
		public unsafe void* BackendLanguageUserData;
		public unsafe void* GetClipboardTextFn;
		public unsafe void* SetClipboardTextFn;
		public unsafe void* ClipboardUserData;
		public unsafe void* SetPlatformImeDataFn;
		public unsafe void* UnusedPadding;
		public byte WantCaptureMouse;
		public byte WantCaptureKeyboard;
		public byte WantTextInput;
		public byte WantSetMousePos;
		public byte WantSaveIniSettings;
		public byte NavActive;
		public byte NavVisible;
		public float Framerate;
		public int MetricsRenderVertices;
		public int MetricsRenderIndices;
		public int MetricsRenderWindows;
		public int MetricsActiveWindows;
		public int MetricsActiveAllocations;
		public Vector2 MouseDelta;
		public int KeyMap_0;
		public int KeyMap_1;
		public int KeyMap_2;
		public int KeyMap_3;
		public int KeyMap_4;
		public int KeyMap_5;
		public int KeyMap_6;
		public int KeyMap_7;
		public int KeyMap_8;
		public int KeyMap_9;
		public int KeyMap_10;
		public int KeyMap_11;
		public int KeyMap_12;
		public int KeyMap_13;
		public int KeyMap_14;
		public int KeyMap_15;
		public int KeyMap_16;
		public int KeyMap_17;
		public int KeyMap_18;
		public int KeyMap_19;
		public int KeyMap_20;
		public int KeyMap_21;
		public int KeyMap_22;
		public int KeyMap_23;
		public int KeyMap_24;
		public int KeyMap_25;
		public int KeyMap_26;
		public int KeyMap_27;
		public int KeyMap_28;
		public int KeyMap_29;
		public int KeyMap_30;
		public int KeyMap_31;
		public int KeyMap_32;
		public int KeyMap_33;
		public int KeyMap_34;
		public int KeyMap_35;
		public int KeyMap_36;
		public int KeyMap_37;
		public int KeyMap_38;
		public int KeyMap_39;
		public int KeyMap_40;
		public int KeyMap_41;
		public int KeyMap_42;
		public int KeyMap_43;
		public int KeyMap_44;
		public int KeyMap_45;
		public int KeyMap_46;
		public int KeyMap_47;
		public int KeyMap_48;
		public int KeyMap_49;
		public int KeyMap_50;
		public int KeyMap_51;
		public int KeyMap_52;
		public int KeyMap_53;
		public int KeyMap_54;
		public int KeyMap_55;
		public int KeyMap_56;
		public int KeyMap_57;
		public int KeyMap_58;
		public int KeyMap_59;
		public int KeyMap_60;
		public int KeyMap_61;
		public int KeyMap_62;
		public int KeyMap_63;
		public int KeyMap_64;
		public int KeyMap_65;
		public int KeyMap_66;
		public int KeyMap_67;
		public int KeyMap_68;
		public int KeyMap_69;
		public int KeyMap_70;
		public int KeyMap_71;
		public int KeyMap_72;
		public int KeyMap_73;
		public int KeyMap_74;
		public int KeyMap_75;
		public int KeyMap_76;
		public int KeyMap_77;
		public int KeyMap_78;
		public int KeyMap_79;
		public int KeyMap_80;
		public int KeyMap_81;
		public int KeyMap_82;
		public int KeyMap_83;
		public int KeyMap_84;
		public int KeyMap_85;
		public int KeyMap_86;
		public int KeyMap_87;
		public int KeyMap_88;
		public int KeyMap_89;
		public int KeyMap_90;
		public int KeyMap_91;
		public int KeyMap_92;
		public int KeyMap_93;
		public int KeyMap_94;
		public int KeyMap_95;
		public int KeyMap_96;
		public int KeyMap_97;
		public int KeyMap_98;
		public int KeyMap_99;
		public int KeyMap_100;
		public int KeyMap_101;
		public int KeyMap_102;
		public int KeyMap_103;
		public int KeyMap_104;
		public int KeyMap_105;
		public int KeyMap_106;
		public int KeyMap_107;
		public int KeyMap_108;
		public int KeyMap_109;
		public int KeyMap_110;
		public int KeyMap_111;
		public int KeyMap_112;
		public int KeyMap_113;
		public int KeyMap_114;
		public int KeyMap_115;
		public int KeyMap_116;
		public int KeyMap_117;
		public int KeyMap_118;
		public int KeyMap_119;
		public int KeyMap_120;
		public int KeyMap_121;
		public int KeyMap_122;
		public int KeyMap_123;
		public int KeyMap_124;
		public int KeyMap_125;
		public int KeyMap_126;
		public int KeyMap_127;
		public int KeyMap_128;
		public int KeyMap_129;
		public int KeyMap_130;
		public int KeyMap_131;
		public int KeyMap_132;
		public int KeyMap_133;
		public int KeyMap_134;
		public int KeyMap_135;
		public int KeyMap_136;
		public int KeyMap_137;
		public int KeyMap_138;
		public int KeyMap_139;
		public int KeyMap_140;
		public int KeyMap_141;
		public int KeyMap_142;
		public int KeyMap_143;
		public int KeyMap_144;
		public int KeyMap_145;
		public int KeyMap_146;
		public int KeyMap_147;
		public int KeyMap_148;
		public int KeyMap_149;
		public int KeyMap_150;
		public int KeyMap_151;
		public int KeyMap_152;
		public int KeyMap_153;
		public int KeyMap_154;
		public int KeyMap_155;
		public int KeyMap_156;
		public int KeyMap_157;
		public int KeyMap_158;
		public int KeyMap_159;
		public int KeyMap_160;
		public int KeyMap_161;
		public int KeyMap_162;
		public int KeyMap_163;
		public int KeyMap_164;
		public int KeyMap_165;
		public int KeyMap_166;
		public int KeyMap_167;
		public int KeyMap_168;
		public int KeyMap_169;
		public int KeyMap_170;
		public int KeyMap_171;
		public int KeyMap_172;
		public int KeyMap_173;
		public int KeyMap_174;
		public int KeyMap_175;
		public int KeyMap_176;
		public int KeyMap_177;
		public int KeyMap_178;
		public int KeyMap_179;
		public int KeyMap_180;
		public int KeyMap_181;
		public int KeyMap_182;
		public int KeyMap_183;
		public int KeyMap_184;
		public int KeyMap_185;
		public int KeyMap_186;
		public int KeyMap_187;
		public int KeyMap_188;
		public int KeyMap_189;
		public int KeyMap_190;
		public int KeyMap_191;
		public int KeyMap_192;
		public int KeyMap_193;
		public int KeyMap_194;
		public int KeyMap_195;
		public int KeyMap_196;
		public int KeyMap_197;
		public int KeyMap_198;
		public int KeyMap_199;
		public int KeyMap_200;
		public int KeyMap_201;
		public int KeyMap_202;
		public int KeyMap_203;
		public int KeyMap_204;
		public int KeyMap_205;
		public int KeyMap_206;
		public int KeyMap_207;
		public int KeyMap_208;
		public int KeyMap_209;
		public int KeyMap_210;
		public int KeyMap_211;
		public int KeyMap_212;
		public int KeyMap_213;
		public int KeyMap_214;
		public int KeyMap_215;
		public int KeyMap_216;
		public int KeyMap_217;
		public int KeyMap_218;
		public int KeyMap_219;
		public int KeyMap_220;
		public int KeyMap_221;
		public int KeyMap_222;
		public int KeyMap_223;
		public int KeyMap_224;
		public int KeyMap_225;
		public int KeyMap_226;
		public int KeyMap_227;
		public int KeyMap_228;
		public int KeyMap_229;
		public int KeyMap_230;
		public int KeyMap_231;
		public int KeyMap_232;
		public int KeyMap_233;
		public int KeyMap_234;
		public int KeyMap_235;
		public int KeyMap_236;
		public int KeyMap_237;
		public int KeyMap_238;
		public int KeyMap_239;
		public int KeyMap_240;
		public int KeyMap_241;
		public int KeyMap_242;
		public int KeyMap_243;
		public int KeyMap_244;
		public int KeyMap_245;
		public int KeyMap_246;
		public int KeyMap_247;
		public int KeyMap_248;
		public int KeyMap_249;
		public int KeyMap_250;
		public int KeyMap_251;
		public int KeyMap_252;
		public int KeyMap_253;
		public int KeyMap_254;
		public int KeyMap_255;
		public int KeyMap_256;
		public int KeyMap_257;
		public int KeyMap_258;
		public int KeyMap_259;
		public int KeyMap_260;
		public int KeyMap_261;
		public int KeyMap_262;
		public int KeyMap_263;
		public int KeyMap_264;
		public int KeyMap_265;
		public int KeyMap_266;
		public int KeyMap_267;
		public int KeyMap_268;
		public int KeyMap_269;
		public int KeyMap_270;
		public int KeyMap_271;
		public int KeyMap_272;
		public int KeyMap_273;
		public int KeyMap_274;
		public int KeyMap_275;
		public int KeyMap_276;
		public int KeyMap_277;
		public int KeyMap_278;
		public int KeyMap_279;
		public int KeyMap_280;
		public int KeyMap_281;
		public int KeyMap_282;
		public int KeyMap_283;
		public int KeyMap_284;
		public int KeyMap_285;
		public int KeyMap_286;
		public int KeyMap_287;
		public int KeyMap_288;
		public int KeyMap_289;
		public int KeyMap_290;
		public int KeyMap_291;
		public int KeyMap_292;
		public int KeyMap_293;
		public int KeyMap_294;
		public int KeyMap_295;
		public int KeyMap_296;
		public int KeyMap_297;
		public int KeyMap_298;
		public int KeyMap_299;
		public int KeyMap_300;
		public int KeyMap_301;
		public int KeyMap_302;
		public int KeyMap_303;
		public int KeyMap_304;
		public int KeyMap_305;
		public int KeyMap_306;
		public int KeyMap_307;
		public int KeyMap_308;
		public int KeyMap_309;
		public int KeyMap_310;
		public int KeyMap_311;
		public int KeyMap_312;
		public int KeyMap_313;
		public int KeyMap_314;
		public int KeyMap_315;
		public int KeyMap_316;
		public int KeyMap_317;
		public int KeyMap_318;
		public int KeyMap_319;
		public int KeyMap_320;
		public int KeyMap_321;
		public int KeyMap_322;
		public int KeyMap_323;
		public int KeyMap_324;
		public int KeyMap_325;
		public int KeyMap_326;
		public int KeyMap_327;
		public int KeyMap_328;
		public int KeyMap_329;
		public int KeyMap_330;
		public int KeyMap_331;
		public int KeyMap_332;
		public int KeyMap_333;
		public int KeyMap_334;
		public int KeyMap_335;
		public int KeyMap_336;
		public int KeyMap_337;
		public int KeyMap_338;
		public int KeyMap_339;
		public int KeyMap_340;
		public int KeyMap_341;
		public int KeyMap_342;
		public int KeyMap_343;
		public int KeyMap_344;
		public int KeyMap_345;
		public int KeyMap_346;
		public int KeyMap_347;
		public int KeyMap_348;
		public int KeyMap_349;
		public int KeyMap_350;
		public int KeyMap_351;
		public int KeyMap_352;
		public int KeyMap_353;
		public int KeyMap_354;
		public int KeyMap_355;
		public int KeyMap_356;
		public int KeyMap_357;
		public int KeyMap_358;
		public int KeyMap_359;
		public int KeyMap_360;
		public int KeyMap_361;
		public int KeyMap_362;
		public int KeyMap_363;
		public int KeyMap_364;
		public int KeyMap_365;
		public int KeyMap_366;
		public int KeyMap_367;
		public int KeyMap_368;
		public int KeyMap_369;
		public int KeyMap_370;
		public int KeyMap_371;
		public int KeyMap_372;
		public int KeyMap_373;
		public int KeyMap_374;
		public int KeyMap_375;
		public int KeyMap_376;
		public int KeyMap_377;
		public int KeyMap_378;
		public int KeyMap_379;
		public int KeyMap_380;
		public int KeyMap_381;
		public int KeyMap_382;
		public int KeyMap_383;
		public int KeyMap_384;
		public int KeyMap_385;
		public int KeyMap_386;
		public int KeyMap_387;
		public int KeyMap_388;
		public int KeyMap_389;
		public int KeyMap_390;
		public int KeyMap_391;
		public int KeyMap_392;
		public int KeyMap_393;
		public int KeyMap_394;
		public int KeyMap_395;
		public int KeyMap_396;
		public int KeyMap_397;
		public int KeyMap_398;
		public int KeyMap_399;
		public int KeyMap_400;
		public int KeyMap_401;
		public int KeyMap_402;
		public int KeyMap_403;
		public int KeyMap_404;
		public int KeyMap_405;
		public int KeyMap_406;
		public int KeyMap_407;
		public int KeyMap_408;
		public int KeyMap_409;
		public int KeyMap_410;
		public int KeyMap_411;
		public int KeyMap_412;
		public int KeyMap_413;
		public int KeyMap_414;
		public int KeyMap_415;
		public int KeyMap_416;
		public int KeyMap_417;
		public int KeyMap_418;
		public int KeyMap_419;
		public int KeyMap_420;
		public int KeyMap_421;
		public int KeyMap_422;
		public int KeyMap_423;
		public int KeyMap_424;
		public int KeyMap_425;
		public int KeyMap_426;
		public int KeyMap_427;
		public int KeyMap_428;
		public int KeyMap_429;
		public int KeyMap_430;
		public int KeyMap_431;
		public int KeyMap_432;
		public int KeyMap_433;
		public int KeyMap_434;
		public int KeyMap_435;
		public int KeyMap_436;
		public int KeyMap_437;
		public int KeyMap_438;
		public int KeyMap_439;
		public int KeyMap_440;
		public int KeyMap_441;
		public int KeyMap_442;
		public int KeyMap_443;
		public int KeyMap_444;
		public int KeyMap_445;
		public int KeyMap_446;
		public int KeyMap_447;
		public int KeyMap_448;
		public int KeyMap_449;
		public int KeyMap_450;
		public int KeyMap_451;
		public int KeyMap_452;
		public int KeyMap_453;
		public int KeyMap_454;
		public int KeyMap_455;
		public int KeyMap_456;
		public int KeyMap_457;
		public int KeyMap_458;
		public int KeyMap_459;
		public int KeyMap_460;
		public int KeyMap_461;
		public int KeyMap_462;
		public int KeyMap_463;
		public int KeyMap_464;
		public int KeyMap_465;
		public int KeyMap_466;
		public int KeyMap_467;
		public int KeyMap_468;
		public int KeyMap_469;
		public int KeyMap_470;
		public int KeyMap_471;
		public int KeyMap_472;
		public int KeyMap_473;
		public int KeyMap_474;
		public int KeyMap_475;
		public int KeyMap_476;
		public int KeyMap_477;
		public int KeyMap_478;
		public int KeyMap_479;
		public int KeyMap_480;
		public int KeyMap_481;
		public int KeyMap_482;
		public int KeyMap_483;
		public int KeyMap_484;
		public int KeyMap_485;
		public int KeyMap_486;
		public int KeyMap_487;
		public int KeyMap_488;
		public int KeyMap_489;
		public int KeyMap_490;
		public int KeyMap_491;
		public int KeyMap_492;
		public int KeyMap_493;
		public int KeyMap_494;
		public int KeyMap_495;
		public int KeyMap_496;
		public int KeyMap_497;
		public int KeyMap_498;
		public int KeyMap_499;
		public int KeyMap_500;
		public int KeyMap_501;
		public int KeyMap_502;
		public int KeyMap_503;
		public int KeyMap_504;
		public int KeyMap_505;
		public int KeyMap_506;
		public int KeyMap_507;
		public int KeyMap_508;
		public int KeyMap_509;
		public int KeyMap_510;
		public int KeyMap_511;
		public int KeyMap_512;
		public int KeyMap_513;
		public int KeyMap_514;
		public int KeyMap_515;
		public int KeyMap_516;
		public int KeyMap_517;
		public int KeyMap_518;
		public int KeyMap_519;
		public int KeyMap_520;
		public int KeyMap_521;
		public int KeyMap_522;
		public int KeyMap_523;
		public int KeyMap_524;
		public int KeyMap_525;
		public int KeyMap_526;
		public int KeyMap_527;
		public int KeyMap_528;
		public int KeyMap_529;
		public int KeyMap_530;
		public int KeyMap_531;
		public int KeyMap_532;
		public int KeyMap_533;
		public int KeyMap_534;
		public int KeyMap_535;
		public int KeyMap_536;
		public int KeyMap_537;
		public int KeyMap_538;
		public int KeyMap_539;
		public int KeyMap_540;
		public int KeyMap_541;
		public int KeyMap_542;
		public int KeyMap_543;
		public int KeyMap_544;
		public int KeyMap_545;
		public int KeyMap_546;
		public int KeyMap_547;
		public int KeyMap_548;
		public int KeyMap_549;
		public int KeyMap_550;
		public int KeyMap_551;
		public int KeyMap_552;
		public int KeyMap_553;
		public int KeyMap_554;
		public int KeyMap_555;
		public int KeyMap_556;
		public int KeyMap_557;
		public int KeyMap_558;
		public int KeyMap_559;
		public int KeyMap_560;
		public int KeyMap_561;
		public int KeyMap_562;
		public int KeyMap_563;
		public int KeyMap_564;
		public int KeyMap_565;
		public int KeyMap_566;
		public int KeyMap_567;
		public int KeyMap_568;
		public int KeyMap_569;
		public int KeyMap_570;
		public int KeyMap_571;
		public int KeyMap_572;
		public int KeyMap_573;
		public int KeyMap_574;
		public int KeyMap_575;
		public int KeyMap_576;
		public int KeyMap_577;
		public int KeyMap_578;
		public int KeyMap_579;
		public int KeyMap_580;
		public int KeyMap_581;
		public int KeyMap_582;
		public int KeyMap_583;
		public int KeyMap_584;
		public int KeyMap_585;
		public int KeyMap_586;
		public int KeyMap_587;
		public int KeyMap_588;
		public int KeyMap_589;
		public int KeyMap_590;
		public int KeyMap_591;
		public int KeyMap_592;
		public int KeyMap_593;
		public int KeyMap_594;
		public int KeyMap_595;
		public int KeyMap_596;
		public int KeyMap_597;
		public int KeyMap_598;
		public int KeyMap_599;
		public int KeyMap_600;
		public int KeyMap_601;
		public int KeyMap_602;
		public int KeyMap_603;
		public int KeyMap_604;
		public int KeyMap_605;
		public int KeyMap_606;
		public int KeyMap_607;
		public int KeyMap_608;
		public int KeyMap_609;
		public int KeyMap_610;
		public int KeyMap_611;
		public int KeyMap_612;
		public int KeyMap_613;
		public int KeyMap_614;
		public int KeyMap_615;
		public int KeyMap_616;
		public int KeyMap_617;
		public int KeyMap_618;
		public int KeyMap_619;
		public int KeyMap_620;
		public int KeyMap_621;
		public int KeyMap_622;
		public int KeyMap_623;
		public int KeyMap_624;
		public int KeyMap_625;
		public int KeyMap_626;
		public int KeyMap_627;
		public int KeyMap_628;
		public int KeyMap_629;
		public int KeyMap_630;
		public int KeyMap_631;
		public int KeyMap_632;
		public int KeyMap_633;
		public int KeyMap_634;
		public int KeyMap_635;
		public int KeyMap_636;
		public int KeyMap_637;
		public int KeyMap_638;
		public int KeyMap_639;
		public int KeyMap_640;
		public int KeyMap_641;
		public int KeyMap_642;
		public int KeyMap_643;
		public int KeyMap_644;
		public int KeyMap_645;
		public int KeyMap_646;
		public int KeyMap_647;
		public int KeyMap_648;
		public int KeyMap_649;
		public int KeyMap_650;
		public int KeyMap_651;
		public bool KeysDown_0;
		public bool KeysDown_1;
		public bool KeysDown_2;
		public bool KeysDown_3;
		public bool KeysDown_4;
		public bool KeysDown_5;
		public bool KeysDown_6;
		public bool KeysDown_7;
		public bool KeysDown_8;
		public bool KeysDown_9;
		public bool KeysDown_10;
		public bool KeysDown_11;
		public bool KeysDown_12;
		public bool KeysDown_13;
		public bool KeysDown_14;
		public bool KeysDown_15;
		public bool KeysDown_16;
		public bool KeysDown_17;
		public bool KeysDown_18;
		public bool KeysDown_19;
		public bool KeysDown_20;
		public bool KeysDown_21;
		public bool KeysDown_22;
		public bool KeysDown_23;
		public bool KeysDown_24;
		public bool KeysDown_25;
		public bool KeysDown_26;
		public bool KeysDown_27;
		public bool KeysDown_28;
		public bool KeysDown_29;
		public bool KeysDown_30;
		public bool KeysDown_31;
		public bool KeysDown_32;
		public bool KeysDown_33;
		public bool KeysDown_34;
		public bool KeysDown_35;
		public bool KeysDown_36;
		public bool KeysDown_37;
		public bool KeysDown_38;
		public bool KeysDown_39;
		public bool KeysDown_40;
		public bool KeysDown_41;
		public bool KeysDown_42;
		public bool KeysDown_43;
		public bool KeysDown_44;
		public bool KeysDown_45;
		public bool KeysDown_46;
		public bool KeysDown_47;
		public bool KeysDown_48;
		public bool KeysDown_49;
		public bool KeysDown_50;
		public bool KeysDown_51;
		public bool KeysDown_52;
		public bool KeysDown_53;
		public bool KeysDown_54;
		public bool KeysDown_55;
		public bool KeysDown_56;
		public bool KeysDown_57;
		public bool KeysDown_58;
		public bool KeysDown_59;
		public bool KeysDown_60;
		public bool KeysDown_61;
		public bool KeysDown_62;
		public bool KeysDown_63;
		public bool KeysDown_64;
		public bool KeysDown_65;
		public bool KeysDown_66;
		public bool KeysDown_67;
		public bool KeysDown_68;
		public bool KeysDown_69;
		public bool KeysDown_70;
		public bool KeysDown_71;
		public bool KeysDown_72;
		public bool KeysDown_73;
		public bool KeysDown_74;
		public bool KeysDown_75;
		public bool KeysDown_76;
		public bool KeysDown_77;
		public bool KeysDown_78;
		public bool KeysDown_79;
		public bool KeysDown_80;
		public bool KeysDown_81;
		public bool KeysDown_82;
		public bool KeysDown_83;
		public bool KeysDown_84;
		public bool KeysDown_85;
		public bool KeysDown_86;
		public bool KeysDown_87;
		public bool KeysDown_88;
		public bool KeysDown_89;
		public bool KeysDown_90;
		public bool KeysDown_91;
		public bool KeysDown_92;
		public bool KeysDown_93;
		public bool KeysDown_94;
		public bool KeysDown_95;
		public bool KeysDown_96;
		public bool KeysDown_97;
		public bool KeysDown_98;
		public bool KeysDown_99;
		public bool KeysDown_100;
		public bool KeysDown_101;
		public bool KeysDown_102;
		public bool KeysDown_103;
		public bool KeysDown_104;
		public bool KeysDown_105;
		public bool KeysDown_106;
		public bool KeysDown_107;
		public bool KeysDown_108;
		public bool KeysDown_109;
		public bool KeysDown_110;
		public bool KeysDown_111;
		public bool KeysDown_112;
		public bool KeysDown_113;
		public bool KeysDown_114;
		public bool KeysDown_115;
		public bool KeysDown_116;
		public bool KeysDown_117;
		public bool KeysDown_118;
		public bool KeysDown_119;
		public bool KeysDown_120;
		public bool KeysDown_121;
		public bool KeysDown_122;
		public bool KeysDown_123;
		public bool KeysDown_124;
		public bool KeysDown_125;
		public bool KeysDown_126;
		public bool KeysDown_127;
		public bool KeysDown_128;
		public bool KeysDown_129;
		public bool KeysDown_130;
		public bool KeysDown_131;
		public bool KeysDown_132;
		public bool KeysDown_133;
		public bool KeysDown_134;
		public bool KeysDown_135;
		public bool KeysDown_136;
		public bool KeysDown_137;
		public bool KeysDown_138;
		public bool KeysDown_139;
		public bool KeysDown_140;
		public bool KeysDown_141;
		public bool KeysDown_142;
		public bool KeysDown_143;
		public bool KeysDown_144;
		public bool KeysDown_145;
		public bool KeysDown_146;
		public bool KeysDown_147;
		public bool KeysDown_148;
		public bool KeysDown_149;
		public bool KeysDown_150;
		public bool KeysDown_151;
		public bool KeysDown_152;
		public bool KeysDown_153;
		public bool KeysDown_154;
		public bool KeysDown_155;
		public bool KeysDown_156;
		public bool KeysDown_157;
		public bool KeysDown_158;
		public bool KeysDown_159;
		public bool KeysDown_160;
		public bool KeysDown_161;
		public bool KeysDown_162;
		public bool KeysDown_163;
		public bool KeysDown_164;
		public bool KeysDown_165;
		public bool KeysDown_166;
		public bool KeysDown_167;
		public bool KeysDown_168;
		public bool KeysDown_169;
		public bool KeysDown_170;
		public bool KeysDown_171;
		public bool KeysDown_172;
		public bool KeysDown_173;
		public bool KeysDown_174;
		public bool KeysDown_175;
		public bool KeysDown_176;
		public bool KeysDown_177;
		public bool KeysDown_178;
		public bool KeysDown_179;
		public bool KeysDown_180;
		public bool KeysDown_181;
		public bool KeysDown_182;
		public bool KeysDown_183;
		public bool KeysDown_184;
		public bool KeysDown_185;
		public bool KeysDown_186;
		public bool KeysDown_187;
		public bool KeysDown_188;
		public bool KeysDown_189;
		public bool KeysDown_190;
		public bool KeysDown_191;
		public bool KeysDown_192;
		public bool KeysDown_193;
		public bool KeysDown_194;
		public bool KeysDown_195;
		public bool KeysDown_196;
		public bool KeysDown_197;
		public bool KeysDown_198;
		public bool KeysDown_199;
		public bool KeysDown_200;
		public bool KeysDown_201;
		public bool KeysDown_202;
		public bool KeysDown_203;
		public bool KeysDown_204;
		public bool KeysDown_205;
		public bool KeysDown_206;
		public bool KeysDown_207;
		public bool KeysDown_208;
		public bool KeysDown_209;
		public bool KeysDown_210;
		public bool KeysDown_211;
		public bool KeysDown_212;
		public bool KeysDown_213;
		public bool KeysDown_214;
		public bool KeysDown_215;
		public bool KeysDown_216;
		public bool KeysDown_217;
		public bool KeysDown_218;
		public bool KeysDown_219;
		public bool KeysDown_220;
		public bool KeysDown_221;
		public bool KeysDown_222;
		public bool KeysDown_223;
		public bool KeysDown_224;
		public bool KeysDown_225;
		public bool KeysDown_226;
		public bool KeysDown_227;
		public bool KeysDown_228;
		public bool KeysDown_229;
		public bool KeysDown_230;
		public bool KeysDown_231;
		public bool KeysDown_232;
		public bool KeysDown_233;
		public bool KeysDown_234;
		public bool KeysDown_235;
		public bool KeysDown_236;
		public bool KeysDown_237;
		public bool KeysDown_238;
		public bool KeysDown_239;
		public bool KeysDown_240;
		public bool KeysDown_241;
		public bool KeysDown_242;
		public bool KeysDown_243;
		public bool KeysDown_244;
		public bool KeysDown_245;
		public bool KeysDown_246;
		public bool KeysDown_247;
		public bool KeysDown_248;
		public bool KeysDown_249;
		public bool KeysDown_250;
		public bool KeysDown_251;
		public bool KeysDown_252;
		public bool KeysDown_253;
		public bool KeysDown_254;
		public bool KeysDown_255;
		public bool KeysDown_256;
		public bool KeysDown_257;
		public bool KeysDown_258;
		public bool KeysDown_259;
		public bool KeysDown_260;
		public bool KeysDown_261;
		public bool KeysDown_262;
		public bool KeysDown_263;
		public bool KeysDown_264;
		public bool KeysDown_265;
		public bool KeysDown_266;
		public bool KeysDown_267;
		public bool KeysDown_268;
		public bool KeysDown_269;
		public bool KeysDown_270;
		public bool KeysDown_271;
		public bool KeysDown_272;
		public bool KeysDown_273;
		public bool KeysDown_274;
		public bool KeysDown_275;
		public bool KeysDown_276;
		public bool KeysDown_277;
		public bool KeysDown_278;
		public bool KeysDown_279;
		public bool KeysDown_280;
		public bool KeysDown_281;
		public bool KeysDown_282;
		public bool KeysDown_283;
		public bool KeysDown_284;
		public bool KeysDown_285;
		public bool KeysDown_286;
		public bool KeysDown_287;
		public bool KeysDown_288;
		public bool KeysDown_289;
		public bool KeysDown_290;
		public bool KeysDown_291;
		public bool KeysDown_292;
		public bool KeysDown_293;
		public bool KeysDown_294;
		public bool KeysDown_295;
		public bool KeysDown_296;
		public bool KeysDown_297;
		public bool KeysDown_298;
		public bool KeysDown_299;
		public bool KeysDown_300;
		public bool KeysDown_301;
		public bool KeysDown_302;
		public bool KeysDown_303;
		public bool KeysDown_304;
		public bool KeysDown_305;
		public bool KeysDown_306;
		public bool KeysDown_307;
		public bool KeysDown_308;
		public bool KeysDown_309;
		public bool KeysDown_310;
		public bool KeysDown_311;
		public bool KeysDown_312;
		public bool KeysDown_313;
		public bool KeysDown_314;
		public bool KeysDown_315;
		public bool KeysDown_316;
		public bool KeysDown_317;
		public bool KeysDown_318;
		public bool KeysDown_319;
		public bool KeysDown_320;
		public bool KeysDown_321;
		public bool KeysDown_322;
		public bool KeysDown_323;
		public bool KeysDown_324;
		public bool KeysDown_325;
		public bool KeysDown_326;
		public bool KeysDown_327;
		public bool KeysDown_328;
		public bool KeysDown_329;
		public bool KeysDown_330;
		public bool KeysDown_331;
		public bool KeysDown_332;
		public bool KeysDown_333;
		public bool KeysDown_334;
		public bool KeysDown_335;
		public bool KeysDown_336;
		public bool KeysDown_337;
		public bool KeysDown_338;
		public bool KeysDown_339;
		public bool KeysDown_340;
		public bool KeysDown_341;
		public bool KeysDown_342;
		public bool KeysDown_343;
		public bool KeysDown_344;
		public bool KeysDown_345;
		public bool KeysDown_346;
		public bool KeysDown_347;
		public bool KeysDown_348;
		public bool KeysDown_349;
		public bool KeysDown_350;
		public bool KeysDown_351;
		public bool KeysDown_352;
		public bool KeysDown_353;
		public bool KeysDown_354;
		public bool KeysDown_355;
		public bool KeysDown_356;
		public bool KeysDown_357;
		public bool KeysDown_358;
		public bool KeysDown_359;
		public bool KeysDown_360;
		public bool KeysDown_361;
		public bool KeysDown_362;
		public bool KeysDown_363;
		public bool KeysDown_364;
		public bool KeysDown_365;
		public bool KeysDown_366;
		public bool KeysDown_367;
		public bool KeysDown_368;
		public bool KeysDown_369;
		public bool KeysDown_370;
		public bool KeysDown_371;
		public bool KeysDown_372;
		public bool KeysDown_373;
		public bool KeysDown_374;
		public bool KeysDown_375;
		public bool KeysDown_376;
		public bool KeysDown_377;
		public bool KeysDown_378;
		public bool KeysDown_379;
		public bool KeysDown_380;
		public bool KeysDown_381;
		public bool KeysDown_382;
		public bool KeysDown_383;
		public bool KeysDown_384;
		public bool KeysDown_385;
		public bool KeysDown_386;
		public bool KeysDown_387;
		public bool KeysDown_388;
		public bool KeysDown_389;
		public bool KeysDown_390;
		public bool KeysDown_391;
		public bool KeysDown_392;
		public bool KeysDown_393;
		public bool KeysDown_394;
		public bool KeysDown_395;
		public bool KeysDown_396;
		public bool KeysDown_397;
		public bool KeysDown_398;
		public bool KeysDown_399;
		public bool KeysDown_400;
		public bool KeysDown_401;
		public bool KeysDown_402;
		public bool KeysDown_403;
		public bool KeysDown_404;
		public bool KeysDown_405;
		public bool KeysDown_406;
		public bool KeysDown_407;
		public bool KeysDown_408;
		public bool KeysDown_409;
		public bool KeysDown_410;
		public bool KeysDown_411;
		public bool KeysDown_412;
		public bool KeysDown_413;
		public bool KeysDown_414;
		public bool KeysDown_415;
		public bool KeysDown_416;
		public bool KeysDown_417;
		public bool KeysDown_418;
		public bool KeysDown_419;
		public bool KeysDown_420;
		public bool KeysDown_421;
		public bool KeysDown_422;
		public bool KeysDown_423;
		public bool KeysDown_424;
		public bool KeysDown_425;
		public bool KeysDown_426;
		public bool KeysDown_427;
		public bool KeysDown_428;
		public bool KeysDown_429;
		public bool KeysDown_430;
		public bool KeysDown_431;
		public bool KeysDown_432;
		public bool KeysDown_433;
		public bool KeysDown_434;
		public bool KeysDown_435;
		public bool KeysDown_436;
		public bool KeysDown_437;
		public bool KeysDown_438;
		public bool KeysDown_439;
		public bool KeysDown_440;
		public bool KeysDown_441;
		public bool KeysDown_442;
		public bool KeysDown_443;
		public bool KeysDown_444;
		public bool KeysDown_445;
		public bool KeysDown_446;
		public bool KeysDown_447;
		public bool KeysDown_448;
		public bool KeysDown_449;
		public bool KeysDown_450;
		public bool KeysDown_451;
		public bool KeysDown_452;
		public bool KeysDown_453;
		public bool KeysDown_454;
		public bool KeysDown_455;
		public bool KeysDown_456;
		public bool KeysDown_457;
		public bool KeysDown_458;
		public bool KeysDown_459;
		public bool KeysDown_460;
		public bool KeysDown_461;
		public bool KeysDown_462;
		public bool KeysDown_463;
		public bool KeysDown_464;
		public bool KeysDown_465;
		public bool KeysDown_466;
		public bool KeysDown_467;
		public bool KeysDown_468;
		public bool KeysDown_469;
		public bool KeysDown_470;
		public bool KeysDown_471;
		public bool KeysDown_472;
		public bool KeysDown_473;
		public bool KeysDown_474;
		public bool KeysDown_475;
		public bool KeysDown_476;
		public bool KeysDown_477;
		public bool KeysDown_478;
		public bool KeysDown_479;
		public bool KeysDown_480;
		public bool KeysDown_481;
		public bool KeysDown_482;
		public bool KeysDown_483;
		public bool KeysDown_484;
		public bool KeysDown_485;
		public bool KeysDown_486;
		public bool KeysDown_487;
		public bool KeysDown_488;
		public bool KeysDown_489;
		public bool KeysDown_490;
		public bool KeysDown_491;
		public bool KeysDown_492;
		public bool KeysDown_493;
		public bool KeysDown_494;
		public bool KeysDown_495;
		public bool KeysDown_496;
		public bool KeysDown_497;
		public bool KeysDown_498;
		public bool KeysDown_499;
		public bool KeysDown_500;
		public bool KeysDown_501;
		public bool KeysDown_502;
		public bool KeysDown_503;
		public bool KeysDown_504;
		public bool KeysDown_505;
		public bool KeysDown_506;
		public bool KeysDown_507;
		public bool KeysDown_508;
		public bool KeysDown_509;
		public bool KeysDown_510;
		public bool KeysDown_511;
		public bool KeysDown_512;
		public bool KeysDown_513;
		public bool KeysDown_514;
		public bool KeysDown_515;
		public bool KeysDown_516;
		public bool KeysDown_517;
		public bool KeysDown_518;
		public bool KeysDown_519;
		public bool KeysDown_520;
		public bool KeysDown_521;
		public bool KeysDown_522;
		public bool KeysDown_523;
		public bool KeysDown_524;
		public bool KeysDown_525;
		public bool KeysDown_526;
		public bool KeysDown_527;
		public bool KeysDown_528;
		public bool KeysDown_529;
		public bool KeysDown_530;
		public bool KeysDown_531;
		public bool KeysDown_532;
		public bool KeysDown_533;
		public bool KeysDown_534;
		public bool KeysDown_535;
		public bool KeysDown_536;
		public bool KeysDown_537;
		public bool KeysDown_538;
		public bool KeysDown_539;
		public bool KeysDown_540;
		public bool KeysDown_541;
		public bool KeysDown_542;
		public bool KeysDown_543;
		public bool KeysDown_544;
		public bool KeysDown_545;
		public bool KeysDown_546;
		public bool KeysDown_547;
		public bool KeysDown_548;
		public bool KeysDown_549;
		public bool KeysDown_550;
		public bool KeysDown_551;
		public bool KeysDown_552;
		public bool KeysDown_553;
		public bool KeysDown_554;
		public bool KeysDown_555;
		public bool KeysDown_556;
		public bool KeysDown_557;
		public bool KeysDown_558;
		public bool KeysDown_559;
		public bool KeysDown_560;
		public bool KeysDown_561;
		public bool KeysDown_562;
		public bool KeysDown_563;
		public bool KeysDown_564;
		public bool KeysDown_565;
		public bool KeysDown_566;
		public bool KeysDown_567;
		public bool KeysDown_568;
		public bool KeysDown_569;
		public bool KeysDown_570;
		public bool KeysDown_571;
		public bool KeysDown_572;
		public bool KeysDown_573;
		public bool KeysDown_574;
		public bool KeysDown_575;
		public bool KeysDown_576;
		public bool KeysDown_577;
		public bool KeysDown_578;
		public bool KeysDown_579;
		public bool KeysDown_580;
		public bool KeysDown_581;
		public bool KeysDown_582;
		public bool KeysDown_583;
		public bool KeysDown_584;
		public bool KeysDown_585;
		public bool KeysDown_586;
		public bool KeysDown_587;
		public bool KeysDown_588;
		public bool KeysDown_589;
		public bool KeysDown_590;
		public bool KeysDown_591;
		public bool KeysDown_592;
		public bool KeysDown_593;
		public bool KeysDown_594;
		public bool KeysDown_595;
		public bool KeysDown_596;
		public bool KeysDown_597;
		public bool KeysDown_598;
		public bool KeysDown_599;
		public bool KeysDown_600;
		public bool KeysDown_601;
		public bool KeysDown_602;
		public bool KeysDown_603;
		public bool KeysDown_604;
		public bool KeysDown_605;
		public bool KeysDown_606;
		public bool KeysDown_607;
		public bool KeysDown_608;
		public bool KeysDown_609;
		public bool KeysDown_610;
		public bool KeysDown_611;
		public bool KeysDown_612;
		public bool KeysDown_613;
		public bool KeysDown_614;
		public bool KeysDown_615;
		public bool KeysDown_616;
		public bool KeysDown_617;
		public bool KeysDown_618;
		public bool KeysDown_619;
		public bool KeysDown_620;
		public bool KeysDown_621;
		public bool KeysDown_622;
		public bool KeysDown_623;
		public bool KeysDown_624;
		public bool KeysDown_625;
		public bool KeysDown_626;
		public bool KeysDown_627;
		public bool KeysDown_628;
		public bool KeysDown_629;
		public bool KeysDown_630;
		public bool KeysDown_631;
		public bool KeysDown_632;
		public bool KeysDown_633;
		public bool KeysDown_634;
		public bool KeysDown_635;
		public bool KeysDown_636;
		public bool KeysDown_637;
		public bool KeysDown_638;
		public bool KeysDown_639;
		public bool KeysDown_640;
		public bool KeysDown_641;
		public bool KeysDown_642;
		public bool KeysDown_643;
		public bool KeysDown_644;
		public bool KeysDown_645;
		public bool KeysDown_646;
		public bool KeysDown_647;
		public bool KeysDown_648;
		public bool KeysDown_649;
		public bool KeysDown_650;
		public bool KeysDown_651;
		public float NavInputs_0;
		public float NavInputs_1;
		public float NavInputs_2;
		public float NavInputs_3;
		public float NavInputs_4;
		public float NavInputs_5;
		public float NavInputs_6;
		public float NavInputs_7;
		public float NavInputs_8;
		public float NavInputs_9;
		public float NavInputs_10;
		public float NavInputs_11;
		public float NavInputs_12;
		public float NavInputs_13;
		public float NavInputs_14;
		public float NavInputs_15;
		public unsafe ImGuiContext* Ctx;
		public Vector2 MousePos;
		public bool MouseDown_0;
		public bool MouseDown_1;
		public bool MouseDown_2;
		public bool MouseDown_3;
		public bool MouseDown_4;
		public float MouseWheel;
		public float MouseWheelH;
		public ImGuiMouseSource MouseSource;
		public int MouseHoveredViewport;
		public byte KeyCtrl;
		public byte KeyShift;
		public byte KeyAlt;
		public byte KeySuper;
		public int KeyMods;
		public ImGuiKeyData KeysData_0;
		public ImGuiKeyData KeysData_1;
		public ImGuiKeyData KeysData_2;
		public ImGuiKeyData KeysData_3;
		public ImGuiKeyData KeysData_4;
		public ImGuiKeyData KeysData_5;
		public ImGuiKeyData KeysData_6;
		public ImGuiKeyData KeysData_7;
		public ImGuiKeyData KeysData_8;
		public ImGuiKeyData KeysData_9;
		public ImGuiKeyData KeysData_10;
		public ImGuiKeyData KeysData_11;
		public ImGuiKeyData KeysData_12;
		public ImGuiKeyData KeysData_13;
		public ImGuiKeyData KeysData_14;
		public ImGuiKeyData KeysData_15;
		public ImGuiKeyData KeysData_16;
		public ImGuiKeyData KeysData_17;
		public ImGuiKeyData KeysData_18;
		public ImGuiKeyData KeysData_19;
		public ImGuiKeyData KeysData_20;
		public ImGuiKeyData KeysData_21;
		public ImGuiKeyData KeysData_22;
		public ImGuiKeyData KeysData_23;
		public ImGuiKeyData KeysData_24;
		public ImGuiKeyData KeysData_25;
		public ImGuiKeyData KeysData_26;
		public ImGuiKeyData KeysData_27;
		public ImGuiKeyData KeysData_28;
		public ImGuiKeyData KeysData_29;
		public ImGuiKeyData KeysData_30;
		public ImGuiKeyData KeysData_31;
		public ImGuiKeyData KeysData_32;
		public ImGuiKeyData KeysData_33;
		public ImGuiKeyData KeysData_34;
		public ImGuiKeyData KeysData_35;
		public ImGuiKeyData KeysData_36;
		public ImGuiKeyData KeysData_37;
		public ImGuiKeyData KeysData_38;
		public ImGuiKeyData KeysData_39;
		public ImGuiKeyData KeysData_40;
		public ImGuiKeyData KeysData_41;
		public ImGuiKeyData KeysData_42;
		public ImGuiKeyData KeysData_43;
		public ImGuiKeyData KeysData_44;
		public ImGuiKeyData KeysData_45;
		public ImGuiKeyData KeysData_46;
		public ImGuiKeyData KeysData_47;
		public ImGuiKeyData KeysData_48;
		public ImGuiKeyData KeysData_49;
		public ImGuiKeyData KeysData_50;
		public ImGuiKeyData KeysData_51;
		public ImGuiKeyData KeysData_52;
		public ImGuiKeyData KeysData_53;
		public ImGuiKeyData KeysData_54;
		public ImGuiKeyData KeysData_55;
		public ImGuiKeyData KeysData_56;
		public ImGuiKeyData KeysData_57;
		public ImGuiKeyData KeysData_58;
		public ImGuiKeyData KeysData_59;
		public ImGuiKeyData KeysData_60;
		public ImGuiKeyData KeysData_61;
		public ImGuiKeyData KeysData_62;
		public ImGuiKeyData KeysData_63;
		public ImGuiKeyData KeysData_64;
		public ImGuiKeyData KeysData_65;
		public ImGuiKeyData KeysData_66;
		public ImGuiKeyData KeysData_67;
		public ImGuiKeyData KeysData_68;
		public ImGuiKeyData KeysData_69;
		public ImGuiKeyData KeysData_70;
		public ImGuiKeyData KeysData_71;
		public ImGuiKeyData KeysData_72;
		public ImGuiKeyData KeysData_73;
		public ImGuiKeyData KeysData_74;
		public ImGuiKeyData KeysData_75;
		public ImGuiKeyData KeysData_76;
		public ImGuiKeyData KeysData_77;
		public ImGuiKeyData KeysData_78;
		public ImGuiKeyData KeysData_79;
		public ImGuiKeyData KeysData_80;
		public ImGuiKeyData KeysData_81;
		public ImGuiKeyData KeysData_82;
		public ImGuiKeyData KeysData_83;
		public ImGuiKeyData KeysData_84;
		public ImGuiKeyData KeysData_85;
		public ImGuiKeyData KeysData_86;
		public ImGuiKeyData KeysData_87;
		public ImGuiKeyData KeysData_88;
		public ImGuiKeyData KeysData_89;
		public ImGuiKeyData KeysData_90;
		public ImGuiKeyData KeysData_91;
		public ImGuiKeyData KeysData_92;
		public ImGuiKeyData KeysData_93;
		public ImGuiKeyData KeysData_94;
		public ImGuiKeyData KeysData_95;
		public ImGuiKeyData KeysData_96;
		public ImGuiKeyData KeysData_97;
		public ImGuiKeyData KeysData_98;
		public ImGuiKeyData KeysData_99;
		public ImGuiKeyData KeysData_100;
		public ImGuiKeyData KeysData_101;
		public ImGuiKeyData KeysData_102;
		public ImGuiKeyData KeysData_103;
		public ImGuiKeyData KeysData_104;
		public ImGuiKeyData KeysData_105;
		public ImGuiKeyData KeysData_106;
		public ImGuiKeyData KeysData_107;
		public ImGuiKeyData KeysData_108;
		public ImGuiKeyData KeysData_109;
		public ImGuiKeyData KeysData_110;
		public ImGuiKeyData KeysData_111;
		public ImGuiKeyData KeysData_112;
		public ImGuiKeyData KeysData_113;
		public ImGuiKeyData KeysData_114;
		public ImGuiKeyData KeysData_115;
		public ImGuiKeyData KeysData_116;
		public ImGuiKeyData KeysData_117;
		public ImGuiKeyData KeysData_118;
		public ImGuiKeyData KeysData_119;
		public ImGuiKeyData KeysData_120;
		public ImGuiKeyData KeysData_121;
		public ImGuiKeyData KeysData_122;
		public ImGuiKeyData KeysData_123;
		public ImGuiKeyData KeysData_124;
		public ImGuiKeyData KeysData_125;
		public ImGuiKeyData KeysData_126;
		public ImGuiKeyData KeysData_127;
		public ImGuiKeyData KeysData_128;
		public ImGuiKeyData KeysData_129;
		public ImGuiKeyData KeysData_130;
		public ImGuiKeyData KeysData_131;
		public ImGuiKeyData KeysData_132;
		public ImGuiKeyData KeysData_133;
		public ImGuiKeyData KeysData_134;
		public ImGuiKeyData KeysData_135;
		public ImGuiKeyData KeysData_136;
		public ImGuiKeyData KeysData_137;
		public ImGuiKeyData KeysData_138;
		public ImGuiKeyData KeysData_139;
		public ImGuiKeyData KeysData_140;
		public ImGuiKeyData KeysData_141;
		public ImGuiKeyData KeysData_142;
		public ImGuiKeyData KeysData_143;
		public ImGuiKeyData KeysData_144;
		public ImGuiKeyData KeysData_145;
		public ImGuiKeyData KeysData_146;
		public ImGuiKeyData KeysData_147;
		public ImGuiKeyData KeysData_148;
		public ImGuiKeyData KeysData_149;
		public ImGuiKeyData KeysData_150;
		public ImGuiKeyData KeysData_151;
		public ImGuiKeyData KeysData_152;
		public ImGuiKeyData KeysData_153;
		public ImGuiKeyData KeysData_154;
		public ImGuiKeyData KeysData_155;
		public ImGuiKeyData KeysData_156;
		public ImGuiKeyData KeysData_157;
		public ImGuiKeyData KeysData_158;
		public ImGuiKeyData KeysData_159;
		public ImGuiKeyData KeysData_160;
		public ImGuiKeyData KeysData_161;
		public ImGuiKeyData KeysData_162;
		public ImGuiKeyData KeysData_163;
		public ImGuiKeyData KeysData_164;
		public ImGuiKeyData KeysData_165;
		public ImGuiKeyData KeysData_166;
		public ImGuiKeyData KeysData_167;
		public ImGuiKeyData KeysData_168;
		public ImGuiKeyData KeysData_169;
		public ImGuiKeyData KeysData_170;
		public ImGuiKeyData KeysData_171;
		public ImGuiKeyData KeysData_172;
		public ImGuiKeyData KeysData_173;
		public ImGuiKeyData KeysData_174;
		public ImGuiKeyData KeysData_175;
		public ImGuiKeyData KeysData_176;
		public ImGuiKeyData KeysData_177;
		public ImGuiKeyData KeysData_178;
		public ImGuiKeyData KeysData_179;
		public ImGuiKeyData KeysData_180;
		public ImGuiKeyData KeysData_181;
		public ImGuiKeyData KeysData_182;
		public ImGuiKeyData KeysData_183;
		public ImGuiKeyData KeysData_184;
		public ImGuiKeyData KeysData_185;
		public ImGuiKeyData KeysData_186;
		public ImGuiKeyData KeysData_187;
		public ImGuiKeyData KeysData_188;
		public ImGuiKeyData KeysData_189;
		public ImGuiKeyData KeysData_190;
		public ImGuiKeyData KeysData_191;
		public ImGuiKeyData KeysData_192;
		public ImGuiKeyData KeysData_193;
		public ImGuiKeyData KeysData_194;
		public ImGuiKeyData KeysData_195;
		public ImGuiKeyData KeysData_196;
		public ImGuiKeyData KeysData_197;
		public ImGuiKeyData KeysData_198;
		public ImGuiKeyData KeysData_199;
		public ImGuiKeyData KeysData_200;
		public ImGuiKeyData KeysData_201;
		public ImGuiKeyData KeysData_202;
		public ImGuiKeyData KeysData_203;
		public ImGuiKeyData KeysData_204;
		public ImGuiKeyData KeysData_205;
		public ImGuiKeyData KeysData_206;
		public ImGuiKeyData KeysData_207;
		public ImGuiKeyData KeysData_208;
		public ImGuiKeyData KeysData_209;
		public ImGuiKeyData KeysData_210;
		public ImGuiKeyData KeysData_211;
		public ImGuiKeyData KeysData_212;
		public ImGuiKeyData KeysData_213;
		public ImGuiKeyData KeysData_214;
		public ImGuiKeyData KeysData_215;
		public ImGuiKeyData KeysData_216;
		public ImGuiKeyData KeysData_217;
		public ImGuiKeyData KeysData_218;
		public ImGuiKeyData KeysData_219;
		public ImGuiKeyData KeysData_220;
		public ImGuiKeyData KeysData_221;
		public ImGuiKeyData KeysData_222;
		public ImGuiKeyData KeysData_223;
		public ImGuiKeyData KeysData_224;
		public ImGuiKeyData KeysData_225;
		public ImGuiKeyData KeysData_226;
		public ImGuiKeyData KeysData_227;
		public ImGuiKeyData KeysData_228;
		public ImGuiKeyData KeysData_229;
		public ImGuiKeyData KeysData_230;
		public ImGuiKeyData KeysData_231;
		public ImGuiKeyData KeysData_232;
		public ImGuiKeyData KeysData_233;
		public ImGuiKeyData KeysData_234;
		public ImGuiKeyData KeysData_235;
		public ImGuiKeyData KeysData_236;
		public ImGuiKeyData KeysData_237;
		public ImGuiKeyData KeysData_238;
		public ImGuiKeyData KeysData_239;
		public ImGuiKeyData KeysData_240;
		public ImGuiKeyData KeysData_241;
		public ImGuiKeyData KeysData_242;
		public ImGuiKeyData KeysData_243;
		public ImGuiKeyData KeysData_244;
		public ImGuiKeyData KeysData_245;
		public ImGuiKeyData KeysData_246;
		public ImGuiKeyData KeysData_247;
		public ImGuiKeyData KeysData_248;
		public ImGuiKeyData KeysData_249;
		public ImGuiKeyData KeysData_250;
		public ImGuiKeyData KeysData_251;
		public ImGuiKeyData KeysData_252;
		public ImGuiKeyData KeysData_253;
		public ImGuiKeyData KeysData_254;
		public ImGuiKeyData KeysData_255;
		public ImGuiKeyData KeysData_256;
		public ImGuiKeyData KeysData_257;
		public ImGuiKeyData KeysData_258;
		public ImGuiKeyData KeysData_259;
		public ImGuiKeyData KeysData_260;
		public ImGuiKeyData KeysData_261;
		public ImGuiKeyData KeysData_262;
		public ImGuiKeyData KeysData_263;
		public ImGuiKeyData KeysData_264;
		public ImGuiKeyData KeysData_265;
		public ImGuiKeyData KeysData_266;
		public ImGuiKeyData KeysData_267;
		public ImGuiKeyData KeysData_268;
		public ImGuiKeyData KeysData_269;
		public ImGuiKeyData KeysData_270;
		public ImGuiKeyData KeysData_271;
		public ImGuiKeyData KeysData_272;
		public ImGuiKeyData KeysData_273;
		public ImGuiKeyData KeysData_274;
		public ImGuiKeyData KeysData_275;
		public ImGuiKeyData KeysData_276;
		public ImGuiKeyData KeysData_277;
		public ImGuiKeyData KeysData_278;
		public ImGuiKeyData KeysData_279;
		public ImGuiKeyData KeysData_280;
		public ImGuiKeyData KeysData_281;
		public ImGuiKeyData KeysData_282;
		public ImGuiKeyData KeysData_283;
		public ImGuiKeyData KeysData_284;
		public ImGuiKeyData KeysData_285;
		public ImGuiKeyData KeysData_286;
		public ImGuiKeyData KeysData_287;
		public ImGuiKeyData KeysData_288;
		public ImGuiKeyData KeysData_289;
		public ImGuiKeyData KeysData_290;
		public ImGuiKeyData KeysData_291;
		public ImGuiKeyData KeysData_292;
		public ImGuiKeyData KeysData_293;
		public ImGuiKeyData KeysData_294;
		public ImGuiKeyData KeysData_295;
		public ImGuiKeyData KeysData_296;
		public ImGuiKeyData KeysData_297;
		public ImGuiKeyData KeysData_298;
		public ImGuiKeyData KeysData_299;
		public ImGuiKeyData KeysData_300;
		public ImGuiKeyData KeysData_301;
		public ImGuiKeyData KeysData_302;
		public ImGuiKeyData KeysData_303;
		public ImGuiKeyData KeysData_304;
		public ImGuiKeyData KeysData_305;
		public ImGuiKeyData KeysData_306;
		public ImGuiKeyData KeysData_307;
		public ImGuiKeyData KeysData_308;
		public ImGuiKeyData KeysData_309;
		public ImGuiKeyData KeysData_310;
		public ImGuiKeyData KeysData_311;
		public ImGuiKeyData KeysData_312;
		public ImGuiKeyData KeysData_313;
		public ImGuiKeyData KeysData_314;
		public ImGuiKeyData KeysData_315;
		public ImGuiKeyData KeysData_316;
		public ImGuiKeyData KeysData_317;
		public ImGuiKeyData KeysData_318;
		public ImGuiKeyData KeysData_319;
		public ImGuiKeyData KeysData_320;
		public ImGuiKeyData KeysData_321;
		public ImGuiKeyData KeysData_322;
		public ImGuiKeyData KeysData_323;
		public ImGuiKeyData KeysData_324;
		public ImGuiKeyData KeysData_325;
		public ImGuiKeyData KeysData_326;
		public ImGuiKeyData KeysData_327;
		public ImGuiKeyData KeysData_328;
		public ImGuiKeyData KeysData_329;
		public ImGuiKeyData KeysData_330;
		public ImGuiKeyData KeysData_331;
		public ImGuiKeyData KeysData_332;
		public ImGuiKeyData KeysData_333;
		public ImGuiKeyData KeysData_334;
		public ImGuiKeyData KeysData_335;
		public ImGuiKeyData KeysData_336;
		public ImGuiKeyData KeysData_337;
		public ImGuiKeyData KeysData_338;
		public ImGuiKeyData KeysData_339;
		public ImGuiKeyData KeysData_340;
		public ImGuiKeyData KeysData_341;
		public ImGuiKeyData KeysData_342;
		public ImGuiKeyData KeysData_343;
		public ImGuiKeyData KeysData_344;
		public ImGuiKeyData KeysData_345;
		public ImGuiKeyData KeysData_346;
		public ImGuiKeyData KeysData_347;
		public ImGuiKeyData KeysData_348;
		public ImGuiKeyData KeysData_349;
		public ImGuiKeyData KeysData_350;
		public ImGuiKeyData KeysData_351;
		public ImGuiKeyData KeysData_352;
		public ImGuiKeyData KeysData_353;
		public ImGuiKeyData KeysData_354;
		public ImGuiKeyData KeysData_355;
		public ImGuiKeyData KeysData_356;
		public ImGuiKeyData KeysData_357;
		public ImGuiKeyData KeysData_358;
		public ImGuiKeyData KeysData_359;
		public ImGuiKeyData KeysData_360;
		public ImGuiKeyData KeysData_361;
		public ImGuiKeyData KeysData_362;
		public ImGuiKeyData KeysData_363;
		public ImGuiKeyData KeysData_364;
		public ImGuiKeyData KeysData_365;
		public ImGuiKeyData KeysData_366;
		public ImGuiKeyData KeysData_367;
		public ImGuiKeyData KeysData_368;
		public ImGuiKeyData KeysData_369;
		public ImGuiKeyData KeysData_370;
		public ImGuiKeyData KeysData_371;
		public ImGuiKeyData KeysData_372;
		public ImGuiKeyData KeysData_373;
		public ImGuiKeyData KeysData_374;
		public ImGuiKeyData KeysData_375;
		public ImGuiKeyData KeysData_376;
		public ImGuiKeyData KeysData_377;
		public ImGuiKeyData KeysData_378;
		public ImGuiKeyData KeysData_379;
		public ImGuiKeyData KeysData_380;
		public ImGuiKeyData KeysData_381;
		public ImGuiKeyData KeysData_382;
		public ImGuiKeyData KeysData_383;
		public ImGuiKeyData KeysData_384;
		public ImGuiKeyData KeysData_385;
		public ImGuiKeyData KeysData_386;
		public ImGuiKeyData KeysData_387;
		public ImGuiKeyData KeysData_388;
		public ImGuiKeyData KeysData_389;
		public ImGuiKeyData KeysData_390;
		public ImGuiKeyData KeysData_391;
		public ImGuiKeyData KeysData_392;
		public ImGuiKeyData KeysData_393;
		public ImGuiKeyData KeysData_394;
		public ImGuiKeyData KeysData_395;
		public ImGuiKeyData KeysData_396;
		public ImGuiKeyData KeysData_397;
		public ImGuiKeyData KeysData_398;
		public ImGuiKeyData KeysData_399;
		public ImGuiKeyData KeysData_400;
		public ImGuiKeyData KeysData_401;
		public ImGuiKeyData KeysData_402;
		public ImGuiKeyData KeysData_403;
		public ImGuiKeyData KeysData_404;
		public ImGuiKeyData KeysData_405;
		public ImGuiKeyData KeysData_406;
		public ImGuiKeyData KeysData_407;
		public ImGuiKeyData KeysData_408;
		public ImGuiKeyData KeysData_409;
		public ImGuiKeyData KeysData_410;
		public ImGuiKeyData KeysData_411;
		public ImGuiKeyData KeysData_412;
		public ImGuiKeyData KeysData_413;
		public ImGuiKeyData KeysData_414;
		public ImGuiKeyData KeysData_415;
		public ImGuiKeyData KeysData_416;
		public ImGuiKeyData KeysData_417;
		public ImGuiKeyData KeysData_418;
		public ImGuiKeyData KeysData_419;
		public ImGuiKeyData KeysData_420;
		public ImGuiKeyData KeysData_421;
		public ImGuiKeyData KeysData_422;
		public ImGuiKeyData KeysData_423;
		public ImGuiKeyData KeysData_424;
		public ImGuiKeyData KeysData_425;
		public ImGuiKeyData KeysData_426;
		public ImGuiKeyData KeysData_427;
		public ImGuiKeyData KeysData_428;
		public ImGuiKeyData KeysData_429;
		public ImGuiKeyData KeysData_430;
		public ImGuiKeyData KeysData_431;
		public ImGuiKeyData KeysData_432;
		public ImGuiKeyData KeysData_433;
		public ImGuiKeyData KeysData_434;
		public ImGuiKeyData KeysData_435;
		public ImGuiKeyData KeysData_436;
		public ImGuiKeyData KeysData_437;
		public ImGuiKeyData KeysData_438;
		public ImGuiKeyData KeysData_439;
		public ImGuiKeyData KeysData_440;
		public ImGuiKeyData KeysData_441;
		public ImGuiKeyData KeysData_442;
		public ImGuiKeyData KeysData_443;
		public ImGuiKeyData KeysData_444;
		public ImGuiKeyData KeysData_445;
		public ImGuiKeyData KeysData_446;
		public ImGuiKeyData KeysData_447;
		public ImGuiKeyData KeysData_448;
		public ImGuiKeyData KeysData_449;
		public ImGuiKeyData KeysData_450;
		public ImGuiKeyData KeysData_451;
		public ImGuiKeyData KeysData_452;
		public ImGuiKeyData KeysData_453;
		public ImGuiKeyData KeysData_454;
		public ImGuiKeyData KeysData_455;
		public ImGuiKeyData KeysData_456;
		public ImGuiKeyData KeysData_457;
		public ImGuiKeyData KeysData_458;
		public ImGuiKeyData KeysData_459;
		public ImGuiKeyData KeysData_460;
		public ImGuiKeyData KeysData_461;
		public ImGuiKeyData KeysData_462;
		public ImGuiKeyData KeysData_463;
		public ImGuiKeyData KeysData_464;
		public ImGuiKeyData KeysData_465;
		public ImGuiKeyData KeysData_466;
		public ImGuiKeyData KeysData_467;
		public ImGuiKeyData KeysData_468;
		public ImGuiKeyData KeysData_469;
		public ImGuiKeyData KeysData_470;
		public ImGuiKeyData KeysData_471;
		public ImGuiKeyData KeysData_472;
		public ImGuiKeyData KeysData_473;
		public ImGuiKeyData KeysData_474;
		public ImGuiKeyData KeysData_475;
		public ImGuiKeyData KeysData_476;
		public ImGuiKeyData KeysData_477;
		public ImGuiKeyData KeysData_478;
		public ImGuiKeyData KeysData_479;
		public ImGuiKeyData KeysData_480;
		public ImGuiKeyData KeysData_481;
		public ImGuiKeyData KeysData_482;
		public ImGuiKeyData KeysData_483;
		public ImGuiKeyData KeysData_484;
		public ImGuiKeyData KeysData_485;
		public ImGuiKeyData KeysData_486;
		public ImGuiKeyData KeysData_487;
		public ImGuiKeyData KeysData_488;
		public ImGuiKeyData KeysData_489;
		public ImGuiKeyData KeysData_490;
		public ImGuiKeyData KeysData_491;
		public ImGuiKeyData KeysData_492;
		public ImGuiKeyData KeysData_493;
		public ImGuiKeyData KeysData_494;
		public ImGuiKeyData KeysData_495;
		public ImGuiKeyData KeysData_496;
		public ImGuiKeyData KeysData_497;
		public ImGuiKeyData KeysData_498;
		public ImGuiKeyData KeysData_499;
		public ImGuiKeyData KeysData_500;
		public ImGuiKeyData KeysData_501;
		public ImGuiKeyData KeysData_502;
		public ImGuiKeyData KeysData_503;
		public ImGuiKeyData KeysData_504;
		public ImGuiKeyData KeysData_505;
		public ImGuiKeyData KeysData_506;
		public ImGuiKeyData KeysData_507;
		public ImGuiKeyData KeysData_508;
		public ImGuiKeyData KeysData_509;
		public ImGuiKeyData KeysData_510;
		public ImGuiKeyData KeysData_511;
		public ImGuiKeyData KeysData_512;
		public ImGuiKeyData KeysData_513;
		public ImGuiKeyData KeysData_514;
		public ImGuiKeyData KeysData_515;
		public ImGuiKeyData KeysData_516;
		public ImGuiKeyData KeysData_517;
		public ImGuiKeyData KeysData_518;
		public ImGuiKeyData KeysData_519;
		public ImGuiKeyData KeysData_520;
		public ImGuiKeyData KeysData_521;
		public ImGuiKeyData KeysData_522;
		public ImGuiKeyData KeysData_523;
		public ImGuiKeyData KeysData_524;
		public ImGuiKeyData KeysData_525;
		public ImGuiKeyData KeysData_526;
		public ImGuiKeyData KeysData_527;
		public ImGuiKeyData KeysData_528;
		public ImGuiKeyData KeysData_529;
		public ImGuiKeyData KeysData_530;
		public ImGuiKeyData KeysData_531;
		public ImGuiKeyData KeysData_532;
		public ImGuiKeyData KeysData_533;
		public ImGuiKeyData KeysData_534;
		public ImGuiKeyData KeysData_535;
		public ImGuiKeyData KeysData_536;
		public ImGuiKeyData KeysData_537;
		public ImGuiKeyData KeysData_538;
		public ImGuiKeyData KeysData_539;
		public ImGuiKeyData KeysData_540;
		public ImGuiKeyData KeysData_541;
		public ImGuiKeyData KeysData_542;
		public ImGuiKeyData KeysData_543;
		public ImGuiKeyData KeysData_544;
		public ImGuiKeyData KeysData_545;
		public ImGuiKeyData KeysData_546;
		public ImGuiKeyData KeysData_547;
		public ImGuiKeyData KeysData_548;
		public ImGuiKeyData KeysData_549;
		public ImGuiKeyData KeysData_550;
		public ImGuiKeyData KeysData_551;
		public ImGuiKeyData KeysData_552;
		public ImGuiKeyData KeysData_553;
		public ImGuiKeyData KeysData_554;
		public ImGuiKeyData KeysData_555;
		public ImGuiKeyData KeysData_556;
		public ImGuiKeyData KeysData_557;
		public ImGuiKeyData KeysData_558;
		public ImGuiKeyData KeysData_559;
		public ImGuiKeyData KeysData_560;
		public ImGuiKeyData KeysData_561;
		public ImGuiKeyData KeysData_562;
		public ImGuiKeyData KeysData_563;
		public ImGuiKeyData KeysData_564;
		public ImGuiKeyData KeysData_565;
		public ImGuiKeyData KeysData_566;
		public ImGuiKeyData KeysData_567;
		public ImGuiKeyData KeysData_568;
		public ImGuiKeyData KeysData_569;
		public ImGuiKeyData KeysData_570;
		public ImGuiKeyData KeysData_571;
		public ImGuiKeyData KeysData_572;
		public ImGuiKeyData KeysData_573;
		public ImGuiKeyData KeysData_574;
		public ImGuiKeyData KeysData_575;
		public ImGuiKeyData KeysData_576;
		public ImGuiKeyData KeysData_577;
		public ImGuiKeyData KeysData_578;
		public ImGuiKeyData KeysData_579;
		public ImGuiKeyData KeysData_580;
		public ImGuiKeyData KeysData_581;
		public ImGuiKeyData KeysData_582;
		public ImGuiKeyData KeysData_583;
		public ImGuiKeyData KeysData_584;
		public ImGuiKeyData KeysData_585;
		public ImGuiKeyData KeysData_586;
		public ImGuiKeyData KeysData_587;
		public ImGuiKeyData KeysData_588;
		public ImGuiKeyData KeysData_589;
		public ImGuiKeyData KeysData_590;
		public ImGuiKeyData KeysData_591;
		public ImGuiKeyData KeysData_592;
		public ImGuiKeyData KeysData_593;
		public ImGuiKeyData KeysData_594;
		public ImGuiKeyData KeysData_595;
		public ImGuiKeyData KeysData_596;
		public ImGuiKeyData KeysData_597;
		public ImGuiKeyData KeysData_598;
		public ImGuiKeyData KeysData_599;
		public ImGuiKeyData KeysData_600;
		public ImGuiKeyData KeysData_601;
		public ImGuiKeyData KeysData_602;
		public ImGuiKeyData KeysData_603;
		public ImGuiKeyData KeysData_604;
		public ImGuiKeyData KeysData_605;
		public ImGuiKeyData KeysData_606;
		public ImGuiKeyData KeysData_607;
		public ImGuiKeyData KeysData_608;
		public ImGuiKeyData KeysData_609;
		public ImGuiKeyData KeysData_610;
		public ImGuiKeyData KeysData_611;
		public ImGuiKeyData KeysData_612;
		public ImGuiKeyData KeysData_613;
		public ImGuiKeyData KeysData_614;
		public ImGuiKeyData KeysData_615;
		public ImGuiKeyData KeysData_616;
		public ImGuiKeyData KeysData_617;
		public ImGuiKeyData KeysData_618;
		public ImGuiKeyData KeysData_619;
		public ImGuiKeyData KeysData_620;
		public ImGuiKeyData KeysData_621;
		public ImGuiKeyData KeysData_622;
		public ImGuiKeyData KeysData_623;
		public ImGuiKeyData KeysData_624;
		public ImGuiKeyData KeysData_625;
		public ImGuiKeyData KeysData_626;
		public ImGuiKeyData KeysData_627;
		public ImGuiKeyData KeysData_628;
		public ImGuiKeyData KeysData_629;
		public ImGuiKeyData KeysData_630;
		public ImGuiKeyData KeysData_631;
		public ImGuiKeyData KeysData_632;
		public ImGuiKeyData KeysData_633;
		public ImGuiKeyData KeysData_634;
		public ImGuiKeyData KeysData_635;
		public ImGuiKeyData KeysData_636;
		public ImGuiKeyData KeysData_637;
		public ImGuiKeyData KeysData_638;
		public ImGuiKeyData KeysData_639;
		public ImGuiKeyData KeysData_640;
		public ImGuiKeyData KeysData_641;
		public ImGuiKeyData KeysData_642;
		public ImGuiKeyData KeysData_643;
		public ImGuiKeyData KeysData_644;
		public ImGuiKeyData KeysData_645;
		public ImGuiKeyData KeysData_646;
		public ImGuiKeyData KeysData_647;
		public ImGuiKeyData KeysData_648;
		public ImGuiKeyData KeysData_649;
		public ImGuiKeyData KeysData_650;
		public ImGuiKeyData KeysData_651;
		public byte WantCaptureMouseUnlessPopupClose;
		public Vector2 MousePosPrev;
		public Vector2 MouseClickedPos_0;
		public Vector2 MouseClickedPos_1;
		public Vector2 MouseClickedPos_2;
		public Vector2 MouseClickedPos_3;
		public Vector2 MouseClickedPos_4;
		public double MouseClickedTime_0;
		public double MouseClickedTime_1;
		public double MouseClickedTime_2;
		public double MouseClickedTime_3;
		public double MouseClickedTime_4;
		public bool MouseClicked_0;
		public bool MouseClicked_1;
		public bool MouseClicked_2;
		public bool MouseClicked_3;
		public bool MouseClicked_4;
		public bool MouseDoubleClicked_0;
		public bool MouseDoubleClicked_1;
		public bool MouseDoubleClicked_2;
		public bool MouseDoubleClicked_3;
		public bool MouseDoubleClicked_4;
		public ushort MouseClickedCount_0;
		public ushort MouseClickedCount_1;
		public ushort MouseClickedCount_2;
		public ushort MouseClickedCount_3;
		public ushort MouseClickedCount_4;
		public ushort MouseClickedLastCount_0;
		public ushort MouseClickedLastCount_1;
		public ushort MouseClickedLastCount_2;
		public ushort MouseClickedLastCount_3;
		public ushort MouseClickedLastCount_4;
		public bool MouseReleased_0;
		public bool MouseReleased_1;
		public bool MouseReleased_2;
		public bool MouseReleased_3;
		public bool MouseReleased_4;
		public bool MouseDownOwned_0;
		public bool MouseDownOwned_1;
		public bool MouseDownOwned_2;
		public bool MouseDownOwned_3;
		public bool MouseDownOwned_4;
		public bool MouseDownOwnedUnlessPopupClose_0;
		public bool MouseDownOwnedUnlessPopupClose_1;
		public bool MouseDownOwnedUnlessPopupClose_2;
		public bool MouseDownOwnedUnlessPopupClose_3;
		public bool MouseDownOwnedUnlessPopupClose_4;
		public byte MouseWheelRequestAxisSwap;
		public float MouseDownDuration_0;
		public float MouseDownDuration_1;
		public float MouseDownDuration_2;
		public float MouseDownDuration_3;
		public float MouseDownDuration_4;
		public float MouseDownDurationPrev_0;
		public float MouseDownDurationPrev_1;
		public float MouseDownDurationPrev_2;
		public float MouseDownDurationPrev_3;
		public float MouseDownDurationPrev_4;
		public Vector2 MouseDragMaxDistanceAbs_0;
		public Vector2 MouseDragMaxDistanceAbs_1;
		public Vector2 MouseDragMaxDistanceAbs_2;
		public Vector2 MouseDragMaxDistanceAbs_3;
		public Vector2 MouseDragMaxDistanceAbs_4;
		public float MouseDragMaxDistanceSqr_0;
		public float MouseDragMaxDistanceSqr_1;
		public float MouseDragMaxDistanceSqr_2;
		public float MouseDragMaxDistanceSqr_3;
		public float MouseDragMaxDistanceSqr_4;
		public float PenPressure;
		public byte AppFocusLost;
		public byte AppAcceptingEvents;
		public sbyte BackendUsingLegacyKeyArrays;
		public byte BackendUsingLegacyNavInputArray;
		public char InputQueueSurrogate;
		public ImVectorImWchar InputQueueCharacters;

		public unsafe Span<ImGuiKeyData> KeysData
		
		{
			get
			{
				fixed (ImGuiKeyData* p = &this.KeysData_0)
				{
					return new Span<ImGuiKeyData>(p, 652);
				}
			}
		}
		public unsafe Span<Vector2> MouseClickedPos
		
		{
			get
			{
				fixed (Vector2* p = &this.MouseClickedPos_0)
				{
					return new Span<Vector2>(p, 5);
				}
			}
		}
		public unsafe Span<Vector2> MouseDragMaxDistanceAbs
		
		{
			get
			{
				fixed (Vector2* p = &this.MouseDragMaxDistanceAbs_0)
				{
					return new Span<Vector2>(p, 5);
				}
			}
		}

		public unsafe void AddFocusEvent(bool focused)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddFocusEventNative(@this, focused ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddInputCharacter(uint c)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharacterNative(@this, c);
			}
		}

		public unsafe void AddInputCharactersUTF8(byte* str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharactersUTF8Native(@this, str);
			}
		}

		public unsafe void AddInputCharactersUTF8(ref byte str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.AddInputCharactersUTF8Native(@this, (byte*)pstr);
				}
			}
		}

		public unsafe void AddInputCharactersUTF8(string str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddInputCharactersUTF8Native(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddInputCharacterUTF16(char c)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharacterUTF16Native(@this, c);
			}
		}

		public unsafe void AddKeyAnalogEvent(ImGuiKey key, bool down, float v)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddKeyAnalogEventNative(@this, key, down ? (byte)1 : (byte)0, v);
			}
		}

		public unsafe void AddKeyEvent(ImGuiKey key, bool down)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddKeyEventNative(@this, key, down ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddMouseButtonEvent(int button, bool down)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseButtonEventNative(@this, button, down ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddMousePosEvent(float x, float y)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMousePosEventNative(@this, x, y);
			}
		}

		public unsafe void AddMouseSourceEvent(ImGuiMouseSource source)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseSourceEventNative(@this, source);
			}
		}

		public unsafe void AddMouseViewportEvent(int id)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseViewportEventNative(@this, id);
			}
		}

		public unsafe void AddMouseWheelEvent(float wheelX, float wheelY)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseWheelEventNative(@this, wheelX, wheelY);
			}
		}

		public unsafe void ClearInputCharacters()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.ClearInputCharactersNative(@this);
			}
		}

		public unsafe void ClearInputKeys()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.ClearInputKeysNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void SetAppAcceptingEvents(bool acceptingEvents)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetAppAcceptingEventsNative(@this, acceptingEvents ? (byte)1 : (byte)0);
			}
		}

		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetKeyEventNativeDataNative(@this, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			}
		}

		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetKeyEventNativeDataNative(@this, key, nativeKeycode, nativeScancode, (int)(-1));
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiIOPtr : IEquatable<ImGuiIOPtr>
	{
		public ImGuiIOPtr(ImGuiIO* handle) { Handle = handle; }

		public ImGuiIO* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiIOPtr Null => new ImGuiIOPtr(null);

		public static implicit operator ImGuiIOPtr(ImGuiIO* handle) => new ImGuiIOPtr(handle);

		public static implicit operator ImGuiIO*(ImGuiIOPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiIOPtr left, ImGuiIOPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiIOPtr left, ImGuiIOPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiIOPtr left, ImGuiIO* right) => left.Handle == right;

		public static bool operator !=(ImGuiIOPtr left, ImGuiIO* right) => left.Handle != right;

		public bool Equals(ImGuiIOPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiIOPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiIOPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiConfigFlags ConfigFlags => ref Unsafe.AsRef<ImGuiConfigFlags>(&Handle->ConfigFlags);
		public ref ImGuiBackendFlags BackendFlags => ref Unsafe.AsRef<ImGuiBackendFlags>(&Handle->BackendFlags);
		public ref Vector2 DisplaySize => ref Unsafe.AsRef<Vector2>(&Handle->DisplaySize);
		public ref float DeltaTime => ref Unsafe.AsRef<float>(&Handle->DeltaTime);
		public ref float IniSavingRate => ref Unsafe.AsRef<float>(&Handle->IniSavingRate);
		public byte* IniFilename { get => Handle->IniFilename; set => Handle->IniFilename = value; }
		public byte* LogFilename { get => Handle->LogFilename; set => Handle->LogFilename = value; }
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
		public ref ImFontAtlasPtr Fonts => ref Unsafe.AsRef<ImFontAtlasPtr>(&Handle->Fonts);
		public ref float FontGlobalScale => ref Unsafe.AsRef<float>(&Handle->FontGlobalScale);
		public ref bool FontAllowUserScaling => ref Unsafe.AsRef<bool>(&Handle->FontAllowUserScaling);
		public ref ImFontPtr FontDefault => ref Unsafe.AsRef<ImFontPtr>(&Handle->FontDefault);
		public ref Vector2 DisplayFramebufferScale => ref Unsafe.AsRef<Vector2>(&Handle->DisplayFramebufferScale);
		public ref bool ConfigDockingNoSplit => ref Unsafe.AsRef<bool>(&Handle->ConfigDockingNoSplit);
		public ref bool ConfigDockingWithShift => ref Unsafe.AsRef<bool>(&Handle->ConfigDockingWithShift);
		public ref bool ConfigDockingAlwaysTabBar => ref Unsafe.AsRef<bool>(&Handle->ConfigDockingAlwaysTabBar);
		public ref bool ConfigDockingTransparentPayload => ref Unsafe.AsRef<bool>(&Handle->ConfigDockingTransparentPayload);
		public ref bool ConfigViewportsNoAutoMerge => ref Unsafe.AsRef<bool>(&Handle->ConfigViewportsNoAutoMerge);
		public ref bool ConfigViewportsNoTaskBarIcon => ref Unsafe.AsRef<bool>(&Handle->ConfigViewportsNoTaskBarIcon);
		public ref bool ConfigViewportsNoDecoration => ref Unsafe.AsRef<bool>(&Handle->ConfigViewportsNoDecoration);
		public ref bool ConfigViewportsNoDefaultParent => ref Unsafe.AsRef<bool>(&Handle->ConfigViewportsNoDefaultParent);
		public ref bool MouseDrawCursor => ref Unsafe.AsRef<bool>(&Handle->MouseDrawCursor);
		public ref bool ConfigMacOSXBehaviors => ref Unsafe.AsRef<bool>(&Handle->ConfigMacOSXBehaviors);
		public ref bool ConfigInputTrickleEventQueue => ref Unsafe.AsRef<bool>(&Handle->ConfigInputTrickleEventQueue);
		public ref bool ConfigInputTextCursorBlink => ref Unsafe.AsRef<bool>(&Handle->ConfigInputTextCursorBlink);
		public ref bool ConfigInputTextEnterKeepActive => ref Unsafe.AsRef<bool>(&Handle->ConfigInputTextEnterKeepActive);
		public ref bool ConfigDragClickToInputText => ref Unsafe.AsRef<bool>(&Handle->ConfigDragClickToInputText);
		public ref bool ConfigWindowsResizeFromEdges => ref Unsafe.AsRef<bool>(&Handle->ConfigWindowsResizeFromEdges);
		public ref bool ConfigWindowsMoveFromTitleBarOnly => ref Unsafe.AsRef<bool>(&Handle->ConfigWindowsMoveFromTitleBarOnly);
		public ref float ConfigMemoryCompactTimer => ref Unsafe.AsRef<float>(&Handle->ConfigMemoryCompactTimer);
		public ref float MouseDoubleClickTime => ref Unsafe.AsRef<float>(&Handle->MouseDoubleClickTime);
		public ref float MouseDoubleClickMaxDist => ref Unsafe.AsRef<float>(&Handle->MouseDoubleClickMaxDist);
		public ref float MouseDragThreshold => ref Unsafe.AsRef<float>(&Handle->MouseDragThreshold);
		public ref float KeyRepeatDelay => ref Unsafe.AsRef<float>(&Handle->KeyRepeatDelay);
		public ref float KeyRepeatRate => ref Unsafe.AsRef<float>(&Handle->KeyRepeatRate);
		public ref bool ConfigDebugBeginReturnValueOnce => ref Unsafe.AsRef<bool>(&Handle->ConfigDebugBeginReturnValueOnce);
		public ref bool ConfigDebugBeginReturnValueLoop => ref Unsafe.AsRef<bool>(&Handle->ConfigDebugBeginReturnValueLoop);
		public ref bool ConfigDebugIgnoreFocusLoss => ref Unsafe.AsRef<bool>(&Handle->ConfigDebugIgnoreFocusLoss);
		public ref bool ConfigDebugIniSettings => ref Unsafe.AsRef<bool>(&Handle->ConfigDebugIniSettings);
		public byte* BackendPlatformName { get => Handle->BackendPlatformName; set => Handle->BackendPlatformName = value; }
		public byte* BackendRendererName { get => Handle->BackendRendererName; set => Handle->BackendRendererName = value; }
		public void* BackendPlatformUserData { get => Handle->BackendPlatformUserData; set => Handle->BackendPlatformUserData = value; }
		public void* BackendRendererUserData { get => Handle->BackendRendererUserData; set => Handle->BackendRendererUserData = value; }
		public void* BackendLanguageUserData { get => Handle->BackendLanguageUserData; set => Handle->BackendLanguageUserData = value; }
		public void* GetClipboardTextFn { get => Handle->GetClipboardTextFn; set => Handle->GetClipboardTextFn = value; }
		public void* SetClipboardTextFn { get => Handle->SetClipboardTextFn; set => Handle->SetClipboardTextFn = value; }
		public void* ClipboardUserData { get => Handle->ClipboardUserData; set => Handle->ClipboardUserData = value; }
		public void* SetPlatformImeDataFn { get => Handle->SetPlatformImeDataFn; set => Handle->SetPlatformImeDataFn = value; }
		public void* UnusedPadding { get => Handle->UnusedPadding; set => Handle->UnusedPadding = value; }
		public ref bool WantCaptureMouse => ref Unsafe.AsRef<bool>(&Handle->WantCaptureMouse);
		public ref bool WantCaptureKeyboard => ref Unsafe.AsRef<bool>(&Handle->WantCaptureKeyboard);
		public ref bool WantTextInput => ref Unsafe.AsRef<bool>(&Handle->WantTextInput);
		public ref bool WantSetMousePos => ref Unsafe.AsRef<bool>(&Handle->WantSetMousePos);
		public ref bool WantSaveIniSettings => ref Unsafe.AsRef<bool>(&Handle->WantSaveIniSettings);
		public ref bool NavActive => ref Unsafe.AsRef<bool>(&Handle->NavActive);
		public ref bool NavVisible => ref Unsafe.AsRef<bool>(&Handle->NavVisible);
		public ref float Framerate => ref Unsafe.AsRef<float>(&Handle->Framerate);
		public ref int MetricsRenderVertices => ref Unsafe.AsRef<int>(&Handle->MetricsRenderVertices);
		public ref int MetricsRenderIndices => ref Unsafe.AsRef<int>(&Handle->MetricsRenderIndices);
		public ref int MetricsRenderWindows => ref Unsafe.AsRef<int>(&Handle->MetricsRenderWindows);
		public ref int MetricsActiveWindows => ref Unsafe.AsRef<int>(&Handle->MetricsActiveWindows);
		public ref int MetricsActiveAllocations => ref Unsafe.AsRef<int>(&Handle->MetricsActiveAllocations);
		public ref Vector2 MouseDelta => ref Unsafe.AsRef<Vector2>(&Handle->MouseDelta);
		public unsafe Span<int> KeyMap
		
		{
			get
			{
				return new Span<int>(&Handle->KeyMap_0, 652);
			}
		}
		public unsafe Span<bool> KeysDown
		
		{
			get
			{
				return new Span<bool>(&Handle->KeysDown_0, 652);
			}
		}
		public unsafe Span<float> NavInputs
		
		{
			get
			{
				return new Span<float>(&Handle->NavInputs_0, 16);
			}
		}
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		public ref Vector2 MousePos => ref Unsafe.AsRef<Vector2>(&Handle->MousePos);
		public unsafe Span<bool> MouseDown
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseDown_0, 5);
			}
		}
		public ref float MouseWheel => ref Unsafe.AsRef<float>(&Handle->MouseWheel);
		public ref float MouseWheelH => ref Unsafe.AsRef<float>(&Handle->MouseWheelH);
		public ref ImGuiMouseSource MouseSource => ref Unsafe.AsRef<ImGuiMouseSource>(&Handle->MouseSource);
		public ref int MouseHoveredViewport => ref Unsafe.AsRef<int>(&Handle->MouseHoveredViewport);
		public ref bool KeyCtrl => ref Unsafe.AsRef<bool>(&Handle->KeyCtrl);
		public ref bool KeyShift => ref Unsafe.AsRef<bool>(&Handle->KeyShift);
		public ref bool KeyAlt => ref Unsafe.AsRef<bool>(&Handle->KeyAlt);
		public ref bool KeySuper => ref Unsafe.AsRef<bool>(&Handle->KeySuper);
		public ref int KeyMods => ref Unsafe.AsRef<int>(&Handle->KeyMods);
		public unsafe Span<ImGuiKeyData> KeysData
		
		{
			get
			{
				return new Span<ImGuiKeyData>(&Handle->KeysData_0, 652);
			}
		}
		public ref bool WantCaptureMouseUnlessPopupClose => ref Unsafe.AsRef<bool>(&Handle->WantCaptureMouseUnlessPopupClose);
		public ref Vector2 MousePosPrev => ref Unsafe.AsRef<Vector2>(&Handle->MousePosPrev);
		public unsafe Span<Vector2> MouseClickedPos
		
		{
			get
			{
				return new Span<Vector2>(&Handle->MouseClickedPos_0, 5);
			}
		}
		public unsafe Span<double> MouseClickedTime
		
		{
			get
			{
				return new Span<double>(&Handle->MouseClickedTime_0, 5);
			}
		}
		public unsafe Span<bool> MouseClicked
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseClicked_0, 5);
			}
		}
		public unsafe Span<bool> MouseDoubleClicked
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseDoubleClicked_0, 5);
			}
		}
		public unsafe Span<ushort> MouseClickedCount
		
		{
			get
			{
				return new Span<ushort>(&Handle->MouseClickedCount_0, 5);
			}
		}
		public unsafe Span<ushort> MouseClickedLastCount
		
		{
			get
			{
				return new Span<ushort>(&Handle->MouseClickedLastCount_0, 5);
			}
		}
		public unsafe Span<bool> MouseReleased
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseReleased_0, 5);
			}
		}
		public unsafe Span<bool> MouseDownOwned
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseDownOwned_0, 5);
			}
		}
		public unsafe Span<bool> MouseDownOwnedUnlessPopupClose
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseDownOwnedUnlessPopupClose_0, 5);
			}
		}
		public ref bool MouseWheelRequestAxisSwap => ref Unsafe.AsRef<bool>(&Handle->MouseWheelRequestAxisSwap);
		public unsafe Span<float> MouseDownDuration
		
		{
			get
			{
				return new Span<float>(&Handle->MouseDownDuration_0, 5);
			}
		}
		public unsafe Span<float> MouseDownDurationPrev
		
		{
			get
			{
				return new Span<float>(&Handle->MouseDownDurationPrev_0, 5);
			}
		}
		public unsafe Span<Vector2> MouseDragMaxDistanceAbs
		
		{
			get
			{
				return new Span<Vector2>(&Handle->MouseDragMaxDistanceAbs_0, 5);
			}
		}
		public unsafe Span<float> MouseDragMaxDistanceSqr
		
		{
			get
			{
				return new Span<float>(&Handle->MouseDragMaxDistanceSqr_0, 5);
			}
		}
		public ref float PenPressure => ref Unsafe.AsRef<float>(&Handle->PenPressure);
		public ref bool AppFocusLost => ref Unsafe.AsRef<bool>(&Handle->AppFocusLost);
		public ref bool AppAcceptingEvents => ref Unsafe.AsRef<bool>(&Handle->AppAcceptingEvents);
		public ref sbyte BackendUsingLegacyKeyArrays => ref Unsafe.AsRef<sbyte>(&Handle->BackendUsingLegacyKeyArrays);
		public ref bool BackendUsingLegacyNavInputArray => ref Unsafe.AsRef<bool>(&Handle->BackendUsingLegacyNavInputArray);
		public ref char InputQueueSurrogate => ref Unsafe.AsRef<char>(&Handle->InputQueueSurrogate);
		public ref ImVectorImWchar InputQueueCharacters => ref Unsafe.AsRef<ImVectorImWchar>(&Handle->InputQueueCharacters);

		public unsafe void AddFocusEvent(bool focused)
		{
			ImGui.AddFocusEventNative(Handle, focused ? (byte)1 : (byte)0);
		}

		public unsafe void AddInputCharacter(uint c)
		{
			ImGui.AddInputCharacterNative(Handle, c);
		}

		public unsafe void AddInputCharactersUTF8(byte* str)
		{
			ImGui.AddInputCharactersUTF8Native(Handle, str);
		}

		public unsafe void AddInputCharactersUTF8(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				ImGui.AddInputCharactersUTF8Native(Handle, (byte*)pstr);
			}
		}

		public unsafe void AddInputCharactersUTF8(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddInputCharactersUTF8Native(Handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddInputCharacterUTF16(char c)
		{
			ImGui.AddInputCharacterUTF16Native(Handle, c);
		}

		public unsafe void AddKeyAnalogEvent(ImGuiKey key, bool down, float v)
		{
			ImGui.AddKeyAnalogEventNative(Handle, key, down ? (byte)1 : (byte)0, v);
		}

		public unsafe void AddKeyEvent(ImGuiKey key, bool down)
		{
			ImGui.AddKeyEventNative(Handle, key, down ? (byte)1 : (byte)0);
		}

		public unsafe void AddMouseButtonEvent(int button, bool down)
		{
			ImGui.AddMouseButtonEventNative(Handle, button, down ? (byte)1 : (byte)0);
		}

		public unsafe void AddMousePosEvent(float x, float y)
		{
			ImGui.AddMousePosEventNative(Handle, x, y);
		}

		public unsafe void AddMouseSourceEvent(ImGuiMouseSource source)
		{
			ImGui.AddMouseSourceEventNative(Handle, source);
		}

		public unsafe void AddMouseViewportEvent(int id)
		{
			ImGui.AddMouseViewportEventNative(Handle, id);
		}

		public unsafe void AddMouseWheelEvent(float wheelX, float wheelY)
		{
			ImGui.AddMouseWheelEventNative(Handle, wheelX, wheelY);
		}

		public unsafe void ClearInputCharacters()
		{
			ImGui.ClearInputCharactersNative(Handle);
		}

		public unsafe void ClearInputKeys()
		{
			ImGui.ClearInputKeysNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void SetAppAcceptingEvents(bool acceptingEvents)
		{
			ImGui.SetAppAcceptingEventsNative(Handle, acceptingEvents ? (byte)1 : (byte)0);
		}

		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			ImGui.SetKeyEventNativeDataNative(Handle, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
		}

		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			ImGui.SetKeyEventNativeDataNative(Handle, key, nativeKeycode, nativeScancode, (int)(-1));
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformImeData
	{
		public byte WantVisible;
		public Vector2 InputPos;
		public float InputLineHeight;


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformImeData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPlatformImeDataPtr : IEquatable<ImGuiPlatformImeDataPtr>
	{
		public ImGuiPlatformImeDataPtr(ImGuiPlatformImeData* handle) { Handle = handle; }

		public ImGuiPlatformImeData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPlatformImeDataPtr Null => new ImGuiPlatformImeDataPtr(null);

		public static implicit operator ImGuiPlatformImeDataPtr(ImGuiPlatformImeData* handle) => new ImGuiPlatformImeDataPtr(handle);

		public static implicit operator ImGuiPlatformImeData*(ImGuiPlatformImeDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPlatformImeDataPtr left, ImGuiPlatformImeDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPlatformImeDataPtr left, ImGuiPlatformImeDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPlatformImeDataPtr left, ImGuiPlatformImeData* right) => left.Handle == right;

		public static bool operator !=(ImGuiPlatformImeDataPtr left, ImGuiPlatformImeData* right) => left.Handle != right;

		public bool Equals(ImGuiPlatformImeDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPlatformImeDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPlatformImeDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref bool WantVisible => ref Unsafe.AsRef<bool>(&Handle->WantVisible);
		public ref Vector2 InputPos => ref Unsafe.AsRef<Vector2>(&Handle->InputPos);
		public ref float InputLineHeight => ref Unsafe.AsRef<float>(&Handle->InputLineHeight);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyData
	{
		public byte Down;
		public float DownDuration;
		public float DownDurationPrev;
		public float AnalogValue;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiKeyDataPtr : IEquatable<ImGuiKeyDataPtr>
	{
		public ImGuiKeyDataPtr(ImGuiKeyData* handle) { Handle = handle; }

		public ImGuiKeyData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiKeyDataPtr Null => new ImGuiKeyDataPtr(null);

		public static implicit operator ImGuiKeyDataPtr(ImGuiKeyData* handle) => new ImGuiKeyDataPtr(handle);

		public static implicit operator ImGuiKeyData*(ImGuiKeyDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiKeyDataPtr left, ImGuiKeyDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiKeyDataPtr left, ImGuiKeyDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiKeyDataPtr left, ImGuiKeyData* right) => left.Handle == right;

		public static bool operator !=(ImGuiKeyDataPtr left, ImGuiKeyData* right) => left.Handle != right;

		public bool Equals(ImGuiKeyDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiKeyDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiKeyDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref bool Down => ref Unsafe.AsRef<bool>(&Handle->Down);
		public ref float DownDuration => ref Unsafe.AsRef<float>(&Handle->DownDuration);
		public ref float DownDurationPrev => ref Unsafe.AsRef<float>(&Handle->DownDurationPrev);
		public ref float AnalogValue => ref Unsafe.AsRef<float>(&Handle->AnalogValue);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformIO
	{
		public unsafe void* PlatformCreateWindow;
		public unsafe void* PlatformDestroyWindow;
		public unsafe void* PlatformShowWindow;
		public unsafe void* PlatformSetWindowPos;
		public unsafe void* PlatformGetWindowPos;
		public unsafe void* PlatformSetWindowSize;
		public unsafe void* PlatformGetWindowSize;
		public unsafe void* PlatformSetWindowFocus;
		public unsafe void* PlatformGetWindowFocus;
		public unsafe void* PlatformGetWindowMinimized;
		public unsafe void* PlatformSetWindowTitle;
		public unsafe void* PlatformSetWindowAlpha;
		public unsafe void* PlatformUpdateWindow;
		public unsafe void* PlatformRenderWindow;
		public unsafe void* PlatformSwapBuffers;
		public unsafe void* PlatformGetWindowDpiScale;
		public unsafe void* PlatformOnChangedViewport;
		public unsafe void* PlatformCreateVkSurface;
		public unsafe void* RendererCreateWindow;
		public unsafe void* RendererDestroyWindow;
		public unsafe void* RendererSetWindowSize;
		public unsafe void* RendererRenderWindow;
		public unsafe void* RendererSwapBuffers;
		public ImVectorImGuiPlatformMonitor Monitors;
		public ImVectorImGuiViewportPtr Viewports;


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformIO* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPlatformIOPtr : IEquatable<ImGuiPlatformIOPtr>
	{
		public ImGuiPlatformIOPtr(ImGuiPlatformIO* handle) { Handle = handle; }

		public ImGuiPlatformIO* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPlatformIOPtr Null => new ImGuiPlatformIOPtr(null);

		public static implicit operator ImGuiPlatformIOPtr(ImGuiPlatformIO* handle) => new ImGuiPlatformIOPtr(handle);

		public static implicit operator ImGuiPlatformIO*(ImGuiPlatformIOPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPlatformIOPtr left, ImGuiPlatformIOPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPlatformIOPtr left, ImGuiPlatformIOPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPlatformIOPtr left, ImGuiPlatformIO* right) => left.Handle == right;

		public static bool operator !=(ImGuiPlatformIOPtr left, ImGuiPlatformIO* right) => left.Handle != right;

		public bool Equals(ImGuiPlatformIOPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPlatformIOPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPlatformIOPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public void* PlatformCreateWindow { get => Handle->PlatformCreateWindow; set => Handle->PlatformCreateWindow = value; }
		public void* PlatformDestroyWindow { get => Handle->PlatformDestroyWindow; set => Handle->PlatformDestroyWindow = value; }
		public void* PlatformShowWindow { get => Handle->PlatformShowWindow; set => Handle->PlatformShowWindow = value; }
		public void* PlatformSetWindowPos { get => Handle->PlatformSetWindowPos; set => Handle->PlatformSetWindowPos = value; }
		public void* PlatformGetWindowPos { get => Handle->PlatformGetWindowPos; set => Handle->PlatformGetWindowPos = value; }
		public void* PlatformSetWindowSize { get => Handle->PlatformSetWindowSize; set => Handle->PlatformSetWindowSize = value; }
		public void* PlatformGetWindowSize { get => Handle->PlatformGetWindowSize; set => Handle->PlatformGetWindowSize = value; }
		public void* PlatformSetWindowFocus { get => Handle->PlatformSetWindowFocus; set => Handle->PlatformSetWindowFocus = value; }
		public void* PlatformGetWindowFocus { get => Handle->PlatformGetWindowFocus; set => Handle->PlatformGetWindowFocus = value; }
		public void* PlatformGetWindowMinimized { get => Handle->PlatformGetWindowMinimized; set => Handle->PlatformGetWindowMinimized = value; }
		public void* PlatformSetWindowTitle { get => Handle->PlatformSetWindowTitle; set => Handle->PlatformSetWindowTitle = value; }
		public void* PlatformSetWindowAlpha { get => Handle->PlatformSetWindowAlpha; set => Handle->PlatformSetWindowAlpha = value; }
		public void* PlatformUpdateWindow { get => Handle->PlatformUpdateWindow; set => Handle->PlatformUpdateWindow = value; }
		public void* PlatformRenderWindow { get => Handle->PlatformRenderWindow; set => Handle->PlatformRenderWindow = value; }
		public void* PlatformSwapBuffers { get => Handle->PlatformSwapBuffers; set => Handle->PlatformSwapBuffers = value; }
		public void* PlatformGetWindowDpiScale { get => Handle->PlatformGetWindowDpiScale; set => Handle->PlatformGetWindowDpiScale = value; }
		public void* PlatformOnChangedViewport { get => Handle->PlatformOnChangedViewport; set => Handle->PlatformOnChangedViewport = value; }
		public void* PlatformCreateVkSurface { get => Handle->PlatformCreateVkSurface; set => Handle->PlatformCreateVkSurface = value; }
		public void* RendererCreateWindow { get => Handle->RendererCreateWindow; set => Handle->RendererCreateWindow = value; }
		public void* RendererDestroyWindow { get => Handle->RendererDestroyWindow; set => Handle->RendererDestroyWindow = value; }
		public void* RendererSetWindowSize { get => Handle->RendererSetWindowSize; set => Handle->RendererSetWindowSize = value; }
		public void* RendererRenderWindow { get => Handle->RendererRenderWindow; set => Handle->RendererRenderWindow = value; }
		public void* RendererSwapBuffers { get => Handle->RendererSwapBuffers; set => Handle->RendererSwapBuffers = value; }
		public ref ImVectorImGuiPlatformMonitor Monitors => ref Unsafe.AsRef<ImVectorImGuiPlatformMonitor>(&Handle->Monitors);
		public ref ImVectorImGuiViewportPtr Viewports => ref Unsafe.AsRef<ImVectorImGuiViewportPtr>(&Handle->Viewports);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPlatformMonitor
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPlatformMonitor* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformMonitor
	{
		public Vector2 MainPos;
		public Vector2 MainSize;
		public Vector2 WorkPos;
		public Vector2 WorkSize;
		public float DpiScale;
		public unsafe void* PlatformHandle;


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformMonitor* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPlatformMonitorPtr : IEquatable<ImGuiPlatformMonitorPtr>
	{
		public ImGuiPlatformMonitorPtr(ImGuiPlatformMonitor* handle) { Handle = handle; }

		public ImGuiPlatformMonitor* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPlatformMonitorPtr Null => new ImGuiPlatformMonitorPtr(null);

		public static implicit operator ImGuiPlatformMonitorPtr(ImGuiPlatformMonitor* handle) => new ImGuiPlatformMonitorPtr(handle);

		public static implicit operator ImGuiPlatformMonitor*(ImGuiPlatformMonitorPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPlatformMonitorPtr left, ImGuiPlatformMonitorPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPlatformMonitorPtr left, ImGuiPlatformMonitorPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPlatformMonitorPtr left, ImGuiPlatformMonitor* right) => left.Handle == right;

		public static bool operator !=(ImGuiPlatformMonitorPtr left, ImGuiPlatformMonitor* right) => left.Handle != right;

		public bool Equals(ImGuiPlatformMonitorPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPlatformMonitorPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPlatformMonitorPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref Vector2 MainPos => ref Unsafe.AsRef<Vector2>(&Handle->MainPos);
		public ref Vector2 MainSize => ref Unsafe.AsRef<Vector2>(&Handle->MainSize);
		public ref Vector2 WorkPos => ref Unsafe.AsRef<Vector2>(&Handle->WorkPos);
		public ref Vector2 WorkSize => ref Unsafe.AsRef<Vector2>(&Handle->WorkSize);
		public ref float DpiScale => ref Unsafe.AsRef<float>(&Handle->DpiScale);
		public void* PlatformHandle { get => Handle->PlatformHandle; set => Handle->PlatformHandle = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiViewport** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyle
	{
		public float Alpha;
		public float DisabledAlpha;
		public Vector2 WindowPadding;
		public float WindowRounding;
		public float WindowBorderSize;
		public Vector2 WindowMinSize;
		public Vector2 WindowTitleAlign;
		public ImGuiDir WindowMenuButtonPosition;
		public float ChildRounding;
		public float ChildBorderSize;
		public float PopupRounding;
		public float PopupBorderSize;
		public Vector2 FramePadding;
		public float FrameRounding;
		public float FrameBorderSize;
		public Vector2 ItemSpacing;
		public Vector2 ItemInnerSpacing;
		public Vector2 CellPadding;
		public Vector2 TouchExtraPadding;
		public float IndentSpacing;
		public float ColumnsMinSpacing;
		public float ScrollbarSize;
		public float ScrollbarRounding;
		public float GrabMinSize;
		public float GrabRounding;
		public float LogSliderDeadzone;
		public float TabRounding;
		public float TabBorderSize;
		public float TabMinWidthForCloseButton;
		public ImGuiDir ColorButtonPosition;
		public Vector2 ButtonTextAlign;
		public Vector2 SelectableTextAlign;
		public float SeparatorTextBorderSize;
		public Vector2 SeparatorTextAlign;
		public Vector2 SeparatorTextPadding;
		public Vector2 DisplayWindowPadding;
		public Vector2 DisplaySafeAreaPadding;
		public float MouseCursorScale;
		public byte AntiAliasedLines;
		public byte AntiAliasedLinesUseTex;
		public byte AntiAliasedFill;
		public float CurveTessellationTol;
		public float CircleTessellationMaxError;
		public Vector4 Colors_0;
		public Vector4 Colors_1;
		public Vector4 Colors_2;
		public Vector4 Colors_3;
		public Vector4 Colors_4;
		public Vector4 Colors_5;
		public Vector4 Colors_6;
		public Vector4 Colors_7;
		public Vector4 Colors_8;
		public Vector4 Colors_9;
		public Vector4 Colors_10;
		public Vector4 Colors_11;
		public Vector4 Colors_12;
		public Vector4 Colors_13;
		public Vector4 Colors_14;
		public Vector4 Colors_15;
		public Vector4 Colors_16;
		public Vector4 Colors_17;
		public Vector4 Colors_18;
		public Vector4 Colors_19;
		public Vector4 Colors_20;
		public Vector4 Colors_21;
		public Vector4 Colors_22;
		public Vector4 Colors_23;
		public Vector4 Colors_24;
		public Vector4 Colors_25;
		public Vector4 Colors_26;
		public Vector4 Colors_27;
		public Vector4 Colors_28;
		public Vector4 Colors_29;
		public Vector4 Colors_30;
		public Vector4 Colors_31;
		public Vector4 Colors_32;
		public Vector4 Colors_33;
		public Vector4 Colors_34;
		public Vector4 Colors_35;
		public Vector4 Colors_36;
		public Vector4 Colors_37;
		public Vector4 Colors_38;
		public Vector4 Colors_39;
		public Vector4 Colors_40;
		public Vector4 Colors_41;
		public Vector4 Colors_42;
		public Vector4 Colors_43;
		public Vector4 Colors_44;
		public Vector4 Colors_45;
		public Vector4 Colors_46;
		public Vector4 Colors_47;
		public Vector4 Colors_48;
		public Vector4 Colors_49;
		public Vector4 Colors_50;
		public Vector4 Colors_51;
		public Vector4 Colors_52;
		public Vector4 Colors_53;
		public Vector4 Colors_54;
		public float HoverStationaryDelay;
		public float HoverDelayShort;
		public float HoverDelayNormal;
		public ImGuiHoveredFlags HoverFlagsForTooltipMouse;
		public ImGuiHoveredFlags HoverFlagsForTooltipNav;

		public unsafe Span<Vector4> Colors
		
		{
			get
			{
				fixed (Vector4* p = &this.Colors_0)
				{
					return new Span<Vector4>(p, 55);
				}
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiStyle* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void ScaleAllSizes(float scaleFactor)
		{
			fixed (ImGuiStyle* @this = &this)
			{
				ImGui.ScaleAllSizesNative(@this, scaleFactor);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStylePtr : IEquatable<ImGuiStylePtr>
	{
		public ImGuiStylePtr(ImGuiStyle* handle) { Handle = handle; }

		public ImGuiStyle* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStylePtr Null => new ImGuiStylePtr(null);

		public static implicit operator ImGuiStylePtr(ImGuiStyle* handle) => new ImGuiStylePtr(handle);

		public static implicit operator ImGuiStyle*(ImGuiStylePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStylePtr left, ImGuiStylePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStylePtr left, ImGuiStylePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStylePtr left, ImGuiStyle* right) => left.Handle == right;

		public static bool operator !=(ImGuiStylePtr left, ImGuiStyle* right) => left.Handle != right;

		public bool Equals(ImGuiStylePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStylePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStylePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref float Alpha => ref Unsafe.AsRef<float>(&Handle->Alpha);
		public ref float DisabledAlpha => ref Unsafe.AsRef<float>(&Handle->DisabledAlpha);
		public ref Vector2 WindowPadding => ref Unsafe.AsRef<Vector2>(&Handle->WindowPadding);
		public ref float WindowRounding => ref Unsafe.AsRef<float>(&Handle->WindowRounding);
		public ref float WindowBorderSize => ref Unsafe.AsRef<float>(&Handle->WindowBorderSize);
		public ref Vector2 WindowMinSize => ref Unsafe.AsRef<Vector2>(&Handle->WindowMinSize);
		public ref Vector2 WindowTitleAlign => ref Unsafe.AsRef<Vector2>(&Handle->WindowTitleAlign);
		public ref ImGuiDir WindowMenuButtonPosition => ref Unsafe.AsRef<ImGuiDir>(&Handle->WindowMenuButtonPosition);
		public ref float ChildRounding => ref Unsafe.AsRef<float>(&Handle->ChildRounding);
		public ref float ChildBorderSize => ref Unsafe.AsRef<float>(&Handle->ChildBorderSize);
		public ref float PopupRounding => ref Unsafe.AsRef<float>(&Handle->PopupRounding);
		public ref float PopupBorderSize => ref Unsafe.AsRef<float>(&Handle->PopupBorderSize);
		public ref Vector2 FramePadding => ref Unsafe.AsRef<Vector2>(&Handle->FramePadding);
		public ref float FrameRounding => ref Unsafe.AsRef<float>(&Handle->FrameRounding);
		public ref float FrameBorderSize => ref Unsafe.AsRef<float>(&Handle->FrameBorderSize);
		public ref Vector2 ItemSpacing => ref Unsafe.AsRef<Vector2>(&Handle->ItemSpacing);
		public ref Vector2 ItemInnerSpacing => ref Unsafe.AsRef<Vector2>(&Handle->ItemInnerSpacing);
		public ref Vector2 CellPadding => ref Unsafe.AsRef<Vector2>(&Handle->CellPadding);
		public ref Vector2 TouchExtraPadding => ref Unsafe.AsRef<Vector2>(&Handle->TouchExtraPadding);
		public ref float IndentSpacing => ref Unsafe.AsRef<float>(&Handle->IndentSpacing);
		public ref float ColumnsMinSpacing => ref Unsafe.AsRef<float>(&Handle->ColumnsMinSpacing);
		public ref float ScrollbarSize => ref Unsafe.AsRef<float>(&Handle->ScrollbarSize);
		public ref float ScrollbarRounding => ref Unsafe.AsRef<float>(&Handle->ScrollbarRounding);
		public ref float GrabMinSize => ref Unsafe.AsRef<float>(&Handle->GrabMinSize);
		public ref float GrabRounding => ref Unsafe.AsRef<float>(&Handle->GrabRounding);
		public ref float LogSliderDeadzone => ref Unsafe.AsRef<float>(&Handle->LogSliderDeadzone);
		public ref float TabRounding => ref Unsafe.AsRef<float>(&Handle->TabRounding);
		public ref float TabBorderSize => ref Unsafe.AsRef<float>(&Handle->TabBorderSize);
		public ref float TabMinWidthForCloseButton => ref Unsafe.AsRef<float>(&Handle->TabMinWidthForCloseButton);
		public ref ImGuiDir ColorButtonPosition => ref Unsafe.AsRef<ImGuiDir>(&Handle->ColorButtonPosition);
		public ref Vector2 ButtonTextAlign => ref Unsafe.AsRef<Vector2>(&Handle->ButtonTextAlign);
		public ref Vector2 SelectableTextAlign => ref Unsafe.AsRef<Vector2>(&Handle->SelectableTextAlign);
		public ref float SeparatorTextBorderSize => ref Unsafe.AsRef<float>(&Handle->SeparatorTextBorderSize);
		public ref Vector2 SeparatorTextAlign => ref Unsafe.AsRef<Vector2>(&Handle->SeparatorTextAlign);
		public ref Vector2 SeparatorTextPadding => ref Unsafe.AsRef<Vector2>(&Handle->SeparatorTextPadding);
		public ref Vector2 DisplayWindowPadding => ref Unsafe.AsRef<Vector2>(&Handle->DisplayWindowPadding);
		public ref Vector2 DisplaySafeAreaPadding => ref Unsafe.AsRef<Vector2>(&Handle->DisplaySafeAreaPadding);
		public ref float MouseCursorScale => ref Unsafe.AsRef<float>(&Handle->MouseCursorScale);
		public ref bool AntiAliasedLines => ref Unsafe.AsRef<bool>(&Handle->AntiAliasedLines);
		public ref bool AntiAliasedLinesUseTex => ref Unsafe.AsRef<bool>(&Handle->AntiAliasedLinesUseTex);
		public ref bool AntiAliasedFill => ref Unsafe.AsRef<bool>(&Handle->AntiAliasedFill);
		public ref float CurveTessellationTol => ref Unsafe.AsRef<float>(&Handle->CurveTessellationTol);
		public ref float CircleTessellationMaxError => ref Unsafe.AsRef<float>(&Handle->CircleTessellationMaxError);
		public unsafe Span<Vector4> Colors
		
		{
			get
			{
				return new Span<Vector4>(&Handle->Colors_0, 55);
			}
		}
		public ref float HoverStationaryDelay => ref Unsafe.AsRef<float>(&Handle->HoverStationaryDelay);
		public ref float HoverDelayShort => ref Unsafe.AsRef<float>(&Handle->HoverDelayShort);
		public ref float HoverDelayNormal => ref Unsafe.AsRef<float>(&Handle->HoverDelayNormal);
		public ref ImGuiHoveredFlags HoverFlagsForTooltipMouse => ref Unsafe.AsRef<ImGuiHoveredFlags>(&Handle->HoverFlagsForTooltipMouse);
		public ref ImGuiHoveredFlags HoverFlagsForTooltipNav => ref Unsafe.AsRef<ImGuiHoveredFlags>(&Handle->HoverFlagsForTooltipNav);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void ScaleAllSizes(float scaleFactor)
		{
			ImGui.ScaleAllSizesNative(Handle, scaleFactor);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiInputEvent
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiInputEvent* Data;

	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiInputEventUnion
	{
		[FieldOffset(0)]
		public ImGuiInputEventMousePos MousePos;
		[FieldOffset(0)]
		public ImGuiInputEventMouseWheel MouseWheel;
		[FieldOffset(0)]
		public ImGuiInputEventMouseButton MouseButton;
		[FieldOffset(0)]
		public ImGuiInputEventMouseViewport MouseViewport;
		[FieldOffset(0)]
		public ImGuiInputEventKey Key;
		[FieldOffset(0)]
		public ImGuiInputEventText Text;
		[FieldOffset(0)]
		public ImGuiInputEventAppFocused AppFocused;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEvent
	{
		public ImGuiInputEventType Type;
		public ImGuiInputSource Source;
		public uint EventId;
		public ImGuiInputEventUnion ImGuiInputEventUnion;
		public byte AddedByTestEngine;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiInputEventPtr : IEquatable<ImGuiInputEventPtr>
	{
		public ImGuiInputEventPtr(ImGuiInputEvent* handle) { Handle = handle; }

		public ImGuiInputEvent* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputEventPtr Null => new ImGuiInputEventPtr(null);

		public static implicit operator ImGuiInputEventPtr(ImGuiInputEvent* handle) => new ImGuiInputEventPtr(handle);

		public static implicit operator ImGuiInputEvent*(ImGuiInputEventPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputEventPtr left, ImGuiInputEventPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputEventPtr left, ImGuiInputEventPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputEventPtr left, ImGuiInputEvent* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputEventPtr left, ImGuiInputEvent* right) => left.Handle != right;

		public bool Equals(ImGuiInputEventPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputEventPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiInputEventPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiInputEventType Type => ref Unsafe.AsRef<ImGuiInputEventType>(&Handle->Type);
		public ref ImGuiInputSource Source => ref Unsafe.AsRef<ImGuiInputSource>(&Handle->Source);
		public ref uint EventId => ref Unsafe.AsRef<uint>(&Handle->EventId);
		public ref ImGuiInputEventUnion ImGuiInputEventUnion => ref Unsafe.AsRef<ImGuiInputEventUnion>(&Handle->ImGuiInputEventUnion);
		public ref bool AddedByTestEngine => ref Unsafe.AsRef<bool>(&Handle->AddedByTestEngine);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMousePos
	{
		public float PosX;
		public float PosY;
		public ImGuiMouseSource MouseSource;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseWheel
	{
		public float WheelX;
		public float WheelY;
		public ImGuiMouseSource MouseSource;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseButton
	{
		public int Button;
		public byte Down;
		public ImGuiMouseSource MouseSource;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseViewport
	{
		public int HoveredViewportID;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventKey
	{
		public ImGuiKey Key;
		public byte Down;
		public float AnalogValue;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventText
	{
		public uint Char;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventAppFocused
	{
		public byte Focused;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiWindow** Data;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorImGuiWindowPtrPtr : IEquatable<ImVectorImGuiWindowPtrPtr>
	{
		public ImVectorImGuiWindowPtrPtr(ImVectorImGuiWindowPtr* handle) { Handle = handle; }

		public ImVectorImGuiWindowPtr* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorImGuiWindowPtrPtr Null => new ImVectorImGuiWindowPtrPtr(null);

		public static implicit operator ImVectorImGuiWindowPtrPtr(ImVectorImGuiWindowPtr* handle) => new ImVectorImGuiWindowPtrPtr(handle);

		public static implicit operator ImVectorImGuiWindowPtr*(ImVectorImGuiWindowPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImVectorImGuiWindowPtrPtr left, ImVectorImGuiWindowPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorImGuiWindowPtrPtr left, ImVectorImGuiWindowPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorImGuiWindowPtrPtr left, ImVectorImGuiWindowPtr* right) => left.Handle == right;

		public static bool operator !=(ImVectorImGuiWindowPtrPtr left, ImVectorImGuiWindowPtr* right) => left.Handle != right;

		public bool Equals(ImVectorImGuiWindowPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorImGuiWindowPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorImGuiWindowPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public ref ImGuiWindowPtrPtr Data => ref Unsafe.AsRef<ImGuiWindowPtrPtr>(&Handle->Data);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindow
	{
		public unsafe ImGuiContext* Ctx;
		public unsafe byte* Name;
		public int ID;
		public ImGuiWindowFlags Flags;
		public ImGuiWindowFlags FlagsPreviousFrame;
		public ImGuiWindowClass WindowClass;
		public unsafe ImGuiViewportP* Viewport;
		public int ViewportId;
		public Vector2 ViewportPos;
		public int ViewportAllowPlatformMonitorExtend;
		public Vector2 Pos;
		public Vector2 Size;
		public Vector2 SizeFull;
		public Vector2 ContentSize;
		public Vector2 ContentSizeIdeal;
		public Vector2 ContentSizeExplicit;
		public Vector2 WindowPadding;
		public float WindowRounding;
		public float WindowBorderSize;
		public float DecoOuterSizeX1;
		public float DecoOuterSizeY1;
		public float DecoOuterSizeX2;
		public float DecoOuterSizeY2;
		public float DecoInnerSizeX1;
		public float DecoInnerSizeY1;
		public int NameBufLen;
		public int MoveId;
		public int TabId;
		public int ChildId;
		public Vector2 Scroll;
		public Vector2 ScrollMax;
		public Vector2 ScrollTarget;
		public Vector2 ScrollTargetCenterRatio;
		public Vector2 ScrollTargetEdgeSnapDist;
		public Vector2 ScrollbarSizes;
		public byte ScrollbarX;
		public byte ScrollbarY;
		public byte ViewportOwned;
		public byte Active;
		public byte WasActive;
		public byte WriteAccessed;
		public byte Collapsed;
		public byte WantCollapseToggle;
		public byte SkipItems;
		public byte Appearing;
		public byte Hidden;
		public byte IsFallbackWindow;
		public byte IsExplicitChild;
		public byte HasCloseButton;
		public byte ResizeBorderHeld;
		public short BeginCount;
		public short BeginCountPreviousFrame;
		public short BeginOrderWithinParent;
		public short BeginOrderWithinContext;
		public short FocusOrder;
		public int PopupId;
		public sbyte AutoFitFramesX;
		public sbyte AutoFitFramesY;
		public sbyte AutoFitChildAxises;
		public byte AutoFitOnlyGrows;
		public ImGuiDir AutoPosLastDirection;
		public sbyte HiddenFramesCanSkipItems;
		public sbyte HiddenFramesCannotSkipItems;
		public sbyte HiddenFramesForRenderOnly;
		public sbyte DisableInputsFrames;
		public ImGuiCond SetWindowPosAllowFlags;
		public ImGuiCond SetWindowSizeAllowFlags;
		public ImGuiCond SetWindowCollapsedAllowFlags;
		public ImGuiCond SetWindowDockAllowFlags;
		public Vector2 SetWindowPosVal;
		public Vector2 SetWindowPosPivot;
		public ImVectorImGuiID IDStack;
		public ImGuiWindowTempData DC;
		public ImRect OuterRectClipped;
		public ImRect InnerRect;
		public ImRect InnerClipRect;
		public ImRect WorkRect;
		public ImRect ParentWorkRect;
		public ImRect ClipRect;
		public ImRect ContentRegionRect;
		public ImVec2ih HitTestHoleSize;
		public ImVec2ih HitTestHoleOffset;
		public int LastFrameActive;
		public int LastFrameJustFocused;
		public float LastTimeActive;
		public float ItemWidthDefault;
		public ImGuiStorage StateStorage;
		public ImVectorImGuiOldColumns ColumnsStorage;
		public float FontWindowScale;
		public float FontDpiScale;
		public int SettingsOffset;
		public unsafe ImDrawList* DrawList;
		public ImDrawList DrawListInst;
		public unsafe ImGuiWindow* ParentWindow;
		public unsafe ImGuiWindow* ParentWindowInBeginStack;
		public unsafe ImGuiWindow* RootWindow;
		public unsafe ImGuiWindow* RootWindowPopupTree;
		public unsafe ImGuiWindow* RootWindowDockTree;
		public unsafe ImGuiWindow* RootWindowForTitleBarHighlight;
		public unsafe ImGuiWindow* RootWindowForNav;
		public unsafe ImGuiWindow* NavLastChildNavWindow;
		public uint NavLastIds_0;
		public uint NavLastIds_1;
		public ImRect NavRectRel_0;
		public ImRect NavRectRel_1;
		public Vector2 NavPreferredScoringPosRel_0;
		public Vector2 NavPreferredScoringPosRel_1;
		public int NavRootFocusScopeId;
		public int MemoryDrawListIdxCapacity;
		public int MemoryDrawListVtxCapacity;
		public byte MemoryCompacted;
		public byte DockIsActive;
		public byte DockNodeIsVisible;
		public byte DockTabIsVisible;
		public byte DockTabWantClose;
		public short DockOrder;
		public ImGuiWindowDockStyle DockStyle;
		public unsafe ImGuiDockNode* DockNode;
		public unsafe ImGuiDockNode* DockNodeAsHost;
		public int DockId;
		public ImGuiItemStatusFlags DockTabItemStatusFlags;
		public ImRect DockTabItemRect;

		public unsafe Span<ImRect> NavRectRel
		
		{
			get
			{
				fixed (ImRect* p = &this.NavRectRel_0)
				{
					return new Span<ImRect>(p, 2);
				}
			}
		}
		public unsafe Span<Vector2> NavPreferredScoringPosRel
		
		{
			get
			{
				fixed (Vector2* p = &this.NavPreferredScoringPosRel_0)
				{
					return new Span<Vector2>(p, 2);
				}
			}
		}
	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowPtr : IEquatable<ImGuiWindowPtr>
	{
		public ImGuiWindowPtr(ImGuiWindow* handle) { Handle = handle; }

		public ImGuiWindow* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowPtr Null => new ImGuiWindowPtr(null);

		public static implicit operator ImGuiWindowPtr(ImGuiWindow* handle) => new ImGuiWindowPtr(handle);

		public static implicit operator ImGuiWindow*(ImGuiWindowPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowPtr left, ImGuiWindowPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowPtr left, ImGuiWindowPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowPtr left, ImGuiWindow* right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowPtr left, ImGuiWindow* right) => left.Handle != right;

		public bool Equals(ImGuiWindowPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		public byte* Name { get => Handle->Name; set => Handle->Name = value; }
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiWindowFlags Flags => ref Unsafe.AsRef<ImGuiWindowFlags>(&Handle->Flags);
		public ref ImGuiWindowFlags FlagsPreviousFrame => ref Unsafe.AsRef<ImGuiWindowFlags>(&Handle->FlagsPreviousFrame);
		public ref ImGuiWindowClass WindowClass => ref Unsafe.AsRef<ImGuiWindowClass>(&Handle->WindowClass);
		public ref ImGuiViewportPPtr Viewport => ref Unsafe.AsRef<ImGuiViewportPPtr>(&Handle->Viewport);
		public ref int ViewportId => ref Unsafe.AsRef<int>(&Handle->ViewportId);
		public ref Vector2 ViewportPos => ref Unsafe.AsRef<Vector2>(&Handle->ViewportPos);
		public ref int ViewportAllowPlatformMonitorExtend => ref Unsafe.AsRef<int>(&Handle->ViewportAllowPlatformMonitorExtend);
		public ref Vector2 Pos => ref Unsafe.AsRef<Vector2>(&Handle->Pos);
		public ref Vector2 Size => ref Unsafe.AsRef<Vector2>(&Handle->Size);
		public ref Vector2 SizeFull => ref Unsafe.AsRef<Vector2>(&Handle->SizeFull);
		public ref Vector2 ContentSize => ref Unsafe.AsRef<Vector2>(&Handle->ContentSize);
		public ref Vector2 ContentSizeIdeal => ref Unsafe.AsRef<Vector2>(&Handle->ContentSizeIdeal);
		public ref Vector2 ContentSizeExplicit => ref Unsafe.AsRef<Vector2>(&Handle->ContentSizeExplicit);
		public ref Vector2 WindowPadding => ref Unsafe.AsRef<Vector2>(&Handle->WindowPadding);
		public ref float WindowRounding => ref Unsafe.AsRef<float>(&Handle->WindowRounding);
		public ref float WindowBorderSize => ref Unsafe.AsRef<float>(&Handle->WindowBorderSize);
		public ref float DecoOuterSizeX1 => ref Unsafe.AsRef<float>(&Handle->DecoOuterSizeX1);
		public ref float DecoOuterSizeY1 => ref Unsafe.AsRef<float>(&Handle->DecoOuterSizeY1);
		public ref float DecoOuterSizeX2 => ref Unsafe.AsRef<float>(&Handle->DecoOuterSizeX2);
		public ref float DecoOuterSizeY2 => ref Unsafe.AsRef<float>(&Handle->DecoOuterSizeY2);
		public ref float DecoInnerSizeX1 => ref Unsafe.AsRef<float>(&Handle->DecoInnerSizeX1);
		public ref float DecoInnerSizeY1 => ref Unsafe.AsRef<float>(&Handle->DecoInnerSizeY1);
		public ref int NameBufLen => ref Unsafe.AsRef<int>(&Handle->NameBufLen);
		public ref int MoveId => ref Unsafe.AsRef<int>(&Handle->MoveId);
		public ref int TabId => ref Unsafe.AsRef<int>(&Handle->TabId);
		public ref int ChildId => ref Unsafe.AsRef<int>(&Handle->ChildId);
		public ref Vector2 Scroll => ref Unsafe.AsRef<Vector2>(&Handle->Scroll);
		public ref Vector2 ScrollMax => ref Unsafe.AsRef<Vector2>(&Handle->ScrollMax);
		public ref Vector2 ScrollTarget => ref Unsafe.AsRef<Vector2>(&Handle->ScrollTarget);
		public ref Vector2 ScrollTargetCenterRatio => ref Unsafe.AsRef<Vector2>(&Handle->ScrollTargetCenterRatio);
		public ref Vector2 ScrollTargetEdgeSnapDist => ref Unsafe.AsRef<Vector2>(&Handle->ScrollTargetEdgeSnapDist);
		public ref Vector2 ScrollbarSizes => ref Unsafe.AsRef<Vector2>(&Handle->ScrollbarSizes);
		public ref bool ScrollbarX => ref Unsafe.AsRef<bool>(&Handle->ScrollbarX);
		public ref bool ScrollbarY => ref Unsafe.AsRef<bool>(&Handle->ScrollbarY);
		public ref bool ViewportOwned => ref Unsafe.AsRef<bool>(&Handle->ViewportOwned);
		public ref bool Active => ref Unsafe.AsRef<bool>(&Handle->Active);
		public ref bool WasActive => ref Unsafe.AsRef<bool>(&Handle->WasActive);
		public ref bool WriteAccessed => ref Unsafe.AsRef<bool>(&Handle->WriteAccessed);
		public ref bool Collapsed => ref Unsafe.AsRef<bool>(&Handle->Collapsed);
		public ref bool WantCollapseToggle => ref Unsafe.AsRef<bool>(&Handle->WantCollapseToggle);
		public ref bool SkipItems => ref Unsafe.AsRef<bool>(&Handle->SkipItems);
		public ref bool Appearing => ref Unsafe.AsRef<bool>(&Handle->Appearing);
		public ref bool Hidden => ref Unsafe.AsRef<bool>(&Handle->Hidden);
		public ref bool IsFallbackWindow => ref Unsafe.AsRef<bool>(&Handle->IsFallbackWindow);
		public ref bool IsExplicitChild => ref Unsafe.AsRef<bool>(&Handle->IsExplicitChild);
		public ref bool HasCloseButton => ref Unsafe.AsRef<bool>(&Handle->HasCloseButton);
		public ref byte ResizeBorderHeld => ref Unsafe.AsRef<byte>(&Handle->ResizeBorderHeld);
		public ref short BeginCount => ref Unsafe.AsRef<short>(&Handle->BeginCount);
		public ref short BeginCountPreviousFrame => ref Unsafe.AsRef<short>(&Handle->BeginCountPreviousFrame);
		public ref short BeginOrderWithinParent => ref Unsafe.AsRef<short>(&Handle->BeginOrderWithinParent);
		public ref short BeginOrderWithinContext => ref Unsafe.AsRef<short>(&Handle->BeginOrderWithinContext);
		public ref short FocusOrder => ref Unsafe.AsRef<short>(&Handle->FocusOrder);
		public ref int PopupId => ref Unsafe.AsRef<int>(&Handle->PopupId);
		public ref sbyte AutoFitFramesX => ref Unsafe.AsRef<sbyte>(&Handle->AutoFitFramesX);
		public ref sbyte AutoFitFramesY => ref Unsafe.AsRef<sbyte>(&Handle->AutoFitFramesY);
		public ref sbyte AutoFitChildAxises => ref Unsafe.AsRef<sbyte>(&Handle->AutoFitChildAxises);
		public ref bool AutoFitOnlyGrows => ref Unsafe.AsRef<bool>(&Handle->AutoFitOnlyGrows);
		public ref ImGuiDir AutoPosLastDirection => ref Unsafe.AsRef<ImGuiDir>(&Handle->AutoPosLastDirection);
		public ref sbyte HiddenFramesCanSkipItems => ref Unsafe.AsRef<sbyte>(&Handle->HiddenFramesCanSkipItems);
		public ref sbyte HiddenFramesCannotSkipItems => ref Unsafe.AsRef<sbyte>(&Handle->HiddenFramesCannotSkipItems);
		public ref sbyte HiddenFramesForRenderOnly => ref Unsafe.AsRef<sbyte>(&Handle->HiddenFramesForRenderOnly);
		public ref sbyte DisableInputsFrames => ref Unsafe.AsRef<sbyte>(&Handle->DisableInputsFrames);
		public ref ImGuiCond SetWindowPosAllowFlags => ref Unsafe.AsRef<ImGuiCond>(&Handle->SetWindowPosAllowFlags);
		public ref ImGuiCond SetWindowSizeAllowFlags => ref Unsafe.AsRef<ImGuiCond>(&Handle->SetWindowSizeAllowFlags);
		public ref ImGuiCond SetWindowCollapsedAllowFlags => ref Unsafe.AsRef<ImGuiCond>(&Handle->SetWindowCollapsedAllowFlags);
		public ref ImGuiCond SetWindowDockAllowFlags => ref Unsafe.AsRef<ImGuiCond>(&Handle->SetWindowDockAllowFlags);
		public ref Vector2 SetWindowPosVal => ref Unsafe.AsRef<Vector2>(&Handle->SetWindowPosVal);
		public ref Vector2 SetWindowPosPivot => ref Unsafe.AsRef<Vector2>(&Handle->SetWindowPosPivot);
		public ref ImVectorImGuiID IDStack => ref Unsafe.AsRef<ImVectorImGuiID>(&Handle->IDStack);
		public ref ImGuiWindowTempData DC => ref Unsafe.AsRef<ImGuiWindowTempData>(&Handle->DC);
		public ref ImRect OuterRectClipped => ref Unsafe.AsRef<ImRect>(&Handle->OuterRectClipped);
		public ref ImRect InnerRect => ref Unsafe.AsRef<ImRect>(&Handle->InnerRect);
		public ref ImRect InnerClipRect => ref Unsafe.AsRef<ImRect>(&Handle->InnerClipRect);
		public ref ImRect WorkRect => ref Unsafe.AsRef<ImRect>(&Handle->WorkRect);
		public ref ImRect ParentWorkRect => ref Unsafe.AsRef<ImRect>(&Handle->ParentWorkRect);
		public ref ImRect ClipRect => ref Unsafe.AsRef<ImRect>(&Handle->ClipRect);
		public ref ImRect ContentRegionRect => ref Unsafe.AsRef<ImRect>(&Handle->ContentRegionRect);
		public ref ImVec2ih HitTestHoleSize => ref Unsafe.AsRef<ImVec2ih>(&Handle->HitTestHoleSize);
		public ref ImVec2ih HitTestHoleOffset => ref Unsafe.AsRef<ImVec2ih>(&Handle->HitTestHoleOffset);
		public ref int LastFrameActive => ref Unsafe.AsRef<int>(&Handle->LastFrameActive);
		public ref int LastFrameJustFocused => ref Unsafe.AsRef<int>(&Handle->LastFrameJustFocused);
		public ref float LastTimeActive => ref Unsafe.AsRef<float>(&Handle->LastTimeActive);
		public ref float ItemWidthDefault => ref Unsafe.AsRef<float>(&Handle->ItemWidthDefault);
		public ref ImGuiStorage StateStorage => ref Unsafe.AsRef<ImGuiStorage>(&Handle->StateStorage);
		public ref ImVectorImGuiOldColumns ColumnsStorage => ref Unsafe.AsRef<ImVectorImGuiOldColumns>(&Handle->ColumnsStorage);
		public ref float FontWindowScale => ref Unsafe.AsRef<float>(&Handle->FontWindowScale);
		public ref float FontDpiScale => ref Unsafe.AsRef<float>(&Handle->FontDpiScale);
		public ref int SettingsOffset => ref Unsafe.AsRef<int>(&Handle->SettingsOffset);
		public ref ImDrawListPtr DrawList => ref Unsafe.AsRef<ImDrawListPtr>(&Handle->DrawList);
		public ref ImDrawList DrawListInst => ref Unsafe.AsRef<ImDrawList>(&Handle->DrawListInst);
		public ref ImGuiWindowPtr ParentWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->ParentWindow);
		public ref ImGuiWindowPtr ParentWindowInBeginStack => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->ParentWindowInBeginStack);
		public ref ImGuiWindowPtr RootWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindow);
		public ref ImGuiWindowPtr RootWindowPopupTree => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindowPopupTree);
		public ref ImGuiWindowPtr RootWindowDockTree => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindowDockTree);
		public ref ImGuiWindowPtr RootWindowForTitleBarHighlight => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindowForTitleBarHighlight);
		public ref ImGuiWindowPtr RootWindowForNav => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindowForNav);
		public ref ImGuiWindowPtr NavLastChildNavWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavLastChildNavWindow);
		public unsafe Span<uint> NavLastIds
		
		{
			get
			{
				return new Span<uint>(&Handle->NavLastIds_0, 2);
			}
		}
		public unsafe Span<ImRect> NavRectRel
		
		{
			get
			{
				return new Span<ImRect>(&Handle->NavRectRel_0, 2);
			}
		}
		public unsafe Span<Vector2> NavPreferredScoringPosRel
		
		{
			get
			{
				return new Span<Vector2>(&Handle->NavPreferredScoringPosRel_0, 2);
			}
		}
		public ref int NavRootFocusScopeId => ref Unsafe.AsRef<int>(&Handle->NavRootFocusScopeId);
		public ref int MemoryDrawListIdxCapacity => ref Unsafe.AsRef<int>(&Handle->MemoryDrawListIdxCapacity);
		public ref int MemoryDrawListVtxCapacity => ref Unsafe.AsRef<int>(&Handle->MemoryDrawListVtxCapacity);
		public ref bool MemoryCompacted => ref Unsafe.AsRef<bool>(&Handle->MemoryCompacted);
		public ref bool DockIsActive => ref Unsafe.AsRef<bool>(&Handle->DockIsActive);
		public ref bool DockNodeIsVisible => ref Unsafe.AsRef<bool>(&Handle->DockNodeIsVisible);
		public ref bool DockTabIsVisible => ref Unsafe.AsRef<bool>(&Handle->DockTabIsVisible);
		public ref bool DockTabWantClose => ref Unsafe.AsRef<bool>(&Handle->DockTabWantClose);
		public ref short DockOrder => ref Unsafe.AsRef<short>(&Handle->DockOrder);
		public ref ImGuiWindowDockStyle DockStyle => ref Unsafe.AsRef<ImGuiWindowDockStyle>(&Handle->DockStyle);
		public ref ImGuiDockNodePtr DockNode => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->DockNode);
		public ref ImGuiDockNodePtr DockNodeAsHost => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->DockNodeAsHost);
		public ref int DockId => ref Unsafe.AsRef<int>(&Handle->DockId);
		public ref ImGuiItemStatusFlags DockTabItemStatusFlags => ref Unsafe.AsRef<ImGuiItemStatusFlags>(&Handle->DockTabItemStatusFlags);
		public ref ImRect DockTabItemRect => ref Unsafe.AsRef<ImRect>(&Handle->DockTabItemRect);
	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowPtrPtr : IEquatable<ImGuiWindowPtrPtr>
	{
		public ImGuiWindowPtrPtr(ImGuiWindow** handle) { Handle = handle; }

		public ImGuiWindow** Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowPtrPtr Null => new ImGuiWindowPtrPtr(null);

		public static implicit operator ImGuiWindowPtrPtr(ImGuiWindow** handle) => new ImGuiWindowPtrPtr(handle);

		public static implicit operator ImGuiWindow**(ImGuiWindowPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowPtrPtr left, ImGuiWindowPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowPtrPtr left, ImGuiWindowPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowPtrPtr left, ImGuiWindow** right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowPtrPtr left, ImGuiWindow** right) => left.Handle != right;

		public bool Equals(ImGuiWindowPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImGuiWindowPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowClass
	{
		public int ClassId;
		public int ParentViewportId;
		public ImGuiViewportFlags ViewportFlagsOverrideSet;
		public ImGuiViewportFlags ViewportFlagsOverrideClear;
		public ImGuiTabItemFlags TabItemFlagsOverrideSet;
		public ImGuiDockNodeFlags DockNodeFlagsOverrideSet;
		public byte DockingAlwaysTabBar;
		public byte DockingAllowUnclassed;


		public unsafe void Destroy()
		{
			fixed (ImGuiWindowClass* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowClassPtr : IEquatable<ImGuiWindowClassPtr>
	{
		public ImGuiWindowClassPtr(ImGuiWindowClass* handle) { Handle = handle; }

		public ImGuiWindowClass* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowClassPtr Null => new ImGuiWindowClassPtr(null);

		public static implicit operator ImGuiWindowClassPtr(ImGuiWindowClass* handle) => new ImGuiWindowClassPtr(handle);

		public static implicit operator ImGuiWindowClass*(ImGuiWindowClassPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowClassPtr left, ImGuiWindowClassPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowClassPtr left, ImGuiWindowClassPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowClassPtr left, ImGuiWindowClass* right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowClassPtr left, ImGuiWindowClass* right) => left.Handle != right;

		public bool Equals(ImGuiWindowClassPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowClassPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowClassPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ClassId => ref Unsafe.AsRef<int>(&Handle->ClassId);
		public ref int ParentViewportId => ref Unsafe.AsRef<int>(&Handle->ParentViewportId);
		public ref ImGuiViewportFlags ViewportFlagsOverrideSet => ref Unsafe.AsRef<ImGuiViewportFlags>(&Handle->ViewportFlagsOverrideSet);
		public ref ImGuiViewportFlags ViewportFlagsOverrideClear => ref Unsafe.AsRef<ImGuiViewportFlags>(&Handle->ViewportFlagsOverrideClear);
		public ref ImGuiTabItemFlags TabItemFlagsOverrideSet => ref Unsafe.AsRef<ImGuiTabItemFlags>(&Handle->TabItemFlagsOverrideSet);
		public ref ImGuiDockNodeFlags DockNodeFlagsOverrideSet => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->DockNodeFlagsOverrideSet);
		public ref bool DockingAlwaysTabBar => ref Unsafe.AsRef<bool>(&Handle->DockingAlwaysTabBar);
		public ref bool DockingAllowUnclassed => ref Unsafe.AsRef<bool>(&Handle->DockingAllowUnclassed);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiViewportP
	{
		public ImGuiViewport ImGuiViewport;
		public unsafe ImGuiWindow* Window;
		public int Idx;
		public int LastFrameActive;
		public int LastFocusedStampCount;
		public int LastNameHash;
		public Vector2 LastPos;
		public float Alpha;
		public float LastAlpha;
		public byte LastFocusedHadNavWindow;
		public short PlatformMonitor;
		public int DrawListsLastFrame_0;
		public int DrawListsLastFrame_1;
		public unsafe ImDrawList* DrawLists_0;
		public unsafe ImDrawList* DrawLists_1;
		public ImDrawData DrawDataP;
		public ImDrawDataBuilder DrawDataBuilder;
		public Vector2 LastPlatformPos;
		public Vector2 LastPlatformSize;
		public Vector2 LastRendererSize;
		public Vector2 WorkOffsetMin;
		public Vector2 WorkOffsetMax;
		public Vector2 BuildWorkOffsetMin;
		public Vector2 BuildWorkOffsetMax;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiViewportPPtr : IEquatable<ImGuiViewportPPtr>
	{
		public ImGuiViewportPPtr(ImGuiViewportP* handle) { Handle = handle; }

		public ImGuiViewportP* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiViewportPPtr Null => new ImGuiViewportPPtr(null);

		public static implicit operator ImGuiViewportPPtr(ImGuiViewportP* handle) => new ImGuiViewportPPtr(handle);

		public static implicit operator ImGuiViewportP*(ImGuiViewportPPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiViewportPPtr left, ImGuiViewportPPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiViewportPPtr left, ImGuiViewportPPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiViewportPPtr left, ImGuiViewportP* right) => left.Handle == right;

		public static bool operator !=(ImGuiViewportPPtr left, ImGuiViewportP* right) => left.Handle != right;

		public bool Equals(ImGuiViewportPPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiViewportPPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiViewportPPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiViewport ImGuiViewport => ref Unsafe.AsRef<ImGuiViewport>(&Handle->ImGuiViewport);
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		public ref int Idx => ref Unsafe.AsRef<int>(&Handle->Idx);
		public ref int LastFrameActive => ref Unsafe.AsRef<int>(&Handle->LastFrameActive);
		public ref int LastFocusedStampCount => ref Unsafe.AsRef<int>(&Handle->LastFocusedStampCount);
		public ref int LastNameHash => ref Unsafe.AsRef<int>(&Handle->LastNameHash);
		public ref Vector2 LastPos => ref Unsafe.AsRef<Vector2>(&Handle->LastPos);
		public ref float Alpha => ref Unsafe.AsRef<float>(&Handle->Alpha);
		public ref float LastAlpha => ref Unsafe.AsRef<float>(&Handle->LastAlpha);
		public ref bool LastFocusedHadNavWindow => ref Unsafe.AsRef<bool>(&Handle->LastFocusedHadNavWindow);
		public ref short PlatformMonitor => ref Unsafe.AsRef<short>(&Handle->PlatformMonitor);
		public unsafe Span<int> DrawListsLastFrame
		
		{
			get
			{
				return new Span<int>(&Handle->DrawListsLastFrame_0, 2);
			}
		}
		public ref ImDrawData DrawDataP => ref Unsafe.AsRef<ImDrawData>(&Handle->DrawDataP);
		public ref ImDrawDataBuilder DrawDataBuilder => ref Unsafe.AsRef<ImDrawDataBuilder>(&Handle->DrawDataBuilder);
		public ref Vector2 LastPlatformPos => ref Unsafe.AsRef<Vector2>(&Handle->LastPlatformPos);
		public ref Vector2 LastPlatformSize => ref Unsafe.AsRef<Vector2>(&Handle->LastPlatformSize);
		public ref Vector2 LastRendererSize => ref Unsafe.AsRef<Vector2>(&Handle->LastRendererSize);
		public ref Vector2 WorkOffsetMin => ref Unsafe.AsRef<Vector2>(&Handle->WorkOffsetMin);
		public ref Vector2 WorkOffsetMax => ref Unsafe.AsRef<Vector2>(&Handle->WorkOffsetMax);
		public ref Vector2 BuildWorkOffsetMin => ref Unsafe.AsRef<Vector2>(&Handle->BuildWorkOffsetMin);
		public ref Vector2 BuildWorkOffsetMax => ref Unsafe.AsRef<Vector2>(&Handle->BuildWorkOffsetMax);
	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiViewportPPtrPtr : IEquatable<ImGuiViewportPPtrPtr>
	{
		public ImGuiViewportPPtrPtr(ImGuiViewportP** handle) { Handle = handle; }

		public ImGuiViewportP** Handle;

		public bool IsNull => Handle == null;

		public static ImGuiViewportPPtrPtr Null => new ImGuiViewportPPtrPtr(null);

		public static implicit operator ImGuiViewportPPtrPtr(ImGuiViewportP** handle) => new ImGuiViewportPPtrPtr(handle);

		public static implicit operator ImGuiViewportP**(ImGuiViewportPPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiViewportPPtrPtr left, ImGuiViewportPPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiViewportPPtrPtr left, ImGuiViewportPPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiViewportPPtrPtr left, ImGuiViewportP** right) => left.Handle == right;

		public static bool operator !=(ImGuiViewportPPtrPtr left, ImGuiViewportP** right) => left.Handle != right;

		public bool Equals(ImGuiViewportPPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiViewportPPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiViewportPPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImGuiViewportPPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawDataBuilder
	{
		public ImVectorImDrawListPtr Layers_0;
		public ImVectorImDrawListPtr Layers_1;

		public unsafe Span<ImVectorImDrawListPtr> Layers
		
		{
			get
			{
				fixed (ImVectorImDrawListPtr* p = &this.Layers_0)
				{
					return new Span<ImVectorImDrawListPtr>(p, 2);
				}
			}
		}
	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawDataBuilderPtr : IEquatable<ImDrawDataBuilderPtr>
	{
		public ImDrawDataBuilderPtr(ImDrawDataBuilder* handle) { Handle = handle; }

		public ImDrawDataBuilder* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawDataBuilderPtr Null => new ImDrawDataBuilderPtr(null);

		public static implicit operator ImDrawDataBuilderPtr(ImDrawDataBuilder* handle) => new ImDrawDataBuilderPtr(handle);

		public static implicit operator ImDrawDataBuilder*(ImDrawDataBuilderPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawDataBuilderPtr left, ImDrawDataBuilderPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawDataBuilderPtr left, ImDrawDataBuilderPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawDataBuilderPtr left, ImDrawDataBuilder* right) => left.Handle == right;

		public static bool operator !=(ImDrawDataBuilderPtr left, ImDrawDataBuilder* right) => left.Handle != right;

		public bool Equals(ImDrawDataBuilderPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawDataBuilderPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawDataBuilderPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public unsafe Span<ImVectorImDrawListPtr> Layers
		
		{
			get
			{
				return new Span<ImVectorImDrawListPtr>(&Handle->Layers_0, 2);
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawListPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawList** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiID
	{
		public int Size;
		public int Capacity;
		public unsafe int* Data;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorImGuiIDPtr : IEquatable<ImVectorImGuiIDPtr>
	{
		public ImVectorImGuiIDPtr(ImVectorImGuiID* handle) { Handle = handle; }

		public ImVectorImGuiID* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorImGuiIDPtr Null => new ImVectorImGuiIDPtr(null);

		public static implicit operator ImVectorImGuiIDPtr(ImVectorImGuiID* handle) => new ImVectorImGuiIDPtr(handle);

		public static implicit operator ImVectorImGuiID*(ImVectorImGuiIDPtr handle) => handle.Handle;

		public static bool operator ==(ImVectorImGuiIDPtr left, ImVectorImGuiIDPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorImGuiIDPtr left, ImVectorImGuiIDPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorImGuiIDPtr left, ImVectorImGuiID* right) => left.Handle == right;

		public static bool operator !=(ImVectorImGuiIDPtr left, ImVectorImGuiID* right) => left.Handle != right;

		public bool Equals(ImVectorImGuiIDPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorImGuiIDPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorImGuiIDPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public int* Data { get => Handle->Data; set => Handle->Data = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowTempData
	{
		public Vector2 CursorPos;
		public Vector2 CursorPosPrevLine;
		public Vector2 CursorStartPos;
		public Vector2 CursorMaxPos;
		public Vector2 IdealMaxPos;
		public Vector2 CurrLineSize;
		public Vector2 PrevLineSize;
		public float CurrLineTextBaseOffset;
		public float PrevLineTextBaseOffset;
		public byte IsSameLine;
		public byte IsSetPos;
		public ImVec1 Indent;
		public ImVec1 ColumnsOffset;
		public ImVec1 GroupOffset;
		public Vector2 CursorStartPosLossyness;
		public ImGuiNavLayer NavLayerCurrent;
		public short NavLayersActiveMask;
		public short NavLayersActiveMaskNext;
		public byte NavIsScrollPushableX;
		public byte NavHideHighlightOneFrame;
		public byte NavWindowHasScrollY;
		public byte MenuBarAppending;
		public Vector2 MenuBarOffset;
		public ImGuiMenuColumns MenuColumns;
		public int TreeDepth;
		public uint TreeJumpToParentOnPopMask;
		public ImVectorImGuiWindowPtr ChildWindows;
		public unsafe ImGuiStorage* StateStorage;
		public unsafe ImGuiOldColumns* CurrentColumns;
		public int CurrentTableIdx;
		public ImGuiLayoutType LayoutType;
		public ImGuiLayoutType ParentLayoutType;
		public float ItemWidth;
		public float TextWrapPos;
		public ImVectorFloat ItemWidthStack;
		public ImVectorFloat TextWrapPosStack;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec1
	{
		public float X;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVec1Ptr : IEquatable<ImVec1Ptr>
	{
		public ImVec1Ptr(ImVec1* handle) { Handle = handle; }

		public ImVec1* Handle;

		public bool IsNull => Handle == null;

		public static ImVec1Ptr Null => new ImVec1Ptr(null);

		public static implicit operator ImVec1Ptr(ImVec1* handle) => new ImVec1Ptr(handle);

		public static implicit operator ImVec1*(ImVec1Ptr handle) => handle.Handle;

		public static bool operator ==(ImVec1Ptr left, ImVec1Ptr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVec1Ptr left, ImVec1Ptr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVec1Ptr left, ImVec1* right) => left.Handle == right;

		public static bool operator !=(ImVec1Ptr left, ImVec1* right) => left.Handle != right;

		public bool Equals(ImVec1Ptr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVec1Ptr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVec1Ptr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref float X => ref Unsafe.AsRef<float>(&Handle->X);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMenuColumns
	{
		public uint TotalWidth;
		public uint NextTotalWidth;
		public ushort Spacing;
		public ushort OffsetIcon;
		public ushort OffsetLabel;
		public ushort OffsetShortcut;
		public ushort OffsetMark;
		public ushort Widths_0;
		public ushort Widths_1;
		public ushort Widths_2;
		public ushort Widths_3;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiMenuColumnsPtr : IEquatable<ImGuiMenuColumnsPtr>
	{
		public ImGuiMenuColumnsPtr(ImGuiMenuColumns* handle) { Handle = handle; }

		public ImGuiMenuColumns* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiMenuColumnsPtr Null => new ImGuiMenuColumnsPtr(null);

		public static implicit operator ImGuiMenuColumnsPtr(ImGuiMenuColumns* handle) => new ImGuiMenuColumnsPtr(handle);

		public static implicit operator ImGuiMenuColumns*(ImGuiMenuColumnsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiMenuColumnsPtr left, ImGuiMenuColumnsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiMenuColumnsPtr left, ImGuiMenuColumnsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiMenuColumnsPtr left, ImGuiMenuColumns* right) => left.Handle == right;

		public static bool operator !=(ImGuiMenuColumnsPtr left, ImGuiMenuColumns* right) => left.Handle != right;

		public bool Equals(ImGuiMenuColumnsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiMenuColumnsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiMenuColumnsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref uint TotalWidth => ref Unsafe.AsRef<uint>(&Handle->TotalWidth);
		public ref uint NextTotalWidth => ref Unsafe.AsRef<uint>(&Handle->NextTotalWidth);
		public ref ushort Spacing => ref Unsafe.AsRef<ushort>(&Handle->Spacing);
		public ref ushort OffsetIcon => ref Unsafe.AsRef<ushort>(&Handle->OffsetIcon);
		public ref ushort OffsetLabel => ref Unsafe.AsRef<ushort>(&Handle->OffsetLabel);
		public ref ushort OffsetShortcut => ref Unsafe.AsRef<ushort>(&Handle->OffsetShortcut);
		public ref ushort OffsetMark => ref Unsafe.AsRef<ushort>(&Handle->OffsetMark);
		public unsafe Span<ushort> Widths
		
		{
			get
			{
				return new Span<ushort>(&Handle->Widths_0, 4);
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStorage
	{
		public ImVectorImGuiStoragePair Data;


		public unsafe void BuildSortByKey()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.BuildSortByKeyNative(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe bool GetBool(int key, bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte ret = ImGui.GetBoolNative(@this, key, defaultVal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public unsafe bool GetBool(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte ret = ImGui.GetBoolNative(@this, key, (byte)(0));
				return ret != 0;
			}
		}

		public unsafe bool* GetBoolRef(int key, bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				bool* ret = ImGui.GetBoolRefNative(@this, key, defaultVal ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public unsafe bool* GetBoolRef(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				bool* ret = ImGui.GetBoolRefNative(@this, key, (byte)(0));
				return ret;
			}
		}

		public unsafe float GetFloat(int key, float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloatNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float GetFloat(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloatNative(@this, key, (float)(0.0f));
				return ret;
			}
		}

		public unsafe float* GetFloatRef(int key, float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float* GetFloatRef(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRefNative(@this, key, (float)(0.0f));
				return ret;
			}
		}

		public unsafe int GetInt(int key, int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetIntNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int GetInt(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetIntNative(@this, key, (int)(0));
				return ret;
			}
		}

		public unsafe int* GetIntRef(int key, int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int* GetIntRef(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRefNative(@this, key, (int)(0));
				return ret;
			}
		}

		public unsafe void* GetVoidPtr(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void* ret = ImGui.GetVoidPtrNative(@this, key);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef(int key, void* defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRefNative(@this, key, (void*)(default));
				return ret;
			}
		}

		public unsafe void SetAllInt(int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetAllIntNative(@this, val);
			}
		}

		public unsafe void SetBool(int key, bool val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetBoolNative(@this, key, val ? (byte)1 : (byte)0);
			}
		}

		public unsafe void SetFloat(int key, float val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetFloatNative(@this, key, val);
			}
		}

		public unsafe void SetInt(int key, int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetIntNative(@this, key, val);
			}
		}

		public unsafe void SetVoidPtr(int key, void* val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetVoidPtrNative(@this, key, val);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStoragePtr : IEquatable<ImGuiStoragePtr>
	{
		public ImGuiStoragePtr(ImGuiStorage* handle) { Handle = handle; }

		public ImGuiStorage* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStoragePtr Null => new ImGuiStoragePtr(null);

		public static implicit operator ImGuiStoragePtr(ImGuiStorage* handle) => new ImGuiStoragePtr(handle);

		public static implicit operator ImGuiStorage*(ImGuiStoragePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStoragePtr left, ImGuiStoragePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStoragePtr left, ImGuiStoragePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStoragePtr left, ImGuiStorage* right) => left.Handle == right;

		public static bool operator !=(ImGuiStoragePtr left, ImGuiStorage* right) => left.Handle != right;

		public bool Equals(ImGuiStoragePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStoragePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStoragePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImGuiStoragePair Data => ref Unsafe.AsRef<ImVectorImGuiStoragePair>(&Handle->Data);

		public unsafe void BuildSortByKey()
		{
			ImGui.BuildSortByKeyNative(Handle);
		}

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe bool GetBool(int key, bool defaultVal)
		{
			byte ret = ImGui.GetBoolNative(Handle, key, defaultVal ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public unsafe bool GetBool(int key)
		{
			byte ret = ImGui.GetBoolNative(Handle, key, (byte)(0));
			return ret != 0;
		}

		public unsafe bool* GetBoolRef(int key, bool defaultVal)
		{
			bool* ret = ImGui.GetBoolRefNative(Handle, key, defaultVal ? (byte)1 : (byte)0);
			return ret;
		}

		public unsafe bool* GetBoolRef(int key)
		{
			bool* ret = ImGui.GetBoolRefNative(Handle, key, (byte)(0));
			return ret;
		}

		public unsafe float GetFloat(int key, float defaultVal)
		{
			float ret = ImGui.GetFloatNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe float GetFloat(int key)
		{
			float ret = ImGui.GetFloatNative(Handle, key, (float)(0.0f));
			return ret;
		}

		public unsafe float* GetFloatRef(int key, float defaultVal)
		{
			float* ret = ImGui.GetFloatRefNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe float* GetFloatRef(int key)
		{
			float* ret = ImGui.GetFloatRefNative(Handle, key, (float)(0.0f));
			return ret;
		}

		public unsafe int GetInt(int key, int defaultVal)
		{
			int ret = ImGui.GetIntNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe int GetInt(int key)
		{
			int ret = ImGui.GetIntNative(Handle, key, (int)(0));
			return ret;
		}

		public unsafe int* GetIntRef(int key, int defaultVal)
		{
			int* ret = ImGui.GetIntRefNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe int* GetIntRef(int key)
		{
			int* ret = ImGui.GetIntRefNative(Handle, key, (int)(0));
			return ret;
		}

		public unsafe void* GetVoidPtr(int key)
		{
			void* ret = ImGui.GetVoidPtrNative(Handle, key);
			return ret;
		}

		public unsafe void** GetVoidPtrRef(int key, void* defaultVal)
		{
			void** ret = ImGui.GetVoidPtrRefNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe void** GetVoidPtrRef(int key)
		{
			void** ret = ImGui.GetVoidPtrRefNative(Handle, key, (void*)(default));
			return ret;
		}

		public unsafe void SetAllInt(int val)
		{
			ImGui.SetAllIntNative(Handle, val);
		}

		public unsafe void SetBool(int key, bool val)
		{
			ImGui.SetBoolNative(Handle, key, val ? (byte)1 : (byte)0);
		}

		public unsafe void SetFloat(int key, float val)
		{
			ImGui.SetFloatNative(Handle, key, val);
		}

		public unsafe void SetInt(int key, int val)
		{
			ImGui.SetIntNative(Handle, key, val);
		}

		public unsafe void SetVoidPtr(int key, void* val)
		{
			ImGui.SetVoidPtrNative(Handle, key, val);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStoragePair
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStoragePair* Data;

	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiStoragePairUnion
	{
		[FieldOffset(0)]
		public int ValI;
		[FieldOffset(0)]
		public float ValF;
		[FieldOffset(0)]
		public unsafe void* ValP;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStoragePair
	{
		public int Key;
		public ImGuiStoragePairUnion ImGuiStoragePairUnion;


		public unsafe void Destroy()
		{
			fixed (ImGuiStoragePair* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStoragePairPtr : IEquatable<ImGuiStoragePairPtr>
	{
		public ImGuiStoragePairPtr(ImGuiStoragePair* handle) { Handle = handle; }

		public ImGuiStoragePair* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStoragePairPtr Null => new ImGuiStoragePairPtr(null);

		public static implicit operator ImGuiStoragePairPtr(ImGuiStoragePair* handle) => new ImGuiStoragePairPtr(handle);

		public static implicit operator ImGuiStoragePair*(ImGuiStoragePairPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStoragePairPtr left, ImGuiStoragePairPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStoragePairPtr left, ImGuiStoragePairPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStoragePairPtr left, ImGuiStoragePair* right) => left.Handle == right;

		public static bool operator !=(ImGuiStoragePairPtr left, ImGuiStoragePair* right) => left.Handle != right;

		public bool Equals(ImGuiStoragePairPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStoragePairPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStoragePairPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Key => ref Unsafe.AsRef<int>(&Handle->Key);
		public ref ImGuiStoragePairUnion ImGuiStoragePairUnion => ref Unsafe.AsRef<ImGuiStoragePairUnion>(&Handle->ImGuiStoragePairUnion);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumns
	{
		public int ID;
		public ImGuiOldColumnFlags Flags;
		public byte IsFirstFrame;
		public byte IsBeingResized;
		public int Current;
		public int Count;
		public float OffMinX;
		public float OffMaxX;
		public float LineMinY;
		public float LineMaxY;
		public float HostCursorPosY;
		public float HostCursorMaxPosX;
		public ImRect HostInitialClipRect;
		public ImRect HostBackupClipRect;
		public ImRect HostBackupParentWorkRect;
		public ImVectorImGuiOldColumnData Columns;
		public ImDrawListSplitter Splitter;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiOldColumnsPtr : IEquatable<ImGuiOldColumnsPtr>
	{
		public ImGuiOldColumnsPtr(ImGuiOldColumns* handle) { Handle = handle; }

		public ImGuiOldColumns* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiOldColumnsPtr Null => new ImGuiOldColumnsPtr(null);

		public static implicit operator ImGuiOldColumnsPtr(ImGuiOldColumns* handle) => new ImGuiOldColumnsPtr(handle);

		public static implicit operator ImGuiOldColumns*(ImGuiOldColumnsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiOldColumnsPtr left, ImGuiOldColumnsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiOldColumnsPtr left, ImGuiOldColumnsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiOldColumnsPtr left, ImGuiOldColumns* right) => left.Handle == right;

		public static bool operator !=(ImGuiOldColumnsPtr left, ImGuiOldColumns* right) => left.Handle != right;

		public bool Equals(ImGuiOldColumnsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiOldColumnsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiOldColumnsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiOldColumnFlags Flags => ref Unsafe.AsRef<ImGuiOldColumnFlags>(&Handle->Flags);
		public ref bool IsFirstFrame => ref Unsafe.AsRef<bool>(&Handle->IsFirstFrame);
		public ref bool IsBeingResized => ref Unsafe.AsRef<bool>(&Handle->IsBeingResized);
		public ref int Current => ref Unsafe.AsRef<int>(&Handle->Current);
		public ref int Count => ref Unsafe.AsRef<int>(&Handle->Count);
		public ref float OffMinX => ref Unsafe.AsRef<float>(&Handle->OffMinX);
		public ref float OffMaxX => ref Unsafe.AsRef<float>(&Handle->OffMaxX);
		public ref float LineMinY => ref Unsafe.AsRef<float>(&Handle->LineMinY);
		public ref float LineMaxY => ref Unsafe.AsRef<float>(&Handle->LineMaxY);
		public ref float HostCursorPosY => ref Unsafe.AsRef<float>(&Handle->HostCursorPosY);
		public ref float HostCursorMaxPosX => ref Unsafe.AsRef<float>(&Handle->HostCursorMaxPosX);
		public ref ImRect HostInitialClipRect => ref Unsafe.AsRef<ImRect>(&Handle->HostInitialClipRect);
		public ref ImRect HostBackupClipRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupClipRect);
		public ref ImRect HostBackupParentWorkRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupParentWorkRect);
		public ref ImVectorImGuiOldColumnData Columns => ref Unsafe.AsRef<ImVectorImGuiOldColumnData>(&Handle->Columns);
		public ref ImDrawListSplitter Splitter => ref Unsafe.AsRef<ImDrawListSplitter>(&Handle->Splitter);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImRect
	{
		public Vector2 Min;
		public Vector2 Max;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImRectPtr : IEquatable<ImRectPtr>
	{
		public ImRectPtr(ImRect* handle) { Handle = handle; }

		public ImRect* Handle;

		public bool IsNull => Handle == null;

		public static ImRectPtr Null => new ImRectPtr(null);

		public static implicit operator ImRectPtr(ImRect* handle) => new ImRectPtr(handle);

		public static implicit operator ImRect*(ImRectPtr handle) => handle.Handle;

		public static bool operator ==(ImRectPtr left, ImRectPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImRectPtr left, ImRectPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImRectPtr left, ImRect* right) => left.Handle == right;

		public static bool operator !=(ImRectPtr left, ImRect* right) => left.Handle != right;

		public bool Equals(ImRectPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImRectPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImRectPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref Vector2 Min => ref Unsafe.AsRef<Vector2>(&Handle->Min);
		public ref Vector2 Max => ref Unsafe.AsRef<Vector2>(&Handle->Max);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumnData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiOldColumnData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumnData
	{
		public float OffsetNorm;
		public float OffsetNormBeforeResize;
		public ImGuiOldColumnFlags Flags;
		public ImRect ClipRect;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiOldColumnDataPtr : IEquatable<ImGuiOldColumnDataPtr>
	{
		public ImGuiOldColumnDataPtr(ImGuiOldColumnData* handle) { Handle = handle; }

		public ImGuiOldColumnData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiOldColumnDataPtr Null => new ImGuiOldColumnDataPtr(null);

		public static implicit operator ImGuiOldColumnDataPtr(ImGuiOldColumnData* handle) => new ImGuiOldColumnDataPtr(handle);

		public static implicit operator ImGuiOldColumnData*(ImGuiOldColumnDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiOldColumnDataPtr left, ImGuiOldColumnDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiOldColumnDataPtr left, ImGuiOldColumnDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiOldColumnDataPtr left, ImGuiOldColumnData* right) => left.Handle == right;

		public static bool operator !=(ImGuiOldColumnDataPtr left, ImGuiOldColumnData* right) => left.Handle != right;

		public bool Equals(ImGuiOldColumnDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiOldColumnDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiOldColumnDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref float OffsetNorm => ref Unsafe.AsRef<float>(&Handle->OffsetNorm);
		public ref float OffsetNormBeforeResize => ref Unsafe.AsRef<float>(&Handle->OffsetNormBeforeResize);
		public ref ImGuiOldColumnFlags Flags => ref Unsafe.AsRef<ImGuiOldColumnFlags>(&Handle->Flags);
		public ref ImRect ClipRect => ref Unsafe.AsRef<ImRect>(&Handle->ClipRect);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec2ih
	{
		public short X;
		public short Y;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVec2ihPtr : IEquatable<ImVec2ihPtr>
	{
		public ImVec2ihPtr(ImVec2ih* handle) { Handle = handle; }

		public ImVec2ih* Handle;

		public bool IsNull => Handle == null;

		public static ImVec2ihPtr Null => new ImVec2ihPtr(null);

		public static implicit operator ImVec2ihPtr(ImVec2ih* handle) => new ImVec2ihPtr(handle);

		public static implicit operator ImVec2ih*(ImVec2ihPtr handle) => handle.Handle;

		public static bool operator ==(ImVec2ihPtr left, ImVec2ihPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVec2ihPtr left, ImVec2ihPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVec2ihPtr left, ImVec2ih* right) => left.Handle == right;

		public static bool operator !=(ImVec2ihPtr left, ImVec2ih* right) => left.Handle != right;

		public bool Equals(ImVec2ihPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVec2ihPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVec2ihPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref short X => ref Unsafe.AsRef<short>(&Handle->X);
		public ref short Y => ref Unsafe.AsRef<short>(&Handle->Y);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumns
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiOldColumns* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowDockStyle
	{
		public uint Colors_0;
		public uint Colors_1;
		public uint Colors_2;
		public uint Colors_3;
		public uint Colors_4;
		public uint Colors_5;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNode
	{
		public int ID;
		public ImGuiDockNodeFlags SharedFlags;
		public ImGuiDockNodeFlags LocalFlags;
		public ImGuiDockNodeFlags LocalFlagsInWindows;
		public ImGuiDockNodeFlags MergedFlags;
		public ImGuiDockNodeState State;
		public unsafe ImGuiDockNode* ParentNode;
		public unsafe ImGuiDockNode* ChildNodes_0;
		public unsafe ImGuiDockNode* ChildNodes_1;
		public ImVectorImGuiWindowPtr Windows;
		public unsafe ImGuiTabBar* TabBar;
		public Vector2 Pos;
		public Vector2 Size;
		public Vector2 SizeRef;
		public ImGuiAxis SplitAxis;
		public ImGuiWindowClass WindowClass;
		public uint LastBgColor;
		public unsafe ImGuiWindow* HostWindow;
		public unsafe ImGuiWindow* VisibleWindow;
		public unsafe ImGuiDockNode* CentralNode;
		public unsafe ImGuiDockNode* OnlyNodeWithWindows;
		public int CountNodeWithWindows;
		public int LastFrameAlive;
		public int LastFrameActive;
		public int LastFrameFocused;
		public int LastFocusedNodeId;
		public int SelectedTabId;
		public int WantCloseTabId;
		public int RefViewportId;
		public ImGuiDataAuthority AuthorityForPos;
		public ImGuiDataAuthority AuthorityForSize;
		public ImGuiDataAuthority AuthorityForViewport;
		public byte IsVisible;
		public byte IsFocused;
		public byte IsBgDrawnThisFrame;
		public byte HasCloseButton;
		public byte HasWindowMenuButton;
		public byte HasCentralNodeChild;
		public byte WantCloseAll;
		public byte WantLockSizeOnce;
		public byte WantMouseMove;
		public byte WantHiddenTabBarUpdate;
		public byte WantHiddenTabBarToggle;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDockNodePtr : IEquatable<ImGuiDockNodePtr>
	{
		public ImGuiDockNodePtr(ImGuiDockNode* handle) { Handle = handle; }

		public ImGuiDockNode* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDockNodePtr Null => new ImGuiDockNodePtr(null);

		public static implicit operator ImGuiDockNodePtr(ImGuiDockNode* handle) => new ImGuiDockNodePtr(handle);

		public static implicit operator ImGuiDockNode*(ImGuiDockNodePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDockNodePtr left, ImGuiDockNodePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDockNodePtr left, ImGuiDockNodePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDockNodePtr left, ImGuiDockNode* right) => left.Handle == right;

		public static bool operator !=(ImGuiDockNodePtr left, ImGuiDockNode* right) => left.Handle != right;

		public bool Equals(ImGuiDockNodePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDockNodePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDockNodePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiDockNodeFlags SharedFlags => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->SharedFlags);
		public ref ImGuiDockNodeFlags LocalFlags => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->LocalFlags);
		public ref ImGuiDockNodeFlags LocalFlagsInWindows => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->LocalFlagsInWindows);
		public ref ImGuiDockNodeFlags MergedFlags => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->MergedFlags);
		public ref ImGuiDockNodeState State => ref Unsafe.AsRef<ImGuiDockNodeState>(&Handle->State);
		public ref ImGuiDockNodePtr ParentNode => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->ParentNode);
		public ref ImVectorImGuiWindowPtr Windows => ref Unsafe.AsRef<ImVectorImGuiWindowPtr>(&Handle->Windows);
		public ref ImGuiTabBarPtr TabBar => ref Unsafe.AsRef<ImGuiTabBarPtr>(&Handle->TabBar);
		public ref Vector2 Pos => ref Unsafe.AsRef<Vector2>(&Handle->Pos);
		public ref Vector2 Size => ref Unsafe.AsRef<Vector2>(&Handle->Size);
		public ref Vector2 SizeRef => ref Unsafe.AsRef<Vector2>(&Handle->SizeRef);
		public ref ImGuiAxis SplitAxis => ref Unsafe.AsRef<ImGuiAxis>(&Handle->SplitAxis);
		public ref ImGuiWindowClass WindowClass => ref Unsafe.AsRef<ImGuiWindowClass>(&Handle->WindowClass);
		public ref uint LastBgColor => ref Unsafe.AsRef<uint>(&Handle->LastBgColor);
		public ref ImGuiWindowPtr HostWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->HostWindow);
		public ref ImGuiWindowPtr VisibleWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->VisibleWindow);
		public ref ImGuiDockNodePtr CentralNode => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->CentralNode);
		public ref ImGuiDockNodePtr OnlyNodeWithWindows => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->OnlyNodeWithWindows);
		public ref int CountNodeWithWindows => ref Unsafe.AsRef<int>(&Handle->CountNodeWithWindows);
		public ref int LastFrameAlive => ref Unsafe.AsRef<int>(&Handle->LastFrameAlive);
		public ref int LastFrameActive => ref Unsafe.AsRef<int>(&Handle->LastFrameActive);
		public ref int LastFrameFocused => ref Unsafe.AsRef<int>(&Handle->LastFrameFocused);
		public ref int LastFocusedNodeId => ref Unsafe.AsRef<int>(&Handle->LastFocusedNodeId);
		public ref int SelectedTabId => ref Unsafe.AsRef<int>(&Handle->SelectedTabId);
		public ref int WantCloseTabId => ref Unsafe.AsRef<int>(&Handle->WantCloseTabId);
		public ref int RefViewportId => ref Unsafe.AsRef<int>(&Handle->RefViewportId);
		public ref ImGuiDataAuthority AuthorityForPos => ref Unsafe.AsRef<ImGuiDataAuthority>(&Handle->AuthorityForPos);
		public ref ImGuiDataAuthority AuthorityForSize => ref Unsafe.AsRef<ImGuiDataAuthority>(&Handle->AuthorityForSize);
		public ref ImGuiDataAuthority AuthorityForViewport => ref Unsafe.AsRef<ImGuiDataAuthority>(&Handle->AuthorityForViewport);
		public ref bool IsVisible => ref Unsafe.AsRef<bool>(&Handle->IsVisible);
		public ref bool IsFocused => ref Unsafe.AsRef<bool>(&Handle->IsFocused);
		public ref bool IsBgDrawnThisFrame => ref Unsafe.AsRef<bool>(&Handle->IsBgDrawnThisFrame);
		public ref bool HasCloseButton => ref Unsafe.AsRef<bool>(&Handle->HasCloseButton);
		public ref bool HasWindowMenuButton => ref Unsafe.AsRef<bool>(&Handle->HasWindowMenuButton);
		public ref bool HasCentralNodeChild => ref Unsafe.AsRef<bool>(&Handle->HasCentralNodeChild);
		public ref bool WantCloseAll => ref Unsafe.AsRef<bool>(&Handle->WantCloseAll);
		public ref bool WantLockSizeOnce => ref Unsafe.AsRef<bool>(&Handle->WantLockSizeOnce);
		public ref bool WantMouseMove => ref Unsafe.AsRef<bool>(&Handle->WantMouseMove);
		public ref bool WantHiddenTabBarUpdate => ref Unsafe.AsRef<bool>(&Handle->WantHiddenTabBarUpdate);
		public ref bool WantHiddenTabBarToggle => ref Unsafe.AsRef<bool>(&Handle->WantHiddenTabBarToggle);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabBar
	{
		public ImVectorImGuiTabItem Tabs;
		public ImGuiTabBarFlags Flags;
		public int ID;
		public int SelectedTabId;
		public int NextSelectedTabId;
		public int VisibleTabId;
		public int CurrFrameVisible;
		public int PrevFrameVisible;
		public ImRect BarRect;
		public float CurrTabsContentsHeight;
		public float PrevTabsContentsHeight;
		public float WidthAllTabs;
		public float WidthAllTabsIdeal;
		public float ScrollingAnim;
		public float ScrollingTarget;
		public float ScrollingTargetDistToVisibility;
		public float ScrollingSpeed;
		public float ScrollingRectMinX;
		public float ScrollingRectMaxX;
		public int ReorderRequestTabId;
		public short ReorderRequestOffset;
		public sbyte BeginCount;
		public byte WantLayout;
		public byte VisibleTabWasSubmitted;
		public byte TabsAddedNew;
		public short TabsActiveCount;
		public short LastTabItemIdx;
		public float ItemSpacingY;
		public Vector2 FramePadding;
		public Vector2 BackupCursorPos;
		public ImGuiTextBuffer TabsNames;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTabBarPtr : IEquatable<ImGuiTabBarPtr>
	{
		public ImGuiTabBarPtr(ImGuiTabBar* handle) { Handle = handle; }

		public ImGuiTabBar* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTabBarPtr Null => new ImGuiTabBarPtr(null);

		public static implicit operator ImGuiTabBarPtr(ImGuiTabBar* handle) => new ImGuiTabBarPtr(handle);

		public static implicit operator ImGuiTabBar*(ImGuiTabBarPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTabBarPtr left, ImGuiTabBarPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTabBarPtr left, ImGuiTabBarPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTabBarPtr left, ImGuiTabBar* right) => left.Handle == right;

		public static bool operator !=(ImGuiTabBarPtr left, ImGuiTabBar* right) => left.Handle != right;

		public bool Equals(ImGuiTabBarPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTabBarPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTabBarPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImGuiTabItem Tabs => ref Unsafe.AsRef<ImVectorImGuiTabItem>(&Handle->Tabs);
		public ref ImGuiTabBarFlags Flags => ref Unsafe.AsRef<ImGuiTabBarFlags>(&Handle->Flags);
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref int SelectedTabId => ref Unsafe.AsRef<int>(&Handle->SelectedTabId);
		public ref int NextSelectedTabId => ref Unsafe.AsRef<int>(&Handle->NextSelectedTabId);
		public ref int VisibleTabId => ref Unsafe.AsRef<int>(&Handle->VisibleTabId);
		public ref int CurrFrameVisible => ref Unsafe.AsRef<int>(&Handle->CurrFrameVisible);
		public ref int PrevFrameVisible => ref Unsafe.AsRef<int>(&Handle->PrevFrameVisible);
		public ref ImRect BarRect => ref Unsafe.AsRef<ImRect>(&Handle->BarRect);
		public ref float CurrTabsContentsHeight => ref Unsafe.AsRef<float>(&Handle->CurrTabsContentsHeight);
		public ref float PrevTabsContentsHeight => ref Unsafe.AsRef<float>(&Handle->PrevTabsContentsHeight);
		public ref float WidthAllTabs => ref Unsafe.AsRef<float>(&Handle->WidthAllTabs);
		public ref float WidthAllTabsIdeal => ref Unsafe.AsRef<float>(&Handle->WidthAllTabsIdeal);
		public ref float ScrollingAnim => ref Unsafe.AsRef<float>(&Handle->ScrollingAnim);
		public ref float ScrollingTarget => ref Unsafe.AsRef<float>(&Handle->ScrollingTarget);
		public ref float ScrollingTargetDistToVisibility => ref Unsafe.AsRef<float>(&Handle->ScrollingTargetDistToVisibility);
		public ref float ScrollingSpeed => ref Unsafe.AsRef<float>(&Handle->ScrollingSpeed);
		public ref float ScrollingRectMinX => ref Unsafe.AsRef<float>(&Handle->ScrollingRectMinX);
		public ref float ScrollingRectMaxX => ref Unsafe.AsRef<float>(&Handle->ScrollingRectMaxX);
		public ref int ReorderRequestTabId => ref Unsafe.AsRef<int>(&Handle->ReorderRequestTabId);
		public ref short ReorderRequestOffset => ref Unsafe.AsRef<short>(&Handle->ReorderRequestOffset);
		public ref sbyte BeginCount => ref Unsafe.AsRef<sbyte>(&Handle->BeginCount);
		public ref bool WantLayout => ref Unsafe.AsRef<bool>(&Handle->WantLayout);
		public ref bool VisibleTabWasSubmitted => ref Unsafe.AsRef<bool>(&Handle->VisibleTabWasSubmitted);
		public ref bool TabsAddedNew => ref Unsafe.AsRef<bool>(&Handle->TabsAddedNew);
		public ref short TabsActiveCount => ref Unsafe.AsRef<short>(&Handle->TabsActiveCount);
		public ref short LastTabItemIdx => ref Unsafe.AsRef<short>(&Handle->LastTabItemIdx);
		public ref float ItemSpacingY => ref Unsafe.AsRef<float>(&Handle->ItemSpacingY);
		public ref Vector2 FramePadding => ref Unsafe.AsRef<Vector2>(&Handle->FramePadding);
		public ref Vector2 BackupCursorPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorPos);
		public ref ImGuiTextBuffer TabsNames => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->TabsNames);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabItem
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTabItem* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabItem
	{
		public int ID;
		public ImGuiTabItemFlags Flags;
		public unsafe ImGuiWindow* Window;
		public int LastFrameVisible;
		public int LastFrameSelected;
		public float Offset;
		public float Width;
		public float ContentWidth;
		public float RequestedWidth;
		public int NameOffset;
		public short BeginOrder;
		public short IndexDuringLayout;
		public byte WantClose;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTabItemPtr : IEquatable<ImGuiTabItemPtr>
	{
		public ImGuiTabItemPtr(ImGuiTabItem* handle) { Handle = handle; }

		public ImGuiTabItem* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTabItemPtr Null => new ImGuiTabItemPtr(null);

		public static implicit operator ImGuiTabItemPtr(ImGuiTabItem* handle) => new ImGuiTabItemPtr(handle);

		public static implicit operator ImGuiTabItem*(ImGuiTabItemPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTabItemPtr left, ImGuiTabItemPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTabItemPtr left, ImGuiTabItemPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTabItemPtr left, ImGuiTabItem* right) => left.Handle == right;

		public static bool operator !=(ImGuiTabItemPtr left, ImGuiTabItem* right) => left.Handle != right;

		public bool Equals(ImGuiTabItemPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTabItemPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTabItemPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiTabItemFlags Flags => ref Unsafe.AsRef<ImGuiTabItemFlags>(&Handle->Flags);
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		public ref int LastFrameVisible => ref Unsafe.AsRef<int>(&Handle->LastFrameVisible);
		public ref int LastFrameSelected => ref Unsafe.AsRef<int>(&Handle->LastFrameSelected);
		public ref float Offset => ref Unsafe.AsRef<float>(&Handle->Offset);
		public ref float Width => ref Unsafe.AsRef<float>(&Handle->Width);
		public ref float ContentWidth => ref Unsafe.AsRef<float>(&Handle->ContentWidth);
		public ref float RequestedWidth => ref Unsafe.AsRef<float>(&Handle->RequestedWidth);
		public ref int NameOffset => ref Unsafe.AsRef<int>(&Handle->NameOffset);
		public ref short BeginOrder => ref Unsafe.AsRef<short>(&Handle->BeginOrder);
		public ref short IndexDuringLayout => ref Unsafe.AsRef<short>(&Handle->IndexDuringLayout);
		public ref bool WantClose => ref Unsafe.AsRef<bool>(&Handle->WantClose);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextBuffer
	{
		public ImVectorChar Buf;


		public unsafe void append(byte* str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendNative(@this, str, strEnd);
			}
		}

		public unsafe void append(byte* str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendNative(@this, str, (byte*)(default));
			}
		}

		public unsafe void append(ref byte str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.appendNative(@this, (byte*)pstr, strEnd);
				}
			}
		}

		public unsafe void append(ref byte str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.appendNative(@this, (byte*)pstr, (byte*)(default));
				}
			}
		}

		public unsafe void append(string str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append(string str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append(byte* str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					ImGui.appendNative(@this, str, (byte*)pstrEnd);
				}
			}
		}

		public unsafe void append(byte* str, string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append(ref byte str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						ImGui.appendNative(@this, (byte*)pstr, (byte*)pstrEnd);
					}
				}
			}
		}

		public unsafe void append(string str, string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.appendNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public unsafe void appendf(byte* fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfNative(@this, fmt);
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public unsafe void appendf(ref byte fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfNative(@this, (byte*)pfmt);
				}
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public unsafe void appendf(string fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfNative(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void appendfv(byte* fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfvNative(@this, fmt, args);
			}
		}

		public unsafe void appendfv(ref byte fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfvNative(@this, (byte*)pfmt, args);
				}
			}
		}

		public unsafe void appendfv(string fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfvNative(@this, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe byte* begin()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.beginNative(@this);
				return ret;
			}
		}

		public unsafe string beginS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.beginNative(@this));
				return ret;
			}
		}

		public unsafe byte* c_str()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.c_strNative(@this);
				return ret;
			}
		}

		public unsafe string c_strS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.c_strNative(@this));
				return ret;
			}
		}

		public unsafe void clear()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.clearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte ret = ImGui.emptyNative(@this);
				return ret != 0;
			}
		}

		public unsafe byte* end()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.endNative(@this);
				return ret;
			}
		}

		public unsafe string endS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.endNative(@this));
				return ret;
			}
		}

		public unsafe void reserve(int capacity)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.reserveNative(@this, capacity);
			}
		}

		public unsafe int size()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				int ret = ImGui.sizeNative(@this);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTextBufferPtr : IEquatable<ImGuiTextBufferPtr>
	{
		public ImGuiTextBufferPtr(ImGuiTextBuffer* handle) { Handle = handle; }

		public ImGuiTextBuffer* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextBufferPtr Null => new ImGuiTextBufferPtr(null);

		public static implicit operator ImGuiTextBufferPtr(ImGuiTextBuffer* handle) => new ImGuiTextBufferPtr(handle);

		public static implicit operator ImGuiTextBuffer*(ImGuiTextBufferPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextBufferPtr left, ImGuiTextBufferPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextBufferPtr left, ImGuiTextBufferPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextBufferPtr left, ImGuiTextBuffer* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextBufferPtr left, ImGuiTextBuffer* right) => left.Handle != right;

		public bool Equals(ImGuiTextBufferPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextBufferPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTextBufferPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorChar Buf => ref Unsafe.AsRef<ImVectorChar>(&Handle->Buf);

		public unsafe void append(byte* str, byte* strEnd)
		{
			ImGui.appendNative(Handle, str, strEnd);
		}

		public unsafe void append(byte* str)
		{
			ImGui.appendNative(Handle, str, (byte*)(default));
		}

		public unsafe void append(ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				ImGui.appendNative(Handle, (byte*)pstr, strEnd);
			}
		}

		public unsafe void append(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				ImGui.appendNative(Handle, (byte*)pstr, (byte*)(default));
			}
		}

		public unsafe void append(string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendNative(Handle, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void append(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendNative(Handle, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void append(byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				ImGui.appendNative(Handle, str, (byte*)pstrEnd);
			}
		}

		public unsafe void append(byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendNative(Handle, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void append(ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					ImGui.appendNative(Handle, (byte*)pstr, (byte*)pstrEnd);
				}
			}
		}

		public unsafe void append(string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.appendNative(Handle, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public unsafe void appendf(byte* fmt)
		{
			ImGui.appendfNative(Handle, fmt);
		}

		/// <summary>
/// no appendfV
/// </summary>
public unsafe void appendf(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImGui.appendfNative(Handle, (byte*)pfmt);
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public unsafe void appendf(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendfNative(Handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void appendfv(byte* fmt, nuint args)
		{
			ImGui.appendfvNative(Handle, fmt, args);
		}

		public unsafe void appendfv(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImGui.appendfvNative(Handle, (byte*)pfmt, args);
			}
		}

		public unsafe void appendfv(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendfvNative(Handle, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe byte* begin()
		{
			byte* ret = ImGui.beginNative(Handle);
			return ret;
		}

		public unsafe string beginS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.beginNative(Handle));
			return ret;
		}

		public unsafe byte* c_str()
		{
			byte* ret = ImGui.c_strNative(Handle);
			return ret;
		}

		public unsafe string c_strS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.c_strNative(Handle));
			return ret;
		}

		public unsafe void clear()
		{
			ImGui.clearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool empty()
		{
			byte ret = ImGui.emptyNative(Handle);
			return ret != 0;
		}

		public unsafe byte* end()
		{
			byte* ret = ImGui.endNative(Handle);
			return ret;
		}

		public unsafe string endS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.endNative(Handle));
			return ret;
		}

		public unsafe void reserve(int capacity)
		{
			ImGui.reserveNative(Handle, capacity);
		}

		public unsafe int size()
		{
			int ret = ImGui.sizeNative(Handle);
			return ret;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorChar
	{
		public int Size;
		public int Capacity;
		public unsafe byte* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowStackData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiWindowStackData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowStackData
	{
		public unsafe ImGuiWindow* Window;
		public ImGuiLastItemData ParentLastItemDataBackup;
		public ImGuiStackSizes StackSizesOnBegin;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowStackDataPtr : IEquatable<ImGuiWindowStackDataPtr>
	{
		public ImGuiWindowStackDataPtr(ImGuiWindowStackData* handle) { Handle = handle; }

		public ImGuiWindowStackData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowStackDataPtr Null => new ImGuiWindowStackDataPtr(null);

		public static implicit operator ImGuiWindowStackDataPtr(ImGuiWindowStackData* handle) => new ImGuiWindowStackDataPtr(handle);

		public static implicit operator ImGuiWindowStackData*(ImGuiWindowStackDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowStackDataPtr left, ImGuiWindowStackDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowStackDataPtr left, ImGuiWindowStackDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowStackDataPtr left, ImGuiWindowStackData* right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowStackDataPtr left, ImGuiWindowStackData* right) => left.Handle != right;

		public bool Equals(ImGuiWindowStackDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowStackDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowStackDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		public ref ImGuiLastItemData ParentLastItemDataBackup => ref Unsafe.AsRef<ImGuiLastItemData>(&Handle->ParentLastItemDataBackup);
		public ref ImGuiStackSizes StackSizesOnBegin => ref Unsafe.AsRef<ImGuiStackSizes>(&Handle->StackSizesOnBegin);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLastItemData
	{
		public int ID;
		public ImGuiItemFlags InFlags;
		public ImGuiItemStatusFlags StatusFlags;
		public ImRect Rect;
		public ImRect NavRect;
		public ImRect DisplayRect;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiLastItemDataPtr : IEquatable<ImGuiLastItemDataPtr>
	{
		public ImGuiLastItemDataPtr(ImGuiLastItemData* handle) { Handle = handle; }

		public ImGuiLastItemData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiLastItemDataPtr Null => new ImGuiLastItemDataPtr(null);

		public static implicit operator ImGuiLastItemDataPtr(ImGuiLastItemData* handle) => new ImGuiLastItemDataPtr(handle);

		public static implicit operator ImGuiLastItemData*(ImGuiLastItemDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiLastItemDataPtr left, ImGuiLastItemDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiLastItemDataPtr left, ImGuiLastItemDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiLastItemDataPtr left, ImGuiLastItemData* right) => left.Handle == right;

		public static bool operator !=(ImGuiLastItemDataPtr left, ImGuiLastItemData* right) => left.Handle != right;

		public bool Equals(ImGuiLastItemDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiLastItemDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiLastItemDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiItemFlags InFlags => ref Unsafe.AsRef<ImGuiItemFlags>(&Handle->InFlags);
		public ref ImGuiItemStatusFlags StatusFlags => ref Unsafe.AsRef<ImGuiItemStatusFlags>(&Handle->StatusFlags);
		public ref ImRect Rect => ref Unsafe.AsRef<ImRect>(&Handle->Rect);
		public ref ImRect NavRect => ref Unsafe.AsRef<ImRect>(&Handle->NavRect);
		public ref ImRect DisplayRect => ref Unsafe.AsRef<ImRect>(&Handle->DisplayRect);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackSizes
	{
		public short SizeOfIDStack;
		public short SizeOfColorStack;
		public short SizeOfStyleVarStack;
		public short SizeOfFontStack;
		public short SizeOfFocusScopeStack;
		public short SizeOfGroupStack;
		public short SizeOfItemFlagsStack;
		public short SizeOfBeginPopupStack;
		public short SizeOfDisabledStack;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStackSizesPtr : IEquatable<ImGuiStackSizesPtr>
	{
		public ImGuiStackSizesPtr(ImGuiStackSizes* handle) { Handle = handle; }

		public ImGuiStackSizes* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStackSizesPtr Null => new ImGuiStackSizesPtr(null);

		public static implicit operator ImGuiStackSizesPtr(ImGuiStackSizes* handle) => new ImGuiStackSizesPtr(handle);

		public static implicit operator ImGuiStackSizes*(ImGuiStackSizesPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStackSizesPtr left, ImGuiStackSizesPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStackSizesPtr left, ImGuiStackSizesPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStackSizesPtr left, ImGuiStackSizes* right) => left.Handle == right;

		public static bool operator !=(ImGuiStackSizesPtr left, ImGuiStackSizes* right) => left.Handle != right;

		public bool Equals(ImGuiStackSizesPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStackSizesPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStackSizesPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref short SizeOfIDStack => ref Unsafe.AsRef<short>(&Handle->SizeOfIDStack);
		public ref short SizeOfColorStack => ref Unsafe.AsRef<short>(&Handle->SizeOfColorStack);
		public ref short SizeOfStyleVarStack => ref Unsafe.AsRef<short>(&Handle->SizeOfStyleVarStack);
		public ref short SizeOfFontStack => ref Unsafe.AsRef<short>(&Handle->SizeOfFontStack);
		public ref short SizeOfFocusScopeStack => ref Unsafe.AsRef<short>(&Handle->SizeOfFocusScopeStack);
		public ref short SizeOfGroupStack => ref Unsafe.AsRef<short>(&Handle->SizeOfGroupStack);
		public ref short SizeOfItemFlagsStack => ref Unsafe.AsRef<short>(&Handle->SizeOfItemFlagsStack);
		public ref short SizeOfBeginPopupStack => ref Unsafe.AsRef<short>(&Handle->SizeOfBeginPopupStack);
		public ref short SizeOfDisabledStack => ref Unsafe.AsRef<short>(&Handle->SizeOfDisabledStack);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyOwnerData
	{
		public int OwnerCurr;
		public int OwnerNext;
		public byte LockThisFrame;
		public byte LockUntilRelease;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiKeyOwnerDataPtr : IEquatable<ImGuiKeyOwnerDataPtr>
	{
		public ImGuiKeyOwnerDataPtr(ImGuiKeyOwnerData* handle) { Handle = handle; }

		public ImGuiKeyOwnerData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiKeyOwnerDataPtr Null => new ImGuiKeyOwnerDataPtr(null);

		public static implicit operator ImGuiKeyOwnerDataPtr(ImGuiKeyOwnerData* handle) => new ImGuiKeyOwnerDataPtr(handle);

		public static implicit operator ImGuiKeyOwnerData*(ImGuiKeyOwnerDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiKeyOwnerDataPtr left, ImGuiKeyOwnerDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiKeyOwnerDataPtr left, ImGuiKeyOwnerDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiKeyOwnerDataPtr left, ImGuiKeyOwnerData* right) => left.Handle == right;

		public static bool operator !=(ImGuiKeyOwnerDataPtr left, ImGuiKeyOwnerData* right) => left.Handle != right;

		public bool Equals(ImGuiKeyOwnerDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiKeyOwnerDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiKeyOwnerDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int OwnerCurr => ref Unsafe.AsRef<int>(&Handle->OwnerCurr);
		public ref int OwnerNext => ref Unsafe.AsRef<int>(&Handle->OwnerNext);
		public ref bool LockThisFrame => ref Unsafe.AsRef<bool>(&Handle->LockThisFrame);
		public ref bool LockUntilRelease => ref Unsafe.AsRef<bool>(&Handle->LockUntilRelease);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingTable
	{
		public short Index_0;
		public short Index_1;
		public short Index_2;
		public short Index_3;
		public short Index_4;
		public short Index_5;
		public short Index_6;
		public short Index_7;
		public short Index_8;
		public short Index_9;
		public short Index_10;
		public short Index_11;
		public short Index_12;
		public short Index_13;
		public short Index_14;
		public short Index_15;
		public short Index_16;
		public short Index_17;
		public short Index_18;
		public short Index_19;
		public short Index_20;
		public short Index_21;
		public short Index_22;
		public short Index_23;
		public short Index_24;
		public short Index_25;
		public short Index_26;
		public short Index_27;
		public short Index_28;
		public short Index_29;
		public short Index_30;
		public short Index_31;
		public short Index_32;
		public short Index_33;
		public short Index_34;
		public short Index_35;
		public short Index_36;
		public short Index_37;
		public short Index_38;
		public short Index_39;
		public short Index_40;
		public short Index_41;
		public short Index_42;
		public short Index_43;
		public short Index_44;
		public short Index_45;
		public short Index_46;
		public short Index_47;
		public short Index_48;
		public short Index_49;
		public short Index_50;
		public short Index_51;
		public short Index_52;
		public short Index_53;
		public short Index_54;
		public short Index_55;
		public short Index_56;
		public short Index_57;
		public short Index_58;
		public short Index_59;
		public short Index_60;
		public short Index_61;
		public short Index_62;
		public short Index_63;
		public short Index_64;
		public short Index_65;
		public short Index_66;
		public short Index_67;
		public short Index_68;
		public short Index_69;
		public short Index_70;
		public short Index_71;
		public short Index_72;
		public short Index_73;
		public short Index_74;
		public short Index_75;
		public short Index_76;
		public short Index_77;
		public short Index_78;
		public short Index_79;
		public short Index_80;
		public short Index_81;
		public short Index_82;
		public short Index_83;
		public short Index_84;
		public short Index_85;
		public short Index_86;
		public short Index_87;
		public short Index_88;
		public short Index_89;
		public short Index_90;
		public short Index_91;
		public short Index_92;
		public short Index_93;
		public short Index_94;
		public short Index_95;
		public short Index_96;
		public short Index_97;
		public short Index_98;
		public short Index_99;
		public short Index_100;
		public short Index_101;
		public short Index_102;
		public short Index_103;
		public short Index_104;
		public short Index_105;
		public short Index_106;
		public short Index_107;
		public short Index_108;
		public short Index_109;
		public short Index_110;
		public short Index_111;
		public short Index_112;
		public short Index_113;
		public short Index_114;
		public short Index_115;
		public short Index_116;
		public short Index_117;
		public short Index_118;
		public short Index_119;
		public short Index_120;
		public short Index_121;
		public short Index_122;
		public short Index_123;
		public short Index_124;
		public short Index_125;
		public short Index_126;
		public short Index_127;
		public short Index_128;
		public short Index_129;
		public short Index_130;
		public short Index_131;
		public short Index_132;
		public short Index_133;
		public short Index_134;
		public short Index_135;
		public short Index_136;
		public short Index_137;
		public short Index_138;
		public short Index_139;
		public ImVectorImGuiKeyRoutingData Entries;
		public ImVectorImGuiKeyRoutingData EntriesNext;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiKeyRoutingTablePtr : IEquatable<ImGuiKeyRoutingTablePtr>
	{
		public ImGuiKeyRoutingTablePtr(ImGuiKeyRoutingTable* handle) { Handle = handle; }

		public ImGuiKeyRoutingTable* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiKeyRoutingTablePtr Null => new ImGuiKeyRoutingTablePtr(null);

		public static implicit operator ImGuiKeyRoutingTablePtr(ImGuiKeyRoutingTable* handle) => new ImGuiKeyRoutingTablePtr(handle);

		public static implicit operator ImGuiKeyRoutingTable*(ImGuiKeyRoutingTablePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiKeyRoutingTablePtr left, ImGuiKeyRoutingTablePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiKeyRoutingTablePtr left, ImGuiKeyRoutingTablePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiKeyRoutingTablePtr left, ImGuiKeyRoutingTable* right) => left.Handle == right;

		public static bool operator !=(ImGuiKeyRoutingTablePtr left, ImGuiKeyRoutingTable* right) => left.Handle != right;

		public bool Equals(ImGuiKeyRoutingTablePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiKeyRoutingTablePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiKeyRoutingTablePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public unsafe Span<short> Index
		
		{
			get
			{
				return new Span<short>(&Handle->Index_0, 140);
			}
		}
		public ref ImVectorImGuiKeyRoutingData Entries => ref Unsafe.AsRef<ImVectorImGuiKeyRoutingData>(&Handle->Entries);
		public ref ImVectorImGuiKeyRoutingData EntriesNext => ref Unsafe.AsRef<ImVectorImGuiKeyRoutingData>(&Handle->EntriesNext);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiKeyRoutingData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiKeyRoutingData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingData
	{
		public short NextEntryIndex;
		public ushort Mods;
		public byte RoutingNextScore;
		public int RoutingCurr;
		public int RoutingNext;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiKeyRoutingDataPtr : IEquatable<ImGuiKeyRoutingDataPtr>
	{
		public ImGuiKeyRoutingDataPtr(ImGuiKeyRoutingData* handle) { Handle = handle; }

		public ImGuiKeyRoutingData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiKeyRoutingDataPtr Null => new ImGuiKeyRoutingDataPtr(null);

		public static implicit operator ImGuiKeyRoutingDataPtr(ImGuiKeyRoutingData* handle) => new ImGuiKeyRoutingDataPtr(handle);

		public static implicit operator ImGuiKeyRoutingData*(ImGuiKeyRoutingDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiKeyRoutingDataPtr left, ImGuiKeyRoutingDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiKeyRoutingDataPtr left, ImGuiKeyRoutingDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiKeyRoutingDataPtr left, ImGuiKeyRoutingData* right) => left.Handle == right;

		public static bool operator !=(ImGuiKeyRoutingDataPtr left, ImGuiKeyRoutingData* right) => left.Handle != right;

		public bool Equals(ImGuiKeyRoutingDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiKeyRoutingDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiKeyRoutingDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref short NextEntryIndex => ref Unsafe.AsRef<short>(&Handle->NextEntryIndex);
		public ref ushort Mods => ref Unsafe.AsRef<ushort>(&Handle->Mods);
		public ref byte RoutingNextScore => ref Unsafe.AsRef<byte>(&Handle->RoutingNextScore);
		public ref int RoutingCurr => ref Unsafe.AsRef<int>(&Handle->RoutingCurr);
		public ref int RoutingNext => ref Unsafe.AsRef<int>(&Handle->RoutingNext);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextItemData
	{
		public ImGuiNextItemDataFlags Flags;
		public ImGuiItemFlags ItemFlags;
		public float Width;
		public int FocusScopeId;
		public ImGuiCond OpenCond;
		public byte OpenVal;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiNextItemDataPtr : IEquatable<ImGuiNextItemDataPtr>
	{
		public ImGuiNextItemDataPtr(ImGuiNextItemData* handle) { Handle = handle; }

		public ImGuiNextItemData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiNextItemDataPtr Null => new ImGuiNextItemDataPtr(null);

		public static implicit operator ImGuiNextItemDataPtr(ImGuiNextItemData* handle) => new ImGuiNextItemDataPtr(handle);

		public static implicit operator ImGuiNextItemData*(ImGuiNextItemDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiNextItemDataPtr left, ImGuiNextItemDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiNextItemDataPtr left, ImGuiNextItemDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiNextItemDataPtr left, ImGuiNextItemData* right) => left.Handle == right;

		public static bool operator !=(ImGuiNextItemDataPtr left, ImGuiNextItemData* right) => left.Handle != right;

		public bool Equals(ImGuiNextItemDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiNextItemDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiNextItemDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiNextItemDataFlags Flags => ref Unsafe.AsRef<ImGuiNextItemDataFlags>(&Handle->Flags);
		public ref ImGuiItemFlags ItemFlags => ref Unsafe.AsRef<ImGuiItemFlags>(&Handle->ItemFlags);
		public ref float Width => ref Unsafe.AsRef<float>(&Handle->Width);
		public ref int FocusScopeId => ref Unsafe.AsRef<int>(&Handle->FocusScopeId);
		public ref ImGuiCond OpenCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->OpenCond);
		public ref bool OpenVal => ref Unsafe.AsRef<bool>(&Handle->OpenVal);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextWindowData
	{
		public ImGuiNextWindowDataFlags Flags;
		public ImGuiCond PosCond;
		public ImGuiCond SizeCond;
		public ImGuiCond CollapsedCond;
		public ImGuiCond DockCond;
		public Vector2 PosVal;
		public Vector2 PosPivotVal;
		public Vector2 SizeVal;
		public Vector2 ContentSizeVal;
		public Vector2 ScrollVal;
		public byte PosUndock;
		public byte CollapsedVal;
		public ImRect SizeConstraintRect;
		public unsafe void* SizeCallback;
		public unsafe void* SizeCallbackUserData;
		public float BgAlphaVal;
		public int ViewportId;
		public int DockId;
		public ImGuiWindowClass WindowClass;
		public Vector2 MenuBarOffsetMinVal;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiNextWindowDataPtr : IEquatable<ImGuiNextWindowDataPtr>
	{
		public ImGuiNextWindowDataPtr(ImGuiNextWindowData* handle) { Handle = handle; }

		public ImGuiNextWindowData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiNextWindowDataPtr Null => new ImGuiNextWindowDataPtr(null);

		public static implicit operator ImGuiNextWindowDataPtr(ImGuiNextWindowData* handle) => new ImGuiNextWindowDataPtr(handle);

		public static implicit operator ImGuiNextWindowData*(ImGuiNextWindowDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiNextWindowDataPtr left, ImGuiNextWindowDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiNextWindowDataPtr left, ImGuiNextWindowDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiNextWindowDataPtr left, ImGuiNextWindowData* right) => left.Handle == right;

		public static bool operator !=(ImGuiNextWindowDataPtr left, ImGuiNextWindowData* right) => left.Handle != right;

		public bool Equals(ImGuiNextWindowDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiNextWindowDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiNextWindowDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiNextWindowDataFlags Flags => ref Unsafe.AsRef<ImGuiNextWindowDataFlags>(&Handle->Flags);
		public ref ImGuiCond PosCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->PosCond);
		public ref ImGuiCond SizeCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->SizeCond);
		public ref ImGuiCond CollapsedCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->CollapsedCond);
		public ref ImGuiCond DockCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->DockCond);
		public ref Vector2 PosVal => ref Unsafe.AsRef<Vector2>(&Handle->PosVal);
		public ref Vector2 PosPivotVal => ref Unsafe.AsRef<Vector2>(&Handle->PosPivotVal);
		public ref Vector2 SizeVal => ref Unsafe.AsRef<Vector2>(&Handle->SizeVal);
		public ref Vector2 ContentSizeVal => ref Unsafe.AsRef<Vector2>(&Handle->ContentSizeVal);
		public ref Vector2 ScrollVal => ref Unsafe.AsRef<Vector2>(&Handle->ScrollVal);
		public ref bool PosUndock => ref Unsafe.AsRef<bool>(&Handle->PosUndock);
		public ref bool CollapsedVal => ref Unsafe.AsRef<bool>(&Handle->CollapsedVal);
		public ref ImRect SizeConstraintRect => ref Unsafe.AsRef<ImRect>(&Handle->SizeConstraintRect);
		public void* SizeCallback { get => Handle->SizeCallback; set => Handle->SizeCallback = value; }
		public void* SizeCallbackUserData { get => Handle->SizeCallbackUserData; set => Handle->SizeCallbackUserData = value; }
		public ref float BgAlphaVal => ref Unsafe.AsRef<float>(&Handle->BgAlphaVal);
		public ref int ViewportId => ref Unsafe.AsRef<int>(&Handle->ViewportId);
		public ref int DockId => ref Unsafe.AsRef<int>(&Handle->DockId);
		public ref ImGuiWindowClass WindowClass => ref Unsafe.AsRef<ImGuiWindowClass>(&Handle->WindowClass);
		public ref Vector2 MenuBarOffsetMinVal => ref Unsafe.AsRef<Vector2>(&Handle->MenuBarOffsetMinVal);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiSizeCallbackData
	{
		public unsafe void* UserData;
		public Vector2 Pos;
		public Vector2 CurrentSize;
		public Vector2 DesiredSize;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiColorMod
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiColorMod* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiColorMod
	{
		public ImGuiCol Col;
		public Vector4 BackupValue;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiColorModPtr : IEquatable<ImGuiColorModPtr>
	{
		public ImGuiColorModPtr(ImGuiColorMod* handle) { Handle = handle; }

		public ImGuiColorMod* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiColorModPtr Null => new ImGuiColorModPtr(null);

		public static implicit operator ImGuiColorModPtr(ImGuiColorMod* handle) => new ImGuiColorModPtr(handle);

		public static implicit operator ImGuiColorMod*(ImGuiColorModPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiColorModPtr left, ImGuiColorModPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiColorModPtr left, ImGuiColorModPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiColorModPtr left, ImGuiColorMod* right) => left.Handle == right;

		public static bool operator !=(ImGuiColorModPtr left, ImGuiColorMod* right) => left.Handle != right;

		public bool Equals(ImGuiColorModPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiColorModPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiColorModPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiCol Col => ref Unsafe.AsRef<ImGuiCol>(&Handle->Col);
		public ref Vector4 BackupValue => ref Unsafe.AsRef<Vector4>(&Handle->BackupValue);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStyleMod
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStyleMod* Data;

	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiStyleModUnion
	{
		[FieldOffset(0)]
		public int BackupInt_0;
		[FieldOffset(8)]
		public int BackupInt_1;
		[FieldOffset(0)]
		public float BackupFloat_0;
		[FieldOffset(8)]
		public float BackupFloat_1;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyleMod
	{
		public ImGuiStyleVar VarIdx;
		public ImGuiStyleModUnion ImGuiStyleModUnion;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStyleModPtr : IEquatable<ImGuiStyleModPtr>
	{
		public ImGuiStyleModPtr(ImGuiStyleMod* handle) { Handle = handle; }

		public ImGuiStyleMod* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStyleModPtr Null => new ImGuiStyleModPtr(null);

		public static implicit operator ImGuiStyleModPtr(ImGuiStyleMod* handle) => new ImGuiStyleModPtr(handle);

		public static implicit operator ImGuiStyleMod*(ImGuiStyleModPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStyleModPtr left, ImGuiStyleModPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStyleModPtr left, ImGuiStyleModPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStyleModPtr left, ImGuiStyleMod* right) => left.Handle == right;

		public static bool operator !=(ImGuiStyleModPtr left, ImGuiStyleMod* right) => left.Handle != right;

		public bool Equals(ImGuiStyleModPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStyleModPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStyleModPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiStyleVar VarIdx => ref Unsafe.AsRef<ImGuiStyleVar>(&Handle->VarIdx);
		public ref ImGuiStyleModUnion ImGuiStyleModUnion => ref Unsafe.AsRef<ImGuiStyleModUnion>(&Handle->ImGuiStyleModUnion);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiItemFlags
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiItemFlags* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiGroupData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiGroupData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiGroupData
	{
		public int WindowID;
		public Vector2 BackupCursorPos;
		public Vector2 BackupCursorMaxPos;
		public ImVec1 BackupIndent;
		public ImVec1 BackupGroupOffset;
		public Vector2 BackupCurrLineSize;
		public float BackupCurrLineTextBaseOffset;
		public int BackupActiveIdIsAlive;
		public byte BackupActiveIdPreviousFrameIsAlive;
		public byte BackupHoveredIdIsAlive;
		public byte EmitItem;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiGroupDataPtr : IEquatable<ImGuiGroupDataPtr>
	{
		public ImGuiGroupDataPtr(ImGuiGroupData* handle) { Handle = handle; }

		public ImGuiGroupData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiGroupDataPtr Null => new ImGuiGroupDataPtr(null);

		public static implicit operator ImGuiGroupDataPtr(ImGuiGroupData* handle) => new ImGuiGroupDataPtr(handle);

		public static implicit operator ImGuiGroupData*(ImGuiGroupDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiGroupDataPtr left, ImGuiGroupDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiGroupDataPtr left, ImGuiGroupDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiGroupDataPtr left, ImGuiGroupData* right) => left.Handle == right;

		public static bool operator !=(ImGuiGroupDataPtr left, ImGuiGroupData* right) => left.Handle != right;

		public bool Equals(ImGuiGroupDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiGroupDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiGroupDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int WindowID => ref Unsafe.AsRef<int>(&Handle->WindowID);
		public ref Vector2 BackupCursorPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorPos);
		public ref Vector2 BackupCursorMaxPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorMaxPos);
		public ref ImVec1 BackupIndent => ref Unsafe.AsRef<ImVec1>(&Handle->BackupIndent);
		public ref ImVec1 BackupGroupOffset => ref Unsafe.AsRef<ImVec1>(&Handle->BackupGroupOffset);
		public ref Vector2 BackupCurrLineSize => ref Unsafe.AsRef<Vector2>(&Handle->BackupCurrLineSize);
		public ref float BackupCurrLineTextBaseOffset => ref Unsafe.AsRef<float>(&Handle->BackupCurrLineTextBaseOffset);
		public ref int BackupActiveIdIsAlive => ref Unsafe.AsRef<int>(&Handle->BackupActiveIdIsAlive);
		public ref bool BackupActiveIdPreviousFrameIsAlive => ref Unsafe.AsRef<bool>(&Handle->BackupActiveIdPreviousFrameIsAlive);
		public ref bool BackupHoveredIdIsAlive => ref Unsafe.AsRef<bool>(&Handle->BackupHoveredIdIsAlive);
		public ref bool EmitItem => ref Unsafe.AsRef<bool>(&Handle->EmitItem);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPopupData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPopupData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPopupData
	{
		public int PopupId;
		public unsafe ImGuiWindow* Window;
		public unsafe ImGuiWindow* BackupNavWindow;
		public int ParentNavLayer;
		public int OpenFrameCount;
		public int OpenParentId;
		public Vector2 OpenPopupPos;
		public Vector2 OpenMousePos;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPopupDataPtr : IEquatable<ImGuiPopupDataPtr>
	{
		public ImGuiPopupDataPtr(ImGuiPopupData* handle) { Handle = handle; }

		public ImGuiPopupData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPopupDataPtr Null => new ImGuiPopupDataPtr(null);

		public static implicit operator ImGuiPopupDataPtr(ImGuiPopupData* handle) => new ImGuiPopupDataPtr(handle);

		public static implicit operator ImGuiPopupData*(ImGuiPopupDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPopupDataPtr left, ImGuiPopupDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPopupDataPtr left, ImGuiPopupDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPopupDataPtr left, ImGuiPopupData* right) => left.Handle == right;

		public static bool operator !=(ImGuiPopupDataPtr left, ImGuiPopupData* right) => left.Handle != right;

		public bool Equals(ImGuiPopupDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPopupDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPopupDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int PopupId => ref Unsafe.AsRef<int>(&Handle->PopupId);
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		public ref ImGuiWindowPtr BackupNavWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->BackupNavWindow);
		public ref int ParentNavLayer => ref Unsafe.AsRef<int>(&Handle->ParentNavLayer);
		public ref int OpenFrameCount => ref Unsafe.AsRef<int>(&Handle->OpenFrameCount);
		public ref int OpenParentId => ref Unsafe.AsRef<int>(&Handle->OpenParentId);
		public ref Vector2 OpenPopupPos => ref Unsafe.AsRef<Vector2>(&Handle->OpenPopupPos);
		public ref Vector2 OpenMousePos => ref Unsafe.AsRef<Vector2>(&Handle->OpenMousePos);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiViewportP** Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNavItemData
	{
		public unsafe ImGuiWindow* Window;
		public int ID;
		public int FocusScopeId;
		public ImRect RectRel;
		public ImGuiItemFlags InFlags;
		public float DistBox;
		public float DistCenter;
		public float DistAxial;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiNavItemDataPtr : IEquatable<ImGuiNavItemDataPtr>
	{
		public ImGuiNavItemDataPtr(ImGuiNavItemData* handle) { Handle = handle; }

		public ImGuiNavItemData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiNavItemDataPtr Null => new ImGuiNavItemDataPtr(null);

		public static implicit operator ImGuiNavItemDataPtr(ImGuiNavItemData* handle) => new ImGuiNavItemDataPtr(handle);

		public static implicit operator ImGuiNavItemData*(ImGuiNavItemDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiNavItemDataPtr left, ImGuiNavItemDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiNavItemDataPtr left, ImGuiNavItemDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiNavItemDataPtr left, ImGuiNavItemData* right) => left.Handle == right;

		public static bool operator !=(ImGuiNavItemDataPtr left, ImGuiNavItemData* right) => left.Handle != right;

		public bool Equals(ImGuiNavItemDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiNavItemDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiNavItemDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref int FocusScopeId => ref Unsafe.AsRef<int>(&Handle->FocusScopeId);
		public ref ImRect RectRel => ref Unsafe.AsRef<ImRect>(&Handle->RectRel);
		public ref ImGuiItemFlags InFlags => ref Unsafe.AsRef<ImGuiItemFlags>(&Handle->InFlags);
		public ref float DistBox => ref Unsafe.AsRef<float>(&Handle->DistBox);
		public ref float DistCenter => ref Unsafe.AsRef<float>(&Handle->DistCenter);
		public ref float DistAxial => ref Unsafe.AsRef<float>(&Handle->DistAxial);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPayload
	{
		public unsafe void* Data;
		public int DataSize;
		public int SourceId;
		public int SourceParentId;
		public int DataFrameCount;
		public byte DataType_0;
		public byte DataType_1;
		public byte DataType_2;
		public byte DataType_3;
		public byte DataType_4;
		public byte DataType_5;
		public byte DataType_6;
		public byte DataType_7;
		public byte DataType_8;
		public byte DataType_9;
		public byte DataType_10;
		public byte DataType_11;
		public byte DataType_12;
		public byte DataType_13;
		public byte DataType_14;
		public byte DataType_15;
		public byte DataType_16;
		public byte DataType_17;
		public byte DataType_18;
		public byte DataType_19;
		public byte DataType_20;
		public byte DataType_21;
		public byte DataType_22;
		public byte DataType_23;
		public byte DataType_24;
		public byte DataType_25;
		public byte DataType_26;
		public byte DataType_27;
		public byte DataType_28;
		public byte DataType_29;
		public byte DataType_30;
		public byte DataType_31;
		public byte DataType_32;
		public byte Preview;
		public byte Delivery;


		public unsafe void Clear()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsDataType(byte* type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsDataTypeNative(@this, type);
				return ret != 0;
			}
		}

		public unsafe bool IsDataType(ref byte type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				fixed (byte* ptype = &type)
				{
					byte ret = ImGui.IsDataTypeNative(@this, (byte*)ptype);
					return ret != 0;
				}
			}
		}

		public unsafe bool IsDataType(string type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.IsDataTypeNative(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool IsDelivery()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsDeliveryNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsPreview()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsPreviewNative(@this);
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPayloadPtr : IEquatable<ImGuiPayloadPtr>
	{
		public ImGuiPayloadPtr(ImGuiPayload* handle) { Handle = handle; }

		public ImGuiPayload* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPayloadPtr Null => new ImGuiPayloadPtr(null);

		public static implicit operator ImGuiPayloadPtr(ImGuiPayload* handle) => new ImGuiPayloadPtr(handle);

		public static implicit operator ImGuiPayload*(ImGuiPayloadPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPayloadPtr left, ImGuiPayloadPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPayloadPtr left, ImGuiPayloadPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPayloadPtr left, ImGuiPayload* right) => left.Handle == right;

		public static bool operator !=(ImGuiPayloadPtr left, ImGuiPayload* right) => left.Handle != right;

		public bool Equals(ImGuiPayloadPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPayloadPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPayloadPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public void* Data { get => Handle->Data; set => Handle->Data = value; }
		public ref int DataSize => ref Unsafe.AsRef<int>(&Handle->DataSize);
		public ref int SourceId => ref Unsafe.AsRef<int>(&Handle->SourceId);
		public ref int SourceParentId => ref Unsafe.AsRef<int>(&Handle->SourceParentId);
		public ref int DataFrameCount => ref Unsafe.AsRef<int>(&Handle->DataFrameCount);
		public unsafe Span<byte> DataType
		
		{
			get
			{
				return new Span<byte>(&Handle->DataType_0, 33);
			}
		}
		public ref bool Preview => ref Unsafe.AsRef<bool>(&Handle->Preview);
		public ref bool Delivery => ref Unsafe.AsRef<bool>(&Handle->Delivery);

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool IsDataType(byte* type)
		{
			byte ret = ImGui.IsDataTypeNative(Handle, type);
			return ret != 0;
		}

		public unsafe bool IsDataType(ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = ImGui.IsDataTypeNative(Handle, (byte*)ptype);
				return ret != 0;
			}
		}

		public unsafe bool IsDataType(string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.IsDataTypeNative(Handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool IsDelivery()
		{
			byte ret = ImGui.IsDeliveryNative(Handle);
			return ret != 0;
		}

		public unsafe bool IsPreview()
		{
			byte ret = ImGui.IsPreviewNative(Handle);
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorUnsignedChar
	{
		public int Size;
		public int Capacity;
		public unsafe byte* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiListClipperData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperData
	{
		public unsafe ImGuiListClipper* ListClipper;
		public float LossynessOffset;
		public int StepNo;
		public int ItemsFrozen;
		public ImVectorImGuiListClipperRange Ranges;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiListClipperDataPtr : IEquatable<ImGuiListClipperDataPtr>
	{
		public ImGuiListClipperDataPtr(ImGuiListClipperData* handle) { Handle = handle; }

		public ImGuiListClipperData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiListClipperDataPtr Null => new ImGuiListClipperDataPtr(null);

		public static implicit operator ImGuiListClipperDataPtr(ImGuiListClipperData* handle) => new ImGuiListClipperDataPtr(handle);

		public static implicit operator ImGuiListClipperData*(ImGuiListClipperDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiListClipperDataPtr left, ImGuiListClipperDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiListClipperDataPtr left, ImGuiListClipperDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiListClipperDataPtr left, ImGuiListClipperData* right) => left.Handle == right;

		public static bool operator !=(ImGuiListClipperDataPtr left, ImGuiListClipperData* right) => left.Handle != right;

		public bool Equals(ImGuiListClipperDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiListClipperDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiListClipperDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiListClipperPtr ListClipper => ref Unsafe.AsRef<ImGuiListClipperPtr>(&Handle->ListClipper);
		public ref float LossynessOffset => ref Unsafe.AsRef<float>(&Handle->LossynessOffset);
		public ref int StepNo => ref Unsafe.AsRef<int>(&Handle->StepNo);
		public ref int ItemsFrozen => ref Unsafe.AsRef<int>(&Handle->ItemsFrozen);
		public ref ImVectorImGuiListClipperRange Ranges => ref Unsafe.AsRef<ImVectorImGuiListClipperRange>(&Handle->Ranges);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipper
	{
		public unsafe ImGuiContext* Ctx;
		public int DisplayStart;
		public int DisplayEnd;
		public int ItemsCount;
		public float ItemsHeight;
		public float StartPosY;
		public unsafe void* TempData;


		public unsafe void Begin(int itemsCount, float itemsHeight)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.BeginNative(@this, itemsCount, itemsHeight);
			}
		}

		public unsafe void Begin(int itemsCount)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.BeginNative(@this, itemsCount, (float)(-1.0f));
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void End()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.EndNative(@this);
			}
		}

		public unsafe void IncludeRangeByIndices(int itemBegin, int itemEnd)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.IncludeRangeByIndicesNative(@this, itemBegin, itemEnd);
			}
		}

		public unsafe bool Step()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				byte ret = ImGui.StepNative(@this);
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiListClipperPtr : IEquatable<ImGuiListClipperPtr>
	{
		public ImGuiListClipperPtr(ImGuiListClipper* handle) { Handle = handle; }

		public ImGuiListClipper* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiListClipperPtr Null => new ImGuiListClipperPtr(null);

		public static implicit operator ImGuiListClipperPtr(ImGuiListClipper* handle) => new ImGuiListClipperPtr(handle);

		public static implicit operator ImGuiListClipper*(ImGuiListClipperPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiListClipperPtr left, ImGuiListClipperPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiListClipperPtr left, ImGuiListClipperPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiListClipperPtr left, ImGuiListClipper* right) => left.Handle == right;

		public static bool operator !=(ImGuiListClipperPtr left, ImGuiListClipper* right) => left.Handle != right;

		public bool Equals(ImGuiListClipperPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiListClipperPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiListClipperPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		public ref int DisplayStart => ref Unsafe.AsRef<int>(&Handle->DisplayStart);
		public ref int DisplayEnd => ref Unsafe.AsRef<int>(&Handle->DisplayEnd);
		public ref int ItemsCount => ref Unsafe.AsRef<int>(&Handle->ItemsCount);
		public ref float ItemsHeight => ref Unsafe.AsRef<float>(&Handle->ItemsHeight);
		public ref float StartPosY => ref Unsafe.AsRef<float>(&Handle->StartPosY);
		public void* TempData { get => Handle->TempData; set => Handle->TempData = value; }

		public unsafe void Begin(int itemsCount, float itemsHeight)
		{
			ImGui.BeginNative(Handle, itemsCount, itemsHeight);
		}

		public unsafe void Begin(int itemsCount)
		{
			ImGui.BeginNative(Handle, itemsCount, (float)(-1.0f));
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void End()
		{
			ImGui.EndNative(Handle);
		}

		public unsafe void IncludeRangeByIndices(int itemBegin, int itemEnd)
		{
			ImGui.IncludeRangeByIndicesNative(Handle, itemBegin, itemEnd);
		}

		public unsafe bool Step()
		{
			byte ret = ImGui.StepNative(Handle);
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperRange
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiListClipperRange* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperRange
	{
		public int Min;
		public int Max;
		public byte PosToIndexConvert;
		public sbyte PosToIndexOffsetMin;
		public sbyte PosToIndexOffsetMax;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiListClipperRangePtr : IEquatable<ImGuiListClipperRangePtr>
	{
		public ImGuiListClipperRangePtr(ImGuiListClipperRange* handle) { Handle = handle; }

		public ImGuiListClipperRange* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiListClipperRangePtr Null => new ImGuiListClipperRangePtr(null);

		public static implicit operator ImGuiListClipperRangePtr(ImGuiListClipperRange* handle) => new ImGuiListClipperRangePtr(handle);

		public static implicit operator ImGuiListClipperRange*(ImGuiListClipperRangePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiListClipperRangePtr left, ImGuiListClipperRangePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiListClipperRangePtr left, ImGuiListClipperRangePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiListClipperRangePtr left, ImGuiListClipperRange* right) => left.Handle == right;

		public static bool operator !=(ImGuiListClipperRangePtr left, ImGuiListClipperRange* right) => left.Handle != right;

		public bool Equals(ImGuiListClipperRangePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiListClipperRangePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiListClipperRangePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Min => ref Unsafe.AsRef<int>(&Handle->Min);
		public ref int Max => ref Unsafe.AsRef<int>(&Handle->Max);
		public ref bool PosToIndexConvert => ref Unsafe.AsRef<bool>(&Handle->PosToIndexConvert);
		public ref sbyte PosToIndexOffsetMin => ref Unsafe.AsRef<sbyte>(&Handle->PosToIndexOffsetMin);
		public ref sbyte PosToIndexOffsetMax => ref Unsafe.AsRef<sbyte>(&Handle->PosToIndexOffsetMax);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTable
	{
		public int ID;
		public ImGuiTableFlags Flags;
		public unsafe void* RawData;
		public unsafe ImGuiTableTempData* TempData;
		public ImSpanImGuiTableColumn Columns;
		public ImSpanImGuiTableColumnIdx DisplayOrderToIndex;
		public ImSpanImGuiTableCellData RowCellData;
		public ImBitArrayPtr EnabledMaskByDisplayOrder;
		public ImBitArrayPtr EnabledMaskByIndex;
		public ImBitArrayPtr VisibleMaskByIndex;
		public ImGuiTableFlags SettingsLoadedFlags;
		public int SettingsOffset;
		public int LastFrameActive;
		public int ColumnsCount;
		public int CurrentRow;
		public int CurrentColumn;
		public short InstanceCurrent;
		public short InstanceInteracted;
		public float RowPosY1;
		public float RowPosY2;
		public float RowMinHeight;
		public float RowTextBaseline;
		public float RowIndentOffsetX;
		public ImGuiTableRowFlags RowFlags;
		public ImGuiTableRowFlags LastRowFlags;
		public int RowBgColorCounter;
		public uint RowBgColor_0;
		public uint RowBgColor_1;
		public uint BorderColorStrong;
		public uint BorderColorLight;
		public float BorderX1;
		public float BorderX2;
		public float HostIndentX;
		public float MinColumnWidth;
		public float OuterPaddingX;
		public float CellPaddingX;
		public float CellPaddingY;
		public float CellSpacingX1;
		public float CellSpacingX2;
		public float InnerWidth;
		public float ColumnsGivenWidth;
		public float ColumnsAutoFitWidth;
		public float ColumnsStretchSumWeights;
		public float ResizedColumnNextWidth;
		public float ResizeLockMinContentsX2;
		public float RefScale;
		public ImRect OuterRect;
		public ImRect InnerRect;
		public ImRect WorkRect;
		public ImRect InnerClipRect;
		public ImRect BgClipRect;
		public ImRect Bg0ClipRectForDrawCmd;
		public ImRect Bg2ClipRectForDrawCmd;
		public ImRect HostClipRect;
		public ImRect HostBackupInnerClipRect;
		public unsafe ImGuiWindow* OuterWindow;
		public unsafe ImGuiWindow* InnerWindow;
		public ImGuiTextBuffer ColumnsNames;
		public unsafe ImDrawListSplitter* DrawSplitter;
		public ImGuiTableInstanceData InstanceDataFirst;
		public ImVectorImGuiTableInstanceData InstanceDataExtra;
		public ImGuiTableColumnSortSpecs SortSpecsSingle;
		public ImVectorImGuiTableColumnSortSpecs SortSpecsMulti;
		public ImGuiTableSortSpecs SortSpecs;
		public sbyte SortSpecsCount;
		public sbyte ColumnsEnabledCount;
		public sbyte ColumnsEnabledFixedCount;
		public sbyte DeclColumnsCount;
		public sbyte HoveredColumnBody;
		public sbyte HoveredColumnBorder;
		public sbyte AutoFitSingleColumn;
		public sbyte ResizedColumn;
		public sbyte LastResizedColumn;
		public sbyte HeldHeaderColumn;
		public sbyte ReorderColumn;
		public sbyte ReorderColumnDir;
		public sbyte LeftMostEnabledColumn;
		public sbyte RightMostEnabledColumn;
		public sbyte LeftMostStretchedColumn;
		public sbyte RightMostStretchedColumn;
		public sbyte ContextPopupColumn;
		public sbyte FreezeRowsRequest;
		public sbyte FreezeRowsCount;
		public sbyte FreezeColumnsRequest;
		public sbyte FreezeColumnsCount;
		public sbyte RowCellDataCurrent;
		public byte DummyDrawChannel;
		public byte Bg2DrawChannelCurrent;
		public byte Bg2DrawChannelUnfrozen;
		public byte IsLayoutLocked;
		public byte IsInsideRow;
		public byte IsInitializing;
		public byte IsSortSpecsDirty;
		public byte IsUsingHeaders;
		public byte IsContextPopupOpen;
		public byte IsSettingsRequestLoad;
		public byte IsSettingsDirty;
		public byte IsDefaultDisplayOrder;
		public byte IsResetAllRequest;
		public byte IsResetDisplayOrderRequest;
		public byte IsUnfrozenRows;
		public byte IsDefaultSizingPolicy;
		public byte HasScrollbarYCurr;
		public byte HasScrollbarYPrev;
		public byte MemoryCompacted;
		public byte HostSkipItems;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTablePtr : IEquatable<ImGuiTablePtr>
	{
		public ImGuiTablePtr(ImGuiTable* handle) { Handle = handle; }

		public ImGuiTable* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTablePtr Null => new ImGuiTablePtr(null);

		public static implicit operator ImGuiTablePtr(ImGuiTable* handle) => new ImGuiTablePtr(handle);

		public static implicit operator ImGuiTable*(ImGuiTablePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTablePtr left, ImGuiTablePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTablePtr left, ImGuiTablePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTablePtr left, ImGuiTable* right) => left.Handle == right;

		public static bool operator !=(ImGuiTablePtr left, ImGuiTable* right) => left.Handle != right;

		public bool Equals(ImGuiTablePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTablePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTablePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiTableFlags Flags => ref Unsafe.AsRef<ImGuiTableFlags>(&Handle->Flags);
		public void* RawData { get => Handle->RawData; set => Handle->RawData = value; }
		public ref ImGuiTableTempDataPtr TempData => ref Unsafe.AsRef<ImGuiTableTempDataPtr>(&Handle->TempData);
		public ref ImSpanImGuiTableColumn Columns => ref Unsafe.AsRef<ImSpanImGuiTableColumn>(&Handle->Columns);
		public ref ImSpanImGuiTableColumnIdx DisplayOrderToIndex => ref Unsafe.AsRef<ImSpanImGuiTableColumnIdx>(&Handle->DisplayOrderToIndex);
		public ref ImSpanImGuiTableCellData RowCellData => ref Unsafe.AsRef<ImSpanImGuiTableCellData>(&Handle->RowCellData);
		public ref ImBitArrayPtr EnabledMaskByDisplayOrder => ref Unsafe.AsRef<ImBitArrayPtr>(&Handle->EnabledMaskByDisplayOrder);
		public ref ImBitArrayPtr EnabledMaskByIndex => ref Unsafe.AsRef<ImBitArrayPtr>(&Handle->EnabledMaskByIndex);
		public ref ImBitArrayPtr VisibleMaskByIndex => ref Unsafe.AsRef<ImBitArrayPtr>(&Handle->VisibleMaskByIndex);
		public ref ImGuiTableFlags SettingsLoadedFlags => ref Unsafe.AsRef<ImGuiTableFlags>(&Handle->SettingsLoadedFlags);
		public ref int SettingsOffset => ref Unsafe.AsRef<int>(&Handle->SettingsOffset);
		public ref int LastFrameActive => ref Unsafe.AsRef<int>(&Handle->LastFrameActive);
		public ref int ColumnsCount => ref Unsafe.AsRef<int>(&Handle->ColumnsCount);
		public ref int CurrentRow => ref Unsafe.AsRef<int>(&Handle->CurrentRow);
		public ref int CurrentColumn => ref Unsafe.AsRef<int>(&Handle->CurrentColumn);
		public ref short InstanceCurrent => ref Unsafe.AsRef<short>(&Handle->InstanceCurrent);
		public ref short InstanceInteracted => ref Unsafe.AsRef<short>(&Handle->InstanceInteracted);
		public ref float RowPosY1 => ref Unsafe.AsRef<float>(&Handle->RowPosY1);
		public ref float RowPosY2 => ref Unsafe.AsRef<float>(&Handle->RowPosY2);
		public ref float RowMinHeight => ref Unsafe.AsRef<float>(&Handle->RowMinHeight);
		public ref float RowTextBaseline => ref Unsafe.AsRef<float>(&Handle->RowTextBaseline);
		public ref float RowIndentOffsetX => ref Unsafe.AsRef<float>(&Handle->RowIndentOffsetX);
		public ref ImGuiTableRowFlags RowFlags => ref Unsafe.AsRef<ImGuiTableRowFlags>(&Handle->RowFlags);
		public ref ImGuiTableRowFlags LastRowFlags => ref Unsafe.AsRef<ImGuiTableRowFlags>(&Handle->LastRowFlags);
		public ref int RowBgColorCounter => ref Unsafe.AsRef<int>(&Handle->RowBgColorCounter);
		public unsafe Span<uint> RowBgColor
		
		{
			get
			{
				return new Span<uint>(&Handle->RowBgColor_0, 2);
			}
		}
		public ref uint BorderColorStrong => ref Unsafe.AsRef<uint>(&Handle->BorderColorStrong);
		public ref uint BorderColorLight => ref Unsafe.AsRef<uint>(&Handle->BorderColorLight);
		public ref float BorderX1 => ref Unsafe.AsRef<float>(&Handle->BorderX1);
		public ref float BorderX2 => ref Unsafe.AsRef<float>(&Handle->BorderX2);
		public ref float HostIndentX => ref Unsafe.AsRef<float>(&Handle->HostIndentX);
		public ref float MinColumnWidth => ref Unsafe.AsRef<float>(&Handle->MinColumnWidth);
		public ref float OuterPaddingX => ref Unsafe.AsRef<float>(&Handle->OuterPaddingX);
		public ref float CellPaddingX => ref Unsafe.AsRef<float>(&Handle->CellPaddingX);
		public ref float CellPaddingY => ref Unsafe.AsRef<float>(&Handle->CellPaddingY);
		public ref float CellSpacingX1 => ref Unsafe.AsRef<float>(&Handle->CellSpacingX1);
		public ref float CellSpacingX2 => ref Unsafe.AsRef<float>(&Handle->CellSpacingX2);
		public ref float InnerWidth => ref Unsafe.AsRef<float>(&Handle->InnerWidth);
		public ref float ColumnsGivenWidth => ref Unsafe.AsRef<float>(&Handle->ColumnsGivenWidth);
		public ref float ColumnsAutoFitWidth => ref Unsafe.AsRef<float>(&Handle->ColumnsAutoFitWidth);
		public ref float ColumnsStretchSumWeights => ref Unsafe.AsRef<float>(&Handle->ColumnsStretchSumWeights);
		public ref float ResizedColumnNextWidth => ref Unsafe.AsRef<float>(&Handle->ResizedColumnNextWidth);
		public ref float ResizeLockMinContentsX2 => ref Unsafe.AsRef<float>(&Handle->ResizeLockMinContentsX2);
		public ref float RefScale => ref Unsafe.AsRef<float>(&Handle->RefScale);
		public ref ImRect OuterRect => ref Unsafe.AsRef<ImRect>(&Handle->OuterRect);
		public ref ImRect InnerRect => ref Unsafe.AsRef<ImRect>(&Handle->InnerRect);
		public ref ImRect WorkRect => ref Unsafe.AsRef<ImRect>(&Handle->WorkRect);
		public ref ImRect InnerClipRect => ref Unsafe.AsRef<ImRect>(&Handle->InnerClipRect);
		public ref ImRect BgClipRect => ref Unsafe.AsRef<ImRect>(&Handle->BgClipRect);
		public ref ImRect Bg0ClipRectForDrawCmd => ref Unsafe.AsRef<ImRect>(&Handle->Bg0ClipRectForDrawCmd);
		public ref ImRect Bg2ClipRectForDrawCmd => ref Unsafe.AsRef<ImRect>(&Handle->Bg2ClipRectForDrawCmd);
		public ref ImRect HostClipRect => ref Unsafe.AsRef<ImRect>(&Handle->HostClipRect);
		public ref ImRect HostBackupInnerClipRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupInnerClipRect);
		public ref ImGuiWindowPtr OuterWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->OuterWindow);
		public ref ImGuiWindowPtr InnerWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->InnerWindow);
		public ref ImGuiTextBuffer ColumnsNames => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->ColumnsNames);
		public ref ImDrawListSplitterPtr DrawSplitter => ref Unsafe.AsRef<ImDrawListSplitterPtr>(&Handle->DrawSplitter);
		public ref ImGuiTableInstanceData InstanceDataFirst => ref Unsafe.AsRef<ImGuiTableInstanceData>(&Handle->InstanceDataFirst);
		public ref ImVectorImGuiTableInstanceData InstanceDataExtra => ref Unsafe.AsRef<ImVectorImGuiTableInstanceData>(&Handle->InstanceDataExtra);
		public ref ImGuiTableColumnSortSpecs SortSpecsSingle => ref Unsafe.AsRef<ImGuiTableColumnSortSpecs>(&Handle->SortSpecsSingle);
		public ref ImVectorImGuiTableColumnSortSpecs SortSpecsMulti => ref Unsafe.AsRef<ImVectorImGuiTableColumnSortSpecs>(&Handle->SortSpecsMulti);
		public ref ImGuiTableSortSpecs SortSpecs => ref Unsafe.AsRef<ImGuiTableSortSpecs>(&Handle->SortSpecs);
		public ref sbyte SortSpecsCount => ref Unsafe.AsRef<sbyte>(&Handle->SortSpecsCount);
		public ref sbyte ColumnsEnabledCount => ref Unsafe.AsRef<sbyte>(&Handle->ColumnsEnabledCount);
		public ref sbyte ColumnsEnabledFixedCount => ref Unsafe.AsRef<sbyte>(&Handle->ColumnsEnabledFixedCount);
		public ref sbyte DeclColumnsCount => ref Unsafe.AsRef<sbyte>(&Handle->DeclColumnsCount);
		public ref sbyte HoveredColumnBody => ref Unsafe.AsRef<sbyte>(&Handle->HoveredColumnBody);
		public ref sbyte HoveredColumnBorder => ref Unsafe.AsRef<sbyte>(&Handle->HoveredColumnBorder);
		public ref sbyte AutoFitSingleColumn => ref Unsafe.AsRef<sbyte>(&Handle->AutoFitSingleColumn);
		public ref sbyte ResizedColumn => ref Unsafe.AsRef<sbyte>(&Handle->ResizedColumn);
		public ref sbyte LastResizedColumn => ref Unsafe.AsRef<sbyte>(&Handle->LastResizedColumn);
		public ref sbyte HeldHeaderColumn => ref Unsafe.AsRef<sbyte>(&Handle->HeldHeaderColumn);
		public ref sbyte ReorderColumn => ref Unsafe.AsRef<sbyte>(&Handle->ReorderColumn);
		public ref sbyte ReorderColumnDir => ref Unsafe.AsRef<sbyte>(&Handle->ReorderColumnDir);
		public ref sbyte LeftMostEnabledColumn => ref Unsafe.AsRef<sbyte>(&Handle->LeftMostEnabledColumn);
		public ref sbyte RightMostEnabledColumn => ref Unsafe.AsRef<sbyte>(&Handle->RightMostEnabledColumn);
		public ref sbyte LeftMostStretchedColumn => ref Unsafe.AsRef<sbyte>(&Handle->LeftMostStretchedColumn);
		public ref sbyte RightMostStretchedColumn => ref Unsafe.AsRef<sbyte>(&Handle->RightMostStretchedColumn);
		public ref sbyte ContextPopupColumn => ref Unsafe.AsRef<sbyte>(&Handle->ContextPopupColumn);
		public ref sbyte FreezeRowsRequest => ref Unsafe.AsRef<sbyte>(&Handle->FreezeRowsRequest);
		public ref sbyte FreezeRowsCount => ref Unsafe.AsRef<sbyte>(&Handle->FreezeRowsCount);
		public ref sbyte FreezeColumnsRequest => ref Unsafe.AsRef<sbyte>(&Handle->FreezeColumnsRequest);
		public ref sbyte FreezeColumnsCount => ref Unsafe.AsRef<sbyte>(&Handle->FreezeColumnsCount);
		public ref sbyte RowCellDataCurrent => ref Unsafe.AsRef<sbyte>(&Handle->RowCellDataCurrent);
		public ref byte DummyDrawChannel => ref Unsafe.AsRef<byte>(&Handle->DummyDrawChannel);
		public ref byte Bg2DrawChannelCurrent => ref Unsafe.AsRef<byte>(&Handle->Bg2DrawChannelCurrent);
		public ref byte Bg2DrawChannelUnfrozen => ref Unsafe.AsRef<byte>(&Handle->Bg2DrawChannelUnfrozen);
		public ref bool IsLayoutLocked => ref Unsafe.AsRef<bool>(&Handle->IsLayoutLocked);
		public ref bool IsInsideRow => ref Unsafe.AsRef<bool>(&Handle->IsInsideRow);
		public ref bool IsInitializing => ref Unsafe.AsRef<bool>(&Handle->IsInitializing);
		public ref bool IsSortSpecsDirty => ref Unsafe.AsRef<bool>(&Handle->IsSortSpecsDirty);
		public ref bool IsUsingHeaders => ref Unsafe.AsRef<bool>(&Handle->IsUsingHeaders);
		public ref bool IsContextPopupOpen => ref Unsafe.AsRef<bool>(&Handle->IsContextPopupOpen);
		public ref bool IsSettingsRequestLoad => ref Unsafe.AsRef<bool>(&Handle->IsSettingsRequestLoad);
		public ref bool IsSettingsDirty => ref Unsafe.AsRef<bool>(&Handle->IsSettingsDirty);
		public ref bool IsDefaultDisplayOrder => ref Unsafe.AsRef<bool>(&Handle->IsDefaultDisplayOrder);
		public ref bool IsResetAllRequest => ref Unsafe.AsRef<bool>(&Handle->IsResetAllRequest);
		public ref bool IsResetDisplayOrderRequest => ref Unsafe.AsRef<bool>(&Handle->IsResetDisplayOrderRequest);
		public ref bool IsUnfrozenRows => ref Unsafe.AsRef<bool>(&Handle->IsUnfrozenRows);
		public ref bool IsDefaultSizingPolicy => ref Unsafe.AsRef<bool>(&Handle->IsDefaultSizingPolicy);
		public ref bool HasScrollbarYCurr => ref Unsafe.AsRef<bool>(&Handle->HasScrollbarYCurr);
		public ref bool HasScrollbarYPrev => ref Unsafe.AsRef<bool>(&Handle->HasScrollbarYPrev);
		public ref bool MemoryCompacted => ref Unsafe.AsRef<bool>(&Handle->MemoryCompacted);
		public ref bool HostSkipItems => ref Unsafe.AsRef<bool>(&Handle->HostSkipItems);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableTempData
	{
		public int TableIndex;
		public float LastTimeActive;
		public Vector2 UserOuterSize;
		public ImDrawListSplitter DrawSplitter;
		public ImRect HostBackupWorkRect;
		public ImRect HostBackupParentWorkRect;
		public Vector2 HostBackupPrevLineSize;
		public Vector2 HostBackupCurrLineSize;
		public Vector2 HostBackupCursorMaxPos;
		public ImVec1 HostBackupColumnsOffset;
		public float HostBackupItemWidth;
		public int HostBackupItemWidthStackSize;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableTempDataPtr : IEquatable<ImGuiTableTempDataPtr>
	{
		public ImGuiTableTempDataPtr(ImGuiTableTempData* handle) { Handle = handle; }

		public ImGuiTableTempData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableTempDataPtr Null => new ImGuiTableTempDataPtr(null);

		public static implicit operator ImGuiTableTempDataPtr(ImGuiTableTempData* handle) => new ImGuiTableTempDataPtr(handle);

		public static implicit operator ImGuiTableTempData*(ImGuiTableTempDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableTempDataPtr left, ImGuiTableTempDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableTempDataPtr left, ImGuiTableTempDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableTempDataPtr left, ImGuiTableTempData* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableTempDataPtr left, ImGuiTableTempData* right) => left.Handle != right;

		public bool Equals(ImGuiTableTempDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableTempDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableTempDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int TableIndex => ref Unsafe.AsRef<int>(&Handle->TableIndex);
		public ref float LastTimeActive => ref Unsafe.AsRef<float>(&Handle->LastTimeActive);
		public ref Vector2 UserOuterSize => ref Unsafe.AsRef<Vector2>(&Handle->UserOuterSize);
		public ref ImDrawListSplitter DrawSplitter => ref Unsafe.AsRef<ImDrawListSplitter>(&Handle->DrawSplitter);
		public ref ImRect HostBackupWorkRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupWorkRect);
		public ref ImRect HostBackupParentWorkRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupParentWorkRect);
		public ref Vector2 HostBackupPrevLineSize => ref Unsafe.AsRef<Vector2>(&Handle->HostBackupPrevLineSize);
		public ref Vector2 HostBackupCurrLineSize => ref Unsafe.AsRef<Vector2>(&Handle->HostBackupCurrLineSize);
		public ref Vector2 HostBackupCursorMaxPos => ref Unsafe.AsRef<Vector2>(&Handle->HostBackupCursorMaxPos);
		public ref ImVec1 HostBackupColumnsOffset => ref Unsafe.AsRef<ImVec1>(&Handle->HostBackupColumnsOffset);
		public ref float HostBackupItemWidth => ref Unsafe.AsRef<float>(&Handle->HostBackupItemWidth);
		public ref int HostBackupItemWidthStackSize => ref Unsafe.AsRef<int>(&Handle->HostBackupItemWidthStackSize);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableColumn
	{
		public unsafe ImGuiTableColumn* Data;
		public unsafe ImGuiTableColumn* DataEnd;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumn
	{
		public ImGuiTableColumnFlags Flags;
		public float WidthGiven;
		public float MinX;
		public float MaxX;
		public float WidthRequest;
		public float WidthAuto;
		public float StretchWeight;
		public float InitStretchWeightOrWidth;
		public ImRect ClipRect;
		public int UserID;
		public float WorkMinX;
		public float WorkMaxX;
		public float ItemWidth;
		public float ContentMaxXFrozen;
		public float ContentMaxXUnfrozen;
		public float ContentMaxXHeadersUsed;
		public float ContentMaxXHeadersIdeal;
		public short NameOffset;
		public sbyte DisplayOrder;
		public sbyte IndexWithinEnabledSet;
		public sbyte PrevEnabledColumn;
		public sbyte NextEnabledColumn;
		public sbyte SortOrder;
		public byte DrawChannelCurrent;
		public byte DrawChannelFrozen;
		public byte DrawChannelUnfrozen;
		public byte IsEnabled;
		public byte IsUserEnabled;
		public byte IsUserEnabledNextFrame;
		public byte IsVisibleX;
		public byte IsVisibleY;
		public byte IsRequestOutput;
		public byte IsSkipItems;
		public byte IsPreserveWidthAuto;
		public sbyte NavLayerCurrent;
		public byte AutoFitQueue;
		public byte CannotSkipItemsQueue;
		public byte SortDirection;
		public byte SortDirectionsAvailCount;
		public byte SortDirectionsAvailMask;
		public byte SortDirectionsAvailList;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableColumnPtr : IEquatable<ImGuiTableColumnPtr>
	{
		public ImGuiTableColumnPtr(ImGuiTableColumn* handle) { Handle = handle; }

		public ImGuiTableColumn* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableColumnPtr Null => new ImGuiTableColumnPtr(null);

		public static implicit operator ImGuiTableColumnPtr(ImGuiTableColumn* handle) => new ImGuiTableColumnPtr(handle);

		public static implicit operator ImGuiTableColumn*(ImGuiTableColumnPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableColumnPtr left, ImGuiTableColumnPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableColumnPtr left, ImGuiTableColumnPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableColumnPtr left, ImGuiTableColumn* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableColumnPtr left, ImGuiTableColumn* right) => left.Handle != right;

		public bool Equals(ImGuiTableColumnPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableColumnPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableColumnPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiTableColumnFlags Flags => ref Unsafe.AsRef<ImGuiTableColumnFlags>(&Handle->Flags);
		public ref float WidthGiven => ref Unsafe.AsRef<float>(&Handle->WidthGiven);
		public ref float MinX => ref Unsafe.AsRef<float>(&Handle->MinX);
		public ref float MaxX => ref Unsafe.AsRef<float>(&Handle->MaxX);
		public ref float WidthRequest => ref Unsafe.AsRef<float>(&Handle->WidthRequest);
		public ref float WidthAuto => ref Unsafe.AsRef<float>(&Handle->WidthAuto);
		public ref float StretchWeight => ref Unsafe.AsRef<float>(&Handle->StretchWeight);
		public ref float InitStretchWeightOrWidth => ref Unsafe.AsRef<float>(&Handle->InitStretchWeightOrWidth);
		public ref ImRect ClipRect => ref Unsafe.AsRef<ImRect>(&Handle->ClipRect);
		public ref int UserID => ref Unsafe.AsRef<int>(&Handle->UserID);
		public ref float WorkMinX => ref Unsafe.AsRef<float>(&Handle->WorkMinX);
		public ref float WorkMaxX => ref Unsafe.AsRef<float>(&Handle->WorkMaxX);
		public ref float ItemWidth => ref Unsafe.AsRef<float>(&Handle->ItemWidth);
		public ref float ContentMaxXFrozen => ref Unsafe.AsRef<float>(&Handle->ContentMaxXFrozen);
		public ref float ContentMaxXUnfrozen => ref Unsafe.AsRef<float>(&Handle->ContentMaxXUnfrozen);
		public ref float ContentMaxXHeadersUsed => ref Unsafe.AsRef<float>(&Handle->ContentMaxXHeadersUsed);
		public ref float ContentMaxXHeadersIdeal => ref Unsafe.AsRef<float>(&Handle->ContentMaxXHeadersIdeal);
		public ref short NameOffset => ref Unsafe.AsRef<short>(&Handle->NameOffset);
		public ref sbyte DisplayOrder => ref Unsafe.AsRef<sbyte>(&Handle->DisplayOrder);
		public ref sbyte IndexWithinEnabledSet => ref Unsafe.AsRef<sbyte>(&Handle->IndexWithinEnabledSet);
		public ref sbyte PrevEnabledColumn => ref Unsafe.AsRef<sbyte>(&Handle->PrevEnabledColumn);
		public ref sbyte NextEnabledColumn => ref Unsafe.AsRef<sbyte>(&Handle->NextEnabledColumn);
		public ref sbyte SortOrder => ref Unsafe.AsRef<sbyte>(&Handle->SortOrder);
		public ref byte DrawChannelCurrent => ref Unsafe.AsRef<byte>(&Handle->DrawChannelCurrent);
		public ref byte DrawChannelFrozen => ref Unsafe.AsRef<byte>(&Handle->DrawChannelFrozen);
		public ref byte DrawChannelUnfrozen => ref Unsafe.AsRef<byte>(&Handle->DrawChannelUnfrozen);
		public ref bool IsEnabled => ref Unsafe.AsRef<bool>(&Handle->IsEnabled);
		public ref bool IsUserEnabled => ref Unsafe.AsRef<bool>(&Handle->IsUserEnabled);
		public ref bool IsUserEnabledNextFrame => ref Unsafe.AsRef<bool>(&Handle->IsUserEnabledNextFrame);
		public ref bool IsVisibleX => ref Unsafe.AsRef<bool>(&Handle->IsVisibleX);
		public ref bool IsVisibleY => ref Unsafe.AsRef<bool>(&Handle->IsVisibleY);
		public ref bool IsRequestOutput => ref Unsafe.AsRef<bool>(&Handle->IsRequestOutput);
		public ref bool IsSkipItems => ref Unsafe.AsRef<bool>(&Handle->IsSkipItems);
		public ref bool IsPreserveWidthAuto => ref Unsafe.AsRef<bool>(&Handle->IsPreserveWidthAuto);
		public ref sbyte NavLayerCurrent => ref Unsafe.AsRef<sbyte>(&Handle->NavLayerCurrent);
		public ref byte AutoFitQueue => ref Unsafe.AsRef<byte>(&Handle->AutoFitQueue);
		public ref byte CannotSkipItemsQueue => ref Unsafe.AsRef<byte>(&Handle->CannotSkipItemsQueue);
		public ref byte SortDirection => ref Unsafe.AsRef<byte>(&Handle->SortDirection);
		public ref byte SortDirectionsAvailCount => ref Unsafe.AsRef<byte>(&Handle->SortDirectionsAvailCount);
		public ref byte SortDirectionsAvailMask => ref Unsafe.AsRef<byte>(&Handle->SortDirectionsAvailMask);
		public ref byte SortDirectionsAvailList => ref Unsafe.AsRef<byte>(&Handle->SortDirectionsAvailList);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableColumnIdx
	{
		public unsafe sbyte* Data;
		public unsafe sbyte* DataEnd;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableCellData
	{
		public unsafe ImGuiTableCellData* Data;
		public unsafe ImGuiTableCellData* DataEnd;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableCellData
	{
		public uint BgColor;
		public sbyte Column;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableCellDataPtr : IEquatable<ImGuiTableCellDataPtr>
	{
		public ImGuiTableCellDataPtr(ImGuiTableCellData* handle) { Handle = handle; }

		public ImGuiTableCellData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableCellDataPtr Null => new ImGuiTableCellDataPtr(null);

		public static implicit operator ImGuiTableCellDataPtr(ImGuiTableCellData* handle) => new ImGuiTableCellDataPtr(handle);

		public static implicit operator ImGuiTableCellData*(ImGuiTableCellDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableCellDataPtr left, ImGuiTableCellDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableCellDataPtr left, ImGuiTableCellDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableCellDataPtr left, ImGuiTableCellData* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableCellDataPtr left, ImGuiTableCellData* right) => left.Handle != right;

		public bool Equals(ImGuiTableCellDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableCellDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableCellDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref uint BgColor => ref Unsafe.AsRef<uint>(&Handle->BgColor);
		public ref sbyte Column => ref Unsafe.AsRef<sbyte>(&Handle->Column);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableInstanceData
	{
		public int TableInstanceID;
		public float LastOuterHeight;
		public float LastFirstRowHeight;
		public float LastFrozenHeight;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableInstanceDataPtr : IEquatable<ImGuiTableInstanceDataPtr>
	{
		public ImGuiTableInstanceDataPtr(ImGuiTableInstanceData* handle) { Handle = handle; }

		public ImGuiTableInstanceData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableInstanceDataPtr Null => new ImGuiTableInstanceDataPtr(null);

		public static implicit operator ImGuiTableInstanceDataPtr(ImGuiTableInstanceData* handle) => new ImGuiTableInstanceDataPtr(handle);

		public static implicit operator ImGuiTableInstanceData*(ImGuiTableInstanceDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableInstanceDataPtr left, ImGuiTableInstanceDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableInstanceDataPtr left, ImGuiTableInstanceDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableInstanceDataPtr left, ImGuiTableInstanceData* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableInstanceDataPtr left, ImGuiTableInstanceData* right) => left.Handle != right;

		public bool Equals(ImGuiTableInstanceDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableInstanceDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableInstanceDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int TableInstanceID => ref Unsafe.AsRef<int>(&Handle->TableInstanceID);
		public ref float LastOuterHeight => ref Unsafe.AsRef<float>(&Handle->LastOuterHeight);
		public ref float LastFirstRowHeight => ref Unsafe.AsRef<float>(&Handle->LastFirstRowHeight);
		public ref float LastFrozenHeight => ref Unsafe.AsRef<float>(&Handle->LastFrozenHeight);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableInstanceData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableInstanceData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnSortSpecs
	{
		public int ColumnUserID;
		public short ColumnIndex;
		public short SortOrder;
		public ImGuiSortDirection SortDirection;


		public unsafe void Destroy()
		{
			fixed (ImGuiTableColumnSortSpecs* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableColumnSortSpecsPtr : IEquatable<ImGuiTableColumnSortSpecsPtr>
	{
		public ImGuiTableColumnSortSpecsPtr(ImGuiTableColumnSortSpecs* handle) { Handle = handle; }

		public ImGuiTableColumnSortSpecs* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableColumnSortSpecsPtr Null => new ImGuiTableColumnSortSpecsPtr(null);

		public static implicit operator ImGuiTableColumnSortSpecsPtr(ImGuiTableColumnSortSpecs* handle) => new ImGuiTableColumnSortSpecsPtr(handle);

		public static implicit operator ImGuiTableColumnSortSpecs*(ImGuiTableColumnSortSpecsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableColumnSortSpecsPtr left, ImGuiTableColumnSortSpecsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableColumnSortSpecsPtr left, ImGuiTableColumnSortSpecsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableColumnSortSpecsPtr left, ImGuiTableColumnSortSpecs* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableColumnSortSpecsPtr left, ImGuiTableColumnSortSpecs* right) => left.Handle != right;

		public bool Equals(ImGuiTableColumnSortSpecsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableColumnSortSpecsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableColumnSortSpecsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ColumnUserID => ref Unsafe.AsRef<int>(&Handle->ColumnUserID);
		public ref short ColumnIndex => ref Unsafe.AsRef<short>(&Handle->ColumnIndex);
		public ref short SortOrder => ref Unsafe.AsRef<short>(&Handle->SortOrder);
		public ref ImGuiSortDirection SortDirection => ref Unsafe.AsRef<ImGuiSortDirection>(&Handle->SortDirection);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableColumnSortSpecs
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableColumnSortSpecs* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableSortSpecs
	{
		public unsafe ImGuiTableColumnSortSpecs* Specs;
		public int SpecsCount;
		public byte SpecsDirty;


		public unsafe void Destroy()
		{
			fixed (ImGuiTableSortSpecs* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableSortSpecsPtr : IEquatable<ImGuiTableSortSpecsPtr>
	{
		public ImGuiTableSortSpecsPtr(ImGuiTableSortSpecs* handle) { Handle = handle; }

		public ImGuiTableSortSpecs* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableSortSpecsPtr Null => new ImGuiTableSortSpecsPtr(null);

		public static implicit operator ImGuiTableSortSpecsPtr(ImGuiTableSortSpecs* handle) => new ImGuiTableSortSpecsPtr(handle);

		public static implicit operator ImGuiTableSortSpecs*(ImGuiTableSortSpecsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableSortSpecsPtr left, ImGuiTableSortSpecsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableSortSpecsPtr left, ImGuiTableSortSpecsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableSortSpecsPtr left, ImGuiTableSortSpecs* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableSortSpecsPtr left, ImGuiTableSortSpecs* right) => left.Handle != right;

		public bool Equals(ImGuiTableSortSpecsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableSortSpecsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableSortSpecsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiTableColumnSortSpecsPtr Specs => ref Unsafe.AsRef<ImGuiTableColumnSortSpecsPtr>(&Handle->Specs);
		public ref int SpecsCount => ref Unsafe.AsRef<int>(&Handle->SpecsCount);
		public ref bool SpecsDirty => ref Unsafe.AsRef<bool>(&Handle->SpecsDirty);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableTempData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableTempData* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImGuiTable
	{
		public ImVectorImGuiTable Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTable
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTable* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImGuiTabBar
	{
		public ImVectorImGuiTabBar Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabBar
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTabBar* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPtrOrIndex
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPtrOrIndex* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPtrOrIndex
	{
		public unsafe void* Ptr;
		public int Index;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPtrOrIndexPtr : IEquatable<ImGuiPtrOrIndexPtr>
	{
		public ImGuiPtrOrIndexPtr(ImGuiPtrOrIndex* handle) { Handle = handle; }

		public ImGuiPtrOrIndex* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPtrOrIndexPtr Null => new ImGuiPtrOrIndexPtr(null);

		public static implicit operator ImGuiPtrOrIndexPtr(ImGuiPtrOrIndex* handle) => new ImGuiPtrOrIndexPtr(handle);

		public static implicit operator ImGuiPtrOrIndex*(ImGuiPtrOrIndexPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPtrOrIndexPtr left, ImGuiPtrOrIndexPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPtrOrIndexPtr left, ImGuiPtrOrIndexPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPtrOrIndexPtr left, ImGuiPtrOrIndex* right) => left.Handle == right;

		public static bool operator !=(ImGuiPtrOrIndexPtr left, ImGuiPtrOrIndex* right) => left.Handle != right;

		public bool Equals(ImGuiPtrOrIndexPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPtrOrIndexPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPtrOrIndexPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public void* Ptr { get => Handle->Ptr; set => Handle->Ptr = value; }
		public ref int Index => ref Unsafe.AsRef<int>(&Handle->Index);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiShrinkWidthItem
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiShrinkWidthItem* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiShrinkWidthItem
	{
		public int Index;
		public float Width;
		public float InitialWidth;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiShrinkWidthItemPtr : IEquatable<ImGuiShrinkWidthItemPtr>
	{
		public ImGuiShrinkWidthItemPtr(ImGuiShrinkWidthItem* handle) { Handle = handle; }

		public ImGuiShrinkWidthItem* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiShrinkWidthItemPtr Null => new ImGuiShrinkWidthItemPtr(null);

		public static implicit operator ImGuiShrinkWidthItemPtr(ImGuiShrinkWidthItem* handle) => new ImGuiShrinkWidthItemPtr(handle);

		public static implicit operator ImGuiShrinkWidthItem*(ImGuiShrinkWidthItemPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiShrinkWidthItemPtr left, ImGuiShrinkWidthItemPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiShrinkWidthItemPtr left, ImGuiShrinkWidthItemPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiShrinkWidthItemPtr left, ImGuiShrinkWidthItem* right) => left.Handle == right;

		public static bool operator !=(ImGuiShrinkWidthItemPtr left, ImGuiShrinkWidthItem* right) => left.Handle != right;

		public bool Equals(ImGuiShrinkWidthItemPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiShrinkWidthItemPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiShrinkWidthItemPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Index => ref Unsafe.AsRef<int>(&Handle->Index);
		public ref float Width => ref Unsafe.AsRef<float>(&Handle->Width);
		public ref float InitialWidth => ref Unsafe.AsRef<float>(&Handle->InitialWidth);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextState
	{
		public unsafe ImGuiContext* Ctx;
		public int ID;
		public int CurLenW;
		public int CurLenA;
		public ImVectorImWchar TextW;
		public ImVectorChar TextA;
		public ImVectorChar InitialTextA;
		public byte TextAIsValid;
		public int BufCapacityA;
		public float ScrollX;
		public STBTexteditState Stb;
		public float CursorAnim;
		public byte CursorFollow;
		public byte SelectedAllMouseLock;
		public byte Edited;
		public ImGuiInputTextFlags Flags;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiInputTextStatePtr : IEquatable<ImGuiInputTextStatePtr>
	{
		public ImGuiInputTextStatePtr(ImGuiInputTextState* handle) { Handle = handle; }

		public ImGuiInputTextState* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputTextStatePtr Null => new ImGuiInputTextStatePtr(null);

		public static implicit operator ImGuiInputTextStatePtr(ImGuiInputTextState* handle) => new ImGuiInputTextStatePtr(handle);

		public static implicit operator ImGuiInputTextState*(ImGuiInputTextStatePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputTextStatePtr left, ImGuiInputTextStatePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputTextStatePtr left, ImGuiInputTextStatePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputTextStatePtr left, ImGuiInputTextState* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputTextStatePtr left, ImGuiInputTextState* right) => left.Handle != right;

		public bool Equals(ImGuiInputTextStatePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputTextStatePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiInputTextStatePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref int CurLenW => ref Unsafe.AsRef<int>(&Handle->CurLenW);
		public ref int CurLenA => ref Unsafe.AsRef<int>(&Handle->CurLenA);
		public ref ImVectorImWchar TextW => ref Unsafe.AsRef<ImVectorImWchar>(&Handle->TextW);
		public ref ImVectorChar TextA => ref Unsafe.AsRef<ImVectorChar>(&Handle->TextA);
		public ref ImVectorChar InitialTextA => ref Unsafe.AsRef<ImVectorChar>(&Handle->InitialTextA);
		public ref bool TextAIsValid => ref Unsafe.AsRef<bool>(&Handle->TextAIsValid);
		public ref int BufCapacityA => ref Unsafe.AsRef<int>(&Handle->BufCapacityA);
		public ref float ScrollX => ref Unsafe.AsRef<float>(&Handle->ScrollX);
		public ref STBTexteditState Stb => ref Unsafe.AsRef<STBTexteditState>(&Handle->Stb);
		public ref float CursorAnim => ref Unsafe.AsRef<float>(&Handle->CursorAnim);
		public ref bool CursorFollow => ref Unsafe.AsRef<bool>(&Handle->CursorFollow);
		public ref bool SelectedAllMouseLock => ref Unsafe.AsRef<bool>(&Handle->SelectedAllMouseLock);
		public ref bool Edited => ref Unsafe.AsRef<bool>(&Handle->Edited);
		public ref ImGuiInputTextFlags Flags => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->Flags);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct STBTexteditState
	{
		public int Cursor;
		public int SelectStart;
		public int SelectEnd;
		public byte InsertMode;
		public int RowCountPerPage;
		public byte CursorAtEndOfLine;
		public byte Initialized;
		public byte HasPreferredX;
		public byte SingleLine;
		public byte Padding1;
		public byte Padding2;
		public byte Padding3;
		public float PreferredX;
		public StbUndoState Undostate;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbUndoState
	{
		public StbUndoRecord UndoRec_0;
		public StbUndoRecord UndoRec_1;
		public StbUndoRecord UndoRec_2;
		public StbUndoRecord UndoRec_3;
		public StbUndoRecord UndoRec_4;
		public StbUndoRecord UndoRec_5;
		public StbUndoRecord UndoRec_6;
		public StbUndoRecord UndoRec_7;
		public StbUndoRecord UndoRec_8;
		public StbUndoRecord UndoRec_9;
		public StbUndoRecord UndoRec_10;
		public StbUndoRecord UndoRec_11;
		public StbUndoRecord UndoRec_12;
		public StbUndoRecord UndoRec_13;
		public StbUndoRecord UndoRec_14;
		public StbUndoRecord UndoRec_15;
		public StbUndoRecord UndoRec_16;
		public StbUndoRecord UndoRec_17;
		public StbUndoRecord UndoRec_18;
		public StbUndoRecord UndoRec_19;
		public StbUndoRecord UndoRec_20;
		public StbUndoRecord UndoRec_21;
		public StbUndoRecord UndoRec_22;
		public StbUndoRecord UndoRec_23;
		public StbUndoRecord UndoRec_24;
		public StbUndoRecord UndoRec_25;
		public StbUndoRecord UndoRec_26;
		public StbUndoRecord UndoRec_27;
		public StbUndoRecord UndoRec_28;
		public StbUndoRecord UndoRec_29;
		public StbUndoRecord UndoRec_30;
		public StbUndoRecord UndoRec_31;
		public StbUndoRecord UndoRec_32;
		public StbUndoRecord UndoRec_33;
		public StbUndoRecord UndoRec_34;
		public StbUndoRecord UndoRec_35;
		public StbUndoRecord UndoRec_36;
		public StbUndoRecord UndoRec_37;
		public StbUndoRecord UndoRec_38;
		public StbUndoRecord UndoRec_39;
		public StbUndoRecord UndoRec_40;
		public StbUndoRecord UndoRec_41;
		public StbUndoRecord UndoRec_42;
		public StbUndoRecord UndoRec_43;
		public StbUndoRecord UndoRec_44;
		public StbUndoRecord UndoRec_45;
		public StbUndoRecord UndoRec_46;
		public StbUndoRecord UndoRec_47;
		public StbUndoRecord UndoRec_48;
		public StbUndoRecord UndoRec_49;
		public StbUndoRecord UndoRec_50;
		public StbUndoRecord UndoRec_51;
		public StbUndoRecord UndoRec_52;
		public StbUndoRecord UndoRec_53;
		public StbUndoRecord UndoRec_54;
		public StbUndoRecord UndoRec_55;
		public StbUndoRecord UndoRec_56;
		public StbUndoRecord UndoRec_57;
		public StbUndoRecord UndoRec_58;
		public StbUndoRecord UndoRec_59;
		public StbUndoRecord UndoRec_60;
		public StbUndoRecord UndoRec_61;
		public StbUndoRecord UndoRec_62;
		public StbUndoRecord UndoRec_63;
		public StbUndoRecord UndoRec_64;
		public StbUndoRecord UndoRec_65;
		public StbUndoRecord UndoRec_66;
		public StbUndoRecord UndoRec_67;
		public StbUndoRecord UndoRec_68;
		public StbUndoRecord UndoRec_69;
		public StbUndoRecord UndoRec_70;
		public StbUndoRecord UndoRec_71;
		public StbUndoRecord UndoRec_72;
		public StbUndoRecord UndoRec_73;
		public StbUndoRecord UndoRec_74;
		public StbUndoRecord UndoRec_75;
		public StbUndoRecord UndoRec_76;
		public StbUndoRecord UndoRec_77;
		public StbUndoRecord UndoRec_78;
		public StbUndoRecord UndoRec_79;
		public StbUndoRecord UndoRec_80;
		public StbUndoRecord UndoRec_81;
		public StbUndoRecord UndoRec_82;
		public StbUndoRecord UndoRec_83;
		public StbUndoRecord UndoRec_84;
		public StbUndoRecord UndoRec_85;
		public StbUndoRecord UndoRec_86;
		public StbUndoRecord UndoRec_87;
		public StbUndoRecord UndoRec_88;
		public StbUndoRecord UndoRec_89;
		public StbUndoRecord UndoRec_90;
		public StbUndoRecord UndoRec_91;
		public StbUndoRecord UndoRec_92;
		public StbUndoRecord UndoRec_93;
		public StbUndoRecord UndoRec_94;
		public StbUndoRecord UndoRec_95;
		public StbUndoRecord UndoRec_96;
		public StbUndoRecord UndoRec_97;
		public StbUndoRecord UndoRec_98;
		public ushort UndoChar_0;
		public ushort UndoChar_1;
		public ushort UndoChar_2;
		public ushort UndoChar_3;
		public ushort UndoChar_4;
		public ushort UndoChar_5;
		public ushort UndoChar_6;
		public ushort UndoChar_7;
		public ushort UndoChar_8;
		public ushort UndoChar_9;
		public ushort UndoChar_10;
		public ushort UndoChar_11;
		public ushort UndoChar_12;
		public ushort UndoChar_13;
		public ushort UndoChar_14;
		public ushort UndoChar_15;
		public ushort UndoChar_16;
		public ushort UndoChar_17;
		public ushort UndoChar_18;
		public ushort UndoChar_19;
		public ushort UndoChar_20;
		public ushort UndoChar_21;
		public ushort UndoChar_22;
		public ushort UndoChar_23;
		public ushort UndoChar_24;
		public ushort UndoChar_25;
		public ushort UndoChar_26;
		public ushort UndoChar_27;
		public ushort UndoChar_28;
		public ushort UndoChar_29;
		public ushort UndoChar_30;
		public ushort UndoChar_31;
		public ushort UndoChar_32;
		public ushort UndoChar_33;
		public ushort UndoChar_34;
		public ushort UndoChar_35;
		public ushort UndoChar_36;
		public ushort UndoChar_37;
		public ushort UndoChar_38;
		public ushort UndoChar_39;
		public ushort UndoChar_40;
		public ushort UndoChar_41;
		public ushort UndoChar_42;
		public ushort UndoChar_43;
		public ushort UndoChar_44;
		public ushort UndoChar_45;
		public ushort UndoChar_46;
		public ushort UndoChar_47;
		public ushort UndoChar_48;
		public ushort UndoChar_49;
		public ushort UndoChar_50;
		public ushort UndoChar_51;
		public ushort UndoChar_52;
		public ushort UndoChar_53;
		public ushort UndoChar_54;
		public ushort UndoChar_55;
		public ushort UndoChar_56;
		public ushort UndoChar_57;
		public ushort UndoChar_58;
		public ushort UndoChar_59;
		public ushort UndoChar_60;
		public ushort UndoChar_61;
		public ushort UndoChar_62;
		public ushort UndoChar_63;
		public ushort UndoChar_64;
		public ushort UndoChar_65;
		public ushort UndoChar_66;
		public ushort UndoChar_67;
		public ushort UndoChar_68;
		public ushort UndoChar_69;
		public ushort UndoChar_70;
		public ushort UndoChar_71;
		public ushort UndoChar_72;
		public ushort UndoChar_73;
		public ushort UndoChar_74;
		public ushort UndoChar_75;
		public ushort UndoChar_76;
		public ushort UndoChar_77;
		public ushort UndoChar_78;
		public ushort UndoChar_79;
		public ushort UndoChar_80;
		public ushort UndoChar_81;
		public ushort UndoChar_82;
		public ushort UndoChar_83;
		public ushort UndoChar_84;
		public ushort UndoChar_85;
		public ushort UndoChar_86;
		public ushort UndoChar_87;
		public ushort UndoChar_88;
		public ushort UndoChar_89;
		public ushort UndoChar_90;
		public ushort UndoChar_91;
		public ushort UndoChar_92;
		public ushort UndoChar_93;
		public ushort UndoChar_94;
		public ushort UndoChar_95;
		public ushort UndoChar_96;
		public ushort UndoChar_97;
		public ushort UndoChar_98;
		public ushort UndoChar_99;
		public ushort UndoChar_100;
		public ushort UndoChar_101;
		public ushort UndoChar_102;
		public ushort UndoChar_103;
		public ushort UndoChar_104;
		public ushort UndoChar_105;
		public ushort UndoChar_106;
		public ushort UndoChar_107;
		public ushort UndoChar_108;
		public ushort UndoChar_109;
		public ushort UndoChar_110;
		public ushort UndoChar_111;
		public ushort UndoChar_112;
		public ushort UndoChar_113;
		public ushort UndoChar_114;
		public ushort UndoChar_115;
		public ushort UndoChar_116;
		public ushort UndoChar_117;
		public ushort UndoChar_118;
		public ushort UndoChar_119;
		public ushort UndoChar_120;
		public ushort UndoChar_121;
		public ushort UndoChar_122;
		public ushort UndoChar_123;
		public ushort UndoChar_124;
		public ushort UndoChar_125;
		public ushort UndoChar_126;
		public ushort UndoChar_127;
		public ushort UndoChar_128;
		public ushort UndoChar_129;
		public ushort UndoChar_130;
		public ushort UndoChar_131;
		public ushort UndoChar_132;
		public ushort UndoChar_133;
		public ushort UndoChar_134;
		public ushort UndoChar_135;
		public ushort UndoChar_136;
		public ushort UndoChar_137;
		public ushort UndoChar_138;
		public ushort UndoChar_139;
		public ushort UndoChar_140;
		public ushort UndoChar_141;
		public ushort UndoChar_142;
		public ushort UndoChar_143;
		public ushort UndoChar_144;
		public ushort UndoChar_145;
		public ushort UndoChar_146;
		public ushort UndoChar_147;
		public ushort UndoChar_148;
		public ushort UndoChar_149;
		public ushort UndoChar_150;
		public ushort UndoChar_151;
		public ushort UndoChar_152;
		public ushort UndoChar_153;
		public ushort UndoChar_154;
		public ushort UndoChar_155;
		public ushort UndoChar_156;
		public ushort UndoChar_157;
		public ushort UndoChar_158;
		public ushort UndoChar_159;
		public ushort UndoChar_160;
		public ushort UndoChar_161;
		public ushort UndoChar_162;
		public ushort UndoChar_163;
		public ushort UndoChar_164;
		public ushort UndoChar_165;
		public ushort UndoChar_166;
		public ushort UndoChar_167;
		public ushort UndoChar_168;
		public ushort UndoChar_169;
		public ushort UndoChar_170;
		public ushort UndoChar_171;
		public ushort UndoChar_172;
		public ushort UndoChar_173;
		public ushort UndoChar_174;
		public ushort UndoChar_175;
		public ushort UndoChar_176;
		public ushort UndoChar_177;
		public ushort UndoChar_178;
		public ushort UndoChar_179;
		public ushort UndoChar_180;
		public ushort UndoChar_181;
		public ushort UndoChar_182;
		public ushort UndoChar_183;
		public ushort UndoChar_184;
		public ushort UndoChar_185;
		public ushort UndoChar_186;
		public ushort UndoChar_187;
		public ushort UndoChar_188;
		public ushort UndoChar_189;
		public ushort UndoChar_190;
		public ushort UndoChar_191;
		public ushort UndoChar_192;
		public ushort UndoChar_193;
		public ushort UndoChar_194;
		public ushort UndoChar_195;
		public ushort UndoChar_196;
		public ushort UndoChar_197;
		public ushort UndoChar_198;
		public ushort UndoChar_199;
		public ushort UndoChar_200;
		public ushort UndoChar_201;
		public ushort UndoChar_202;
		public ushort UndoChar_203;
		public ushort UndoChar_204;
		public ushort UndoChar_205;
		public ushort UndoChar_206;
		public ushort UndoChar_207;
		public ushort UndoChar_208;
		public ushort UndoChar_209;
		public ushort UndoChar_210;
		public ushort UndoChar_211;
		public ushort UndoChar_212;
		public ushort UndoChar_213;
		public ushort UndoChar_214;
		public ushort UndoChar_215;
		public ushort UndoChar_216;
		public ushort UndoChar_217;
		public ushort UndoChar_218;
		public ushort UndoChar_219;
		public ushort UndoChar_220;
		public ushort UndoChar_221;
		public ushort UndoChar_222;
		public ushort UndoChar_223;
		public ushort UndoChar_224;
		public ushort UndoChar_225;
		public ushort UndoChar_226;
		public ushort UndoChar_227;
		public ushort UndoChar_228;
		public ushort UndoChar_229;
		public ushort UndoChar_230;
		public ushort UndoChar_231;
		public ushort UndoChar_232;
		public ushort UndoChar_233;
		public ushort UndoChar_234;
		public ushort UndoChar_235;
		public ushort UndoChar_236;
		public ushort UndoChar_237;
		public ushort UndoChar_238;
		public ushort UndoChar_239;
		public ushort UndoChar_240;
		public ushort UndoChar_241;
		public ushort UndoChar_242;
		public ushort UndoChar_243;
		public ushort UndoChar_244;
		public ushort UndoChar_245;
		public ushort UndoChar_246;
		public ushort UndoChar_247;
		public ushort UndoChar_248;
		public ushort UndoChar_249;
		public ushort UndoChar_250;
		public ushort UndoChar_251;
		public ushort UndoChar_252;
		public ushort UndoChar_253;
		public ushort UndoChar_254;
		public ushort UndoChar_255;
		public ushort UndoChar_256;
		public ushort UndoChar_257;
		public ushort UndoChar_258;
		public ushort UndoChar_259;
		public ushort UndoChar_260;
		public ushort UndoChar_261;
		public ushort UndoChar_262;
		public ushort UndoChar_263;
		public ushort UndoChar_264;
		public ushort UndoChar_265;
		public ushort UndoChar_266;
		public ushort UndoChar_267;
		public ushort UndoChar_268;
		public ushort UndoChar_269;
		public ushort UndoChar_270;
		public ushort UndoChar_271;
		public ushort UndoChar_272;
		public ushort UndoChar_273;
		public ushort UndoChar_274;
		public ushort UndoChar_275;
		public ushort UndoChar_276;
		public ushort UndoChar_277;
		public ushort UndoChar_278;
		public ushort UndoChar_279;
		public ushort UndoChar_280;
		public ushort UndoChar_281;
		public ushort UndoChar_282;
		public ushort UndoChar_283;
		public ushort UndoChar_284;
		public ushort UndoChar_285;
		public ushort UndoChar_286;
		public ushort UndoChar_287;
		public ushort UndoChar_288;
		public ushort UndoChar_289;
		public ushort UndoChar_290;
		public ushort UndoChar_291;
		public ushort UndoChar_292;
		public ushort UndoChar_293;
		public ushort UndoChar_294;
		public ushort UndoChar_295;
		public ushort UndoChar_296;
		public ushort UndoChar_297;
		public ushort UndoChar_298;
		public ushort UndoChar_299;
		public ushort UndoChar_300;
		public ushort UndoChar_301;
		public ushort UndoChar_302;
		public ushort UndoChar_303;
		public ushort UndoChar_304;
		public ushort UndoChar_305;
		public ushort UndoChar_306;
		public ushort UndoChar_307;
		public ushort UndoChar_308;
		public ushort UndoChar_309;
		public ushort UndoChar_310;
		public ushort UndoChar_311;
		public ushort UndoChar_312;
		public ushort UndoChar_313;
		public ushort UndoChar_314;
		public ushort UndoChar_315;
		public ushort UndoChar_316;
		public ushort UndoChar_317;
		public ushort UndoChar_318;
		public ushort UndoChar_319;
		public ushort UndoChar_320;
		public ushort UndoChar_321;
		public ushort UndoChar_322;
		public ushort UndoChar_323;
		public ushort UndoChar_324;
		public ushort UndoChar_325;
		public ushort UndoChar_326;
		public ushort UndoChar_327;
		public ushort UndoChar_328;
		public ushort UndoChar_329;
		public ushort UndoChar_330;
		public ushort UndoChar_331;
		public ushort UndoChar_332;
		public ushort UndoChar_333;
		public ushort UndoChar_334;
		public ushort UndoChar_335;
		public ushort UndoChar_336;
		public ushort UndoChar_337;
		public ushort UndoChar_338;
		public ushort UndoChar_339;
		public ushort UndoChar_340;
		public ushort UndoChar_341;
		public ushort UndoChar_342;
		public ushort UndoChar_343;
		public ushort UndoChar_344;
		public ushort UndoChar_345;
		public ushort UndoChar_346;
		public ushort UndoChar_347;
		public ushort UndoChar_348;
		public ushort UndoChar_349;
		public ushort UndoChar_350;
		public ushort UndoChar_351;
		public ushort UndoChar_352;
		public ushort UndoChar_353;
		public ushort UndoChar_354;
		public ushort UndoChar_355;
		public ushort UndoChar_356;
		public ushort UndoChar_357;
		public ushort UndoChar_358;
		public ushort UndoChar_359;
		public ushort UndoChar_360;
		public ushort UndoChar_361;
		public ushort UndoChar_362;
		public ushort UndoChar_363;
		public ushort UndoChar_364;
		public ushort UndoChar_365;
		public ushort UndoChar_366;
		public ushort UndoChar_367;
		public ushort UndoChar_368;
		public ushort UndoChar_369;
		public ushort UndoChar_370;
		public ushort UndoChar_371;
		public ushort UndoChar_372;
		public ushort UndoChar_373;
		public ushort UndoChar_374;
		public ushort UndoChar_375;
		public ushort UndoChar_376;
		public ushort UndoChar_377;
		public ushort UndoChar_378;
		public ushort UndoChar_379;
		public ushort UndoChar_380;
		public ushort UndoChar_381;
		public ushort UndoChar_382;
		public ushort UndoChar_383;
		public ushort UndoChar_384;
		public ushort UndoChar_385;
		public ushort UndoChar_386;
		public ushort UndoChar_387;
		public ushort UndoChar_388;
		public ushort UndoChar_389;
		public ushort UndoChar_390;
		public ushort UndoChar_391;
		public ushort UndoChar_392;
		public ushort UndoChar_393;
		public ushort UndoChar_394;
		public ushort UndoChar_395;
		public ushort UndoChar_396;
		public ushort UndoChar_397;
		public ushort UndoChar_398;
		public ushort UndoChar_399;
		public ushort UndoChar_400;
		public ushort UndoChar_401;
		public ushort UndoChar_402;
		public ushort UndoChar_403;
		public ushort UndoChar_404;
		public ushort UndoChar_405;
		public ushort UndoChar_406;
		public ushort UndoChar_407;
		public ushort UndoChar_408;
		public ushort UndoChar_409;
		public ushort UndoChar_410;
		public ushort UndoChar_411;
		public ushort UndoChar_412;
		public ushort UndoChar_413;
		public ushort UndoChar_414;
		public ushort UndoChar_415;
		public ushort UndoChar_416;
		public ushort UndoChar_417;
		public ushort UndoChar_418;
		public ushort UndoChar_419;
		public ushort UndoChar_420;
		public ushort UndoChar_421;
		public ushort UndoChar_422;
		public ushort UndoChar_423;
		public ushort UndoChar_424;
		public ushort UndoChar_425;
		public ushort UndoChar_426;
		public ushort UndoChar_427;
		public ushort UndoChar_428;
		public ushort UndoChar_429;
		public ushort UndoChar_430;
		public ushort UndoChar_431;
		public ushort UndoChar_432;
		public ushort UndoChar_433;
		public ushort UndoChar_434;
		public ushort UndoChar_435;
		public ushort UndoChar_436;
		public ushort UndoChar_437;
		public ushort UndoChar_438;
		public ushort UndoChar_439;
		public ushort UndoChar_440;
		public ushort UndoChar_441;
		public ushort UndoChar_442;
		public ushort UndoChar_443;
		public ushort UndoChar_444;
		public ushort UndoChar_445;
		public ushort UndoChar_446;
		public ushort UndoChar_447;
		public ushort UndoChar_448;
		public ushort UndoChar_449;
		public ushort UndoChar_450;
		public ushort UndoChar_451;
		public ushort UndoChar_452;
		public ushort UndoChar_453;
		public ushort UndoChar_454;
		public ushort UndoChar_455;
		public ushort UndoChar_456;
		public ushort UndoChar_457;
		public ushort UndoChar_458;
		public ushort UndoChar_459;
		public ushort UndoChar_460;
		public ushort UndoChar_461;
		public ushort UndoChar_462;
		public ushort UndoChar_463;
		public ushort UndoChar_464;
		public ushort UndoChar_465;
		public ushort UndoChar_466;
		public ushort UndoChar_467;
		public ushort UndoChar_468;
		public ushort UndoChar_469;
		public ushort UndoChar_470;
		public ushort UndoChar_471;
		public ushort UndoChar_472;
		public ushort UndoChar_473;
		public ushort UndoChar_474;
		public ushort UndoChar_475;
		public ushort UndoChar_476;
		public ushort UndoChar_477;
		public ushort UndoChar_478;
		public ushort UndoChar_479;
		public ushort UndoChar_480;
		public ushort UndoChar_481;
		public ushort UndoChar_482;
		public ushort UndoChar_483;
		public ushort UndoChar_484;
		public ushort UndoChar_485;
		public ushort UndoChar_486;
		public ushort UndoChar_487;
		public ushort UndoChar_488;
		public ushort UndoChar_489;
		public ushort UndoChar_490;
		public ushort UndoChar_491;
		public ushort UndoChar_492;
		public ushort UndoChar_493;
		public ushort UndoChar_494;
		public ushort UndoChar_495;
		public ushort UndoChar_496;
		public ushort UndoChar_497;
		public ushort UndoChar_498;
		public ushort UndoChar_499;
		public ushort UndoChar_500;
		public ushort UndoChar_501;
		public ushort UndoChar_502;
		public ushort UndoChar_503;
		public ushort UndoChar_504;
		public ushort UndoChar_505;
		public ushort UndoChar_506;
		public ushort UndoChar_507;
		public ushort UndoChar_508;
		public ushort UndoChar_509;
		public ushort UndoChar_510;
		public ushort UndoChar_511;
		public ushort UndoChar_512;
		public ushort UndoChar_513;
		public ushort UndoChar_514;
		public ushort UndoChar_515;
		public ushort UndoChar_516;
		public ushort UndoChar_517;
		public ushort UndoChar_518;
		public ushort UndoChar_519;
		public ushort UndoChar_520;
		public ushort UndoChar_521;
		public ushort UndoChar_522;
		public ushort UndoChar_523;
		public ushort UndoChar_524;
		public ushort UndoChar_525;
		public ushort UndoChar_526;
		public ushort UndoChar_527;
		public ushort UndoChar_528;
		public ushort UndoChar_529;
		public ushort UndoChar_530;
		public ushort UndoChar_531;
		public ushort UndoChar_532;
		public ushort UndoChar_533;
		public ushort UndoChar_534;
		public ushort UndoChar_535;
		public ushort UndoChar_536;
		public ushort UndoChar_537;
		public ushort UndoChar_538;
		public ushort UndoChar_539;
		public ushort UndoChar_540;
		public ushort UndoChar_541;
		public ushort UndoChar_542;
		public ushort UndoChar_543;
		public ushort UndoChar_544;
		public ushort UndoChar_545;
		public ushort UndoChar_546;
		public ushort UndoChar_547;
		public ushort UndoChar_548;
		public ushort UndoChar_549;
		public ushort UndoChar_550;
		public ushort UndoChar_551;
		public ushort UndoChar_552;
		public ushort UndoChar_553;
		public ushort UndoChar_554;
		public ushort UndoChar_555;
		public ushort UndoChar_556;
		public ushort UndoChar_557;
		public ushort UndoChar_558;
		public ushort UndoChar_559;
		public ushort UndoChar_560;
		public ushort UndoChar_561;
		public ushort UndoChar_562;
		public ushort UndoChar_563;
		public ushort UndoChar_564;
		public ushort UndoChar_565;
		public ushort UndoChar_566;
		public ushort UndoChar_567;
		public ushort UndoChar_568;
		public ushort UndoChar_569;
		public ushort UndoChar_570;
		public ushort UndoChar_571;
		public ushort UndoChar_572;
		public ushort UndoChar_573;
		public ushort UndoChar_574;
		public ushort UndoChar_575;
		public ushort UndoChar_576;
		public ushort UndoChar_577;
		public ushort UndoChar_578;
		public ushort UndoChar_579;
		public ushort UndoChar_580;
		public ushort UndoChar_581;
		public ushort UndoChar_582;
		public ushort UndoChar_583;
		public ushort UndoChar_584;
		public ushort UndoChar_585;
		public ushort UndoChar_586;
		public ushort UndoChar_587;
		public ushort UndoChar_588;
		public ushort UndoChar_589;
		public ushort UndoChar_590;
		public ushort UndoChar_591;
		public ushort UndoChar_592;
		public ushort UndoChar_593;
		public ushort UndoChar_594;
		public ushort UndoChar_595;
		public ushort UndoChar_596;
		public ushort UndoChar_597;
		public ushort UndoChar_598;
		public ushort UndoChar_599;
		public ushort UndoChar_600;
		public ushort UndoChar_601;
		public ushort UndoChar_602;
		public ushort UndoChar_603;
		public ushort UndoChar_604;
		public ushort UndoChar_605;
		public ushort UndoChar_606;
		public ushort UndoChar_607;
		public ushort UndoChar_608;
		public ushort UndoChar_609;
		public ushort UndoChar_610;
		public ushort UndoChar_611;
		public ushort UndoChar_612;
		public ushort UndoChar_613;
		public ushort UndoChar_614;
		public ushort UndoChar_615;
		public ushort UndoChar_616;
		public ushort UndoChar_617;
		public ushort UndoChar_618;
		public ushort UndoChar_619;
		public ushort UndoChar_620;
		public ushort UndoChar_621;
		public ushort UndoChar_622;
		public ushort UndoChar_623;
		public ushort UndoChar_624;
		public ushort UndoChar_625;
		public ushort UndoChar_626;
		public ushort UndoChar_627;
		public ushort UndoChar_628;
		public ushort UndoChar_629;
		public ushort UndoChar_630;
		public ushort UndoChar_631;
		public ushort UndoChar_632;
		public ushort UndoChar_633;
		public ushort UndoChar_634;
		public ushort UndoChar_635;
		public ushort UndoChar_636;
		public ushort UndoChar_637;
		public ushort UndoChar_638;
		public ushort UndoChar_639;
		public ushort UndoChar_640;
		public ushort UndoChar_641;
		public ushort UndoChar_642;
		public ushort UndoChar_643;
		public ushort UndoChar_644;
		public ushort UndoChar_645;
		public ushort UndoChar_646;
		public ushort UndoChar_647;
		public ushort UndoChar_648;
		public ushort UndoChar_649;
		public ushort UndoChar_650;
		public ushort UndoChar_651;
		public ushort UndoChar_652;
		public ushort UndoChar_653;
		public ushort UndoChar_654;
		public ushort UndoChar_655;
		public ushort UndoChar_656;
		public ushort UndoChar_657;
		public ushort UndoChar_658;
		public ushort UndoChar_659;
		public ushort UndoChar_660;
		public ushort UndoChar_661;
		public ushort UndoChar_662;
		public ushort UndoChar_663;
		public ushort UndoChar_664;
		public ushort UndoChar_665;
		public ushort UndoChar_666;
		public ushort UndoChar_667;
		public ushort UndoChar_668;
		public ushort UndoChar_669;
		public ushort UndoChar_670;
		public ushort UndoChar_671;
		public ushort UndoChar_672;
		public ushort UndoChar_673;
		public ushort UndoChar_674;
		public ushort UndoChar_675;
		public ushort UndoChar_676;
		public ushort UndoChar_677;
		public ushort UndoChar_678;
		public ushort UndoChar_679;
		public ushort UndoChar_680;
		public ushort UndoChar_681;
		public ushort UndoChar_682;
		public ushort UndoChar_683;
		public ushort UndoChar_684;
		public ushort UndoChar_685;
		public ushort UndoChar_686;
		public ushort UndoChar_687;
		public ushort UndoChar_688;
		public ushort UndoChar_689;
		public ushort UndoChar_690;
		public ushort UndoChar_691;
		public ushort UndoChar_692;
		public ushort UndoChar_693;
		public ushort UndoChar_694;
		public ushort UndoChar_695;
		public ushort UndoChar_696;
		public ushort UndoChar_697;
		public ushort UndoChar_698;
		public ushort UndoChar_699;
		public ushort UndoChar_700;
		public ushort UndoChar_701;
		public ushort UndoChar_702;
		public ushort UndoChar_703;
		public ushort UndoChar_704;
		public ushort UndoChar_705;
		public ushort UndoChar_706;
		public ushort UndoChar_707;
		public ushort UndoChar_708;
		public ushort UndoChar_709;
		public ushort UndoChar_710;
		public ushort UndoChar_711;
		public ushort UndoChar_712;
		public ushort UndoChar_713;
		public ushort UndoChar_714;
		public ushort UndoChar_715;
		public ushort UndoChar_716;
		public ushort UndoChar_717;
		public ushort UndoChar_718;
		public ushort UndoChar_719;
		public ushort UndoChar_720;
		public ushort UndoChar_721;
		public ushort UndoChar_722;
		public ushort UndoChar_723;
		public ushort UndoChar_724;
		public ushort UndoChar_725;
		public ushort UndoChar_726;
		public ushort UndoChar_727;
		public ushort UndoChar_728;
		public ushort UndoChar_729;
		public ushort UndoChar_730;
		public ushort UndoChar_731;
		public ushort UndoChar_732;
		public ushort UndoChar_733;
		public ushort UndoChar_734;
		public ushort UndoChar_735;
		public ushort UndoChar_736;
		public ushort UndoChar_737;
		public ushort UndoChar_738;
		public ushort UndoChar_739;
		public ushort UndoChar_740;
		public ushort UndoChar_741;
		public ushort UndoChar_742;
		public ushort UndoChar_743;
		public ushort UndoChar_744;
		public ushort UndoChar_745;
		public ushort UndoChar_746;
		public ushort UndoChar_747;
		public ushort UndoChar_748;
		public ushort UndoChar_749;
		public ushort UndoChar_750;
		public ushort UndoChar_751;
		public ushort UndoChar_752;
		public ushort UndoChar_753;
		public ushort UndoChar_754;
		public ushort UndoChar_755;
		public ushort UndoChar_756;
		public ushort UndoChar_757;
		public ushort UndoChar_758;
		public ushort UndoChar_759;
		public ushort UndoChar_760;
		public ushort UndoChar_761;
		public ushort UndoChar_762;
		public ushort UndoChar_763;
		public ushort UndoChar_764;
		public ushort UndoChar_765;
		public ushort UndoChar_766;
		public ushort UndoChar_767;
		public ushort UndoChar_768;
		public ushort UndoChar_769;
		public ushort UndoChar_770;
		public ushort UndoChar_771;
		public ushort UndoChar_772;
		public ushort UndoChar_773;
		public ushort UndoChar_774;
		public ushort UndoChar_775;
		public ushort UndoChar_776;
		public ushort UndoChar_777;
		public ushort UndoChar_778;
		public ushort UndoChar_779;
		public ushort UndoChar_780;
		public ushort UndoChar_781;
		public ushort UndoChar_782;
		public ushort UndoChar_783;
		public ushort UndoChar_784;
		public ushort UndoChar_785;
		public ushort UndoChar_786;
		public ushort UndoChar_787;
		public ushort UndoChar_788;
		public ushort UndoChar_789;
		public ushort UndoChar_790;
		public ushort UndoChar_791;
		public ushort UndoChar_792;
		public ushort UndoChar_793;
		public ushort UndoChar_794;
		public ushort UndoChar_795;
		public ushort UndoChar_796;
		public ushort UndoChar_797;
		public ushort UndoChar_798;
		public ushort UndoChar_799;
		public ushort UndoChar_800;
		public ushort UndoChar_801;
		public ushort UndoChar_802;
		public ushort UndoChar_803;
		public ushort UndoChar_804;
		public ushort UndoChar_805;
		public ushort UndoChar_806;
		public ushort UndoChar_807;
		public ushort UndoChar_808;
		public ushort UndoChar_809;
		public ushort UndoChar_810;
		public ushort UndoChar_811;
		public ushort UndoChar_812;
		public ushort UndoChar_813;
		public ushort UndoChar_814;
		public ushort UndoChar_815;
		public ushort UndoChar_816;
		public ushort UndoChar_817;
		public ushort UndoChar_818;
		public ushort UndoChar_819;
		public ushort UndoChar_820;
		public ushort UndoChar_821;
		public ushort UndoChar_822;
		public ushort UndoChar_823;
		public ushort UndoChar_824;
		public ushort UndoChar_825;
		public ushort UndoChar_826;
		public ushort UndoChar_827;
		public ushort UndoChar_828;
		public ushort UndoChar_829;
		public ushort UndoChar_830;
		public ushort UndoChar_831;
		public ushort UndoChar_832;
		public ushort UndoChar_833;
		public ushort UndoChar_834;
		public ushort UndoChar_835;
		public ushort UndoChar_836;
		public ushort UndoChar_837;
		public ushort UndoChar_838;
		public ushort UndoChar_839;
		public ushort UndoChar_840;
		public ushort UndoChar_841;
		public ushort UndoChar_842;
		public ushort UndoChar_843;
		public ushort UndoChar_844;
		public ushort UndoChar_845;
		public ushort UndoChar_846;
		public ushort UndoChar_847;
		public ushort UndoChar_848;
		public ushort UndoChar_849;
		public ushort UndoChar_850;
		public ushort UndoChar_851;
		public ushort UndoChar_852;
		public ushort UndoChar_853;
		public ushort UndoChar_854;
		public ushort UndoChar_855;
		public ushort UndoChar_856;
		public ushort UndoChar_857;
		public ushort UndoChar_858;
		public ushort UndoChar_859;
		public ushort UndoChar_860;
		public ushort UndoChar_861;
		public ushort UndoChar_862;
		public ushort UndoChar_863;
		public ushort UndoChar_864;
		public ushort UndoChar_865;
		public ushort UndoChar_866;
		public ushort UndoChar_867;
		public ushort UndoChar_868;
		public ushort UndoChar_869;
		public ushort UndoChar_870;
		public ushort UndoChar_871;
		public ushort UndoChar_872;
		public ushort UndoChar_873;
		public ushort UndoChar_874;
		public ushort UndoChar_875;
		public ushort UndoChar_876;
		public ushort UndoChar_877;
		public ushort UndoChar_878;
		public ushort UndoChar_879;
		public ushort UndoChar_880;
		public ushort UndoChar_881;
		public ushort UndoChar_882;
		public ushort UndoChar_883;
		public ushort UndoChar_884;
		public ushort UndoChar_885;
		public ushort UndoChar_886;
		public ushort UndoChar_887;
		public ushort UndoChar_888;
		public ushort UndoChar_889;
		public ushort UndoChar_890;
		public ushort UndoChar_891;
		public ushort UndoChar_892;
		public ushort UndoChar_893;
		public ushort UndoChar_894;
		public ushort UndoChar_895;
		public ushort UndoChar_896;
		public ushort UndoChar_897;
		public ushort UndoChar_898;
		public ushort UndoChar_899;
		public ushort UndoChar_900;
		public ushort UndoChar_901;
		public ushort UndoChar_902;
		public ushort UndoChar_903;
		public ushort UndoChar_904;
		public ushort UndoChar_905;
		public ushort UndoChar_906;
		public ushort UndoChar_907;
		public ushort UndoChar_908;
		public ushort UndoChar_909;
		public ushort UndoChar_910;
		public ushort UndoChar_911;
		public ushort UndoChar_912;
		public ushort UndoChar_913;
		public ushort UndoChar_914;
		public ushort UndoChar_915;
		public ushort UndoChar_916;
		public ushort UndoChar_917;
		public ushort UndoChar_918;
		public ushort UndoChar_919;
		public ushort UndoChar_920;
		public ushort UndoChar_921;
		public ushort UndoChar_922;
		public ushort UndoChar_923;
		public ushort UndoChar_924;
		public ushort UndoChar_925;
		public ushort UndoChar_926;
		public ushort UndoChar_927;
		public ushort UndoChar_928;
		public ushort UndoChar_929;
		public ushort UndoChar_930;
		public ushort UndoChar_931;
		public ushort UndoChar_932;
		public ushort UndoChar_933;
		public ushort UndoChar_934;
		public ushort UndoChar_935;
		public ushort UndoChar_936;
		public ushort UndoChar_937;
		public ushort UndoChar_938;
		public ushort UndoChar_939;
		public ushort UndoChar_940;
		public ushort UndoChar_941;
		public ushort UndoChar_942;
		public ushort UndoChar_943;
		public ushort UndoChar_944;
		public ushort UndoChar_945;
		public ushort UndoChar_946;
		public ushort UndoChar_947;
		public ushort UndoChar_948;
		public ushort UndoChar_949;
		public ushort UndoChar_950;
		public ushort UndoChar_951;
		public ushort UndoChar_952;
		public ushort UndoChar_953;
		public ushort UndoChar_954;
		public ushort UndoChar_955;
		public ushort UndoChar_956;
		public ushort UndoChar_957;
		public ushort UndoChar_958;
		public ushort UndoChar_959;
		public ushort UndoChar_960;
		public ushort UndoChar_961;
		public ushort UndoChar_962;
		public ushort UndoChar_963;
		public ushort UndoChar_964;
		public ushort UndoChar_965;
		public ushort UndoChar_966;
		public ushort UndoChar_967;
		public ushort UndoChar_968;
		public ushort UndoChar_969;
		public ushort UndoChar_970;
		public ushort UndoChar_971;
		public ushort UndoChar_972;
		public ushort UndoChar_973;
		public ushort UndoChar_974;
		public ushort UndoChar_975;
		public ushort UndoChar_976;
		public ushort UndoChar_977;
		public ushort UndoChar_978;
		public ushort UndoChar_979;
		public ushort UndoChar_980;
		public ushort UndoChar_981;
		public ushort UndoChar_982;
		public ushort UndoChar_983;
		public ushort UndoChar_984;
		public ushort UndoChar_985;
		public ushort UndoChar_986;
		public ushort UndoChar_987;
		public ushort UndoChar_988;
		public ushort UndoChar_989;
		public ushort UndoChar_990;
		public ushort UndoChar_991;
		public ushort UndoChar_992;
		public ushort UndoChar_993;
		public ushort UndoChar_994;
		public ushort UndoChar_995;
		public ushort UndoChar_996;
		public ushort UndoChar_997;
		public ushort UndoChar_998;
		public short UndoPoint;
		public short RedoPoint;
		public int UndoCharPoint;
		public int RedoCharPoint;

		public unsafe Span<StbUndoRecord> UndoRec
		
		{
			get
			{
				fixed (StbUndoRecord* p = &this.UndoRec_0)
				{
					return new Span<StbUndoRecord>(p, 99);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbUndoRecord
	{
		public int Where;
		public int InsertLength;
		public int DeleteLength;
		public int CharStorage;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextDeactivatedState
	{
		public int ID;
		public ImVectorChar TextA;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiInputTextDeactivatedStatePtr : IEquatable<ImGuiInputTextDeactivatedStatePtr>
	{
		public ImGuiInputTextDeactivatedStatePtr(ImGuiInputTextDeactivatedState* handle) { Handle = handle; }

		public ImGuiInputTextDeactivatedState* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputTextDeactivatedStatePtr Null => new ImGuiInputTextDeactivatedStatePtr(null);

		public static implicit operator ImGuiInputTextDeactivatedStatePtr(ImGuiInputTextDeactivatedState* handle) => new ImGuiInputTextDeactivatedStatePtr(handle);

		public static implicit operator ImGuiInputTextDeactivatedState*(ImGuiInputTextDeactivatedStatePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputTextDeactivatedStatePtr left, ImGuiInputTextDeactivatedStatePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputTextDeactivatedStatePtr left, ImGuiInputTextDeactivatedStatePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputTextDeactivatedStatePtr left, ImGuiInputTextDeactivatedState* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputTextDeactivatedStatePtr left, ImGuiInputTextDeactivatedState* right) => left.Handle != right;

		public bool Equals(ImGuiInputTextDeactivatedStatePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputTextDeactivatedStatePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiInputTextDeactivatedStatePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImVectorChar TextA => ref Unsafe.AsRef<ImVectorChar>(&Handle->TextA);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiComboPreviewData
	{
		public ImRect PreviewRect;
		public Vector2 BackupCursorPos;
		public Vector2 BackupCursorMaxPos;
		public Vector2 BackupCursorPosPrevLine;
		public float BackupPrevLineTextBaseOffset;
		public ImGuiLayoutType BackupLayout;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiComboPreviewDataPtr : IEquatable<ImGuiComboPreviewDataPtr>
	{
		public ImGuiComboPreviewDataPtr(ImGuiComboPreviewData* handle) { Handle = handle; }

		public ImGuiComboPreviewData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiComboPreviewDataPtr Null => new ImGuiComboPreviewDataPtr(null);

		public static implicit operator ImGuiComboPreviewDataPtr(ImGuiComboPreviewData* handle) => new ImGuiComboPreviewDataPtr(handle);

		public static implicit operator ImGuiComboPreviewData*(ImGuiComboPreviewDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiComboPreviewDataPtr left, ImGuiComboPreviewDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiComboPreviewDataPtr left, ImGuiComboPreviewDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiComboPreviewDataPtr left, ImGuiComboPreviewData* right) => left.Handle == right;

		public static bool operator !=(ImGuiComboPreviewDataPtr left, ImGuiComboPreviewData* right) => left.Handle != right;

		public bool Equals(ImGuiComboPreviewDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiComboPreviewDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiComboPreviewDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImRect PreviewRect => ref Unsafe.AsRef<ImRect>(&Handle->PreviewRect);
		public ref Vector2 BackupCursorPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorPos);
		public ref Vector2 BackupCursorMaxPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorMaxPos);
		public ref Vector2 BackupCursorPosPrevLine => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorPosPrevLine);
		public ref float BackupPrevLineTextBaseOffset => ref Unsafe.AsRef<float>(&Handle->BackupPrevLineTextBaseOffset);
		public ref ImGuiLayoutType BackupLayout => ref Unsafe.AsRef<ImGuiLayoutType>(&Handle->BackupLayout);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockContext
	{
		public ImGuiStorage Nodes;
		public ImVectorImGuiDockRequest Requests;
		public ImVectorImGuiDockNodeSettings NodesSettings;
		public byte WantFullRebuild;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDockContextPtr : IEquatable<ImGuiDockContextPtr>
	{
		public ImGuiDockContextPtr(ImGuiDockContext* handle) { Handle = handle; }

		public ImGuiDockContext* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDockContextPtr Null => new ImGuiDockContextPtr(null);

		public static implicit operator ImGuiDockContextPtr(ImGuiDockContext* handle) => new ImGuiDockContextPtr(handle);

		public static implicit operator ImGuiDockContext*(ImGuiDockContextPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDockContextPtr left, ImGuiDockContextPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDockContextPtr left, ImGuiDockContextPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDockContextPtr left, ImGuiDockContext* right) => left.Handle == right;

		public static bool operator !=(ImGuiDockContextPtr left, ImGuiDockContext* right) => left.Handle != right;

		public bool Equals(ImGuiDockContextPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDockContextPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDockContextPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiStorage Nodes => ref Unsafe.AsRef<ImGuiStorage>(&Handle->Nodes);
		public ref ImVectorImGuiDockRequest Requests => ref Unsafe.AsRef<ImVectorImGuiDockRequest>(&Handle->Requests);
		public ref ImVectorImGuiDockNodeSettings NodesSettings => ref Unsafe.AsRef<ImVectorImGuiDockNodeSettings>(&Handle->NodesSettings);
		public ref bool WantFullRebuild => ref Unsafe.AsRef<bool>(&Handle->WantFullRebuild);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiDockRequest
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiDockRequest* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockRequest
	{

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDockRequestPtr : IEquatable<ImGuiDockRequestPtr>
	{
		public ImGuiDockRequestPtr(ImGuiDockRequest* handle) { Handle = handle; }

		public ImGuiDockRequest* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDockRequestPtr Null => new ImGuiDockRequestPtr(null);

		public static implicit operator ImGuiDockRequestPtr(ImGuiDockRequest* handle) => new ImGuiDockRequestPtr(handle);

		public static implicit operator ImGuiDockRequest*(ImGuiDockRequestPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDockRequestPtr left, ImGuiDockRequestPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDockRequestPtr left, ImGuiDockRequestPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDockRequestPtr left, ImGuiDockRequest* right) => left.Handle == right;

		public static bool operator !=(ImGuiDockRequestPtr left, ImGuiDockRequest* right) => left.Handle != right;

		public bool Equals(ImGuiDockRequestPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDockRequestPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDockRequestPtr [0x{0}]", ((nuint)Handle).ToString("X"));
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiDockNodeSettings
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiDockNodeSettings* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNodeSettings
	{

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDockNodeSettingsPtr : IEquatable<ImGuiDockNodeSettingsPtr>
	{
		public ImGuiDockNodeSettingsPtr(ImGuiDockNodeSettings* handle) { Handle = handle; }

		public ImGuiDockNodeSettings* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDockNodeSettingsPtr Null => new ImGuiDockNodeSettingsPtr(null);

		public static implicit operator ImGuiDockNodeSettingsPtr(ImGuiDockNodeSettings* handle) => new ImGuiDockNodeSettingsPtr(handle);

		public static implicit operator ImGuiDockNodeSettings*(ImGuiDockNodeSettingsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDockNodeSettingsPtr left, ImGuiDockNodeSettingsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDockNodeSettingsPtr left, ImGuiDockNodeSettingsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDockNodeSettingsPtr left, ImGuiDockNodeSettings* right) => left.Handle == right;

		public static bool operator !=(ImGuiDockNodeSettingsPtr left, ImGuiDockNodeSettings* right) => left.Handle != right;

		public bool Equals(ImGuiDockNodeSettingsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDockNodeSettingsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDockNodeSettingsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiSettingsHandler
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiSettingsHandler* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiSettingsHandler
	{
		public unsafe byte* TypeName;
		public int TypeHash;
		public unsafe void* ClearAllFn;
		public unsafe void* ReadInitFn;
		public unsafe void* ReadOpenFn;
		public unsafe void* ReadLineFn;
		public unsafe void* ApplyAllFn;
		public unsafe void* WriteAllFn;
		public unsafe void* UserData;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiSettingsHandlerPtr : IEquatable<ImGuiSettingsHandlerPtr>
	{
		public ImGuiSettingsHandlerPtr(ImGuiSettingsHandler* handle) { Handle = handle; }

		public ImGuiSettingsHandler* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiSettingsHandlerPtr Null => new ImGuiSettingsHandlerPtr(null);

		public static implicit operator ImGuiSettingsHandlerPtr(ImGuiSettingsHandler* handle) => new ImGuiSettingsHandlerPtr(handle);

		public static implicit operator ImGuiSettingsHandler*(ImGuiSettingsHandlerPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiSettingsHandlerPtr left, ImGuiSettingsHandlerPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiSettingsHandlerPtr left, ImGuiSettingsHandlerPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiSettingsHandlerPtr left, ImGuiSettingsHandler* right) => left.Handle == right;

		public static bool operator !=(ImGuiSettingsHandlerPtr left, ImGuiSettingsHandler* right) => left.Handle != right;

		public bool Equals(ImGuiSettingsHandlerPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiSettingsHandlerPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiSettingsHandlerPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public byte* TypeName { get => Handle->TypeName; set => Handle->TypeName = value; }
		public ref int TypeHash => ref Unsafe.AsRef<int>(&Handle->TypeHash);
		public void* ClearAllFn { get => Handle->ClearAllFn; set => Handle->ClearAllFn = value; }
		public void* ReadInitFn { get => Handle->ReadInitFn; set => Handle->ReadInitFn = value; }
		public void* ReadOpenFn { get => Handle->ReadOpenFn; set => Handle->ReadOpenFn = value; }
		public void* ReadLineFn { get => Handle->ReadLineFn; set => Handle->ReadLineFn = value; }
		public void* ApplyAllFn { get => Handle->ApplyAllFn; set => Handle->ApplyAllFn = value; }
		public void* WriteAllFn { get => Handle->WriteAllFn; set => Handle->WriteAllFn = value; }
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImChunkStreamImGuiWindowSettings
	{
		public ImVectorChar Buf;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImChunkStreamImGuiTableSettings
	{
		public ImVectorChar Buf;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiContextHook
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiContextHook* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiContextHook
	{
		public int HookId;
		public ImGuiContextHookType Type;
		public int Owner;
		public unsafe void* Callback;
		public unsafe void* UserData;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiContextHookPtr : IEquatable<ImGuiContextHookPtr>
	{
		public ImGuiContextHookPtr(ImGuiContextHook* handle) { Handle = handle; }

		public ImGuiContextHook* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiContextHookPtr Null => new ImGuiContextHookPtr(null);

		public static implicit operator ImGuiContextHookPtr(ImGuiContextHook* handle) => new ImGuiContextHookPtr(handle);

		public static implicit operator ImGuiContextHook*(ImGuiContextHookPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiContextHookPtr left, ImGuiContextHookPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiContextHookPtr left, ImGuiContextHookPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiContextHookPtr left, ImGuiContextHook* right) => left.Handle == right;

		public static bool operator !=(ImGuiContextHookPtr left, ImGuiContextHook* right) => left.Handle != right;

		public bool Equals(ImGuiContextHookPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiContextHookPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiContextHookPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int HookId => ref Unsafe.AsRef<int>(&Handle->HookId);
		public ref ImGuiContextHookType Type => ref Unsafe.AsRef<ImGuiContextHookType>(&Handle->Type);
		public ref int Owner => ref Unsafe.AsRef<int>(&Handle->Owner);
		public void* Callback { get => Handle->Callback; set => Handle->Callback = value; }
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextIndex
	{
		public ImVectorInt LineOffsets;
		public int EndOffset;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTextIndexPtr : IEquatable<ImGuiTextIndexPtr>
	{
		public ImGuiTextIndexPtr(ImGuiTextIndex* handle) { Handle = handle; }

		public ImGuiTextIndex* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextIndexPtr Null => new ImGuiTextIndexPtr(null);

		public static implicit operator ImGuiTextIndexPtr(ImGuiTextIndex* handle) => new ImGuiTextIndexPtr(handle);

		public static implicit operator ImGuiTextIndex*(ImGuiTextIndexPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextIndexPtr left, ImGuiTextIndexPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextIndexPtr left, ImGuiTextIndexPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextIndexPtr left, ImGuiTextIndex* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextIndexPtr left, ImGuiTextIndex* right) => left.Handle != right;

		public bool Equals(ImGuiTextIndexPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextIndexPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTextIndexPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorInt LineOffsets => ref Unsafe.AsRef<ImVectorInt>(&Handle->LineOffsets);
		public ref int EndOffset => ref Unsafe.AsRef<int>(&Handle->EndOffset);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorInt
	{
		public int Size;
		public int Capacity;
		public unsafe int* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMetricsConfig
	{
		public byte ShowDebugLog;
		public byte ShowStackTool;
		public byte ShowWindowsRects;
		public byte ShowWindowsBeginOrder;
		public byte ShowTablesRects;
		public byte ShowDrawCmdMesh;
		public byte ShowDrawCmdBoundingBoxes;
		public byte ShowAtlasTintedWithTextColor;
		public byte ShowDockingNodes;
		public int ShowWindowsRectsType;
		public int ShowTablesRectsType;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackTool
	{
		public int LastActiveFrame;
		public int StackLevel;
		public int QueryId;
		public ImVectorImGuiStackLevelInfo Results;
		public byte CopyToClipboardOnCtrlC;
		public float CopyToClipboardLastTime;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStackToolPtr : IEquatable<ImGuiStackToolPtr>
	{
		public ImGuiStackToolPtr(ImGuiStackTool* handle) { Handle = handle; }

		public ImGuiStackTool* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStackToolPtr Null => new ImGuiStackToolPtr(null);

		public static implicit operator ImGuiStackToolPtr(ImGuiStackTool* handle) => new ImGuiStackToolPtr(handle);

		public static implicit operator ImGuiStackTool*(ImGuiStackToolPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStackToolPtr left, ImGuiStackToolPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStackToolPtr left, ImGuiStackToolPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStackToolPtr left, ImGuiStackTool* right) => left.Handle == right;

		public static bool operator !=(ImGuiStackToolPtr left, ImGuiStackTool* right) => left.Handle != right;

		public bool Equals(ImGuiStackToolPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStackToolPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStackToolPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int LastActiveFrame => ref Unsafe.AsRef<int>(&Handle->LastActiveFrame);
		public ref int StackLevel => ref Unsafe.AsRef<int>(&Handle->StackLevel);
		public ref int QueryId => ref Unsafe.AsRef<int>(&Handle->QueryId);
		public ref ImVectorImGuiStackLevelInfo Results => ref Unsafe.AsRef<ImVectorImGuiStackLevelInfo>(&Handle->Results);
		public ref bool CopyToClipboardOnCtrlC => ref Unsafe.AsRef<bool>(&Handle->CopyToClipboardOnCtrlC);
		public ref float CopyToClipboardLastTime => ref Unsafe.AsRef<float>(&Handle->CopyToClipboardLastTime);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStackLevelInfo
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStackLevelInfo* Data;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackLevelInfo
	{
		public int ID;
		public sbyte QueryFrameCount;
		public byte QuerySuccess;
		public ImGuiDataType DataType;
		public byte Desc_0;
		public byte Desc_1;
		public byte Desc_2;
		public byte Desc_3;
		public byte Desc_4;
		public byte Desc_5;
		public byte Desc_6;
		public byte Desc_7;
		public byte Desc_8;
		public byte Desc_9;
		public byte Desc_10;
		public byte Desc_11;
		public byte Desc_12;
		public byte Desc_13;
		public byte Desc_14;
		public byte Desc_15;
		public byte Desc_16;
		public byte Desc_17;
		public byte Desc_18;
		public byte Desc_19;
		public byte Desc_20;
		public byte Desc_21;
		public byte Desc_22;
		public byte Desc_23;
		public byte Desc_24;
		public byte Desc_25;
		public byte Desc_26;
		public byte Desc_27;
		public byte Desc_28;
		public byte Desc_29;
		public byte Desc_30;
		public byte Desc_31;
		public byte Desc_32;
		public byte Desc_33;
		public byte Desc_34;
		public byte Desc_35;
		public byte Desc_36;
		public byte Desc_37;
		public byte Desc_38;
		public byte Desc_39;
		public byte Desc_40;
		public byte Desc_41;
		public byte Desc_42;
		public byte Desc_43;
		public byte Desc_44;
		public byte Desc_45;
		public byte Desc_46;
		public byte Desc_47;
		public byte Desc_48;
		public byte Desc_49;
		public byte Desc_50;
		public byte Desc_51;
		public byte Desc_52;
		public byte Desc_53;
		public byte Desc_54;
		public byte Desc_55;
		public byte Desc_56;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStackLevelInfoPtr : IEquatable<ImGuiStackLevelInfoPtr>
	{
		public ImGuiStackLevelInfoPtr(ImGuiStackLevelInfo* handle) { Handle = handle; }

		public ImGuiStackLevelInfo* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStackLevelInfoPtr Null => new ImGuiStackLevelInfoPtr(null);

		public static implicit operator ImGuiStackLevelInfoPtr(ImGuiStackLevelInfo* handle) => new ImGuiStackLevelInfoPtr(handle);

		public static implicit operator ImGuiStackLevelInfo*(ImGuiStackLevelInfoPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStackLevelInfoPtr left, ImGuiStackLevelInfoPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStackLevelInfoPtr left, ImGuiStackLevelInfoPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStackLevelInfoPtr left, ImGuiStackLevelInfo* right) => left.Handle == right;

		public static bool operator !=(ImGuiStackLevelInfoPtr left, ImGuiStackLevelInfo* right) => left.Handle != right;

		public bool Equals(ImGuiStackLevelInfoPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStackLevelInfoPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStackLevelInfoPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref sbyte QueryFrameCount => ref Unsafe.AsRef<sbyte>(&Handle->QueryFrameCount);
		public ref bool QuerySuccess => ref Unsafe.AsRef<bool>(&Handle->QuerySuccess);
		public ref ImGuiDataType DataType => ref Unsafe.AsRef<ImGuiDataType>(&Handle->DataType);
		public unsafe Span<byte> Desc
		
		{
			get
			{
				return new Span<byte>(&Handle->Desc_0, 57);
			}
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextCallbackData
	{
		public unsafe ImGuiContext* Ctx;
		public ImGuiInputTextFlags EventFlag;
		public ImGuiInputTextFlags Flags;
		public unsafe void* UserData;
		public char EventChar;
		public ImGuiKey EventKey;
		public unsafe byte* Buf;
		public int BufTextLen;
		public int BufSize;
		public byte BufDirty;
		public int CursorPos;
		public int SelectionStart;
		public int SelectionEnd;


		public unsafe void ClearSelection()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.ClearSelectionNative(@this);
			}
		}

		public unsafe void DeleteChars(int pos, int bytesCount)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.DeleteCharsNative(@this, pos, bytesCount);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool HasSelection()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte ret = ImGui.HasSelectionNative(@this);
				return ret != 0;
			}
		}

		public unsafe void InsertChars(int pos, byte* text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.InsertCharsNative(@this, pos, text, textEnd);
			}
		}

		public unsafe void InsertChars(int pos, byte* text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.InsertCharsNative(@this, pos, text, (byte*)(default));
			}
		}

		public unsafe void InsertChars(int pos, ref byte text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.InsertCharsNative(@this, pos, (byte*)ptext, textEnd);
				}
			}
		}

		public unsafe void InsertChars(int pos, ref byte text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.InsertCharsNative(@this, pos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		public unsafe void InsertChars(int pos, string text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars(int pos, string text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars(int pos, byte* text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.InsertCharsNative(@this, pos, text, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void InsertChars(int pos, byte* text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars(int pos, ref byte text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.InsertCharsNative(@this, pos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void InsertChars(int pos, string text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void SelectAll()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.SelectAllNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiInputTextCallbackDataPtr : IEquatable<ImGuiInputTextCallbackDataPtr>
	{
		public ImGuiInputTextCallbackDataPtr(ImGuiInputTextCallbackData* handle) { Handle = handle; }

		public ImGuiInputTextCallbackData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputTextCallbackDataPtr Null => new ImGuiInputTextCallbackDataPtr(null);

		public static implicit operator ImGuiInputTextCallbackDataPtr(ImGuiInputTextCallbackData* handle) => new ImGuiInputTextCallbackDataPtr(handle);

		public static implicit operator ImGuiInputTextCallbackData*(ImGuiInputTextCallbackDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputTextCallbackDataPtr left, ImGuiInputTextCallbackDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputTextCallbackDataPtr left, ImGuiInputTextCallbackDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputTextCallbackDataPtr left, ImGuiInputTextCallbackData* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputTextCallbackDataPtr left, ImGuiInputTextCallbackData* right) => left.Handle != right;

		public bool Equals(ImGuiInputTextCallbackDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputTextCallbackDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiInputTextCallbackDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		public ref ImGuiInputTextFlags EventFlag => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->EventFlag);
		public ref ImGuiInputTextFlags Flags => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->Flags);
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
		public ref char EventChar => ref Unsafe.AsRef<char>(&Handle->EventChar);
		public ref ImGuiKey EventKey => ref Unsafe.AsRef<ImGuiKey>(&Handle->EventKey);
		public byte* Buf { get => Handle->Buf; set => Handle->Buf = value; }
		public ref int BufTextLen => ref Unsafe.AsRef<int>(&Handle->BufTextLen);
		public ref int BufSize => ref Unsafe.AsRef<int>(&Handle->BufSize);
		public ref bool BufDirty => ref Unsafe.AsRef<bool>(&Handle->BufDirty);
		public ref int CursorPos => ref Unsafe.AsRef<int>(&Handle->CursorPos);
		public ref int SelectionStart => ref Unsafe.AsRef<int>(&Handle->SelectionStart);
		public ref int SelectionEnd => ref Unsafe.AsRef<int>(&Handle->SelectionEnd);

		public unsafe void ClearSelection()
		{
			ImGui.ClearSelectionNative(Handle);
		}

		public unsafe void DeleteChars(int pos, int bytesCount)
		{
			ImGui.DeleteCharsNative(Handle, pos, bytesCount);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool HasSelection()
		{
			byte ret = ImGui.HasSelectionNative(Handle);
			return ret != 0;
		}

		public unsafe void InsertChars(int pos, byte* text, byte* textEnd)
		{
			ImGui.InsertCharsNative(Handle, pos, text, textEnd);
		}

		public unsafe void InsertChars(int pos, byte* text)
		{
			ImGui.InsertCharsNative(Handle, pos, text, (byte*)(default));
		}

		public unsafe void InsertChars(int pos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				ImGui.InsertCharsNative(Handle, pos, (byte*)ptext, textEnd);
			}
		}

		public unsafe void InsertChars(int pos, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				ImGui.InsertCharsNative(Handle, pos, (byte*)ptext, (byte*)(default));
			}
		}

		public unsafe void InsertChars(int pos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.InsertCharsNative(Handle, pos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void InsertChars(int pos, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.InsertCharsNative(Handle, pos, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void InsertChars(int pos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.InsertCharsNative(Handle, pos, text, (byte*)ptextEnd);
			}
		}

		public unsafe void InsertChars(int pos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.InsertCharsNative(Handle, pos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void InsertChars(int pos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.InsertCharsNative(Handle, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void InsertChars(int pos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.InsertCharsNative(Handle, pos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void SelectAll()
		{
			ImGui.SelectAllNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOnceUponAFrame
	{
		public int RefFrame;


		public unsafe void Destroy()
		{
			fixed (ImGuiOnceUponAFrame* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiOnceUponAFramePtr : IEquatable<ImGuiOnceUponAFramePtr>
	{
		public ImGuiOnceUponAFramePtr(ImGuiOnceUponAFrame* handle) { Handle = handle; }

		public ImGuiOnceUponAFrame* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiOnceUponAFramePtr Null => new ImGuiOnceUponAFramePtr(null);

		public static implicit operator ImGuiOnceUponAFramePtr(ImGuiOnceUponAFrame* handle) => new ImGuiOnceUponAFramePtr(handle);

		public static implicit operator ImGuiOnceUponAFrame*(ImGuiOnceUponAFramePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiOnceUponAFramePtr left, ImGuiOnceUponAFramePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiOnceUponAFramePtr left, ImGuiOnceUponAFramePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiOnceUponAFramePtr left, ImGuiOnceUponAFrame* right) => left.Handle == right;

		public static bool operator !=(ImGuiOnceUponAFramePtr left, ImGuiOnceUponAFrame* right) => left.Handle != right;

		public bool Equals(ImGuiOnceUponAFramePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiOnceUponAFramePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiOnceUponAFramePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int RefFrame => ref Unsafe.AsRef<int>(&Handle->RefFrame);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextFilter
	{
		public byte InputBuf_0;
		public byte InputBuf_1;
		public byte InputBuf_2;
		public byte InputBuf_3;
		public byte InputBuf_4;
		public byte InputBuf_5;
		public byte InputBuf_6;
		public byte InputBuf_7;
		public byte InputBuf_8;
		public byte InputBuf_9;
		public byte InputBuf_10;
		public byte InputBuf_11;
		public byte InputBuf_12;
		public byte InputBuf_13;
		public byte InputBuf_14;
		public byte InputBuf_15;
		public byte InputBuf_16;
		public byte InputBuf_17;
		public byte InputBuf_18;
		public byte InputBuf_19;
		public byte InputBuf_20;
		public byte InputBuf_21;
		public byte InputBuf_22;
		public byte InputBuf_23;
		public byte InputBuf_24;
		public byte InputBuf_25;
		public byte InputBuf_26;
		public byte InputBuf_27;
		public byte InputBuf_28;
		public byte InputBuf_29;
		public byte InputBuf_30;
		public byte InputBuf_31;
		public byte InputBuf_32;
		public byte InputBuf_33;
		public byte InputBuf_34;
		public byte InputBuf_35;
		public byte InputBuf_36;
		public byte InputBuf_37;
		public byte InputBuf_38;
		public byte InputBuf_39;
		public byte InputBuf_40;
		public byte InputBuf_41;
		public byte InputBuf_42;
		public byte InputBuf_43;
		public byte InputBuf_44;
		public byte InputBuf_45;
		public byte InputBuf_46;
		public byte InputBuf_47;
		public byte InputBuf_48;
		public byte InputBuf_49;
		public byte InputBuf_50;
		public byte InputBuf_51;
		public byte InputBuf_52;
		public byte InputBuf_53;
		public byte InputBuf_54;
		public byte InputBuf_55;
		public byte InputBuf_56;
		public byte InputBuf_57;
		public byte InputBuf_58;
		public byte InputBuf_59;
		public byte InputBuf_60;
		public byte InputBuf_61;
		public byte InputBuf_62;
		public byte InputBuf_63;
		public byte InputBuf_64;
		public byte InputBuf_65;
		public byte InputBuf_66;
		public byte InputBuf_67;
		public byte InputBuf_68;
		public byte InputBuf_69;
		public byte InputBuf_70;
		public byte InputBuf_71;
		public byte InputBuf_72;
		public byte InputBuf_73;
		public byte InputBuf_74;
		public byte InputBuf_75;
		public byte InputBuf_76;
		public byte InputBuf_77;
		public byte InputBuf_78;
		public byte InputBuf_79;
		public byte InputBuf_80;
		public byte InputBuf_81;
		public byte InputBuf_82;
		public byte InputBuf_83;
		public byte InputBuf_84;
		public byte InputBuf_85;
		public byte InputBuf_86;
		public byte InputBuf_87;
		public byte InputBuf_88;
		public byte InputBuf_89;
		public byte InputBuf_90;
		public byte InputBuf_91;
		public byte InputBuf_92;
		public byte InputBuf_93;
		public byte InputBuf_94;
		public byte InputBuf_95;
		public byte InputBuf_96;
		public byte InputBuf_97;
		public byte InputBuf_98;
		public byte InputBuf_99;
		public byte InputBuf_100;
		public byte InputBuf_101;
		public byte InputBuf_102;
		public byte InputBuf_103;
		public byte InputBuf_104;
		public byte InputBuf_105;
		public byte InputBuf_106;
		public byte InputBuf_107;
		public byte InputBuf_108;
		public byte InputBuf_109;
		public byte InputBuf_110;
		public byte InputBuf_111;
		public byte InputBuf_112;
		public byte InputBuf_113;
		public byte InputBuf_114;
		public byte InputBuf_115;
		public byte InputBuf_116;
		public byte InputBuf_117;
		public byte InputBuf_118;
		public byte InputBuf_119;
		public byte InputBuf_120;
		public byte InputBuf_121;
		public byte InputBuf_122;
		public byte InputBuf_123;
		public byte InputBuf_124;
		public byte InputBuf_125;
		public byte InputBuf_126;
		public byte InputBuf_127;
		public byte InputBuf_128;
		public byte InputBuf_129;
		public byte InputBuf_130;
		public byte InputBuf_131;
		public byte InputBuf_132;
		public byte InputBuf_133;
		public byte InputBuf_134;
		public byte InputBuf_135;
		public byte InputBuf_136;
		public byte InputBuf_137;
		public byte InputBuf_138;
		public byte InputBuf_139;
		public byte InputBuf_140;
		public byte InputBuf_141;
		public byte InputBuf_142;
		public byte InputBuf_143;
		public byte InputBuf_144;
		public byte InputBuf_145;
		public byte InputBuf_146;
		public byte InputBuf_147;
		public byte InputBuf_148;
		public byte InputBuf_149;
		public byte InputBuf_150;
		public byte InputBuf_151;
		public byte InputBuf_152;
		public byte InputBuf_153;
		public byte InputBuf_154;
		public byte InputBuf_155;
		public byte InputBuf_156;
		public byte InputBuf_157;
		public byte InputBuf_158;
		public byte InputBuf_159;
		public byte InputBuf_160;
		public byte InputBuf_161;
		public byte InputBuf_162;
		public byte InputBuf_163;
		public byte InputBuf_164;
		public byte InputBuf_165;
		public byte InputBuf_166;
		public byte InputBuf_167;
		public byte InputBuf_168;
		public byte InputBuf_169;
		public byte InputBuf_170;
		public byte InputBuf_171;
		public byte InputBuf_172;
		public byte InputBuf_173;
		public byte InputBuf_174;
		public byte InputBuf_175;
		public byte InputBuf_176;
		public byte InputBuf_177;
		public byte InputBuf_178;
		public byte InputBuf_179;
		public byte InputBuf_180;
		public byte InputBuf_181;
		public byte InputBuf_182;
		public byte InputBuf_183;
		public byte InputBuf_184;
		public byte InputBuf_185;
		public byte InputBuf_186;
		public byte InputBuf_187;
		public byte InputBuf_188;
		public byte InputBuf_189;
		public byte InputBuf_190;
		public byte InputBuf_191;
		public byte InputBuf_192;
		public byte InputBuf_193;
		public byte InputBuf_194;
		public byte InputBuf_195;
		public byte InputBuf_196;
		public byte InputBuf_197;
		public byte InputBuf_198;
		public byte InputBuf_199;
		public byte InputBuf_200;
		public byte InputBuf_201;
		public byte InputBuf_202;
		public byte InputBuf_203;
		public byte InputBuf_204;
		public byte InputBuf_205;
		public byte InputBuf_206;
		public byte InputBuf_207;
		public byte InputBuf_208;
		public byte InputBuf_209;
		public byte InputBuf_210;
		public byte InputBuf_211;
		public byte InputBuf_212;
		public byte InputBuf_213;
		public byte InputBuf_214;
		public byte InputBuf_215;
		public byte InputBuf_216;
		public byte InputBuf_217;
		public byte InputBuf_218;
		public byte InputBuf_219;
		public byte InputBuf_220;
		public byte InputBuf_221;
		public byte InputBuf_222;
		public byte InputBuf_223;
		public byte InputBuf_224;
		public byte InputBuf_225;
		public byte InputBuf_226;
		public byte InputBuf_227;
		public byte InputBuf_228;
		public byte InputBuf_229;
		public byte InputBuf_230;
		public byte InputBuf_231;
		public byte InputBuf_232;
		public byte InputBuf_233;
		public byte InputBuf_234;
		public byte InputBuf_235;
		public byte InputBuf_236;
		public byte InputBuf_237;
		public byte InputBuf_238;
		public byte InputBuf_239;
		public byte InputBuf_240;
		public byte InputBuf_241;
		public byte InputBuf_242;
		public byte InputBuf_243;
		public byte InputBuf_244;
		public byte InputBuf_245;
		public byte InputBuf_246;
		public byte InputBuf_247;
		public byte InputBuf_248;
		public byte InputBuf_249;
		public byte InputBuf_250;
		public byte InputBuf_251;
		public byte InputBuf_252;
		public byte InputBuf_253;
		public byte InputBuf_254;
		public byte InputBuf_255;
		public ImVectorImGuiTextRange Filters;
		public int CountGrep;


		public unsafe void Build()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.BuildNative(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool Draw(byte* label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.DrawNative(@this, label, width);
				return ret != 0;
			}
		}

		public unsafe bool Draw(byte* label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.DrawNative(@this, label, (float)(0.0f));
				return ret != 0;
			}
		}

		public unsafe bool Draw()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, (string)"Filter(inc,-exc)", (float)(0.0f));
				return ret;
			}
		}

		public unsafe bool Draw(float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, (string)"Filter(inc,-exc)", width);
				return ret;
			}
		}

		public unsafe bool Draw(ref byte label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, width);
					return ret != 0;
				}
			}
		}

		public unsafe bool Draw(ref byte label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, (float)(0.0f));
					return ret != 0;
				}
			}
		}

		public unsafe bool Draw(string label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.DrawNative(@this, pStr0, width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool Draw(string label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.DrawNative(@this, pStr0, (float)(0.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool IsActive()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.IsActiveNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(byte* text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.PassFilterNative(@this, text, textEnd);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(byte* text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.PassFilterNative(@this, text, (byte*)(default));
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(ref byte text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, textEnd);
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter(ref byte text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)(default));
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter(string text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(string text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(byte* text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(@this, text, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter(byte* text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(ref byte text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)ptextEnd);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool PassFilter(string text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTextFilterPtr : IEquatable<ImGuiTextFilterPtr>
	{
		public ImGuiTextFilterPtr(ImGuiTextFilter* handle) { Handle = handle; }

		public ImGuiTextFilter* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextFilterPtr Null => new ImGuiTextFilterPtr(null);

		public static implicit operator ImGuiTextFilterPtr(ImGuiTextFilter* handle) => new ImGuiTextFilterPtr(handle);

		public static implicit operator ImGuiTextFilter*(ImGuiTextFilterPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextFilterPtr left, ImGuiTextFilterPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextFilterPtr left, ImGuiTextFilterPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextFilterPtr left, ImGuiTextFilter* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextFilterPtr left, ImGuiTextFilter* right) => left.Handle != right;

		public bool Equals(ImGuiTextFilterPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextFilterPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTextFilterPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public unsafe Span<byte> InputBuf
		
		{
			get
			{
				return new Span<byte>(&Handle->InputBuf_0, 256);
			}
		}
		public ref ImVectorImGuiTextRange Filters => ref Unsafe.AsRef<ImVectorImGuiTextRange>(&Handle->Filters);
		public ref int CountGrep => ref Unsafe.AsRef<int>(&Handle->CountGrep);

		public unsafe void Build()
		{
			ImGui.BuildNative(Handle);
		}

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool Draw(byte* label, float width)
		{
			byte ret = ImGui.DrawNative(Handle, label, width);
			return ret != 0;
		}

		public unsafe bool Draw(byte* label)
		{
			byte ret = ImGui.DrawNative(Handle, label, (float)(0.0f));
			return ret != 0;
		}

		public unsafe bool Draw()
		{
			bool ret = ImGui.Draw(Handle, (string)"Filter(inc,-exc)", (float)(0.0f));
			return ret;
		}

		public unsafe bool Draw(float width)
		{
			bool ret = ImGui.Draw(Handle, (string)"Filter(inc,-exc)", width);
			return ret;
		}

		public unsafe bool Draw(ref byte label, float width)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGui.DrawNative(Handle, (byte*)plabel, width);
				return ret != 0;
			}
		}

		public unsafe bool Draw(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGui.DrawNative(Handle, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}

		public unsafe bool Draw(string label, float width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.DrawNative(Handle, pStr0, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool Draw(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.DrawNative(Handle, pStr0, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool IsActive()
		{
			byte ret = ImGui.IsActiveNative(Handle);
			return ret != 0;
		}

		public unsafe bool PassFilter(byte* text, byte* textEnd)
		{
			byte ret = ImGui.PassFilterNative(Handle, text, textEnd);
			return ret != 0;
		}

		public unsafe bool PassFilter(byte* text)
		{
			byte ret = ImGui.PassFilterNative(Handle, text, (byte*)(default));
			return ret != 0;
		}

		public unsafe bool PassFilter(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, textEnd);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)(default));
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool PassFilter(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool PassFilter(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte ret = ImGui.PassFilterNative(Handle, text, (byte*)ptextEnd);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool PassFilter(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTextRange
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTextRange* Data;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorImGuiTextRangePtr : IEquatable<ImVectorImGuiTextRangePtr>
	{
		public ImVectorImGuiTextRangePtr(ImVectorImGuiTextRange* handle) { Handle = handle; }

		public ImVectorImGuiTextRange* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorImGuiTextRangePtr Null => new ImVectorImGuiTextRangePtr(null);

		public static implicit operator ImVectorImGuiTextRangePtr(ImVectorImGuiTextRange* handle) => new ImVectorImGuiTextRangePtr(handle);

		public static implicit operator ImVectorImGuiTextRange*(ImVectorImGuiTextRangePtr handle) => handle.Handle;

		public static bool operator ==(ImVectorImGuiTextRangePtr left, ImVectorImGuiTextRangePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorImGuiTextRangePtr left, ImVectorImGuiTextRangePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorImGuiTextRangePtr left, ImVectorImGuiTextRange* right) => left.Handle == right;

		public static bool operator !=(ImVectorImGuiTextRangePtr left, ImVectorImGuiTextRange* right) => left.Handle != right;

		public bool Equals(ImVectorImGuiTextRangePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorImGuiTextRangePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorImGuiTextRangePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public ref ImGuiTextRangePtr Data => ref Unsafe.AsRef<ImGuiTextRangePtr>(&Handle->Data);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextRange
	{
		public unsafe byte* B;
		public unsafe byte* E;


		public unsafe void Destroy()
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				byte ret = ImGui.emptyNative(@this);
				return ret != 0;
			}
		}

		public unsafe void split(byte separator, ImVectorImGuiTextRangePtr output)
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				ImGui.splitNative(@this, separator, output);
			}
		}

		public unsafe void split(byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				fixed (ImVectorImGuiTextRange* poutput = &output)
				{
					ImGui.splitNative(@this, separator, (ImVectorImGuiTextRange*)poutput);
				}
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTextRangePtr : IEquatable<ImGuiTextRangePtr>
	{
		public ImGuiTextRangePtr(ImGuiTextRange* handle) { Handle = handle; }

		public ImGuiTextRange* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextRangePtr Null => new ImGuiTextRangePtr(null);

		public static implicit operator ImGuiTextRangePtr(ImGuiTextRange* handle) => new ImGuiTextRangePtr(handle);

		public static implicit operator ImGuiTextRange*(ImGuiTextRangePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextRangePtr left, ImGuiTextRangePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextRangePtr left, ImGuiTextRangePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextRangePtr left, ImGuiTextRange* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextRangePtr left, ImGuiTextRange* right) => left.Handle != right;

		public bool Equals(ImGuiTextRangePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextRangePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTextRangePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public byte* B { get => Handle->B; set => Handle->B = value; }
		public byte* E { get => Handle->E; set => Handle->E = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool empty()
		{
			byte ret = ImGui.emptyNative(Handle);
			return ret != 0;
		}

		public unsafe void split(byte separator, ImVectorImGuiTextRangePtr output)
		{
			ImGui.splitNative(Handle, separator, output);
		}

		public unsafe void split(byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImVectorImGuiTextRange* poutput = &output)
			{
				ImGui.splitNative(Handle, separator, (ImVectorImGuiTextRange*)poutput);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImBitVector
	{
		public ImVectorImU32 Storage;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImBitVectorPtr : IEquatable<ImBitVectorPtr>
	{
		public ImBitVectorPtr(ImBitVector* handle) { Handle = handle; }

		public ImBitVector* Handle;

		public bool IsNull => Handle == null;

		public static ImBitVectorPtr Null => new ImBitVectorPtr(null);

		public static implicit operator ImBitVectorPtr(ImBitVector* handle) => new ImBitVectorPtr(handle);

		public static implicit operator ImBitVector*(ImBitVectorPtr handle) => handle.Handle;

		public static bool operator ==(ImBitVectorPtr left, ImBitVectorPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImBitVectorPtr left, ImBitVectorPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImBitVectorPtr left, ImBitVector* right) => left.Handle == right;

		public static bool operator !=(ImBitVectorPtr left, ImBitVector* right) => left.Handle != right;

		public bool Equals(ImBitVectorPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImBitVectorPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImBitVectorPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImU32 Storage => ref Unsafe.AsRef<ImVectorImU32>(&Handle->Storage);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataVarInfo
	{
		public ImGuiDataType Type;
		public uint Count;
		public uint Offset;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDataVarInfoPtr : IEquatable<ImGuiDataVarInfoPtr>
	{
		public ImGuiDataVarInfoPtr(ImGuiDataVarInfo* handle) { Handle = handle; }

		public ImGuiDataVarInfo* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDataVarInfoPtr Null => new ImGuiDataVarInfoPtr(null);

		public static implicit operator ImGuiDataVarInfoPtr(ImGuiDataVarInfo* handle) => new ImGuiDataVarInfoPtr(handle);

		public static implicit operator ImGuiDataVarInfo*(ImGuiDataVarInfoPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDataVarInfoPtr left, ImGuiDataVarInfoPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDataVarInfoPtr left, ImGuiDataVarInfoPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDataVarInfoPtr left, ImGuiDataVarInfo* right) => left.Handle == right;

		public static bool operator !=(ImGuiDataVarInfoPtr left, ImGuiDataVarInfo* right) => left.Handle != right;

		public bool Equals(ImGuiDataVarInfoPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDataVarInfoPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDataVarInfoPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiDataType Type => ref Unsafe.AsRef<ImGuiDataType>(&Handle->Type);
		public ref uint Count => ref Unsafe.AsRef<uint>(&Handle->Count);
		public ref uint Offset => ref Unsafe.AsRef<uint>(&Handle->Offset);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataTypeInfo
	{
		public nuint Size;
		public unsafe byte* Name;
		public unsafe byte* PrintFmt;
		public unsafe byte* ScanFmt;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDataTypeInfoPtr : IEquatable<ImGuiDataTypeInfoPtr>
	{
		public ImGuiDataTypeInfoPtr(ImGuiDataTypeInfo* handle) { Handle = handle; }

		public ImGuiDataTypeInfo* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDataTypeInfoPtr Null => new ImGuiDataTypeInfoPtr(null);

		public static implicit operator ImGuiDataTypeInfoPtr(ImGuiDataTypeInfo* handle) => new ImGuiDataTypeInfoPtr(handle);

		public static implicit operator ImGuiDataTypeInfo*(ImGuiDataTypeInfoPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDataTypeInfoPtr left, ImGuiDataTypeInfoPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDataTypeInfoPtr left, ImGuiDataTypeInfoPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDataTypeInfoPtr left, ImGuiDataTypeInfo* right) => left.Handle == right;

		public static bool operator !=(ImGuiDataTypeInfoPtr left, ImGuiDataTypeInfo* right) => left.Handle != right;

		public bool Equals(ImGuiDataTypeInfoPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDataTypeInfoPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDataTypeInfoPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref nuint Size => ref Unsafe.AsRef<nuint>(&Handle->Size);
		public byte* Name { get => Handle->Name; set => Handle->Name = value; }
		public byte* PrintFmt { get => Handle->PrintFmt; set => Handle->PrintFmt = value; }
		public byte* ScanFmt { get => Handle->ScanFmt; set => Handle->ScanFmt = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextDeactivateData
	{

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLocEntry
	{
		public ImGuiLocKey Key;
		public unsafe byte* Text;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiLocEntryPtr : IEquatable<ImGuiLocEntryPtr>
	{
		public ImGuiLocEntryPtr(ImGuiLocEntry* handle) { Handle = handle; }

		public ImGuiLocEntry* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiLocEntryPtr Null => new ImGuiLocEntryPtr(null);

		public static implicit operator ImGuiLocEntryPtr(ImGuiLocEntry* handle) => new ImGuiLocEntryPtr(handle);

		public static implicit operator ImGuiLocEntry*(ImGuiLocEntryPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiLocEntryPtr left, ImGuiLocEntryPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiLocEntryPtr left, ImGuiLocEntryPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiLocEntryPtr left, ImGuiLocEntry* right) => left.Handle == right;

		public static bool operator !=(ImGuiLocEntryPtr left, ImGuiLocEntry* right) => left.Handle != right;

		public bool Equals(ImGuiLocEntryPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiLocEntryPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiLocEntryPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiLocKey Key => ref Unsafe.AsRef<ImGuiLocKey>(&Handle->Key);
		public byte* Text { get => Handle->Text; set => Handle->Text = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableSettings
	{
		public int ID;
		public ImGuiTableFlags SaveFlags;
		public float RefScale;
		public sbyte ColumnsCount;
		public sbyte ColumnsCountMax;
		public byte WantApply;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableSettingsPtr : IEquatable<ImGuiTableSettingsPtr>
	{
		public ImGuiTableSettingsPtr(ImGuiTableSettings* handle) { Handle = handle; }

		public ImGuiTableSettings* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableSettingsPtr Null => new ImGuiTableSettingsPtr(null);

		public static implicit operator ImGuiTableSettingsPtr(ImGuiTableSettings* handle) => new ImGuiTableSettingsPtr(handle);

		public static implicit operator ImGuiTableSettings*(ImGuiTableSettingsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableSettingsPtr left, ImGuiTableSettingsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableSettingsPtr left, ImGuiTableSettingsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableSettingsPtr left, ImGuiTableSettings* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableSettingsPtr left, ImGuiTableSettings* right) => left.Handle != right;

		public bool Equals(ImGuiTableSettingsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableSettingsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableSettingsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiTableFlags SaveFlags => ref Unsafe.AsRef<ImGuiTableFlags>(&Handle->SaveFlags);
		public ref float RefScale => ref Unsafe.AsRef<float>(&Handle->RefScale);
		public ref sbyte ColumnsCount => ref Unsafe.AsRef<sbyte>(&Handle->ColumnsCount);
		public ref sbyte ColumnsCountMax => ref Unsafe.AsRef<sbyte>(&Handle->ColumnsCountMax);
		public ref bool WantApply => ref Unsafe.AsRef<bool>(&Handle->WantApply);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnsSettings
	{

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowSettings
	{
		public int ID;
		public ImVec2ih Pos;
		public ImVec2ih Size;
		public ImVec2ih ViewportPos;
		public int ViewportId;
		public int DockId;
		public int ClassId;
		public short DockOrder;
		public byte Collapsed;
		public byte WantApply;
		public byte WantDelete;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowSettingsPtr : IEquatable<ImGuiWindowSettingsPtr>
	{
		public ImGuiWindowSettingsPtr(ImGuiWindowSettings* handle) { Handle = handle; }

		public ImGuiWindowSettings* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowSettingsPtr Null => new ImGuiWindowSettingsPtr(null);

		public static implicit operator ImGuiWindowSettingsPtr(ImGuiWindowSettings* handle) => new ImGuiWindowSettingsPtr(handle);

		public static implicit operator ImGuiWindowSettings*(ImGuiWindowSettingsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowSettingsPtr left, ImGuiWindowSettingsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowSettingsPtr left, ImGuiWindowSettingsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowSettingsPtr left, ImGuiWindowSettings* right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowSettingsPtr left, ImGuiWindowSettings* right) => left.Handle != right;

		public bool Equals(ImGuiWindowSettingsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowSettingsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowSettingsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImVec2ih Pos => ref Unsafe.AsRef<ImVec2ih>(&Handle->Pos);
		public ref ImVec2ih Size => ref Unsafe.AsRef<ImVec2ih>(&Handle->Size);
		public ref ImVec2ih ViewportPos => ref Unsafe.AsRef<ImVec2ih>(&Handle->ViewportPos);
		public ref int ViewportId => ref Unsafe.AsRef<int>(&Handle->ViewportId);
		public ref int DockId => ref Unsafe.AsRef<int>(&Handle->DockId);
		public ref int ClassId => ref Unsafe.AsRef<int>(&Handle->ClassId);
		public ref short DockOrder => ref Unsafe.AsRef<short>(&Handle->DockOrder);
		public ref bool Collapsed => ref Unsafe.AsRef<bool>(&Handle->Collapsed);
		public ref bool WantApply => ref Unsafe.AsRef<bool>(&Handle->WantApply);
		public ref bool WantDelete => ref Unsafe.AsRef<bool>(&Handle->WantDelete);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorConstCharPtr
	{
		public int Size;
		public int Capacity;
		public unsafe byte** Data;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorConstCharPtrPtr : IEquatable<ImVectorConstCharPtrPtr>
	{
		public ImVectorConstCharPtrPtr(ImVectorConstCharPtr* handle) { Handle = handle; }

		public ImVectorConstCharPtr* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorConstCharPtrPtr Null => new ImVectorConstCharPtrPtr(null);

		public static implicit operator ImVectorConstCharPtrPtr(ImVectorConstCharPtr* handle) => new ImVectorConstCharPtrPtr(handle);

		public static implicit operator ImVectorConstCharPtr*(ImVectorConstCharPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImVectorConstCharPtrPtr left, ImVectorConstCharPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorConstCharPtrPtr left, ImVectorConstCharPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorConstCharPtrPtr left, ImVectorConstCharPtr* right) => left.Handle == right;

		public static bool operator !=(ImVectorConstCharPtrPtr left, ImVectorConstCharPtr* right) => left.Handle != right;

		public bool Equals(ImVectorConstCharPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorConstCharPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorConstCharPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public byte** Data { get => Handle->Data; set => Handle->Data = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbTexteditRow
	{
		public float X0;
		public float X1;
		public float BaselineYDelta;
		public float Ymin;
		public float Ymax;
		public int NumChars;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataTypeTempStorage
	{
		public byte Data_0;
		public byte Data_1;
		public byte Data_2;
		public byte Data_3;
		public byte Data_4;
		public byte Data_5;
		public byte Data_6;
		public byte Data_7;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImBitArrayImGuiKeyNamedKeyCOUNTLessImGuiKeyNamedKeyBEGIN
	{
		public uint Storage_0;
		public uint Storage_1;
		public uint Storage_2;
		public uint Storage_3;
		public uint Storage_4;

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnSettings
	{
		public float WidthOrWeight;
		public int UserID;
		public sbyte Index;
		public sbyte DisplayOrder;
		public sbyte SortOrder;
		public byte SortDirection;
		public byte IsEnabled;
		public byte IsStretch;

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableColumnSettingsPtr : IEquatable<ImGuiTableColumnSettingsPtr>
	{
		public ImGuiTableColumnSettingsPtr(ImGuiTableColumnSettings* handle) { Handle = handle; }

		public ImGuiTableColumnSettings* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableColumnSettingsPtr Null => new ImGuiTableColumnSettingsPtr(null);

		public static implicit operator ImGuiTableColumnSettingsPtr(ImGuiTableColumnSettings* handle) => new ImGuiTableColumnSettingsPtr(handle);

		public static implicit operator ImGuiTableColumnSettings*(ImGuiTableColumnSettingsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableColumnSettingsPtr left, ImGuiTableColumnSettingsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableColumnSettingsPtr left, ImGuiTableColumnSettingsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableColumnSettingsPtr left, ImGuiTableColumnSettings* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableColumnSettingsPtr left, ImGuiTableColumnSettings* right) => left.Handle != right;

		public bool Equals(ImGuiTableColumnSettingsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableColumnSettingsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableColumnSettingsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref float WidthOrWeight => ref Unsafe.AsRef<float>(&Handle->WidthOrWeight);
		public ref int UserID => ref Unsafe.AsRef<int>(&Handle->UserID);
		public ref sbyte Index => ref Unsafe.AsRef<sbyte>(&Handle->Index);
		public ref sbyte DisplayOrder => ref Unsafe.AsRef<sbyte>(&Handle->DisplayOrder);
		public ref sbyte SortOrder => ref Unsafe.AsRef<sbyte>(&Handle->SortOrder);
		public ref byte SortDirection => ref Unsafe.AsRef<byte>(&Handle->SortDirection);
		public ref byte IsEnabled => ref Unsafe.AsRef<byte>(&Handle->IsEnabled);
		public ref byte IsStretch => ref Unsafe.AsRef<byte>(&Handle->IsStretch);
	}

}
