// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

namespace HexaEngine.ImGui
{
	public unsafe partial class ImGui
	{
		internal const string LibName = "cimgui";

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2_ImVec2_Nil")]
		public static extern Vector2* ImVec2();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2_destroy")]
		public static extern void Destroy(Vector2* self);

		public static void Destroy(ref Vector2 self)
		{
			fixed (Vector2* pself = &self)
			{
				Destroy((Vector2*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2_ImVec2_Float")]
		public static extern Vector2* ImVec2(float x, float y);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec4_ImVec4_Nil")]
		public static extern Vector4* ImVec4();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec4_destroy")]
		public static extern void Destroy(Vector4* self);

		public static void Destroy(ref Vector4 self)
		{
			fixed (Vector4* pself = &self)
			{
				Destroy((Vector4*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec4_ImVec4_Float")]
		public static extern Vector4* ImVec4(float x, float y, float z, float w);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCreateContext")]
		public static extern ImGuiContext* CreateContext(ImFontAtlas* sharedFontAtlas);

		public static ImGuiContext* CreateContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContext* ret = CreateContext((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDestroyContext")]
		public static extern void DestroyContext(ImGuiContext* ctx);

		public static void DestroyContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DestroyContext((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentContext")]
		public static extern ImGuiContext* GetCurrentContext();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCurrentContext")]
		public static extern void SetCurrentContext(ImGuiContext* ctx);

		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetCurrentContext((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetIO")]
		public static extern ImGuiIO* GetIO();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStyle")]
		public static extern ImGuiStyle* GetStyle();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNewFrame")]
		public static extern void NewFrame();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndFrame")]
		public static extern void EndFrame();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRender")]
		public static extern void Render();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetDrawData")]
		public static extern ImDrawData* GetDrawData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowDemoWindow")]
		public static extern void ShowDemoWindow(bool* pOpen);

		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDemoWindow((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowMetricsWindow")]
		public static extern void ShowMetricsWindow(bool* pOpen);

		public static void ShowMetricsWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowMetricsWindow((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowDebugLogWindow")]
		public static extern void ShowDebugLogWindow(bool* pOpen);

		public static void ShowDebugLogWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDebugLogWindow((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowStackToolWindow")]
		public static extern void ShowStackToolWindow(bool* pOpen);

		public static void ShowStackToolWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowStackToolWindow((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowAboutWindow")]
		public static extern void ShowAboutWindow(bool* pOpen);

		public static void ShowAboutWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowAboutWindow((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowStyleEditor")]
		public static extern void ShowStyleEditor(ImGuiStyle* reference);

		public static void ShowStyleEditor(ref ImGuiStyle reference)
		{
			fixed (ImGuiStyle* preference = &reference)
			{
				ShowStyleEditor((ImGuiStyle*)preference);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowStyleSelector")]
		public static extern bool ShowStyleSelector(byte* label);

		public static bool ShowStyleSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ShowStyleSelector((byte*)plabel);
				return ret;
			}
		}

		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ShowStyleSelector(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowFontSelector")]
		public static extern void ShowFontSelector(byte* label);

		public static void ShowFontSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ShowFontSelector((byte*)plabel);
			}
		}

		public static void ShowFontSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowFontSelector(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowUserGuide")]
		public static extern void ShowUserGuide();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetVersion")]
		public static extern byte* GetVersion();

		public static string GetVersionS()
		{
			string ret = Marshal.PtrToStringAnsi((nint)GetVersion());
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStyleColorsDark")]
		public static extern void StyleColorsDark(ImGuiStyle* dst);

		public static void StyleColorsDark(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsDark((ImGuiStyle*)pdst);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStyleColorsLight")]
		public static extern void StyleColorsLight(ImGuiStyle* dst);

		public static void StyleColorsLight(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsLight((ImGuiStyle*)pdst);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStyleColorsClassic")]
		public static extern void StyleColorsClassic(ImGuiStyle* dst);

		public static void StyleColorsClassic(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsClassic((ImGuiStyle*)pdst);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBegin")]
		public static extern bool Begin(byte* name, bool* pOpen, ImGuiWindowFlags flags);

		public static bool Begin(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				bool ret = Begin((byte*)pname, (bool*)(null), (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool Begin(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				bool ret = Begin((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool Begin(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				bool ret = Begin((byte*)pname, pOpen, flags);
				return ret;
			}
		}

		public static bool Begin(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Begin(pStr0, (bool*)(null), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Begin(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Begin(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Begin(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Begin(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Begin(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = Begin(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool Begin(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = Begin(name, (bool*)ppOpen, flags);
				return ret;
			}
		}

		public static bool Begin(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = Begin((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret;
				}
			}
		}

		public static bool Begin(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = Begin((byte*)pname, (bool*)ppOpen, flags);
					return ret;
				}
			}
		}

		public static bool Begin(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = Begin(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Begin(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = Begin(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEnd")]
		public static extern void End();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginChild_Str")]
		public static extern bool BeginChild(byte* strId, Vector2 size, bool border, ImGuiWindowFlags flags);

		public static bool BeginChild(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginChild((byte*)pstrId, new Vector2(0,0), false, (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginChild((byte*)pstrId, size, false, (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size, bool border)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginChild((byte*)pstrId, size, border, (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginChild((byte*)pstrId, size, border, flags);
				return ret;
			}
		}

		public static bool BeginChild(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginChild(pStr0, new Vector2(0,0), false, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginChild(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginChild(pStr0, size, false, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginChild(string strId, Vector2 size, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginChild(pStr0, size, border, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginChild(string strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginChild(pStr0, size, border, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginChild_ID")]
		public static extern bool BeginChild(int id, Vector2 size, bool border, ImGuiWindowFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndChild")]
		public static extern void EndChild();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowAppearing")]
		public static extern bool IsWindowAppearing();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowCollapsed")]
		public static extern bool IsWindowCollapsed();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowFocused")]
		public static extern bool IsWindowFocused(ImGuiFocusedFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowHovered")]
		public static extern bool IsWindowHovered(ImGuiHoveredFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowDrawList")]
		public static extern ImDrawList* GetWindowDrawList();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowDpiScale")]
		public static extern float GetWindowDpiScale();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowPos")]
		public static extern void GetWindowPos(Vector2* output);

		public static void GetWindowPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowPos((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowSize")]
		public static extern void GetWindowSize(Vector2* output);

		public static void GetWindowSize(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowSize((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowWidth")]
		public static extern float GetWindowWidth();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowHeight")]
		public static extern float GetWindowHeight();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowViewport")]
		public static extern ImGuiViewport* GetWindowViewport();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowPos")]
		public static extern void SetNextWindowPos(Vector2 pos, ImGuiCond cond, Vector2 pivot);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowSize")]
		public static extern void SetNextWindowSize(Vector2 size, ImGuiCond cond);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowSizeConstraints")]
		public static extern void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, delegate*<ImGuiSizeCallbackData*> customCallback, void* customCallbackData);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowContentSize")]
		public static extern void SetNextWindowContentSize(Vector2 size);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowCollapsed")]
		public static extern void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowFocus")]
		public static extern void SetNextWindowFocus();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowScroll")]
		public static extern void SetNextWindowScroll(Vector2 scroll);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowBgAlpha")]
		public static extern void SetNextWindowBgAlpha(float alpha);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowViewport")]
		public static extern void SetNextWindowViewport(int viewportId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowPos_Vec2")]
		public static extern void SetWindowPos(Vector2 pos, ImGuiCond cond);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowSize_Vec2")]
		public static extern void SetWindowSize(Vector2 size, ImGuiCond cond);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowCollapsed_Bool")]
		public static extern void SetWindowCollapsed(bool collapsed, ImGuiCond cond);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowFocus_Nil")]
		public static extern void SetWindowFocus();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowFontScale")]
		public static extern void SetWindowFontScale(float scale);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowPos_Str")]
		public static extern void SetWindowPos(byte* name, Vector2 pos, ImGuiCond cond);

		public static void SetWindowPos(ref byte name, Vector2 pos)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPos((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		public static void SetWindowPos(ref byte name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPos((byte*)pname, pos, cond);
			}
		}

		public static void SetWindowPos(string name, Vector2 pos)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPos(pStr0, pos, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowPos(string name, Vector2 pos, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPos(pStr0, pos, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowSize_Str")]
		public static extern void SetWindowSize(byte* name, Vector2 size, ImGuiCond cond);

		public static void SetWindowSize(ref byte name, Vector2 size)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSize((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		public static void SetWindowSize(ref byte name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSize((byte*)pname, size, cond);
			}
		}

		public static void SetWindowSize(string name, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSize(pStr0, size, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowSize(string name, Vector2 size, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSize(pStr0, size, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowCollapsed_Str")]
		public static extern void SetWindowCollapsed(byte* name, bool collapsed, ImGuiCond cond);

		public static void SetWindowCollapsed(ref byte name, bool collapsed)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsed((byte*)pname, collapsed, (ImGuiCond)(0));
			}
		}

		public static void SetWindowCollapsed(ref byte name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsed((byte*)pname, collapsed, cond);
			}
		}

		public static void SetWindowCollapsed(string name, bool collapsed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsed(pStr0, collapsed, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowCollapsed(string name, bool collapsed, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsed(pStr0, collapsed, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowFocus_Str")]
		public static extern void SetWindowFocus(byte* name);

		public static void SetWindowFocus(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SetWindowFocus((byte*)pname);
			}
		}

		public static void SetWindowFocus(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowFocus(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetContentRegionAvail")]
		public static extern void GetContentRegionAvail(Vector2* output);

		public static void GetContentRegionAvail(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionAvail((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetContentRegionMax")]
		public static extern void GetContentRegionMax(Vector2* output);

		public static void GetContentRegionMax(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionMax((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowContentRegionMin")]
		public static extern void GetWindowContentRegionMin(Vector2* output);

		public static void GetWindowContentRegionMin(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowContentRegionMin((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowContentRegionMax")]
		public static extern void GetWindowContentRegionMax(Vector2* output);

		public static void GetWindowContentRegionMax(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowContentRegionMax((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetScrollX")]
		public static extern float GetScrollX();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetScrollY")]
		public static extern float GetScrollY();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollX_Float")]
		public static extern void SetScrollX(float scrollX);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollY_Float")]
		public static extern void SetScrollY(float scrollY);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetScrollMaxX")]
		public static extern float GetScrollMaxX();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetScrollMaxY")]
		public static extern float GetScrollMaxY();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollHereX")]
		public static extern void SetScrollHereX(float centerXRatio);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollHereY")]
		public static extern void SetScrollHereY(float centerYRatio);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollFromPosX_Float")]
		public static extern void SetScrollFromPosX(float localX, float centerXRatio);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollFromPosY_Float")]
		public static extern void SetScrollFromPosY(float localY, float centerYRatio);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushFont")]
		public static extern void PushFont(ImFont* font);

		public static void PushFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				PushFont((ImFont*)pfont);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopFont")]
		public static extern void PopFont();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushStyleColor_U32")]
		public static extern void PushStyleColor(ImGuiCol idx, uint col);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushStyleColor_Vec4")]
		public static extern void PushStyleColor(ImGuiCol idx, Vector4 col);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopStyleColor")]
		public static extern void PopStyleColor(int count);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushStyleVar_Float")]
		public static extern void PushStyleVar(ImGuiStyleVar idx, float val);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushStyleVar_Vec2")]
		public static extern void PushStyleVar(ImGuiStyleVar idx, Vector2 val);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopStyleVar")]
		public static extern void PopStyleVar(int count);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushTabStop")]
		public static extern void PushTabStop(bool tabStop);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopTabStop")]
		public static extern void PopTabStop();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushButtonRepeat")]
		public static extern void PushButtonRepeat(bool repeat);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopButtonRepeat")]
		public static extern void PopButtonRepeat();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushItemWidth")]
		public static extern void PushItemWidth(float itemWidth);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopItemWidth")]
		public static extern void PopItemWidth();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextItemWidth")]
		public static extern void SetNextItemWidth(float itemWidth);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcItemWidth")]
		public static extern float CalcItemWidth();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushTextWrapPos")]
		public static extern void PushTextWrapPos(float wrapLocalPosX);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopTextWrapPos")]
		public static extern void PopTextWrapPos();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFont")]
		public static extern ImFont* GetFont();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFontSize")]
		public static extern float GetFontSize();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFontTexUvWhitePixel")]
		public static extern void GetFontTexUvWhitePixel(Vector2* output);

		public static void GetFontTexUvWhitePixel(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetFontTexUvWhitePixel((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColorU32_Col")]
		public static extern uint GetColorU32(ImGuiCol idx, float alphaMul);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColorU32_Vec4")]
		public static extern uint GetColorU32(Vector4 col);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColorU32_U32")]
		public static extern uint GetColorU32(uint col);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStyleColorVec4")]
		public static extern Vector4* GetStyleColorVec4(ImGuiCol idx);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSeparator")]
		public static extern void Separator();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSameLine")]
		public static extern void SameLine(float offsetFromStartX, float spacing);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNewLine")]
		public static extern void NewLine();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSpacing")]
		public static extern void Spacing();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDummy")]
		public static extern void Dummy(Vector2 size);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIndent")]
		public static extern void Indent(float indentW);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUnindent")]
		public static extern void Unindent(float indentW);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginGroup")]
		public static extern void BeginGroup();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndGroup")]
		public static extern void EndGroup();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorPos")]
		public static extern void GetCursorPos(Vector2* output);

		public static void GetCursorPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorPos((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorPosX")]
		public static extern float GetCursorPosX();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorPosY")]
		public static extern float GetCursorPosY();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCursorPos")]
		public static extern void SetCursorPos(Vector2 localPos);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCursorPosX")]
		public static extern void SetCursorPosX(float localX);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCursorPosY")]
		public static extern void SetCursorPosY(float localY);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorStartPos")]
		public static extern void GetCursorStartPos(Vector2* output);

		public static void GetCursorStartPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorStartPos((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorScreenPos")]
		public static extern void GetCursorScreenPos(Vector2* output);

		public static void GetCursorScreenPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorScreenPos((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCursorScreenPos")]
		public static extern void SetCursorScreenPos(Vector2 pos);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igAlignTextToFramePadding")]
		public static extern void AlignTextToFramePadding();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTextLineHeight")]
		public static extern float GetTextLineHeight();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTextLineHeightWithSpacing")]
		public static extern float GetTextLineHeightWithSpacing();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFrameHeight")]
		public static extern float GetFrameHeight();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFrameHeightWithSpacing")]
		public static extern float GetFrameHeightWithSpacing();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushID_Str")]
		public static extern void PushID(byte* strId);

		public static void PushID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				PushID((byte*)pstrId);
			}
		}

		public static void PushID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushID(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushID_StrStr")]
		public static extern void PushID(byte* strIdBegin, byte* strIdEnd);

		public static void PushID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				PushID((byte*)pstrIdBegin, strIdEnd);
			}
		}

		public static void PushID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushID(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushID(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		public static void PushID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushID(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					PushID((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		public static void PushID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PushID(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushID_Ptr")]
		public static extern void PushID(void* ptrId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushID_Int")]
		public static extern void PushID(int intId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopID")]
		public static extern void PopID();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetID_Str")]
		public static extern int GetID(byte* strId);

		public static int GetID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				int ret = GetID((byte*)pstrId);
				return ret;
			}
		}

		public static int GetID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetID(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetID_StrStr")]
		public static extern int GetID(byte* strIdBegin, byte* strIdEnd);

		public static int GetID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				int ret = GetID((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		public static int GetID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetID(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				int ret = GetID(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		public static int GetID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetID(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					int ret = GetID((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		public static int GetID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = GetID(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetID_Ptr")]
		public static extern int GetID(void* ptrId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextUnformatted")]
		public static extern void TextUnformatted(byte* text, byte* textEnd);

		public static void TextUnformatted(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				TextUnformatted((byte*)ptext, (string)null);
			}
		}

		public static void TextUnformatted(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				TextUnformatted((byte*)ptext, textEnd);
			}
		}

		public static void TextUnformatted(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformatted(pStr0, (string)null);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformatted(pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				TextUnformatted(text, (byte*)ptextEnd);
			}
		}

		public static void TextUnformatted(byte* text)
		{
			TextUnformatted(text, (string)null);
		}

		public static void TextUnformatted(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformatted(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					TextUnformatted((byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void TextUnformatted(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			TextUnformatted(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igText")]
		public static extern void Text(byte* fmt);

		public static void Text(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				Text((byte*)pfmt);
			}
		}

		public static void Text(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Text(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextV")]
		public static extern void TextV(byte* fmt, nuint args);

		public static void TextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextV((byte*)pfmt, args);
			}
		}

		public static void TextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextV(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextColored")]
		public static extern void TextColored(Vector4 col, byte* fmt);

		public static void TextColored(Vector4 col, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColored(col, (byte*)pfmt);
			}
		}

		public static void TextColored(Vector4 col, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColored(col, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextColoredV")]
		public static extern void TextColoredV(Vector4 col, byte* fmt, nuint args);

		public static void TextColoredV(Vector4 col, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredV(col, (byte*)pfmt, args);
			}
		}

		public static void TextColoredV(Vector4 col, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredV(col, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextDisabled")]
		public static extern void TextDisabled(byte* fmt);

		public static void TextDisabled(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextDisabled((byte*)pfmt);
			}
		}

		public static void TextDisabled(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextDisabled(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextDisabledV")]
		public static extern void TextDisabledV(byte* fmt, nuint args);

		public static void TextDisabledV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextDisabledV((byte*)pfmt, args);
			}
		}

		public static void TextDisabledV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextDisabledV(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextWrapped")]
		public static extern void TextWrapped(byte* fmt);

		public static void TextWrapped(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextWrapped((byte*)pfmt);
			}
		}

		public static void TextWrapped(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextWrapped(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextWrappedV")]
		public static extern void TextWrappedV(byte* fmt, nuint args);

		public static void TextWrappedV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextWrappedV((byte*)pfmt, args);
			}
		}

		public static void TextWrappedV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextWrappedV(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLabelText")]
		public static extern void LabelText(byte* label, byte* fmt);

		public static void LabelText(ref byte label, byte* fmt)
		{
			fixed (byte* plabel = &label)
			{
				LabelText((byte*)plabel, fmt);
			}
		}

		public static void LabelText(string label, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelText(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(byte* label, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelText(label, (byte*)pfmt);
			}
		}

		public static void LabelText(byte* label, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelText(label, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(ref byte label, ref byte fmt)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pfmt = &fmt)
				{
					LabelText((byte*)plabel, (byte*)pfmt);
				}
			}
		}

		public static void LabelText(string label, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LabelText(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLabelTextV")]
		public static extern void LabelTextV(byte* label, byte* fmt, nuint args);

		public static void LabelTextV(ref byte label, byte* fmt, nuint args)
		{
			fixed (byte* plabel = &label)
			{
				LabelTextV((byte*)plabel, fmt, args);
			}
		}

		public static void LabelTextV(string label, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextV(pStr0, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(byte* label, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextV(label, (byte*)pfmt, args);
			}
		}

		public static void LabelTextV(byte* label, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextV(label, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(ref byte label, ref byte fmt, nuint args)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pfmt = &fmt)
				{
					LabelTextV((byte*)plabel, (byte*)pfmt, args);
				}
			}
		}

		public static void LabelTextV(string label, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LabelTextV(pStr0, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBulletText")]
		public static extern void BulletText(byte* fmt);

		public static void BulletText(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				BulletText((byte*)pfmt);
			}
		}

		public static void BulletText(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BulletText(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBulletTextV")]
		public static extern void BulletTextV(byte* fmt, nuint args);

		public static void BulletTextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				BulletTextV((byte*)pfmt, args);
			}
		}

		public static void BulletTextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BulletTextV(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSeparatorText")]
		public static extern void SeparatorText(byte* label);

		public static void SeparatorText(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				SeparatorText((byte*)plabel);
			}
		}

		public static void SeparatorText(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SeparatorText(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igButton")]
		public static extern bool Button(byte* label, Vector2 size);

		public static bool Button(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Button((byte*)plabel, new Vector2(0,0));
				return ret;
			}
		}

		public static bool Button(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Button((byte*)plabel, size);
				return ret;
			}
		}

		public static bool Button(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Button(pStr0, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Button(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Button(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSmallButton")]
		public static extern bool SmallButton(byte* label);

		public static bool SmallButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SmallButton((byte*)plabel);
				return ret;
			}
		}

		public static bool SmallButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SmallButton(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInvisibleButton")]
		public static extern bool InvisibleButton(byte* strId, Vector2 size, ImGuiButtonFlags flags);

		public static bool InvisibleButton(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = InvisibleButton((byte*)pstrId, size, (ImGuiButtonFlags)(0));
				return ret;
			}
		}

		public static bool InvisibleButton(ref byte strId, Vector2 size, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = InvisibleButton((byte*)pstrId, size, flags);
				return ret;
			}
		}

		public static bool InvisibleButton(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InvisibleButton(pStr0, size, (ImGuiButtonFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InvisibleButton(string strId, Vector2 size, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InvisibleButton(pStr0, size, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igArrowButton")]
		public static extern bool ArrowButton(byte* strId, ImGuiDir dir);

		public static bool ArrowButton(ref byte strId, ImGuiDir dir)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = ArrowButton((byte*)pstrId, dir);
				return ret;
			}
		}

		public static bool ArrowButton(string strId, ImGuiDir dir)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ArrowButton(pStr0, dir);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckbox")]
		public static extern bool Checkbox(byte* label, bool* v);

		public static bool Checkbox(ref byte label, bool* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Checkbox((byte*)plabel, v);
				return ret;
			}
		}

		public static bool Checkbox(string label, bool* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Checkbox(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Checkbox(byte* label, ref bool v)
		{
			fixed (bool* pv = &v)
			{
				bool ret = Checkbox(label, (bool*)pv);
				return ret;
			}
		}

		public static bool Checkbox(ref byte label, ref bool v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* pv = &v)
				{
					bool ret = Checkbox((byte*)plabel, (bool*)pv);
					return ret;
				}
			}
		}

		public static bool Checkbox(string label, ref bool v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* pv = &v)
			{
				bool ret = Checkbox(pStr0, (bool*)pv);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckboxFlags_IntPtr")]
		public static extern bool CheckboxFlags(byte* label, int* flags, int flagsValue);

		public static bool CheckboxFlags(ref byte label, int* flags, int flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret;
			}
		}

		public static bool CheckboxFlags(string label, int* flags, int flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = CheckboxFlags(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool CheckboxFlags(byte* label, ref int flags, int flagsValue)
		{
			fixed (int* pflags = &flags)
			{
				bool ret = CheckboxFlags(label, (int*)pflags, flagsValue);
				return ret;
			}
		}

		public static bool CheckboxFlags(ref byte label, ref int flags, int flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pflags = &flags)
				{
					bool ret = CheckboxFlags((byte*)plabel, (int*)pflags, flagsValue);
					return ret;
				}
			}
		}

		public static bool CheckboxFlags(string label, ref int flags, int flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pflags = &flags)
			{
				bool ret = CheckboxFlags(pStr0, (int*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckboxFlags_UintPtr")]
		public static extern bool CheckboxFlags(byte* label, uint* flags, uint flagsValue);

		public static bool CheckboxFlags(ref byte label, uint* flags, uint flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret;
			}
		}

		public static bool CheckboxFlags(string label, uint* flags, uint flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = CheckboxFlags(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool CheckboxFlags(byte* label, ref uint flags, uint flagsValue)
		{
			fixed (uint* pflags = &flags)
			{
				bool ret = CheckboxFlags(label, (uint*)pflags, flagsValue);
				return ret;
			}
		}

		public static bool CheckboxFlags(ref byte label, ref uint flags, uint flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (uint* pflags = &flags)
				{
					bool ret = CheckboxFlags((byte*)plabel, (uint*)pflags, flagsValue);
					return ret;
				}
			}
		}

		public static bool CheckboxFlags(string label, ref uint flags, uint flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* pflags = &flags)
			{
				bool ret = CheckboxFlags(pStr0, (uint*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRadioButton_Bool")]
		public static extern bool RadioButton(byte* label, bool active);

		public static bool RadioButton(ref byte label, bool active)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = RadioButton((byte*)plabel, active);
				return ret;
			}
		}

		public static bool RadioButton(string label, bool active)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = RadioButton(pStr0, active);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRadioButton_IntPtr")]
		public static extern bool RadioButton(byte* label, int* v, int vButton);

		public static bool RadioButton(ref byte label, int* v, int vButton)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = RadioButton((byte*)plabel, v, vButton);
				return ret;
			}
		}

		public static bool RadioButton(string label, int* v, int vButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = RadioButton(pStr0, v, vButton);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool RadioButton(byte* label, ref int v, int vButton)
		{
			fixed (int* pv = &v)
			{
				bool ret = RadioButton(label, (int*)pv, vButton);
				return ret;
			}
		}

		public static bool RadioButton(ref byte label, ref int v, int vButton)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = RadioButton((byte*)plabel, (int*)pv, vButton);
					return ret;
				}
			}
		}

		public static bool RadioButton(string label, ref int v, int vButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = RadioButton(pStr0, (int*)pv, vButton);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igProgressBar")]
		public static extern void ProgressBar(float fraction, Vector2 sizeArg, byte* overlay);

		public static void ProgressBar(float fraction, Vector2 sizeArg, ref byte overlay)
		{
			fixed (byte* poverlay = &overlay)
			{
				ProgressBar(fraction, sizeArg, (byte*)poverlay);
			}
		}

		public static void ProgressBar(float fraction)
		{
			ProgressBar(fraction, new Vector2(-float.MinValue,0), (string)null);
		}

		public static void ProgressBar(float fraction, Vector2 sizeArg)
		{
			ProgressBar(fraction, sizeArg, (string)null);
		}

		public static void ProgressBar(float fraction, Vector2 sizeArg, string overlay)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlay != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlay);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlay, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgressBar(fraction, sizeArg, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBullet")]
		public static extern void Bullet();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImage")]
		public static extern void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 tintCol, Vector4 borderCol);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImageButton")]
		public static extern bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol);

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = ImageButton((byte*)pstrId, userTextureId, size, new Vector2(0,0), new Vector2(1,1), new Vector4(0,0,0,0), new Vector4(1,1,1,1));
				return ret;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = ImageButton((byte*)pstrId, userTextureId, size, uv0, new Vector2(1,1), new Vector4(0,0,0,0), new Vector4(1,1,1,1));
				return ret;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = ImageButton((byte*)pstrId, userTextureId, size, uv0, uv1, new Vector4(0,0,0,0), new Vector4(1,1,1,1));
				return ret;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = ImageButton((byte*)pstrId, userTextureId, size, uv0, uv1, bgCol, new Vector4(1,1,1,1));
				return ret;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = ImageButton((byte*)pstrId, userTextureId, size, uv0, uv1, bgCol, tintCol);
				return ret;
			}
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ImageButton(pStr0, userTextureId, size, new Vector2(0,0), new Vector2(1,1), new Vector4(0,0,0,0), new Vector4(1,1,1,1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ImageButton(pStr0, userTextureId, size, uv0, new Vector2(1,1), new Vector4(0,0,0,0), new Vector4(1,1,1,1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ImageButton(pStr0, userTextureId, size, uv0, uv1, new Vector4(0,0,0,0), new Vector4(1,1,1,1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ImageButton(pStr0, userTextureId, size, uv0, uv1, bgCol, new Vector4(1,1,1,1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ImageButton(pStr0, userTextureId, size, uv0, uv1, bgCol, tintCol);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginCombo")]
		public static extern bool BeginCombo(byte* label, byte* previewValue, ImGuiComboFlags flags);

		public static bool BeginCombo(ref byte label, byte* previewValue)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginCombo((byte*)plabel, previewValue, (ImGuiComboFlags)(0));
				return ret;
			}
		}

		public static bool BeginCombo(ref byte label, byte* previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginCombo((byte*)plabel, previewValue, flags);
				return ret;
			}
		}

		public static bool BeginCombo(string label, byte* previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginCombo(pStr0, previewValue, (ImGuiComboFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginCombo(string label, byte* previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginCombo(pStr0, previewValue, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginCombo(byte* label, ref byte previewValue)
		{
			fixed (byte* ppreviewValue = &previewValue)
			{
				bool ret = BeginCombo(label, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
				return ret;
			}
		}

		public static bool BeginCombo(byte* label, ref byte previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* ppreviewValue = &previewValue)
			{
				bool ret = BeginCombo(label, (byte*)ppreviewValue, flags);
				return ret;
			}
		}

		public static bool BeginCombo(byte* label, string previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (previewValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginCombo(label, pStr0, (ImGuiComboFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginCombo(byte* label, string previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (previewValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginCombo(label, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginCombo(ref byte label, ref byte previewValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* ppreviewValue = &previewValue)
				{
					bool ret = BeginCombo((byte*)plabel, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
					return ret;
				}
			}
		}

		public static bool BeginCombo(ref byte label, ref byte previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* ppreviewValue = &previewValue)
				{
					bool ret = BeginCombo((byte*)plabel, (byte*)ppreviewValue, flags);
					return ret;
				}
			}
		}

		public static bool BeginCombo(string label, string previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (previewValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(previewValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = BeginCombo(pStr0, pStr1, (ImGuiComboFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginCombo(string label, string previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (previewValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(previewValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = BeginCombo(pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndCombo")]
		public static extern void EndCombo();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCombo_Str_arr")]
		public static extern bool Combo(byte* label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems);

		public static bool Combo(ref byte label, int* currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Combo((byte*)plabel, currentItem, items, itemsCount, -1);
				return ret;
			}
		}

		public static bool Combo(ref byte label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Combo((byte*)plabel, currentItem, items, itemsCount, popupMaxHeightInItems);
				return ret;
			}
		}

		public static bool Combo(string label, int* currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Combo(pStr0, currentItem, items, itemsCount, -1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(string label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Combo(pStr0, currentItem, items, itemsCount, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(byte* label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(label, (int*)pcurrentItem, items, itemsCount, -1);
				return ret;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(label, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
				return ret;
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = Combo((byte*)plabel, (int*)pcurrentItem, items, itemsCount, -1);
					return ret;
				}
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = Combo((byte*)plabel, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
					return ret;
				}
			}
		}

		public static bool Combo(string label, ref int currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(pStr0, (int*)pcurrentItem, items, itemsCount, -1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(string label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(pStr0, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(byte* label, int* currentItem, string[] items, int itemsCount)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			bool ret = Combo(label, currentItem, pStrArray0, itemsCount, -1);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			Utils.Free(pStrArray0);
			return ret;
		}

		public static bool Combo(byte* label, int* currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			bool ret = Combo(label, currentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			Utils.Free(pStrArray0);
			return ret;
		}

		public static bool Combo(string label, int* currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			bool ret = Combo(pStr0, currentItem, pStrArray0, itemsCount, -1);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			Utils.Free(pStrArray0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(string label, int* currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			bool ret = Combo(pStr0, currentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			Utils.Free(pStrArray0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(byte* label, ref int currentItem, string[] items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				bool ret = Combo(label, (int*)pcurrentItem, pStrArray0, itemsCount, -1);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				Utils.Free(pStrArray0);
				return ret;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				bool ret = Combo(label, (int*)pcurrentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				Utils.Free(pStrArray0);
				return ret;
			}
		}

		public static bool Combo(string label, ref int currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				bool ret = Combo(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, -1);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				Utils.Free(pStrArray0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(string label, ref int currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				bool ret = Combo(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				Utils.Free(pStrArray0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCombo_Str")]
		public static extern bool Combo(byte* label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems);

		public static bool Combo(ref byte label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Combo((byte*)plabel, currentItem, itemsSeparatedByZeros, -1);
				return ret;
			}
		}

		public static bool Combo(ref byte label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Combo((byte*)plabel, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				return ret;
			}
		}

		public static bool Combo(string label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Combo(pStr0, currentItem, itemsSeparatedByZeros, -1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(string label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Combo(pStr0, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(byte* label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(label, (int*)pcurrentItem, itemsSeparatedByZeros, -1);
				return ret;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(label, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				return ret;
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = Combo((byte*)plabel, (int*)pcurrentItem, itemsSeparatedByZeros, -1);
					return ret;
				}
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = Combo((byte*)plabel, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
					return ret;
				}
			}
		}

		public static bool Combo(string label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(pStr0, (int*)pcurrentItem, itemsSeparatedByZeros, -1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(string label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(pStr0, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(byte* label, int* currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				bool ret = Combo(label, currentItem, (byte*)pitemsSeparatedByZeros, -1);
				return ret;
			}
		}

		public static bool Combo(byte* label, int* currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				bool ret = Combo(label, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
				return ret;
			}
		}

		public static bool Combo(byte* label, int* currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Combo(label, currentItem, pStr0, -1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(byte* label, int* currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Combo(label, currentItem, pStr0, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(ref byte label, int* currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					bool ret = Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, -1);
					return ret;
				}
			}
		}

		public static bool Combo(ref byte label, int* currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					bool ret = Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret;
				}
			}
		}

		public static bool Combo(string label, int* currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = Combo(pStr0, currentItem, pStr1, -1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(string label, int* currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = Combo(pStr0, currentItem, pStr1, popupMaxHeightInItems);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(byte* label, ref int currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					bool ret = Combo(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, -1);
					return ret;
				}
			}
		}

		public static bool Combo(byte* label, ref int currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					bool ret = Combo(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret;
				}
			}
		}

		public static bool Combo(byte* label, ref int currentItem, string itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = Combo(label, (int*)pcurrentItem, pStr0, -1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = Combo(label, (int*)pcurrentItem, pStr0, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
					{
						bool ret = Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, -1);
						return ret;
					}
				}
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
					{
						bool ret = Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
						return ret;
					}
				}
			}
		}

		public static bool Combo(string label, ref int currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = Combo(pStr0, (int*)pcurrentItem, pStr1, -1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(string label, ref int currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = Combo(pStr0, (int*)pcurrentItem, pStr1, popupMaxHeightInItems);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCombo_FnBoolPtr")]
		public static extern bool Combo(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems);

		public static bool Combo(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Combo((byte*)plabel, currentItem, itemsGetter, data, itemsCount, -1);
				return ret;
			}
		}

		public static bool Combo(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Combo((byte*)plabel, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				return ret;
			}
		}

		public static bool Combo(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Combo(pStr0, currentItem, itemsGetter, data, itemsCount, -1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Combo(pStr0, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Combo(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, -1);
				return ret;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				return ret;
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = Combo((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, -1);
					return ret;
				}
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = Combo((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
					return ret;
				}
			}
		}

		public static bool Combo(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, -1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Combo(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = Combo(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloat")]
		public static extern bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragFloat(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat(string label, ref float v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloat(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloat(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragFloat(byte* label, float* v)
		{
			bool ret = DragFloat(label, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed)
		{
			bool ret = DragFloat(label, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin)
		{
			bool ret = DragFloat(label, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloat(label, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloat2")]
		public static extern bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragFloat2(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat2(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloat2(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloat2(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, float* v)
		{
			bool ret = DragFloat2(label, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed)
		{
			bool ret = DragFloat2(label, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin)
		{
			bool ret = DragFloat2(label, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloat2(label, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat2((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat2((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloat3")]
		public static extern bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragFloat3(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat3(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloat3(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloat3(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, float* v)
		{
			bool ret = DragFloat3(label, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed)
		{
			bool ret = DragFloat3(label, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin)
		{
			bool ret = DragFloat3(label, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloat3(label, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat3((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat3((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloat4")]
		public static extern bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragFloat4(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat4(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloat4(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloat4(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, float* v)
		{
			bool ret = DragFloat4(label, v, 1.0f, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed)
		{
			bool ret = DragFloat4(label, v, vSpeed, 0.0f, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin)
		{
			bool ret = DragFloat4(label, v, vSpeed, vMin, 0.0f, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloat4(label, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat4((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat4((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloatRange2")]
		public static extern bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags);

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, 1.0f, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, 0.0f, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, 0.0f, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* pformatMax = &formatMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformatMax = &formatMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (formatMax != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (formatMax != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (formatMax != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (formatMax != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (formatMax != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (formatMax != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							fixed (byte* pformatMax = &formatMax)
							{
								bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
								return ret;
							}
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							fixed (byte* pformatMax = &formatMax)
							{
								bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
								return ret;
							}
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (formatMax != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (formatMax != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragInt")]
		public static extern bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragInt(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragInt(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragInt(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool DragInt(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragInt(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragInt(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragInt(byte* label, int* v)
		{
			bool ret = DragInt(label, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed)
		{
			bool ret = DragInt(label, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin)
		{
			bool ret = DragInt(label, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragInt(label, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragInt(label, (int*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragInt(label, (int*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragInt2")]
		public static extern bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragInt2(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragInt2(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool DragInt2(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragInt2(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragInt2(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragInt2(byte* label, int* v)
		{
			bool ret = DragInt2(label, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed)
		{
			bool ret = DragInt2(label, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin)
		{
			bool ret = DragInt2(label, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragInt2(label, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt2((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt2((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragInt3")]
		public static extern bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragInt3(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragInt3(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool DragInt3(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragInt3(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragInt3(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragInt3(byte* label, int* v)
		{
			bool ret = DragInt3(label, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed)
		{
			bool ret = DragInt3(label, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin)
		{
			bool ret = DragInt3(label, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragInt3(label, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt3((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt3((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragInt4")]
		public static extern bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragInt4(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragInt4(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool DragInt4(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragInt4(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragInt4(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragInt4(byte* label, int* v)
		{
			bool ret = DragInt4(label, v, 1.0f, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed)
		{
			bool ret = DragInt4(label, v, vSpeed, 0, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin)
		{
			bool ret = DragInt4(label, v, vSpeed, vMin, 0, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragInt4(label, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt4((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt4((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragIntRange2")]
		public static extern bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags);

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, 1.0f, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, 0, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, 0, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, (string)null, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (string)null, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, (string)null, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* pformatMax = &formatMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformatMax = &formatMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (formatMax != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (formatMax != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (formatMax != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (formatMax != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (formatMax != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (formatMax != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							fixed (byte* pformatMax = &formatMax)
							{
								bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
								return ret;
							}
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							fixed (byte* pformatMax = &formatMax)
							{
								bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
								return ret;
							}
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (formatMax != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (formatMax != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragScalar")]
		public static extern bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalar((byte*)plabel, dataType, pData, 1.0f, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalar((byte*)plabel, dataType, pData, vSpeed, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalar((byte*)plabel, dataType, pData, vSpeed, pMin, (void*)(null), (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalar((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalar((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalar((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, format, flags);
				return ret;
			}
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalar(pStr0, dataType, pData, 1.0f, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalar(pStr0, dataType, pData, vSpeed, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalar(pStr0, dataType, pData, vSpeed, pMin, (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalar(pStr0, dataType, pData, vSpeed, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalar(pStr0, dataType, pData, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalar(pStr0, dataType, pData, vSpeed, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragScalar(label, dataType, pData, vSpeed, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragScalar(label, dataType, pData, vSpeed, pMin, pMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData)
		{
			bool ret = DragScalar(label, dataType, pData, 1.0f, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed)
		{
			bool ret = DragScalar(label, dataType, pData, vSpeed, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin)
		{
			bool ret = DragScalar(label, dataType, pData, vSpeed, pMin, (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax)
		{
			bool ret = DragScalar(label, dataType, pData, vSpeed, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalar(label, dataType, pData, vSpeed, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalar(label, dataType, pData, vSpeed, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragScalar((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragScalar((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragScalar(pStr0, dataType, pData, vSpeed, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragScalar(pStr0, dataType, pData, vSpeed, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragScalarN")]
		public static extern bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalarN((byte*)plabel, dataType, pData, components, 1.0f, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalarN((byte*)plabel, dataType, pData, components, vSpeed, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalarN((byte*)plabel, dataType, pData, components, vSpeed, pMin, (void*)(null), (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalarN((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalarN((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragScalarN((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, format, flags);
				return ret;
			}
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalarN(pStr0, dataType, pData, components, 1.0f, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalarN(pStr0, dataType, pData, components, vSpeed, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalarN(pStr0, dataType, pData, components, vSpeed, pMin, (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalarN(pStr0, dataType, pData, components, vSpeed, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalarN(pStr0, dataType, pData, components, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalarN(pStr0, dataType, pData, components, vSpeed, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragScalarN(label, dataType, pData, components, vSpeed, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragScalarN(label, dataType, pData, components, vSpeed, pMin, pMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components)
		{
			bool ret = DragScalarN(label, dataType, pData, components, 1.0f, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed)
		{
			bool ret = DragScalarN(label, dataType, pData, components, vSpeed, (void*)(null), (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin)
		{
			bool ret = DragScalarN(label, dataType, pData, components, vSpeed, pMin, (void*)(null), (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax)
		{
			bool ret = DragScalarN(label, dataType, pData, components, vSpeed, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalarN(label, dataType, pData, components, vSpeed, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragScalarN(label, dataType, pData, components, vSpeed, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragScalarN((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DragScalarN((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragScalarN(pStr0, dataType, pData, components, vSpeed, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DragScalarN(pStr0, dataType, pData, components, vSpeed, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderFloat")]
		public static extern bool SliderFloat(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat((byte*)plabel, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat((byte*)plabel, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat(pStr0, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat(label, (float*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat((byte*)plabel, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat((byte*)plabel, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat((byte*)plabel, (float*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat(pStr0, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat(pStr0, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat(pStr0, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderFloat(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderFloat(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax)
		{
			bool ret = SliderFloat(label, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderFloat(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderFloat(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat(label, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat(label, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderFloat(label, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderFloat(label, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderFloat((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderFloat((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderFloat(pStr0, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderFloat(pStr0, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderFloat2")]
		public static extern bool SliderFloat2(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat2((byte*)plabel, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat2((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat2((byte*)plabel, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat2(pStr0, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat2(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat2(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax, byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat2((byte*)plabel, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat2((byte*)plabel, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat2((byte*)plabel, (float*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = SliderFloat2(pStr0, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = SliderFloat2(pStr0, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = SliderFloat2(pStr0, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderFloat2(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderFloat2(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax)
		{
			bool ret = SliderFloat2(label, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat2(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat2(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat2((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat2((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderFloat2(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderFloat2(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax, string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderFloat2((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderFloat2((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderFloat2(pStr0, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderFloat2(pStr0, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderFloat3")]
		public static extern bool SliderFloat3(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat3((byte*)plabel, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat3((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat3((byte*)plabel, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat3(pStr0, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat3(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat3(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax, byte* format)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat3((byte*)plabel, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat3((byte*)plabel, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat3((byte*)plabel, (float*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = SliderFloat3(pStr0, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = SliderFloat3(pStr0, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = SliderFloat3(pStr0, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderFloat3(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderFloat3(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax)
		{
			bool ret = SliderFloat3(label, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat3(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat3(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat3((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat3((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderFloat3(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderFloat3(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax, string format)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderFloat3((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderFloat3((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderFloat3(pStr0, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderFloat3(pStr0, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderFloat4")]
		public static extern bool SliderFloat4(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat4((byte*)plabel, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat4((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat4((byte*)plabel, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat4(pStr0, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat4(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat4(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax, byte* format)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat4((byte*)plabel, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat4((byte*)plabel, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat4((byte*)plabel, (float*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = SliderFloat4(pStr0, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = SliderFloat4(pStr0, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = SliderFloat4(pStr0, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderFloat4(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderFloat4(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax)
		{
			bool ret = SliderFloat4(label, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat4(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat4(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat4((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat4((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderFloat4(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderFloat4(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax, string format)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderFloat4((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderFloat4((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderFloat4(pStr0, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderFloat4(pStr0, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderAngle")]
		public static extern bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderAngle(ref byte label, float* vRad)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderAngle((byte*)plabel, vRad, -360.0f, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderAngle((byte*)plabel, vRad, vDegreesMin, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderAngle((byte*)plabel, vRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderAngle((byte*)plabel, vRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderAngle((byte*)plabel, vRad, vDegreesMin, vDegreesMax, format, flags);
				return ret;
			}
		}

		public static bool SliderAngle(string label, float* vRad)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, -360.0f, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, vDegreesMin, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, vDegreesMin, vDegreesMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(byte* label, ref float vRad)
		{
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(label, (float*)pvRad, -360.0f, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin)
		{
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax)
		{
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, vDegreesMax, format, flags);
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					bool ret = SliderAngle((byte*)plabel, (float*)pvRad, -360.0f, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					bool ret = SliderAngle((byte*)plabel, (float*)pvRad, vDegreesMin, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					bool ret = SliderAngle((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					bool ret = SliderAngle((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					bool ret = SliderAngle((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderAngle(string label, ref float vRad)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(pStr0, (float*)pvRad, -360.0f, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(pStr0, (float*)pvRad, vDegreesMin, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderAngle(label, vRad, vDegreesMin, vDegreesMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderAngle(label, vRad, vDegreesMin, vDegreesMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, float* vRad)
		{
			bool ret = SliderAngle(label, vRad, -360.0f, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin)
		{
			bool ret = SliderAngle(label, vRad, vDegreesMin, +360.0f, (string)"%.0f deg", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax)
		{
			bool ret = SliderAngle(label, vRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(label, vRad, vDegreesMin, vDegreesMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(label, vRad, vDegreesMin, vDegreesMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderAngle((byte*)plabel, vRad, vDegreesMin, vDegreesMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderAngle((byte*)plabel, vRad, vDegreesMin, vDegreesMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, vDegreesMin, vDegreesMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, vDegreesMin, vDegreesMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, ref byte format)
		{
			fixed (float* pvRad = &vRad)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, vDegreesMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pvRad = &vRad)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, vDegreesMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, string format)
		{
			fixed (float* pvRad = &vRad)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, vDegreesMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, string format, ImGuiSliderFlags flags)
		{
			fixed (float* pvRad = &vRad)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, vDegreesMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderAngle((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderAngle((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderAngle(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderAngle(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderInt")]
		public static extern bool SliderInt(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt((byte*)plabel, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt((byte*)plabel, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt(pStr0, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt(label, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt(label, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt(label, (int*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt((byte*)plabel, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt((byte*)plabel, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt((byte*)plabel, (int*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt(pStr0, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt(pStr0, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt(pStr0, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderInt(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderInt(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax)
		{
			bool ret = SliderInt(label, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderInt(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderInt(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt(label, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt(label, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderInt(label, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderInt(label, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderInt((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderInt((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderInt(pStr0, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderInt(pStr0, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderInt2")]
		public static extern bool SliderInt2(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt2((byte*)plabel, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt2((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt2((byte*)plabel, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt2(pStr0, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt2(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt2(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt2(label, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt2(label, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt2(label, (int*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt2((byte*)plabel, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt2((byte*)plabel, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt2((byte*)plabel, (int*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt2(pStr0, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt2(pStr0, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt2(pStr0, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderInt2(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderInt2(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax)
		{
			bool ret = SliderInt2(label, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt2(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt2(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt2((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt2((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderInt2(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderInt2(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt2(label, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt2(label, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderInt2(label, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderInt2(label, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderInt2((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderInt2((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderInt2(pStr0, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderInt2(pStr0, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderInt3")]
		public static extern bool SliderInt3(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt3((byte*)plabel, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt3((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt3((byte*)plabel, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt3(pStr0, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt3(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt3(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt3(label, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt3(label, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt3(label, (int*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt3((byte*)plabel, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt3((byte*)plabel, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt3((byte*)plabel, (int*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt3(pStr0, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt3(pStr0, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt3(pStr0, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderInt3(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderInt3(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax)
		{
			bool ret = SliderInt3(label, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt3(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt3(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt3((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt3((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderInt3(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderInt3(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt3(label, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt3(label, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderInt3(label, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderInt3(label, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderInt3((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderInt3((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderInt3(pStr0, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderInt3(pStr0, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderInt4")]
		public static extern bool SliderInt4(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt4((byte*)plabel, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt4((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt4((byte*)plabel, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt4(pStr0, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt4(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt4(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt4(label, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt4(label, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt4(label, (int*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt4((byte*)plabel, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt4((byte*)plabel, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt4((byte*)plabel, (int*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt4(pStr0, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt4(pStr0, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt4(pStr0, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderInt4(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderInt4(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax)
		{
			bool ret = SliderInt4(label, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt4(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt4(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt4((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt4((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderInt4(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderInt4(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt4(label, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderInt4(label, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderInt4(label, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = SliderInt4(label, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderInt4((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = SliderInt4((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderInt4(pStr0, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = SliderInt4(pStr0, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderScalar")]
		public static extern bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderScalar((byte*)plabel, dataType, pData, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderScalar((byte*)plabel, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderScalar((byte*)plabel, dataType, pData, pMin, pMax, format, flags);
				return ret;
			}
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalar(pStr0, dataType, pData, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalar(pStr0, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalar(pStr0, dataType, pData, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderScalar(label, dataType, pData, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderScalar(label, dataType, pData, pMin, pMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			bool ret = SliderScalar(label, dataType, pData, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalar(label, dataType, pData, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalar(label, dataType, pData, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderScalar((byte*)plabel, dataType, pData, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderScalar((byte*)plabel, dataType, pData, pMin, pMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderScalar(pStr0, dataType, pData, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderScalar(pStr0, dataType, pData, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderScalarN")]
		public static extern bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderScalarN((byte*)plabel, dataType, pData, components, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderScalarN((byte*)plabel, dataType, pData, components, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderScalarN((byte*)plabel, dataType, pData, components, pMin, pMax, format, flags);
				return ret;
			}
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalarN(pStr0, dataType, pData, components, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalarN(pStr0, dataType, pData, components, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalarN(pStr0, dataType, pData, components, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderScalarN(label, dataType, pData, components, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderScalarN(label, dataType, pData, components, pMin, pMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax)
		{
			bool ret = SliderScalarN(label, dataType, pData, components, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalarN(label, dataType, pData, components, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderScalarN(label, dataType, pData, components, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderScalarN((byte*)plabel, dataType, pData, components, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = SliderScalarN((byte*)plabel, dataType, pData, components, pMin, pMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderScalarN(pStr0, dataType, pData, components, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = SliderScalarN(pStr0, dataType, pData, components, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igVSliderFloat")]
		public static extern bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderFloat((byte*)plabel, size, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderFloat((byte*)plabel, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderFloat((byte*)plabel, size, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderFloat(pStr0, size, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderFloat(pStr0, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderFloat(pStr0, size, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = VSliderFloat(label, size, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = VSliderFloat(label, size, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = VSliderFloat(label, size, (float*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = VSliderFloat((byte*)plabel, size, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = VSliderFloat((byte*)plabel, size, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = VSliderFloat((byte*)plabel, size, (float*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = VSliderFloat(pStr0, size, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = VSliderFloat(pStr0, size, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = VSliderFloat(pStr0, size, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = VSliderFloat(label, size, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = VSliderFloat(label, size, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax)
		{
			bool ret = VSliderFloat(label, size, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderFloat(label, size, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderFloat(label, size, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderFloat((byte*)plabel, size, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderFloat((byte*)plabel, size, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = VSliderFloat(pStr0, size, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = VSliderFloat(pStr0, size, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderFloat(label, size, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderFloat(label, size, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = VSliderFloat(label, size, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = VSliderFloat(label, size, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = VSliderFloat((byte*)plabel, size, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = VSliderFloat((byte*)plabel, size, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = VSliderFloat(pStr0, size, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = VSliderFloat(pStr0, size, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igVSliderInt")]
		public static extern bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderInt((byte*)plabel, size, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderInt((byte*)plabel, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderInt((byte*)plabel, size, v, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderInt(pStr0, size, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderInt(pStr0, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderInt(pStr0, size, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = VSliderInt(label, size, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				bool ret = VSliderInt(label, size, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = VSliderInt(label, size, (int*)pv, vMin, vMax, format, flags);
				return ret;
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = VSliderInt((byte*)plabel, size, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = VSliderInt((byte*)plabel, size, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = VSliderInt((byte*)plabel, size, (int*)pv, vMin, vMax, format, flags);
					return ret;
				}
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = VSliderInt(pStr0, size, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = VSliderInt(pStr0, size, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = VSliderInt(pStr0, size, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = VSliderInt(label, size, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = VSliderInt(label, size, v, vMin, vMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax)
		{
			bool ret = VSliderInt(label, size, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderInt(label, size, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderInt(label, size, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderInt((byte*)plabel, size, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderInt((byte*)plabel, size, v, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = VSliderInt(pStr0, size, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = VSliderInt(pStr0, size, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderInt(label, size, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderInt(label, size, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = VSliderInt(label, size, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = VSliderInt(label, size, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = VSliderInt((byte*)plabel, size, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = VSliderInt((byte*)plabel, size, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = VSliderInt(pStr0, size, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = VSliderInt(pStr0, size, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igVSliderScalar")]
		public static extern bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderScalar((byte*)plabel, size, dataType, pData, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderScalar((byte*)plabel, size, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderScalar((byte*)plabel, size, dataType, pData, pMin, pMax, format, flags);
				return ret;
			}
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderScalar(pStr0, size, dataType, pData, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderScalar(pStr0, size, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderScalar(pStr0, size, dataType, pData, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = VSliderScalar(label, size, dataType, pData, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = VSliderScalar(label, size, dataType, pData, pMin, pMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			bool ret = VSliderScalar(label, size, dataType, pData, pMin, pMax, (string)null, (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderScalar(label, size, dataType, pData, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderScalar(label, size, dataType, pData, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderScalar((byte*)plabel, size, dataType, pData, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = VSliderScalar((byte*)plabel, size, dataType, pData, pMin, pMax, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = VSliderScalar(pStr0, size, dataType, pData, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = VSliderScalar(pStr0, size, dataType, pData, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputText")]
		public static extern bool InputText(byte* label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData);

		public static bool InputText(ref byte label, byte* buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputText((byte*)plabel, buf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputText(ref byte label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputText((byte*)plabel, buf, bufSize, flags, null, (void*)(null));
				return ret;
			}
		}

		public static bool InputText(ref byte label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputText((byte*)plabel, buf, bufSize, flags, callback, (void*)(null));
				return ret;
			}
		}

		public static bool InputText(ref byte label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputText((byte*)plabel, buf, bufSize, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputText(string label, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputText(pStr0, buf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(string label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputText(pStr0, buf, bufSize, flags, null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(string label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputText(pStr0, buf, bufSize, flags, callback, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(string label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputText(pStr0, buf, bufSize, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(byte* label, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputText(label, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputText(byte* label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputText(label, (byte*)pbuf, bufSize, flags, null, (void*)(null));
				return ret;
			}
		}

		public static bool InputText(byte* label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputText(label, (byte*)pbuf, bufSize, flags, callback, (void*)(null));
				return ret;
			}
		}

		public static bool InputText(byte* label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputText(label, (byte*)pbuf, bufSize, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputText(byte* label, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputText(label, pStr0, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(byte* label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputText(label, pStr0, bufSize, flags, null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(byte* label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputText(label, pStr0, bufSize, flags, callback, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(byte* label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputText(label, pStr0, bufSize, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(ref byte label, ref byte buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputText((byte*)plabel, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputText(ref byte label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputText((byte*)plabel, (byte*)pbuf, bufSize, flags, null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputText(ref byte label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputText((byte*)plabel, (byte*)pbuf, bufSize, flags, callback, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputText(ref byte label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputText((byte*)plabel, (byte*)pbuf, bufSize, flags, callback, userData);
					return ret;
				}
			}
		}

		public static bool InputText(string label, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputText(pStr0, pStr1, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(string label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputText(pStr0, pStr1, bufSize, flags, null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(string label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputText(pStr0, pStr1, bufSize, flags, callback, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputText(string label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputText(pStr0, pStr1, bufSize, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputTextMultiline")]
		public static extern bool InputTextMultiline(byte* label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData);

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextMultiline((byte*)plabel, buf, bufSize, new Vector2(0,0), (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextMultiline((byte*)plabel, buf, bufSize, size, (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextMultiline((byte*)plabel, buf, bufSize, size, flags, null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextMultiline((byte*)plabel, buf, bufSize, size, flags, callback, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextMultiline((byte*)plabel, buf, bufSize, size, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(pStr0, buf, bufSize, new Vector2(0,0), (ImGuiInputTextFlags)(0), null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(pStr0, buf, bufSize, size, (ImGuiInputTextFlags)(0), null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(pStr0, buf, bufSize, size, flags, null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(pStr0, buf, bufSize, size, flags, callback, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(pStr0, buf, bufSize, size, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextMultiline(label, (byte*)pbuf, bufSize, new Vector2(0,0), (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize, Vector2 size)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextMultiline(label, (byte*)pbuf, bufSize, size, (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextMultiline(label, (byte*)pbuf, bufSize, size, flags, null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextMultiline(label, (byte*)pbuf, bufSize, size, flags, callback, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextMultiline(label, (byte*)pbuf, bufSize, size, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(label, pStr0, bufSize, new Vector2(0,0), (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(label, pStr0, bufSize, size, (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(label, pStr0, bufSize, size, flags, null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(label, pStr0, bufSize, size, flags, callback, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextMultiline(label, pStr0, bufSize, size, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextMultiline((byte*)plabel, (byte*)pbuf, bufSize, new Vector2(0,0), (ImGuiInputTextFlags)(0), null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextMultiline((byte*)plabel, (byte*)pbuf, bufSize, size, (ImGuiInputTextFlags)(0), null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextMultiline((byte*)plabel, (byte*)pbuf, bufSize, size, flags, null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextMultiline((byte*)plabel, (byte*)pbuf, bufSize, size, flags, callback, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextMultiline((byte*)plabel, (byte*)pbuf, bufSize, size, flags, callback, userData);
					return ret;
				}
			}
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextMultiline(pStr0, pStr1, bufSize, new Vector2(0,0), (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextMultiline(pStr0, pStr1, bufSize, size, (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextMultiline(pStr0, pStr1, bufSize, size, flags, null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextMultiline(pStr0, pStr1, bufSize, size, flags, callback, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextMultiline(pStr0, pStr1, bufSize, size, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputTextWithHint")]
		public static extern bool InputTextWithHint(byte* label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData);

		public static bool InputTextWithHint(ref byte label, byte* hint, byte* buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextWithHint((byte*)plabel, hint, buf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextWithHint((byte*)plabel, hint, buf, bufSize, flags, null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextWithHint((byte*)plabel, hint, buf, bufSize, flags, callback, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextWithHint((byte*)plabel, hint, buf, bufSize, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputTextWithHint(string label, byte* hint, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(pStr0, hint, buf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(pStr0, hint, buf, bufSize, flags, null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(pStr0, hint, buf, bufSize, flags, callback, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(pStr0, hint, buf, bufSize, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, byte* buf, nuint bufSize)
		{
			fixed (byte* phint = &hint)
			{
				bool ret = InputTextWithHint(label, (byte*)phint, buf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* phint = &hint)
			{
				bool ret = InputTextWithHint(label, (byte*)phint, buf, bufSize, flags, null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* phint = &hint)
			{
				bool ret = InputTextWithHint(label, (byte*)phint, buf, bufSize, flags, callback, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* phint = &hint)
			{
				bool ret = InputTextWithHint(label, (byte*)phint, buf, bufSize, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputTextWithHint(byte* label, string hint, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(label, pStr0, buf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(label, pStr0, buf, bufSize, flags, null, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(label, pStr0, buf, bufSize, flags, callback, (void*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(label, pStr0, buf, bufSize, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, byte* buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					bool ret = InputTextWithHint((byte*)plabel, (byte*)phint, buf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					bool ret = InputTextWithHint((byte*)plabel, (byte*)phint, buf, bufSize, flags, null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					bool ret = InputTextWithHint((byte*)plabel, (byte*)phint, buf, bufSize, flags, callback, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					bool ret = InputTextWithHint((byte*)plabel, (byte*)phint, buf, bufSize, flags, callback, userData);
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(string label, string hint, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(pStr0, pStr1, buf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(pStr0, pStr1, buf, bufSize, flags, null, (void*)(null));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(pStr0, pStr1, buf, bufSize, flags, callback, (void*)(null));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(pStr0, pStr1, buf, bufSize, flags, callback, userData);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextWithHint(label, hint, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextWithHint(label, hint, (byte*)pbuf, bufSize, flags, null, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextWithHint(label, hint, (byte*)pbuf, bufSize, flags, callback, (void*)(null));
				return ret;
			}
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextWithHint(label, hint, (byte*)pbuf, bufSize, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(label, hint, pStr0, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(label, hint, pStr0, bufSize, flags, null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(label, hint, pStr0, bufSize, flags, callback, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextWithHint(label, hint, pStr0, bufSize, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, ref byte buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextWithHint((byte*)plabel, hint, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextWithHint((byte*)plabel, hint, (byte*)pbuf, bufSize, flags, null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextWithHint((byte*)plabel, hint, (byte*)pbuf, bufSize, flags, callback, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextWithHint((byte*)plabel, hint, (byte*)pbuf, bufSize, flags, callback, userData);
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(string label, byte* hint, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(pStr0, hint, pStr1, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(pStr0, hint, pStr1, bufSize, flags, null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(pStr0, hint, pStr1, bufSize, flags, callback, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(pStr0, hint, pStr1, bufSize, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, ref byte buf, nuint bufSize)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextWithHint(label, (byte*)phint, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextWithHint(label, (byte*)phint, (byte*)pbuf, bufSize, flags, null, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextWithHint(label, (byte*)phint, (byte*)pbuf, bufSize, flags, callback, (void*)(null));
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextWithHint(label, (byte*)phint, (byte*)pbuf, bufSize, flags, callback, userData);
					return ret;
				}
			}
		}

		public static bool InputTextWithHint(byte* label, string hint, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(label, pStr0, pStr1, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(label, pStr0, pStr1, bufSize, flags, null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(label, pStr0, pStr1, bufSize, flags, callback, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(byte* label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextWithHint(label, pStr0, pStr1, bufSize, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, ref byte buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						bool ret = InputTextWithHint((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
						return ret;
					}
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						bool ret = InputTextWithHint((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, flags, null, (void*)(null));
						return ret;
					}
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						bool ret = InputTextWithHint((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, flags, callback, (void*)(null));
						return ret;
					}
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						bool ret = InputTextWithHint((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, flags, callback, userData);
						return ret;
					}
				}
			}
		}

		public static bool InputTextWithHint(string label, string hint, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = InputTextWithHint(pStr0, pStr1, pStr2, bufSize, (ImGuiInputTextFlags)(0), null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = InputTextWithHint(pStr0, pStr1, pStr2, bufSize, flags, null, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = InputTextWithHint(pStr0, pStr1, pStr2, bufSize, flags, callback, (void*)(null));
			buf = Marshal.PtrToStringAnsi((nint)pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextWithHint(string label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = InputTextWithHint(pStr0, pStr1, pStr2, bufSize, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputFloat")]
		public static extern bool InputFloat(byte* label, float* v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags);

		public static bool InputFloat(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat((byte*)plabel, v, 0.0f, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat((byte*)plabel, v, step, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat((byte*)plabel, v, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat((byte*)plabel, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat((byte*)plabel, v, step, stepFast, format, flags);
				return ret;
			}
		}

		public static bool InputFloat(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(pStr0, v, 0.0f, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(string label, float* v, float step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(pStr0, v, step, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(pStr0, v, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(pStr0, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(pStr0, v, step, stepFast, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(label, (float*)pv, 0.0f, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(label, (float*)pv, step, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(label, (float*)pv, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(label, (float*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(label, (float*)pv, step, stepFast, format, flags);
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat((byte*)plabel, (float*)pv, 0.0f, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat((byte*)plabel, (float*)pv, step, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat((byte*)plabel, (float*)pv, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat((byte*)plabel, (float*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat((byte*)plabel, (float*)pv, step, stepFast, format, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat(string label, ref float v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(pStr0, (float*)pv, 0.0f, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(string label, ref float v, float step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(pStr0, (float*)pv, step, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(pStr0, (float*)pv, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(pStr0, (float*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(pStr0, (float*)pv, step, stepFast, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputFloat(label, v, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputFloat(label, v, step, stepFast, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool InputFloat(byte* label, float* v)
		{
			bool ret = InputFloat(label, v, 0.0f, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat(byte* label, float* v, float step)
		{
			bool ret = InputFloat(label, v, step, 0.0f, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast)
		{
			bool ret = InputFloat(label, v, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(label, v, step, stepFast, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(label, v, step, stepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat((byte*)plabel, v, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat((byte*)plabel, v, step, stepFast, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputFloat(pStr0, v, step, stepFast, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputFloat(pStr0, v, step, stepFast, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat(label, (float*)pv, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat(label, (float*)pv, step, stepFast, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputFloat(label, (float*)pv, step, stepFast, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, string format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputFloat(label, (float*)pv, step, stepFast, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputFloat((byte*)plabel, (float*)pv, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputFloat((byte*)plabel, (float*)pv, step, stepFast, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputFloat(pStr0, (float*)pv, step, stepFast, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputFloat(pStr0, (float*)pv, step, stepFast, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputFloat2")]
		public static extern bool InputFloat2(byte* label, float* v, byte* format, ImGuiInputTextFlags flags);

		public static bool InputFloat2(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat2((byte*)plabel, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(ref byte label, float* v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat2((byte*)plabel, v, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(ref byte label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat2((byte*)plabel, v, format, flags);
				return ret;
			}
		}

		public static bool InputFloat2(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat2(pStr0, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat2(string label, float* v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat2(pStr0, v, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat2(string label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat2(pStr0, v, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat2(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat2(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, ref float v, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat2(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat2(label, (float*)pv, format, flags);
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = InputFloat2(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v, byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = InputFloat2(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = InputFloat2(label, (float*)pv, format, flags);
				return ret;
			}
		}

		public static bool InputFloat2(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat2((byte*)plabel, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat2(ref byte label, ref float v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat2((byte*)plabel, (float*)pv, format, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat2(ref byte label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat2((byte*)plabel, (float*)pv, format, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = InputFloat2(pStr0, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = InputFloat2(pStr0, (float*)pv, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = InputFloat2(pStr0, (float*)pv, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, float* v, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputFloat2(label, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputFloat2(label, v, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, float* v)
		{
			bool ret = InputFloat2(label, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat2(byte* label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat2(label, v, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat2(byte* label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat2(label, v, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat2(ref byte label, float* v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat2((byte*)plabel, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat2(ref byte label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat2((byte*)plabel, v, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat2(string label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputFloat2(pStr0, v, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat2(string label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputFloat2(pStr0, v, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat2(byte* label, ref float v, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat2(label, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat2(byte* label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat2(label, (float*)pv, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v, string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputFloat2(label, (float*)pv, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v, string format, ImGuiInputTextFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputFloat2(label, (float*)pv, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat2(ref byte label, ref float v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputFloat2((byte*)plabel, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool InputFloat2(ref byte label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputFloat2((byte*)plabel, (float*)pv, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputFloat2(pStr0, (float*)pv, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputFloat2(pStr0, (float*)pv, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputFloat3")]
		public static extern bool InputFloat3(byte* label, float* v, byte* format, ImGuiInputTextFlags flags);

		public static bool InputFloat3(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat3((byte*)plabel, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(ref byte label, float* v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat3((byte*)plabel, v, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(ref byte label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat3((byte*)plabel, v, format, flags);
				return ret;
			}
		}

		public static bool InputFloat3(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat3(pStr0, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat3(string label, float* v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat3(pStr0, v, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat3(string label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat3(pStr0, v, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat3(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat3(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, ref float v, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat3(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat3(label, (float*)pv, format, flags);
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = InputFloat3(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v, byte* format)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = InputFloat3(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = InputFloat3(label, (float*)pv, format, flags);
				return ret;
			}
		}

		public static bool InputFloat3(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat3((byte*)plabel, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat3(ref byte label, ref float v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat3((byte*)plabel, (float*)pv, format, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat3(ref byte label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat3((byte*)plabel, (float*)pv, format, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = InputFloat3(pStr0, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = InputFloat3(pStr0, (float*)pv, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = InputFloat3(pStr0, (float*)pv, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, float* v, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputFloat3(label, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputFloat3(label, v, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, float* v)
		{
			bool ret = InputFloat3(label, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat3(byte* label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat3(label, v, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat3(byte* label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat3(label, v, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat3(ref byte label, float* v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat3((byte*)plabel, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat3(ref byte label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat3((byte*)plabel, v, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat3(string label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputFloat3(pStr0, v, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat3(string label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputFloat3(pStr0, v, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat3(byte* label, ref float v, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat3(label, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat3(byte* label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat3(label, (float*)pv, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v, string format)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputFloat3(label, (float*)pv, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v, string format, ImGuiInputTextFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputFloat3(label, (float*)pv, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat3(ref byte label, ref float v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputFloat3((byte*)plabel, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool InputFloat3(ref byte label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputFloat3((byte*)plabel, (float*)pv, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputFloat3(pStr0, (float*)pv, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputFloat3(pStr0, (float*)pv, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputFloat4")]
		public static extern bool InputFloat4(byte* label, float* v, byte* format, ImGuiInputTextFlags flags);

		public static bool InputFloat4(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat4((byte*)plabel, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(ref byte label, float* v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat4((byte*)plabel, v, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(ref byte label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat4((byte*)plabel, v, format, flags);
				return ret;
			}
		}

		public static bool InputFloat4(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat4(pStr0, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat4(string label, float* v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat4(pStr0, v, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat4(string label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat4(pStr0, v, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat4(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, ref float v, byte* format)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, format, flags);
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v, byte* format)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, format, flags);
				return ret;
			}
		}

		public static bool InputFloat4(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat4((byte*)plabel, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat4(ref byte label, ref float v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat4((byte*)plabel, (float*)pv, format, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat4(ref byte label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat4((byte*)plabel, (float*)pv, format, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(pStr0, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(pStr0, (float*)pv, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(pStr0, (float*)pv, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, float* v, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputFloat4(label, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputFloat4(label, v, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, float* v)
		{
			bool ret = InputFloat4(label, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat4(byte* label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat4(label, v, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat4(byte* label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat4(label, v, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat4(ref byte label, float* v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat4((byte*)plabel, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat4(ref byte label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat4((byte*)plabel, v, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat4(string label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputFloat4(pStr0, v, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat4(string label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputFloat4(pStr0, v, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat4(byte* label, ref float v, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat4(label, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat4(byte* label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputFloat4(label, (float*)pv, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v, string format)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputFloat4(label, (float*)pv, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v, string format, ImGuiInputTextFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputFloat4(label, (float*)pv, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat4(ref byte label, ref float v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputFloat4((byte*)plabel, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool InputFloat4(ref byte label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputFloat4((byte*)plabel, (float*)pv, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputFloat4(pStr0, (float*)pv, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputFloat4(pStr0, (float*)pv, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputInt")]
		public static extern bool InputInt(byte* label, int* v, int step, int stepFast, ImGuiInputTextFlags flags);

		public static bool InputInt(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt((byte*)plabel, v, 1, 100, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt(ref byte label, int* v, int step)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt((byte*)plabel, v, step, 100, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt(ref byte label, int* v, int step, int stepFast)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt((byte*)plabel, v, step, stepFast, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt(ref byte label, int* v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt((byte*)plabel, v, step, stepFast, flags);
				return ret;
			}
		}

		public static bool InputInt(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt(pStr0, v, 1, 100, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt(string label, int* v, int step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt(pStr0, v, step, 100, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt(string label, int* v, int step, int stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt(pStr0, v, step, stepFast, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt(string label, int* v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt(pStr0, v, step, stepFast, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt(label, (int*)pv, 1, 100, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt(byte* label, ref int v, int step)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt(label, (int*)pv, step, 100, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt(byte* label, ref int v, int step, int stepFast)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt(label, (int*)pv, step, stepFast, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt(byte* label, ref int v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt(label, (int*)pv, step, stepFast, flags);
				return ret;
			}
		}

		public static bool InputInt(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt((byte*)plabel, (int*)pv, 1, 100, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputInt(ref byte label, ref int v, int step)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt((byte*)plabel, (int*)pv, step, 100, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputInt(ref byte label, ref int v, int step, int stepFast)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt((byte*)plabel, (int*)pv, step, stepFast, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputInt(ref byte label, ref int v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt((byte*)plabel, (int*)pv, step, stepFast, flags);
					return ret;
				}
			}
		}

		public static bool InputInt(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt(pStr0, (int*)pv, 1, 100, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputInt(string label, ref int v, int step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt(pStr0, (int*)pv, step, 100, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputInt(string label, ref int v, int step, int stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt(pStr0, (int*)pv, step, stepFast, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputInt(string label, ref int v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt(pStr0, (int*)pv, step, stepFast, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputInt2")]
		public static extern bool InputInt2(byte* label, int* v, ImGuiInputTextFlags flags);

		public static bool InputInt2(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt2((byte*)plabel, v, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt2(ref byte label, int* v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt2((byte*)plabel, v, flags);
				return ret;
			}
		}

		public static bool InputInt2(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt2(pStr0, v, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt2(string label, int* v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt2(pStr0, v, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt2(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt2(label, (int*)pv, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt2(byte* label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt2(label, (int*)pv, flags);
				return ret;
			}
		}

		public static bool InputInt2(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt2((byte*)plabel, (int*)pv, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputInt2(ref byte label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt2((byte*)plabel, (int*)pv, flags);
					return ret;
				}
			}
		}

		public static bool InputInt2(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt2(pStr0, (int*)pv, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputInt2(string label, ref int v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt2(pStr0, (int*)pv, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputInt3")]
		public static extern bool InputInt3(byte* label, int* v, ImGuiInputTextFlags flags);

		public static bool InputInt3(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt3((byte*)plabel, v, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt3(ref byte label, int* v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt3((byte*)plabel, v, flags);
				return ret;
			}
		}

		public static bool InputInt3(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt3(pStr0, v, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt3(string label, int* v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt3(pStr0, v, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt3(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt3(label, (int*)pv, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt3(byte* label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt3(label, (int*)pv, flags);
				return ret;
			}
		}

		public static bool InputInt3(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt3((byte*)plabel, (int*)pv, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputInt3(ref byte label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt3((byte*)plabel, (int*)pv, flags);
					return ret;
				}
			}
		}

		public static bool InputInt3(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt3(pStr0, (int*)pv, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputInt3(string label, ref int v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt3(pStr0, (int*)pv, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputInt4")]
		public static extern bool InputInt4(byte* label, int* v, ImGuiInputTextFlags flags);

		public static bool InputInt4(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt4((byte*)plabel, v, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt4(ref byte label, int* v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputInt4((byte*)plabel, v, flags);
				return ret;
			}
		}

		public static bool InputInt4(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt4(pStr0, v, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt4(string label, int* v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputInt4(pStr0, v, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputInt4(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt4(label, (int*)pv, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputInt4(byte* label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (int* pv = &v)
			{
				bool ret = InputInt4(label, (int*)pv, flags);
				return ret;
			}
		}

		public static bool InputInt4(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt4((byte*)plabel, (int*)pv, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputInt4(ref byte label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = InputInt4((byte*)plabel, (int*)pv, flags);
					return ret;
				}
			}
		}

		public static bool InputInt4(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt4(pStr0, (int*)pv, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputInt4(string label, ref int v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = InputInt4(pStr0, (int*)pv, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputDouble")]
		public static extern bool InputDouble(byte* label, double* v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags);

		public static bool InputDouble(ref byte label, double* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputDouble((byte*)plabel, v, 0.0, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputDouble((byte*)plabel, v, step, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputDouble((byte*)plabel, v, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputDouble((byte*)plabel, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputDouble((byte*)plabel, v, step, stepFast, format, flags);
				return ret;
			}
		}

		public static bool InputDouble(string label, double* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(pStr0, v, 0.0, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(string label, double* v, double step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(pStr0, v, step, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(pStr0, v, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(pStr0, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(pStr0, v, step, stepFast, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(byte* label, ref double v)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, 0.0, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, byte* format)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, stepFast, format, flags);
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, ref double v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					bool ret = InputDouble((byte*)plabel, (double*)pv, 0.0, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					bool ret = InputDouble((byte*)plabel, (double*)pv, step, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					bool ret = InputDouble((byte*)plabel, (double*)pv, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					bool ret = InputDouble((byte*)plabel, (double*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					bool ret = InputDouble((byte*)plabel, (double*)pv, step, stepFast, format, flags);
					return ret;
				}
			}
		}

		public static bool InputDouble(string label, ref double v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(pStr0, (double*)pv, 0.0, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(string label, ref double v, double step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(pStr0, (double*)pv, step, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(pStr0, (double*)pv, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(pStr0, (double*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(pStr0, (double*)pv, step, stepFast, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputDouble(label, v, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputDouble(label, v, step, stepFast, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool InputDouble(byte* label, double* v)
		{
			bool ret = InputDouble(label, v, 0.0, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputDouble(byte* label, double* v, double step)
		{
			bool ret = InputDouble(label, v, step, 0.0, (string)"%.6f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast)
		{
			bool ret = InputDouble(label, v, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(label, v, step, stepFast, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(label, v, step, stepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputDouble((byte*)plabel, v, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputDouble((byte*)plabel, v, step, stepFast, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputDouble(pStr0, v, step, stepFast, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputDouble(pStr0, v, step, stepFast, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, ref byte format)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputDouble(label, (double*)pv, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputDouble(label, (double*)pv, step, stepFast, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, string format)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputDouble(label, (double*)pv, step, stepFast, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, string format, ImGuiInputTextFlags flags)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = InputDouble(label, (double*)pv, step, stepFast, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputDouble((byte*)plabel, (double*)pv, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						bool ret = InputDouble((byte*)plabel, (double*)pv, step, stepFast, (byte*)pformat, flags);
						return ret;
					}
				}
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputDouble(pStr0, (double*)pv, step, stepFast, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = InputDouble(pStr0, (double*)pv, step, stepFast, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputScalar")]
		public static extern bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags);

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalar((byte*)plabel, dataType, pData, (void*)(null), (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalar((byte*)plabel, dataType, pData, pStep, (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalar((byte*)plabel, dataType, pData, pStep, pStepFast, (string)null, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalar((byte*)plabel, dataType, pData, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalar((byte*)plabel, dataType, pData, pStep, pStepFast, format, flags);
				return ret;
			}
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalar(pStr0, dataType, pData, (void*)(null), (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalar(pStr0, dataType, pData, pStep, (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalar(pStr0, dataType, pData, pStep, pStepFast, (string)null, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalar(pStr0, dataType, pData, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalar(pStr0, dataType, pData, pStep, pStepFast, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputScalar(label, dataType, pData, pStep, pStepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputScalar(label, dataType, pData, pStep, pStepFast, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData)
		{
			bool ret = InputScalar(label, dataType, pData, (void*)(null), (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep)
		{
			bool ret = InputScalar(label, dataType, pData, pStep, (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast)
		{
			bool ret = InputScalar(label, dataType, pData, pStep, pStepFast, (string)null, (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalar(label, dataType, pData, pStep, pStepFast, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalar(label, dataType, pData, pStep, pStepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputScalar((byte*)plabel, dataType, pData, pStep, pStepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputScalar((byte*)plabel, dataType, pData, pStep, pStepFast, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputScalar(pStr0, dataType, pData, pStep, pStepFast, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputScalar(pStr0, dataType, pData, pStep, pStepFast, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputScalarN")]
		public static extern bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags);

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalarN((byte*)plabel, dataType, pData, components, (void*)(null), (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalarN((byte*)plabel, dataType, pData, components, pStep, (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalarN((byte*)plabel, dataType, pData, components, pStep, pStepFast, (string)null, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalarN((byte*)plabel, dataType, pData, components, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputScalarN((byte*)plabel, dataType, pData, components, pStep, pStepFast, format, flags);
				return ret;
			}
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalarN(pStr0, dataType, pData, components, (void*)(null), (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalarN(pStr0, dataType, pData, components, pStep, (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalarN(pStr0, dataType, pData, components, pStep, pStepFast, (string)null, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalarN(pStr0, dataType, pData, components, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalarN(pStr0, dataType, pData, components, pStep, pStepFast, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputScalarN(label, dataType, pData, components, pStep, pStepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = InputScalarN(label, dataType, pData, components, pStep, pStepFast, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components)
		{
			bool ret = InputScalarN(label, dataType, pData, components, (void*)(null), (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep)
		{
			bool ret = InputScalarN(label, dataType, pData, components, pStep, (void*)(null), (string)null, (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast)
		{
			bool ret = InputScalarN(label, dataType, pData, components, pStep, pStepFast, (string)null, (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalarN(label, dataType, pData, components, pStep, pStepFast, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputScalarN(label, dataType, pData, components, pStep, pStepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputScalarN((byte*)plabel, dataType, pData, components, pStep, pStepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = InputScalarN((byte*)plabel, dataType, pData, components, pStep, pStepFast, (byte*)pformat, flags);
					return ret;
				}
			}
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputScalarN(pStr0, dataType, pData, components, pStep, pStepFast, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputScalarN(pStr0, dataType, pData, components, pStep, pStepFast, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorEdit3")]
		public static extern bool ColorEdit3(byte* label, float* col, ImGuiColorEditFlags flags);

		public static bool ColorEdit3(ref byte label, float* col)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorEdit3((byte*)plabel, col, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorEdit3(ref byte label, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorEdit3((byte*)plabel, col, flags);
				return ret;
			}
		}

		public static bool ColorEdit3(string label, float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorEdit3(pStr0, col, (ImGuiColorEditFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorEdit3(string label, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorEdit3(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorEdit3(byte* label, ref float col)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorEdit3(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorEdit3(byte* label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorEdit3(label, (float*)pcol, flags);
				return ret;
			}
		}

		public static bool ColorEdit3(byte* label, ref Vector3 col)
		{
			fixed (Vector3* pcol = &col)
			{
				bool ret = ColorEdit3(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorEdit3(byte* label, ref Vector3 col, ImGuiColorEditFlags flags)
		{
			fixed (Vector3* pcol = &col)
			{
				bool ret = ColorEdit3(label, (float*)pcol, flags);
				return ret;
			}
		}

		public static bool ColorEdit3(ref byte label, ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorEdit3((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0));
					return ret;
				}
			}
		}

		public static bool ColorEdit3(ref byte label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorEdit3((byte*)plabel, (float*)pcol, flags);
					return ret;
				}
			}
		}

		public static bool ColorEdit3(string label, ref Vector3 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pcol = &col)
			{
				bool ret = ColorEdit3(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ColorEdit3(string label, ref Vector3 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pcol = &col)
			{
				bool ret = ColorEdit3(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorEdit4")]
		public static extern bool ColorEdit4(byte* label, float* col, ImGuiColorEditFlags flags);

		public static bool ColorEdit4(ref byte label, float* col)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorEdit4((byte*)plabel, col, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorEdit4(ref byte label, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorEdit4((byte*)plabel, col, flags);
				return ret;
			}
		}

		public static bool ColorEdit4(string label, float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorEdit4(pStr0, col, (ImGuiColorEditFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorEdit4(string label, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorEdit4(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorEdit4(byte* label, ref float col)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorEdit4(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorEdit4(byte* label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorEdit4(label, (float*)pcol, flags);
				return ret;
			}
		}

		public static bool ColorEdit4(byte* label, ref Vector4 col)
		{
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorEdit4(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorEdit4(byte* label, ref Vector4 col, ImGuiColorEditFlags flags)
		{
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorEdit4(label, (float*)pcol, flags);
				return ret;
			}
		}

		public static bool ColorEdit4(ref byte label, ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorEdit4((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0));
					return ret;
				}
			}
		}

		public static bool ColorEdit4(ref byte label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorEdit4((byte*)plabel, (float*)pcol, flags);
					return ret;
				}
			}
		}

		public static bool ColorEdit4(string label, ref Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorEdit4(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ColorEdit4(string label, ref Vector4 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorEdit4(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorPicker3")]
		public static extern bool ColorPicker3(byte* label, float* col, ImGuiColorEditFlags flags);

		public static bool ColorPicker3(ref byte label, float* col)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorPicker3((byte*)plabel, col, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorPicker3(ref byte label, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorPicker3((byte*)plabel, col, flags);
				return ret;
			}
		}

		public static bool ColorPicker3(string label, float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorPicker3(pStr0, col, (ImGuiColorEditFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorPicker3(string label, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorPicker3(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorPicker3(byte* label, ref float col)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorPicker3(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorPicker3(byte* label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorPicker3(label, (float*)pcol, flags);
				return ret;
			}
		}

		public static bool ColorPicker3(byte* label, ref Vector3 col)
		{
			fixed (Vector3* pcol = &col)
			{
				bool ret = ColorPicker3(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret;
			}
		}

		public static bool ColorPicker3(byte* label, ref Vector3 col, ImGuiColorEditFlags flags)
		{
			fixed (Vector3* pcol = &col)
			{
				bool ret = ColorPicker3(label, (float*)pcol, flags);
				return ret;
			}
		}

		public static bool ColorPicker3(ref byte label, ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorPicker3((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0));
					return ret;
				}
			}
		}

		public static bool ColorPicker3(ref byte label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorPicker3((byte*)plabel, (float*)pcol, flags);
					return ret;
				}
			}
		}

		public static bool ColorPicker3(string label, ref Vector3 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pcol = &col)
			{
				bool ret = ColorPicker3(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ColorPicker3(string label, ref Vector3 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pcol = &col)
			{
				bool ret = ColorPicker3(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorPicker4")]
		public static extern bool ColorPicker4(byte* label, float* col, ImGuiColorEditFlags flags, float* refCol);

		public static bool ColorPicker4(ref byte label, float* col)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorPicker4((byte*)plabel, col, (ImGuiColorEditFlags)(0), (float*)(null));
				return ret;
			}
		}

		public static bool ColorPicker4(ref byte label, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorPicker4((byte*)plabel, col, flags, (float*)(null));
				return ret;
			}
		}

		public static bool ColorPicker4(ref byte label, float* col, ImGuiColorEditFlags flags, float* refCol)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ColorPicker4((byte*)plabel, col, flags, refCol);
				return ret;
			}
		}

		public static bool ColorPicker4(string label, float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorPicker4(pStr0, col, (ImGuiColorEditFlags)(0), (float*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorPicker4(string label, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorPicker4(pStr0, col, flags, (float*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorPicker4(string label, float* col, ImGuiColorEditFlags flags, float* refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorPicker4(pStr0, col, flags, refCol);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorPicker4(byte* label, ref float col)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorPicker4(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(null));
				return ret;
			}
		}

		public static bool ColorPicker4(byte* label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorPicker4(label, (float*)pcol, flags, (float*)(null));
				return ret;
			}
		}

		public static bool ColorPicker4(byte* label, ref float col, ImGuiColorEditFlags flags, float* refCol)
		{
			fixed (float* pcol = &col)
			{
				bool ret = ColorPicker4(label, (float*)pcol, flags, refCol);
				return ret;
			}
		}

		public static bool ColorPicker4(byte* label, ref Vector4 col)
		{
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorPicker4(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(null));
				return ret;
			}
		}

		public static bool ColorPicker4(byte* label, ref Vector4 col, ImGuiColorEditFlags flags)
		{
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorPicker4(label, (float*)pcol, flags, (float*)(null));
				return ret;
			}
		}

		public static bool ColorPicker4(byte* label, ref Vector4 col, ImGuiColorEditFlags flags, float* refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorPicker4(label, (float*)pcol, flags, refCol);
				return ret;
			}
		}

		public static bool ColorPicker4(ref byte label, ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorPicker4((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(null));
					return ret;
				}
			}
		}

		public static bool ColorPicker4(ref byte label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorPicker4((byte*)plabel, (float*)pcol, flags, (float*)(null));
					return ret;
				}
			}
		}

		public static bool ColorPicker4(ref byte label, ref float col, ImGuiColorEditFlags flags, float* refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					bool ret = ColorPicker4((byte*)plabel, (float*)pcol, flags, refCol);
					return ret;
				}
			}
		}

		public static bool ColorPicker4(string label, ref Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorPicker4(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ColorPicker4(string label, ref Vector4 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorPicker4(pStr0, (float*)pcol, flags, (float*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ColorPicker4(string label, ref Vector4 col, ImGuiColorEditFlags flags, float* refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				bool ret = ColorPicker4(pStr0, (float*)pcol, flags, refCol);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ColorPicker4(byte* label, float* col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (float* prefCol = &refCol)
			{
				bool ret = ColorPicker4(label, col, flags, (float*)prefCol);
				return ret;
			}
		}

		public static bool ColorPicker4(ref byte label, float* col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* prefCol = &refCol)
				{
					bool ret = ColorPicker4((byte*)plabel, col, flags, (float*)prefCol);
					return ret;
				}
			}
		}

		public static bool ColorPicker4(string label, float* col, ImGuiColorEditFlags flags, ref float refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* prefCol = &refCol)
			{
				bool ret = ColorPicker4(pStr0, col, flags, (float*)prefCol);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ColorPicker4(byte* label, ref float col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (float* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					bool ret = ColorPicker4(label, (float*)pcol, flags, (float*)prefCol);
					return ret;
				}
			}
		}

		public static bool ColorPicker4(byte* label, ref Vector4 col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					bool ret = ColorPicker4(label, (float*)pcol, flags, (float*)prefCol);
					return ret;
				}
			}
		}

		public static bool ColorPicker4(ref byte label, ref float col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					fixed (float* prefCol = &refCol)
					{
						bool ret = ColorPicker4((byte*)plabel, (float*)pcol, flags, (float*)prefCol);
						return ret;
					}
				}
			}
		}

		public static bool ColorPicker4(string label, ref Vector4 col, ImGuiColorEditFlags flags, ref float refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					bool ret = ColorPicker4(pStr0, (float*)pcol, flags, (float*)prefCol);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorButton")]
		public static extern bool ColorButton(byte* descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size);

		public static bool ColorButton(ref byte descId, Vector4 col)
		{
			fixed (byte* pdescId = &descId)
			{
				bool ret = ColorButton((byte*)pdescId, col, (ImGuiColorEditFlags)(0), new Vector2(0,0));
				return ret;
			}
		}

		public static bool ColorButton(ref byte descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			fixed (byte* pdescId = &descId)
			{
				bool ret = ColorButton((byte*)pdescId, col, flags, new Vector2(0,0));
				return ret;
			}
		}

		public static bool ColorButton(ref byte descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			fixed (byte* pdescId = &descId)
			{
				bool ret = ColorButton((byte*)pdescId, col, flags, size);
				return ret;
			}
		}

		public static bool ColorButton(string descId, Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorButton(pStr0, col, (ImGuiColorEditFlags)(0), new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorButton(string descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorButton(pStr0, col, flags, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ColorButton(string descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ColorButton(pStr0, col, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetColorEditOptions")]
		public static extern void SetColorEditOptions(ImGuiColorEditFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNode_Str")]
		public static extern bool TreeNode(byte* label);

		public static bool TreeNode(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TreeNode((byte*)plabel);
				return ret;
			}
		}

		public static bool TreeNode(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNode(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNode_StrStr")]
		public static extern bool TreeNode(byte* strId, byte* fmt);

		public static bool TreeNode(ref byte strId, byte* fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = TreeNode((byte*)pstrId, fmt);
				return ret;
			}
		}

		public static bool TreeNode(string strId, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNode(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNode(byte* strId, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				bool ret = TreeNode(strId, (byte*)pfmt);
				return ret;
			}
		}

		public static bool TreeNode(byte* strId, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNode(strId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNode(ref byte strId, ref byte fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					bool ret = TreeNode((byte*)pstrId, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static bool TreeNode(string strId, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = TreeNode(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNode_Ptr")]
		public static extern bool TreeNode(void* ptrId, byte* fmt);

		public static bool TreeNode(void* ptrId, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				bool ret = TreeNode(ptrId, (byte*)pfmt);
				return ret;
			}
		}

		public static bool TreeNode(void* ptrId, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNode(ptrId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeV_Str")]
		public static extern bool TreeNodeV(byte* strId, byte* fmt, nuint args);

		public static bool TreeNodeV(ref byte strId, byte* fmt, nuint args)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = TreeNodeV((byte*)pstrId, fmt, args);
				return ret;
			}
		}

		public static bool TreeNodeV(string strId, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeV(pStr0, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeV(byte* strId, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				bool ret = TreeNodeV(strId, (byte*)pfmt, args);
				return ret;
			}
		}

		public static bool TreeNodeV(byte* strId, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeV(strId, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeV(ref byte strId, ref byte fmt, nuint args)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					bool ret = TreeNodeV((byte*)pstrId, (byte*)pfmt, args);
					return ret;
				}
			}
		}

		public static bool TreeNodeV(string strId, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = TreeNodeV(pStr0, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeV_Ptr")]
		public static extern bool TreeNodeV(void* ptrId, byte* fmt, nuint args);

		public static bool TreeNodeV(void* ptrId, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				bool ret = TreeNodeV(ptrId, (byte*)pfmt, args);
				return ret;
			}
		}

		public static bool TreeNodeV(void* ptrId, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeV(ptrId, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeEx_Str")]
		public static extern bool TreeNodeEx(byte* label, ImGuiTreeNodeFlags flags);

		public static bool TreeNodeEx(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TreeNodeEx((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret;
			}
		}

		public static bool TreeNodeEx(ref byte label, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TreeNodeEx((byte*)plabel, flags);
				return ret;
			}
		}

		public static bool TreeNodeEx(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeEx(pStr0, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeEx(string label, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeEx(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeEx_StrStr")]
		public static extern bool TreeNodeEx(byte* strId, ImGuiTreeNodeFlags flags, byte* fmt);

		public static bool TreeNodeEx(ref byte strId, ImGuiTreeNodeFlags flags, byte* fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = TreeNodeEx((byte*)pstrId, flags, fmt);
				return ret;
			}
		}

		public static bool TreeNodeEx(string strId, ImGuiTreeNodeFlags flags, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeEx(pStr0, flags, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeEx(byte* strId, ImGuiTreeNodeFlags flags, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				bool ret = TreeNodeEx(strId, flags, (byte*)pfmt);
				return ret;
			}
		}

		public static bool TreeNodeEx(byte* strId, ImGuiTreeNodeFlags flags, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeEx(strId, flags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeEx(ref byte strId, ImGuiTreeNodeFlags flags, ref byte fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					bool ret = TreeNodeEx((byte*)pstrId, flags, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static bool TreeNodeEx(string strId, ImGuiTreeNodeFlags flags, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = TreeNodeEx(pStr0, flags, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeEx_Ptr")]
		public static extern bool TreeNodeEx(void* ptrId, ImGuiTreeNodeFlags flags, byte* fmt);

		public static bool TreeNodeEx(void* ptrId, ImGuiTreeNodeFlags flags, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				bool ret = TreeNodeEx(ptrId, flags, (byte*)pfmt);
				return ret;
			}
		}

		public static bool TreeNodeEx(void* ptrId, ImGuiTreeNodeFlags flags, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeEx(ptrId, flags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeExV_Str")]
		public static extern bool TreeNodeExV(byte* strId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args);

		public static bool TreeNodeExV(ref byte strId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = TreeNodeExV((byte*)pstrId, flags, fmt, args);
				return ret;
			}
		}

		public static bool TreeNodeExV(string strId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeExV(pStr0, flags, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeExV(byte* strId, ImGuiTreeNodeFlags flags, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				bool ret = TreeNodeExV(strId, flags, (byte*)pfmt, args);
				return ret;
			}
		}

		public static bool TreeNodeExV(byte* strId, ImGuiTreeNodeFlags flags, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeExV(strId, flags, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeExV(ref byte strId, ImGuiTreeNodeFlags flags, ref byte fmt, nuint args)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					bool ret = TreeNodeExV((byte*)pstrId, flags, (byte*)pfmt, args);
					return ret;
				}
			}
		}

		public static bool TreeNodeExV(string strId, ImGuiTreeNodeFlags flags, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = TreeNodeExV(pStr0, flags, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeExV_Ptr")]
		public static extern bool TreeNodeExV(void* ptrId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args);

		public static bool TreeNodeExV(void* ptrId, ImGuiTreeNodeFlags flags, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				bool ret = TreeNodeExV(ptrId, flags, (byte*)pfmt, args);
				return ret;
			}
		}

		public static bool TreeNodeExV(void* ptrId, ImGuiTreeNodeFlags flags, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeExV(ptrId, flags, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreePush_Str")]
		public static extern void TreePush(byte* strId);

		public static void TreePush(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				TreePush((byte*)pstrId);
			}
		}

		public static void TreePush(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TreePush(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreePush_Ptr")]
		public static extern void TreePush(void* ptrId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreePop")]
		public static extern void TreePop();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTreeNodeToLabelSpacing")]
		public static extern float GetTreeNodeToLabelSpacing();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCollapsingHeader_TreeNodeFlags")]
		public static extern bool CollapsingHeader(byte* label, ImGuiTreeNodeFlags flags);

		public static bool CollapsingHeader(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = CollapsingHeader((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret;
			}
		}

		public static bool CollapsingHeader(ref byte label, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = CollapsingHeader((byte*)plabel, flags);
				return ret;
			}
		}

		public static bool CollapsingHeader(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = CollapsingHeader(pStr0, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool CollapsingHeader(string label, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = CollapsingHeader(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCollapsingHeader_BoolPtr")]
		public static extern bool CollapsingHeader(byte* label, bool* pVisible, ImGuiTreeNodeFlags flags);

		public static bool CollapsingHeader(ref byte label, bool* pVisible)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = CollapsingHeader((byte*)plabel, pVisible, (ImGuiTreeNodeFlags)(0));
				return ret;
			}
		}

		public static bool CollapsingHeader(ref byte label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = CollapsingHeader((byte*)plabel, pVisible, flags);
				return ret;
			}
		}

		public static bool CollapsingHeader(string label, bool* pVisible)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = CollapsingHeader(pStr0, pVisible, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool CollapsingHeader(string label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = CollapsingHeader(pStr0, pVisible, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool CollapsingHeader(byte* label, ref bool pVisible)
		{
			fixed (bool* ppVisible = &pVisible)
			{
				bool ret = CollapsingHeader(label, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
				return ret;
			}
		}

		public static bool CollapsingHeader(byte* label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (bool* ppVisible = &pVisible)
			{
				bool ret = CollapsingHeader(label, (bool*)ppVisible, flags);
				return ret;
			}
		}

		public static bool CollapsingHeader(ref byte label, ref bool pVisible)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					bool ret = CollapsingHeader((byte*)plabel, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
					return ret;
				}
			}
		}

		public static bool CollapsingHeader(ref byte label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					bool ret = CollapsingHeader((byte*)plabel, (bool*)ppVisible, flags);
					return ret;
				}
			}
		}

		public static bool CollapsingHeader(string label, ref bool pVisible)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppVisible = &pVisible)
			{
				bool ret = CollapsingHeader(pStr0, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool CollapsingHeader(string label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppVisible = &pVisible)
			{
				bool ret = CollapsingHeader(pStr0, (bool*)ppVisible, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextItemOpen")]
		public static extern void SetNextItemOpen(bool isOpen, ImGuiCond cond);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSelectable_Bool")]
		public static extern bool Selectable(byte* label, bool selected, ImGuiSelectableFlags flags, Vector2 size);

		public static bool Selectable(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Selectable((byte*)plabel, false, (ImGuiSelectableFlags)(0), new Vector2(0,0));
				return ret;
			}
		}

		public static bool Selectable(ref byte label, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Selectable((byte*)plabel, selected, (ImGuiSelectableFlags)(0), new Vector2(0,0));
				return ret;
			}
		}

		public static bool Selectable(ref byte label, bool selected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Selectable((byte*)plabel, selected, flags, new Vector2(0,0));
				return ret;
			}
		}

		public static bool Selectable(ref byte label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Selectable((byte*)plabel, selected, flags, size);
				return ret;
			}
		}

		public static bool Selectable(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Selectable(pStr0, false, (ImGuiSelectableFlags)(0), new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Selectable(string label, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Selectable(pStr0, selected, (ImGuiSelectableFlags)(0), new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Selectable(string label, bool selected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Selectable(pStr0, selected, flags, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Selectable(string label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Selectable(pStr0, selected, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSelectable_BoolPtr")]
		public static extern bool Selectable(byte* label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size);

		public static bool Selectable(ref byte label, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Selectable((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), new Vector2(0,0));
				return ret;
			}
		}

		public static bool Selectable(ref byte label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Selectable((byte*)plabel, pSelected, flags, new Vector2(0,0));
				return ret;
			}
		}

		public static bool Selectable(ref byte label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Selectable((byte*)plabel, pSelected, flags, size);
				return ret;
			}
		}

		public static bool Selectable(string label, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Selectable(pStr0, pSelected, (ImGuiSelectableFlags)(0), new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Selectable(string label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Selectable(pStr0, pSelected, flags, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Selectable(string label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Selectable(pStr0, pSelected, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Selectable(byte* label, ref bool pSelected)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = Selectable(label, (bool*)ppSelected, (ImGuiSelectableFlags)(0), new Vector2(0,0));
				return ret;
			}
		}

		public static bool Selectable(byte* label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = Selectable(label, (bool*)ppSelected, flags, new Vector2(0,0));
				return ret;
			}
		}

		public static bool Selectable(byte* label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = Selectable(label, (bool*)ppSelected, flags, size);
				return ret;
			}
		}

		public static bool Selectable(ref byte label, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					bool ret = Selectable((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), new Vector2(0,0));
					return ret;
				}
			}
		}

		public static bool Selectable(ref byte label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					bool ret = Selectable((byte*)plabel, (bool*)ppSelected, flags, new Vector2(0,0));
					return ret;
				}
			}
		}

		public static bool Selectable(ref byte label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					bool ret = Selectable((byte*)plabel, (bool*)ppSelected, flags, size);
					return ret;
				}
			}
		}

		public static bool Selectable(string label, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = Selectable(pStr0, (bool*)ppSelected, (ImGuiSelectableFlags)(0), new Vector2(0,0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Selectable(string label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = Selectable(pStr0, (bool*)ppSelected, flags, new Vector2(0,0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Selectable(string label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = Selectable(pStr0, (bool*)ppSelected, flags, size);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginListBox")]
		public static extern bool BeginListBox(byte* label, Vector2 size);

		public static bool BeginListBox(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginListBox((byte*)plabel, new Vector2(0,0));
				return ret;
			}
		}

		public static bool BeginListBox(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginListBox((byte*)plabel, size);
				return ret;
			}
		}

		public static bool BeginListBox(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginListBox(pStr0, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginListBox(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginListBox(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndListBox")]
		public static extern void EndListBox();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igListBox_Str_arr")]
		public static extern bool ListBox(byte* label, int* currentItem, byte** items, int itemsCount, int heightInItems);

		public static bool ListBox(ref byte label, int* currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ListBox((byte*)plabel, currentItem, items, itemsCount, -1);
				return ret;
			}
		}

		public static bool ListBox(ref byte label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ListBox((byte*)plabel, currentItem, items, itemsCount, heightInItems);
				return ret;
			}
		}

		public static bool ListBox(string label, int* currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ListBox(pStr0, currentItem, items, itemsCount, -1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ListBox(string label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ListBox(pStr0, currentItem, items, itemsCount, heightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ListBox(byte* label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = ListBox(label, (int*)pcurrentItem, items, itemsCount, -1);
				return ret;
			}
		}

		public static bool ListBox(byte* label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = ListBox(label, (int*)pcurrentItem, items, itemsCount, heightInItems);
				return ret;
			}
		}

		public static bool ListBox(ref byte label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = ListBox((byte*)plabel, (int*)pcurrentItem, items, itemsCount, -1);
					return ret;
				}
			}
		}

		public static bool ListBox(ref byte label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = ListBox((byte*)plabel, (int*)pcurrentItem, items, itemsCount, heightInItems);
					return ret;
				}
			}
		}

		public static bool ListBox(string label, ref int currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = ListBox(pStr0, (int*)pcurrentItem, items, itemsCount, -1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ListBox(string label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = ListBox(pStr0, (int*)pcurrentItem, items, itemsCount, heightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ListBox(byte* label, int* currentItem, string[] items, int itemsCount)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			bool ret = ListBox(label, currentItem, pStrArray0, itemsCount, -1);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			Utils.Free(pStrArray0);
			return ret;
		}

		public static bool ListBox(byte* label, int* currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			bool ret = ListBox(label, currentItem, pStrArray0, itemsCount, heightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			Utils.Free(pStrArray0);
			return ret;
		}

		public static bool ListBox(string label, int* currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			bool ret = ListBox(pStr0, currentItem, pStrArray0, itemsCount, -1);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			Utils.Free(pStrArray0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ListBox(string label, int* currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			bool ret = ListBox(pStr0, currentItem, pStrArray0, itemsCount, heightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			Utils.Free(pStrArray0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ListBox(byte* label, ref int currentItem, string[] items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				bool ret = ListBox(label, (int*)pcurrentItem, pStrArray0, itemsCount, -1);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				Utils.Free(pStrArray0);
				return ret;
			}
		}

		public static bool ListBox(byte* label, ref int currentItem, string[] items, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				bool ret = ListBox(label, (int*)pcurrentItem, pStrArray0, itemsCount, heightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				Utils.Free(pStrArray0);
				return ret;
			}
		}

		public static bool ListBox(string label, ref int currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				bool ret = ListBox(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, -1);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				Utils.Free(pStrArray0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ListBox(string label, ref int currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				bool ret = ListBox(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, heightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				Utils.Free(pStrArray0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igListBox_FnBoolPtr")]
		public static extern bool ListBox(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems);

		public static bool ListBox(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ListBox((byte*)plabel, currentItem, itemsGetter, data, itemsCount, -1);
				return ret;
			}
		}

		public static bool ListBox(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ListBox((byte*)plabel, currentItem, itemsGetter, data, itemsCount, heightInItems);
				return ret;
			}
		}

		public static bool ListBox(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ListBox(pStr0, currentItem, itemsGetter, data, itemsCount, -1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ListBox(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ListBox(pStr0, currentItem, itemsGetter, data, itemsCount, heightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool ListBox(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = ListBox(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, -1);
				return ret;
			}
		}

		public static bool ListBox(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = ListBox(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
				return ret;
			}
		}

		public static bool ListBox(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = ListBox((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, -1);
					return ret;
				}
			}
		}

		public static bool ListBox(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					bool ret = ListBox((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
					return ret;
				}
			}
		}

		public static bool ListBox(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = ListBox(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, -1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool ListBox(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				bool ret = ListBox(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotLines_FloatPtr")]
		public static extern void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride);

		public static void PlotLines(ref byte label, float* values, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, values, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, values, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, values, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, values, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount)
		{
			fixed (float* pvalues = &values)
			{
				PlotLines(label, (float*)pvalues, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset)
		{
			fixed (float* pvalues = &values)
			{
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (float* pvalues = &values)
			{
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLines((byte*)plabel, (float*)pvalues, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLines(pStr0, (float*)pvalues, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, values, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, sizeof(float));
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount)
		{
			PlotLines(label, values, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset)
		{
			PlotLines(label, values, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, values, valuesCount, valuesOffset, pStr0, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, values, valuesCount, valuesOffset, pStr0, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, sizeof(float));
				}
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, pStr1, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, sizeof(float));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, sizeof(float));
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLines(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
					}
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
					}
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
					}
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, sizeof(float));
					}
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLines((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
					}
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, sizeof(float));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLines(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotLines_FnFloatPtr")]
		public static extern void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize);

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, valuesGetter, data, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0));
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			PlotLines(label, valuesGetter, data, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLines(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0));
				}
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0));
				}
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0));
				}
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLines((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
				}
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, float.MaxValue, new Vector2(0,0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, new Vector2(0,0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLines(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotHistogram_FloatPtr")]
		public static extern void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride);

		public static void PlotHistogram(ref byte label, float* values, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, values, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogram(label, (float*)pvalues, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, values, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, sizeof(float));
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount)
		{
			PlotHistogram(label, values, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset)
		{
			PlotHistogram(label, values, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, values, valuesCount, valuesOffset, pStr0, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, values, valuesCount, valuesOffset, pStr0, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, sizeof(float));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, sizeof(float));
				}
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, pStr1, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, sizeof(float));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, sizeof(float));
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, sizeof(float));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogram(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
					}
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
					}
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
					}
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, sizeof(float));
					}
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogram((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
					}
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, float.MaxValue, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, float.MaxValue, new Vector2(0,0), sizeof(float));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, new Vector2(0,0), sizeof(float));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, sizeof(float));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogram(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotHistogram_FnFloatPtr")]
		public static extern void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize);

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0));
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0));
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			PlotHistogram(label, valuesGetter, data, valuesCount, 0, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, (string)null, float.MaxValue, float.MaxValue, new Vector2(0,0));
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, float.MaxValue, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, new Vector2(0,0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogram(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, float.MaxValue, float.MaxValue, new Vector2(0,0));
				}
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, float.MaxValue, new Vector2(0,0));
				}
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, new Vector2(0,0));
				}
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogram((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
				}
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, float.MaxValue, float.MaxValue, new Vector2(0,0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, float.MaxValue, new Vector2(0,0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, new Vector2(0,0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogram(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igValue_Bool")]
		public static extern void Value(byte* prefix, bool b);

		public static void Value(ref byte prefix, bool b)
		{
			fixed (byte* pprefix = &prefix)
			{
				Value((byte*)pprefix, b);
			}
		}

		public static void Value(string prefix, bool b)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Value(pStr0, b);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igValue_Int")]
		public static extern void Value(byte* prefix, int v);

		public static void Value(ref byte prefix, int v)
		{
			fixed (byte* pprefix = &prefix)
			{
				Value((byte*)pprefix, v);
			}
		}

		public static void Value(string prefix, int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Value(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igValue_Uint")]
		public static extern void Value(byte* prefix, uint v);

		public static void Value(ref byte prefix, uint v)
		{
			fixed (byte* pprefix = &prefix)
			{
				Value((byte*)pprefix, v);
			}
		}

		public static void Value(string prefix, uint v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Value(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igValue_Float")]
		public static extern void Value(byte* prefix, float v, byte* floatFormat);

		public static void Value(ref byte prefix, float v)
		{
			fixed (byte* pprefix = &prefix)
			{
				Value((byte*)pprefix, v, (string)null);
			}
		}

		public static void Value(ref byte prefix, float v, byte* floatFormat)
		{
			fixed (byte* pprefix = &prefix)
			{
				Value((byte*)pprefix, v, floatFormat);
			}
		}

		public static void Value(string prefix, float v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Value(pStr0, v, (string)null);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Value(string prefix, float v, byte* floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Value(pStr0, v, floatFormat);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Value(byte* prefix, float v, ref byte floatFormat)
		{
			fixed (byte* pfloatFormat = &floatFormat)
			{
				Value(prefix, v, (byte*)pfloatFormat);
			}
		}

		public static void Value(byte* prefix, float v)
		{
			Value(prefix, v, (string)null);
		}

		public static void Value(byte* prefix, float v, string floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (floatFormat != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(floatFormat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(floatFormat, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Value(prefix, v, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Value(ref byte prefix, float v, ref byte floatFormat)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* pfloatFormat = &floatFormat)
				{
					Value((byte*)pprefix, v, (byte*)pfloatFormat);
				}
			}
		}

		public static void Value(string prefix, float v, string floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (floatFormat != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(floatFormat);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(floatFormat, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Value(pStr0, v, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginMenuBar")]
		public static extern bool BeginMenuBar();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndMenuBar")]
		public static extern void EndMenuBar();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginMainMenuBar")]
		public static extern bool BeginMainMenuBar();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndMainMenuBar")]
		public static extern void EndMainMenuBar();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginMenu")]
		public static extern bool BeginMenu(byte* label, bool enabled);

		public static bool BeginMenu(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginMenu((byte*)plabel, true);
				return ret;
			}
		}

		public static bool BeginMenu(ref byte label, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginMenu((byte*)plabel, enabled);
				return ret;
			}
		}

		public static bool BeginMenu(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginMenu(pStr0, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginMenu(string label, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginMenu(pStr0, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndMenu")]
		public static extern void EndMenu();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMenuItem_Bool")]
		public static extern bool MenuItem(byte* label, byte* shortcut, bool selected, bool enabled);

		public static bool MenuItem(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = MenuItem((byte*)plabel, (string)null, false, true);
				return ret;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = MenuItem((byte*)plabel, shortcut, false, true);
				return ret;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = MenuItem((byte*)plabel, shortcut, selected, true);
				return ret;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = MenuItem((byte*)plabel, shortcut, selected, enabled);
				return ret;
			}
		}

		public static bool MenuItem(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(pStr0, (string)null, false, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(string label, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(pStr0, shortcut, false, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(string label, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(pStr0, shortcut, selected, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(string label, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(pStr0, shortcut, selected, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(byte* label, ref byte shortcut)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				bool ret = MenuItem(label, (byte*)pshortcut, false, true);
				return ret;
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, bool selected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				bool ret = MenuItem(label, (byte*)pshortcut, selected, true);
				return ret;
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				bool ret = MenuItem(label, (byte*)pshortcut, selected, enabled);
				return ret;
			}
		}

		public static bool MenuItem(byte* label)
		{
			bool ret = MenuItem(label, (string)null, false, true);
			return ret;
		}

		public static bool MenuItem(byte* label, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(label, pStr0, false, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(byte* label, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(label, pStr0, selected, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(byte* label, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(label, pStr0, selected, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(ref byte label, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					bool ret = MenuItem((byte*)plabel, (byte*)pshortcut, false, true);
					return ret;
				}
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					bool ret = MenuItem((byte*)plabel, (byte*)pshortcut, selected, true);
					return ret;
				}
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					bool ret = MenuItem((byte*)plabel, (byte*)pshortcut, selected, enabled);
					return ret;
				}
			}
		}

		public static bool MenuItem(string label, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = MenuItem(pStr0, pStr1, false, true);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(string label, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = MenuItem(pStr0, pStr1, selected, true);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(string label, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = MenuItem(pStr0, pStr1, selected, enabled);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMenuItem_BoolPtr")]
		public static extern bool MenuItem(byte* label, byte* shortcut, bool* pSelected, bool enabled);

		public static bool MenuItem(ref byte label, byte* shortcut, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = MenuItem((byte*)plabel, shortcut, pSelected, true);
				return ret;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = MenuItem((byte*)plabel, shortcut, pSelected, enabled);
				return ret;
			}
		}

		public static bool MenuItem(string label, byte* shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(pStr0, shortcut, pSelected, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(string label, byte* shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(pStr0, shortcut, pSelected, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(byte* label, ref byte shortcut, bool* pSelected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				bool ret = MenuItem(label, (byte*)pshortcut, pSelected, true);
				return ret;
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				bool ret = MenuItem(label, (byte*)pshortcut, pSelected, enabled);
				return ret;
			}
		}

		public static bool MenuItem(byte* label, string shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(label, pStr0, pSelected, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(byte* label, string shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItem(label, pStr0, pSelected, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					bool ret = MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, true);
					return ret;
				}
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					bool ret = MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, enabled);
					return ret;
				}
			}
		}

		public static bool MenuItem(string label, string shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = MenuItem(pStr0, pStr1, pSelected, true);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(string label, string shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = MenuItem(pStr0, pStr1, pSelected, enabled);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItem(byte* label, byte* shortcut, ref bool pSelected)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = MenuItem(label, shortcut, (bool*)ppSelected, true);
				return ret;
			}
		}

		public static bool MenuItem(byte* label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = MenuItem(label, shortcut, (bool*)ppSelected, enabled);
				return ret;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					bool ret = MenuItem((byte*)plabel, shortcut, (bool*)ppSelected, true);
					return ret;
				}
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					bool ret = MenuItem((byte*)plabel, shortcut, (bool*)ppSelected, enabled);
					return ret;
				}
			}
		}

		public static bool MenuItem(string label, byte* shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = MenuItem(pStr0, shortcut, (bool*)ppSelected, true);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool MenuItem(string label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = MenuItem(pStr0, shortcut, (bool*)ppSelected, enabled);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, ref bool pSelected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					bool ret = MenuItem(label, (byte*)pshortcut, (bool*)ppSelected, true);
					return ret;
				}
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					bool ret = MenuItem(label, (byte*)pshortcut, (bool*)ppSelected, enabled);
					return ret;
				}
			}
		}

		public static bool MenuItem(byte* label, string shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = MenuItem(label, pStr0, (bool*)ppSelected, true);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool MenuItem(byte* label, string shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = MenuItem(label, pStr0, (bool*)ppSelected, enabled);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						bool ret = MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, true);
						return ret;
					}
				}
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						bool ret = MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, enabled);
						return ret;
					}
				}
			}
		}

		public static bool MenuItem(string label, string shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = MenuItem(pStr0, pStr1, (bool*)ppSelected, true);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool MenuItem(string label, string shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				bool ret = MenuItem(pStr0, pStr1, (bool*)ppSelected, enabled);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTooltip")]
		public static extern bool BeginTooltip();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndTooltip")]
		public static extern void EndTooltip();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetTooltip")]
		public static extern void SetTooltip(byte* fmt);

		public static void SetTooltip(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SetTooltip((byte*)pfmt);
			}
		}

		public static void SetTooltip(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTooltip(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetTooltipV")]
		public static extern void SetTooltipV(byte* fmt, nuint args);

		public static void SetTooltipV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				SetTooltipV((byte*)pfmt, args);
			}
		}

		public static void SetTooltipV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTooltipV(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopup")]
		public static extern bool BeginPopup(byte* strId, ImGuiWindowFlags flags);

		public static bool BeginPopup(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginPopup((byte*)pstrId, (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool BeginPopup(ref byte strId, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginPopup((byte*)pstrId, flags);
				return ret;
			}
		}

		public static bool BeginPopup(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopup(pStr0, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginPopup(string strId, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopup(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupModal")]
		public static extern bool BeginPopupModal(byte* name, bool* pOpen, ImGuiWindowFlags flags);

		public static bool BeginPopupModal(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				bool ret = BeginPopupModal((byte*)pname, (bool*)(null), (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool BeginPopupModal(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				bool ret = BeginPopupModal((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool BeginPopupModal(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				bool ret = BeginPopupModal((byte*)pname, pOpen, flags);
				return ret;
			}
		}

		public static bool BeginPopupModal(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupModal(pStr0, (bool*)(null), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginPopupModal(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupModal(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginPopupModal(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupModal(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginPopupModal(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = BeginPopupModal(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret;
			}
		}

		public static bool BeginPopupModal(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = BeginPopupModal(name, (bool*)ppOpen, flags);
				return ret;
			}
		}

		public static bool BeginPopupModal(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = BeginPopupModal((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret;
				}
			}
		}

		public static bool BeginPopupModal(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = BeginPopupModal((byte*)pname, (bool*)ppOpen, flags);
					return ret;
				}
			}
		}

		public static bool BeginPopupModal(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = BeginPopupModal(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool BeginPopupModal(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = BeginPopupModal(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndPopup")]
		public static extern void EndPopup();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igOpenPopup_Str")]
		public static extern void OpenPopup(byte* strId, ImGuiPopupFlags popupFlags);

		public static void OpenPopup(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				OpenPopup((byte*)pstrId, (ImGuiPopupFlags)(0));
			}
		}

		public static void OpenPopup(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				OpenPopup((byte*)pstrId, popupFlags);
			}
		}

		public static void OpenPopup(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenPopup(pStr0, (ImGuiPopupFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void OpenPopup(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenPopup(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igOpenPopup_ID")]
		public static extern void OpenPopup(int id, ImGuiPopupFlags popupFlags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igOpenPopupOnItemClick")]
		public static extern void OpenPopupOnItemClick(byte* strId, ImGuiPopupFlags popupFlags);

		public static void OpenPopupOnItemClick(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				OpenPopupOnItemClick((byte*)pstrId, (ImGuiPopupFlags)(1));
			}
		}

		public static void OpenPopupOnItemClick(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				OpenPopupOnItemClick((byte*)pstrId, popupFlags);
			}
		}

		public static void OpenPopupOnItemClick()
		{
			OpenPopupOnItemClick((string)null, (ImGuiPopupFlags)(1));
		}

		public static void OpenPopupOnItemClick(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenPopupOnItemClick(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void OpenPopupOnItemClick(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenPopupOnItemClick(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCloseCurrentPopup")]
		public static extern void CloseCurrentPopup();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupContextItem")]
		public static extern bool BeginPopupContextItem(byte* strId, ImGuiPopupFlags popupFlags);

		public static bool BeginPopupContextItem(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginPopupContextItem((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret;
			}
		}

		public static bool BeginPopupContextItem(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginPopupContextItem((byte*)pstrId, popupFlags);
				return ret;
			}
		}

		public static bool BeginPopupContextItem()
		{
			bool ret = BeginPopupContextItem((string)null, (ImGuiPopupFlags)(1));
			return ret;
		}

		public static bool BeginPopupContextItem(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupContextItem(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginPopupContextItem(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupContextItem(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupContextWindow")]
		public static extern bool BeginPopupContextWindow(byte* strId, ImGuiPopupFlags popupFlags);

		public static bool BeginPopupContextWindow(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginPopupContextWindow((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret;
			}
		}

		public static bool BeginPopupContextWindow(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginPopupContextWindow((byte*)pstrId, popupFlags);
				return ret;
			}
		}

		public static bool BeginPopupContextWindow()
		{
			bool ret = BeginPopupContextWindow((string)null, (ImGuiPopupFlags)(1));
			return ret;
		}

		public static bool BeginPopupContextWindow(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupContextWindow(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginPopupContextWindow(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupContextWindow(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupContextVoid")]
		public static extern bool BeginPopupContextVoid(byte* strId, ImGuiPopupFlags popupFlags);

		public static bool BeginPopupContextVoid(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginPopupContextVoid((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret;
			}
		}

		public static bool BeginPopupContextVoid(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginPopupContextVoid((byte*)pstrId, popupFlags);
				return ret;
			}
		}

		public static bool BeginPopupContextVoid()
		{
			bool ret = BeginPopupContextVoid((string)null, (ImGuiPopupFlags)(1));
			return ret;
		}

		public static bool BeginPopupContextVoid(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupContextVoid(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginPopupContextVoid(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginPopupContextVoid(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsPopupOpen_Str")]
		public static extern bool IsPopupOpen(byte* strId, ImGuiPopupFlags flags);

		public static bool IsPopupOpen(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = IsPopupOpen((byte*)pstrId, (ImGuiPopupFlags)(0));
				return ret;
			}
		}

		public static bool IsPopupOpen(ref byte strId, ImGuiPopupFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = IsPopupOpen((byte*)pstrId, flags);
				return ret;
			}
		}

		public static bool IsPopupOpen(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = IsPopupOpen(pStr0, (ImGuiPopupFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool IsPopupOpen(string strId, ImGuiPopupFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = IsPopupOpen(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTable")]
		public static extern bool BeginTable(byte* strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth);

		public static bool BeginTable(ref byte strId, int column)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), new Vector2(0.0f,0.0f), 0.0f);
				return ret;
			}
		}

		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginTable((byte*)pstrId, column, flags, new Vector2(0.0f,0.0f), 0.0f);
				return ret;
			}
		}

		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginTable((byte*)pstrId, column, flags, outerSize, 0.0f);
				return ret;
			}
		}

		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginTable((byte*)pstrId, column, flags, outerSize, innerWidth);
				return ret;
			}
		}

		public static bool BeginTable(string strId, int column)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTable(pStr0, column, (ImGuiTableFlags)(0), new Vector2(0.0f,0.0f), 0.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTable(pStr0, column, flags, new Vector2(0.0f,0.0f), 0.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTable(pStr0, column, flags, outerSize, 0.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTable(pStr0, column, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndTable")]
		public static extern void EndTable();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableNextRow")]
		public static extern void TableNextRow(ImGuiTableRowFlags rowFlags, float minRowHeight);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableNextColumn")]
		public static extern bool TableNextColumn();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnIndex")]
		public static extern bool TableSetColumnIndex(int columnN);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetupColumn")]
		public static extern void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight, int userId);

		public static void TableSetupColumn(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), 0.0f, (int)(0));
			}
		}

		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumn((byte*)plabel, flags, 0.0f, (int)(0));
			}
		}

		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumn((byte*)plabel, flags, initWidthOrWeight, (int)(0));
			}
		}

		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, float initWidthOrWeight, int userId)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumn((byte*)plabel, flags, initWidthOrWeight, userId);
			}
		}

		public static void TableSetupColumn(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumn(pStr0, (ImGuiTableColumnFlags)(0), 0.0f, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumn(pStr0, flags, 0.0f, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumn(pStr0, flags, initWidthOrWeight, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, float initWidthOrWeight, int userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumn(pStr0, flags, initWidthOrWeight, userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetupScrollFreeze")]
		public static extern void TableSetupScrollFreeze(int cols, int rows);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableHeadersRow")]
		public static extern void TableHeadersRow();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableHeader")]
		public static extern void TableHeader(byte* label);

		public static void TableHeader(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				TableHeader((byte*)plabel);
			}
		}

		public static void TableHeader(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableHeader(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetSortSpecs")]
		public static extern ImGuiTableSortSpecs* TableGetSortSpecs();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnCount")]
		public static extern int TableGetColumnCount();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnIndex")]
		public static extern int TableGetColumnIndex();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetRowIndex")]
		public static extern int TableGetRowIndex();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnName_Int")]
		public static extern byte* TableGetColumnName(int columnN);

		public static string TableGetColumnNameS()
		{
			string ret = Marshal.PtrToStringAnsi((nint)TableGetColumnName(-1));
			return ret;
		}

		public static string TableGetColumnNameS(int columnN)
		{
			string ret = Marshal.PtrToStringAnsi((nint)TableGetColumnName(columnN));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnFlags")]
		public static extern ImGuiTableColumnFlags TableGetColumnFlags(int columnN);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnEnabled")]
		public static extern void TableSetColumnEnabled(int columnN, bool v);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetBgColor")]
		public static extern void TableSetBgColor(ImGuiTableBgTarget target, uint color, int columnN);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColumns")]
		public static extern void Columns(int count, byte* id, bool border);

		public static void Columns(int count, ref byte id)
		{
			fixed (byte* pid = &id)
			{
				Columns(count, (byte*)pid, true);
			}
		}

		public static void Columns(int count, ref byte id, bool border)
		{
			fixed (byte* pid = &id)
			{
				Columns(count, (byte*)pid, border);
			}
		}

		public static void Columns()
		{
			Columns(1, (string)null, true);
		}

		public static void Columns(int count)
		{
			Columns(count, (string)null, true);
		}

		public static void Columns(int count, string id)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Columns(count, pStr0, true);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Columns(int count, string id, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Columns(count, pStr0, border);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNextColumn")]
		public static extern void NextColumn();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnIndex")]
		public static extern int GetColumnIndex();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnWidth")]
		public static extern float GetColumnWidth(int columnIndex);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetColumnWidth")]
		public static extern void SetColumnWidth(int columnIndex, float width);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnOffset")]
		public static extern float GetColumnOffset(int columnIndex);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetColumnOffset")]
		public static extern void SetColumnOffset(int columnIndex, float offsetX);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnsCount")]
		public static extern int GetColumnsCount();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTabBar")]
		public static extern bool BeginTabBar(byte* strId, ImGuiTabBarFlags flags);

		public static bool BeginTabBar(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginTabBar((byte*)pstrId, (ImGuiTabBarFlags)(0));
				return ret;
			}
		}

		public static bool BeginTabBar(ref byte strId, ImGuiTabBarFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = BeginTabBar((byte*)pstrId, flags);
				return ret;
			}
		}

		public static bool BeginTabBar(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTabBar(pStr0, (ImGuiTabBarFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginTabBar(string strId, ImGuiTabBarFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTabBar(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndTabBar")]
		public static extern void EndTabBar();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTabItem")]
		public static extern bool BeginTabItem(byte* label, bool* pOpen, ImGuiTabItemFlags flags);

		public static bool BeginTabItem(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginTabItem((byte*)plabel, (bool*)(null), (ImGuiTabItemFlags)(0));
				return ret;
			}
		}

		public static bool BeginTabItem(ref byte label, bool* pOpen)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginTabItem((byte*)plabel, pOpen, (ImGuiTabItemFlags)(0));
				return ret;
			}
		}

		public static bool BeginTabItem(ref byte label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginTabItem((byte*)plabel, pOpen, flags);
				return ret;
			}
		}

		public static bool BeginTabItem(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTabItem(pStr0, (bool*)(null), (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginTabItem(string label, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTabItem(pStr0, pOpen, (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginTabItem(string label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTabItem(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginTabItem(byte* label, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = BeginTabItem(label, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
				return ret;
			}
		}

		public static bool BeginTabItem(byte* label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = BeginTabItem(label, (bool*)ppOpen, flags);
				return ret;
			}
		}

		public static bool BeginTabItem(ref byte label, ref bool pOpen)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = BeginTabItem((byte*)plabel, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
					return ret;
				}
			}
		}

		public static bool BeginTabItem(ref byte label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = BeginTabItem((byte*)plabel, (bool*)ppOpen, flags);
					return ret;
				}
			}
		}

		public static bool BeginTabItem(string label, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = BeginTabItem(pStr0, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool BeginTabItem(string label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = BeginTabItem(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndTabItem")]
		public static extern void EndTabItem();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemButton")]
		public static extern bool TabItemButton(byte* label, ImGuiTabItemFlags flags);

		public static bool TabItemButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TabItemButton((byte*)plabel, (ImGuiTabItemFlags)(0));
				return ret;
			}
		}

		public static bool TabItemButton(ref byte label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TabItemButton((byte*)plabel, flags);
				return ret;
			}
		}

		public static bool TabItemButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TabItemButton(pStr0, (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TabItemButton(string label, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TabItemButton(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetTabItemClosed")]
		public static extern void SetTabItemClosed(byte* tabOrDockedWindowLabel);

		public static void SetTabItemClosed(ref byte tabOrDockedWindowLabel)
		{
			fixed (byte* ptabOrDockedWindowLabel = &tabOrDockedWindowLabel)
			{
				SetTabItemClosed((byte*)ptabOrDockedWindowLabel);
			}
		}

		public static void SetTabItemClosed(string tabOrDockedWindowLabel)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tabOrDockedWindowLabel != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tabOrDockedWindowLabel);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tabOrDockedWindowLabel, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTabItemClosed(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockSpace")]
		public static extern int DockSpace(int id, Vector2 size, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass);

		public static int DockSpace(int id, Vector2 size, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				int ret = DockSpace(id, size, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockSpaceOverViewport")]
		public static extern int DockSpaceOverViewport(ImGuiViewport* viewport, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass);

		public static int DockSpaceOverViewport(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				int ret = DockSpaceOverViewport((ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(null));
				return ret;
			}
		}

		public static int DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				int ret = DockSpaceOverViewport((ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)(null));
				return ret;
			}
		}

		public static int DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				int ret = DockSpaceOverViewport((ImGuiViewport*)pviewport, flags, windowClass);
				return ret;
			}
		}

		public static int DockSpaceOverViewport(ImGuiViewport* viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				int ret = DockSpaceOverViewport(viewport, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		public static int DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				fixed (ImGuiWindowClass* pwindowClass = &windowClass)
				{
					int ret = DockSpaceOverViewport((ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)pwindowClass);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowDockID")]
		public static extern void SetNextWindowDockID(int dockId, ImGuiCond cond);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowClass")]
		public static extern void SetNextWindowClass(ImGuiWindowClass* windowClass);

		public static void SetNextWindowClass(ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				SetNextWindowClass((ImGuiWindowClass*)pwindowClass);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowDockID")]
		public static extern int GetWindowDockID();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowDocked")]
		public static extern bool IsWindowDocked();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogToTTY")]
		public static extern void LogToTTY(int autoOpenDepth);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogToFile")]
		public static extern void LogToFile(int autoOpenDepth, byte* filename);

		public static void LogToFile(int autoOpenDepth, ref byte filename)
		{
			fixed (byte* pfilename = &filename)
			{
				LogToFile(autoOpenDepth, (byte*)pfilename);
			}
		}

		public static void LogToFile()
		{
			LogToFile(-1, (string)null);
		}

		public static void LogToFile(int autoOpenDepth)
		{
			LogToFile(autoOpenDepth, (string)null);
		}

		public static void LogToFile(int autoOpenDepth, string filename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogToFile(autoOpenDepth, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogToClipboard")]
		public static extern void LogToClipboard(int autoOpenDepth);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogFinish")]
		public static extern void LogFinish();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogButtons")]
		public static extern void LogButtons();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogTextV")]
		public static extern void LogTextV(byte* fmt, nuint args);

		public static void LogTextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogTextV((byte*)pfmt, args);
			}
		}

		public static void LogTextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogTextV(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDragDropSource")]
		public static extern bool BeginDragDropSource(ImGuiDragDropFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetDragDropPayload")]
		public static extern bool SetDragDropPayload(byte* type, void* data, nuint sz, ImGuiCond cond);

		public static bool SetDragDropPayload(ref byte type, void* data, nuint sz)
		{
			fixed (byte* ptype = &type)
			{
				bool ret = SetDragDropPayload((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret;
			}
		}

		public static bool SetDragDropPayload(ref byte type, void* data, nuint sz, ImGuiCond cond)
		{
			fixed (byte* ptype = &type)
			{
				bool ret = SetDragDropPayload((byte*)ptype, data, sz, cond);
				return ret;
			}
		}

		public static bool SetDragDropPayload(string type, void* data, nuint sz)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SetDragDropPayload(pStr0, data, sz, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SetDragDropPayload(string type, void* data, nuint sz, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SetDragDropPayload(pStr0, data, sz, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndDragDropSource")]
		public static extern void EndDragDropSource();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDragDropTarget")]
		public static extern bool BeginDragDropTarget();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igAcceptDragDropPayload")]
		public static extern ImGuiPayload* AcceptDragDropPayload(byte* type, ImGuiDragDropFlags flags);

		public static ImGuiPayload* AcceptDragDropPayload(ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayload* ret = AcceptDragDropPayload((byte*)ptype, (ImGuiDragDropFlags)(0));
				return ret;
			}
		}

		public static ImGuiPayload* AcceptDragDropPayload(ref byte type, ImGuiDragDropFlags flags)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayload* ret = AcceptDragDropPayload((byte*)ptype, flags);
				return ret;
			}
		}

		public static ImGuiPayload* AcceptDragDropPayload(string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayload* ret = AcceptDragDropPayload(pStr0, (ImGuiDragDropFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImGuiPayload* AcceptDragDropPayload(string type, ImGuiDragDropFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayload* ret = AcceptDragDropPayload(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndDragDropTarget")]
		public static extern void EndDragDropTarget();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetDragDropPayload")]
		public static extern ImGuiPayload* GetDragDropPayload();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDisabled")]
		public static extern void BeginDisabled(bool disabled);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndDisabled")]
		public static extern void EndDisabled();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushClipRect")]
		public static extern void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopClipRect")]
		public static extern void PopClipRect();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetItemDefaultFocus")]
		public static extern void SetItemDefaultFocus();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetKeyboardFocusHere")]
		public static extern void SetKeyboardFocusHere(int offset);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemHovered")]
		public static extern bool IsItemHovered(ImGuiHoveredFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemActive")]
		public static extern bool IsItemActive();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemFocused")]
		public static extern bool IsItemFocused();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemClicked")]
		public static extern bool IsItemClicked(ImGuiMouseButton mouseButton);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemVisible")]
		public static extern bool IsItemVisible();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemEdited")]
		public static extern bool IsItemEdited();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemActivated")]
		public static extern bool IsItemActivated();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemDeactivated")]
		public static extern bool IsItemDeactivated();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemDeactivatedAfterEdit")]
		public static extern bool IsItemDeactivatedAfterEdit();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemToggledOpen")]
		public static extern bool IsItemToggledOpen();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAnyItemHovered")]
		public static extern bool IsAnyItemHovered();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAnyItemActive")]
		public static extern bool IsAnyItemActive();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAnyItemFocused")]
		public static extern bool IsAnyItemFocused();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemID")]
		public static extern int GetItemID();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemRectMin")]
		public static extern void GetItemRectMin(Vector2* output);

		public static void GetItemRectMin(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetItemRectMin((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemRectMax")]
		public static extern void GetItemRectMax(Vector2* output);

		public static void GetItemRectMax(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetItemRectMax((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemRectSize")]
		public static extern void GetItemRectSize(Vector2* output);

		public static void GetItemRectSize(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetItemRectSize((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetItemAllowOverlap")]
		public static extern void SetItemAllowOverlap();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMainViewport")]
		public static extern ImGuiViewport* GetMainViewport();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetBackgroundDrawList_Nil")]
		public static extern ImDrawList* GetBackgroundDrawList();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetForegroundDrawList_Nil")]
		public static extern ImDrawList* GetForegroundDrawList();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetBackgroundDrawList_ViewportPtr")]
		public static extern ImDrawList* GetBackgroundDrawList(ImGuiViewport* viewport);

		public static ImDrawList* GetBackgroundDrawList(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawList* ret = GetBackgroundDrawList((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetForegroundDrawList_ViewportPtr")]
		public static extern ImDrawList* GetForegroundDrawList(ImGuiViewport* viewport);

		public static ImDrawList* GetForegroundDrawList(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawList* ret = GetForegroundDrawList((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsRectVisible_Nil")]
		public static extern bool IsRectVisible(Vector2 size);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsRectVisible_Vec2")]
		public static extern bool IsRectVisible(Vector2 rectMin, Vector2 rectMax);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTime")]
		public static extern double GetTime();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFrameCount")]
		public static extern int GetFrameCount();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetDrawListSharedData")]
		public static extern ImDrawListSharedData* GetDrawListSharedData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStyleColorName")]
		public static extern byte* GetStyleColorName(ImGuiCol idx);

		public static string GetStyleColorNameS(ImGuiCol idx)
		{
			string ret = Marshal.PtrToStringAnsi((nint)GetStyleColorName(idx));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetStateStorage")]
		public static extern void SetStateStorage(ImGuiStorage* storage);

		public static void SetStateStorage(ref ImGuiStorage storage)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				SetStateStorage((ImGuiStorage*)pstorage);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStateStorage")]
		public static extern ImGuiStorage* GetStateStorage();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginChildFrame")]
		public static extern bool BeginChildFrame(int id, Vector2 size, ImGuiWindowFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndChildFrame")]
		public static extern void EndChildFrame();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcTextSize")]
		public static extern void CalcTextSize(Vector2* output, byte* text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth);

		public static void CalcTextSize(ref Vector2 output, byte* text)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSize((Vector2*)poutput, text, (string)null, false, -1.0f);
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSize((Vector2*)poutput, text, textEnd, false, -1.0f);
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSize((Vector2*)poutput, text, textEnd, hideTextAfterDoubleHash, -1.0f);
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSize((Vector2*)poutput, text, textEnd, hideTextAfterDoubleHash, wrapWidth);
			}
		}

		public static void CalcTextSize(Vector2* output, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSize(output, (byte*)ptext, (string)null, false, -1.0f);
			}
		}

		public static void CalcTextSize(Vector2* output, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSize(output, (byte*)ptext, textEnd, false, -1.0f);
			}
		}

		public static void CalcTextSize(Vector2* output, ref byte text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSize(output, (byte*)ptext, textEnd, hideTextAfterDoubleHash, -1.0f);
			}
		}

		public static void CalcTextSize(Vector2* output, ref byte text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSize(output, (byte*)ptext, textEnd, hideTextAfterDoubleHash, wrapWidth);
			}
		}

		public static void CalcTextSize(Vector2* output, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSize(output, pStr0, (string)null, false, -1.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(Vector2* output, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSize(output, pStr0, textEnd, false, -1.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(Vector2* output, string text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSize(output, pStr0, textEnd, hideTextAfterDoubleHash, -1.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(Vector2* output, string text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSize(output, pStr0, textEnd, hideTextAfterDoubleHash, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSize((Vector2*)poutput, (byte*)ptext, (string)null, false, -1.0f);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSize((Vector2*)poutput, (byte*)ptext, textEnd, false, -1.0f);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSize((Vector2*)poutput, (byte*)ptext, textEnd, hideTextAfterDoubleHash, -1.0f);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSize((Vector2*)poutput, (byte*)ptext, textEnd, hideTextAfterDoubleHash, wrapWidth);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSize((Vector2*)poutput, pStr0, (string)null, false, -1.0f);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSize((Vector2*)poutput, pStr0, textEnd, false, -1.0f);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSize((Vector2*)poutput, pStr0, textEnd, hideTextAfterDoubleHash, -1.0f);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSize((Vector2*)poutput, pStr0, textEnd, hideTextAfterDoubleHash, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(Vector2* output, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSize(output, text, (byte*)ptextEnd, false, -1.0f);
			}
		}

		public static void CalcTextSize(Vector2* output, byte* text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSize(output, text, (byte*)ptextEnd, hideTextAfterDoubleHash, -1.0f);
			}
		}

		public static void CalcTextSize(Vector2* output, byte* text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSize(output, text, (byte*)ptextEnd, hideTextAfterDoubleHash, wrapWidth);
			}
		}

		public static void CalcTextSize(Vector2* output, byte* text)
		{
			CalcTextSize(output, text, (string)null, false, -1.0f);
		}

		public static void CalcTextSize(Vector2* output, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSize(output, text, pStr0, false, -1.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(Vector2* output, byte* text, string textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSize(output, text, pStr0, hideTextAfterDoubleHash, -1.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(Vector2* output, byte* text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSize(output, text, pStr0, hideTextAfterDoubleHash, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSize((Vector2*)poutput, text, (byte*)ptextEnd, false, -1.0f);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSize((Vector2*)poutput, text, (byte*)ptextEnd, hideTextAfterDoubleHash, -1.0f);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSize((Vector2*)poutput, text, (byte*)ptextEnd, hideTextAfterDoubleHash, wrapWidth);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSize((Vector2*)poutput, text, pStr0, false, -1.0f);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, string textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSize((Vector2*)poutput, text, pStr0, hideTextAfterDoubleHash, -1.0f);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSize((Vector2*)poutput, text, pStr0, hideTextAfterDoubleHash, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(Vector2* output, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSize(output, (byte*)ptext, (byte*)ptextEnd, false, -1.0f);
				}
			}
		}

		public static void CalcTextSize(Vector2* output, ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSize(output, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash, -1.0f);
				}
			}
		}

		public static void CalcTextSize(Vector2* output, ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSize(output, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash, wrapWidth);
				}
			}
		}

		public static void CalcTextSize(Vector2* output, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSize(output, pStr0, pStr1, false, -1.0f);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(Vector2* output, string text, string textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSize(output, pStr0, pStr1, hideTextAfterDoubleHash, -1.0f);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(Vector2* output, string text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSize(output, pStr0, pStr1, hideTextAfterDoubleHash, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSize((Vector2*)poutput, (byte*)ptext, (byte*)ptextEnd, false, -1.0f);
					}
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSize((Vector2*)poutput, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash, -1.0f);
					}
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSize((Vector2*)poutput, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash, wrapWidth);
					}
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSize((Vector2*)poutput, pStr0, pStr1, false, -1.0f);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, string textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSize((Vector2*)poutput, pStr0, pStr1, hideTextAfterDoubleHash, -1.0f);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSize((Vector2*)poutput, pStr0, pStr1, hideTextAfterDoubleHash, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorConvertU32ToFloat4")]
		public static extern void ColorConvertU32ToFloat4(Vector4* output, uint input);

		public static void ColorConvertU32ToFloat4(ref Vector4 output, uint input)
		{
			fixed (Vector4* poutput = &output)
			{
				ColorConvertU32ToFloat4((Vector4*)poutput, input);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorConvertFloat4ToU32")]
		public static extern uint ColorConvertFloat4ToU32(Vector4 input);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorConvertRGBtoHSV")]
		public static extern void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, float* outS, float* outV);

		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, float* outS, float* outV)
		{
			fixed (float* poutH = &outH)
			{
				ColorConvertRGBtoHSV(r, g, b, (float*)poutH, outS, outV);
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, ref float outS, float* outV)
		{
			fixed (float* poutS = &outS)
			{
				ColorConvertRGBtoHSV(r, g, b, outH, (float*)poutS, outV);
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, ref float outS, float* outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					ColorConvertRGBtoHSV(r, g, b, (float*)poutH, (float*)poutS, outV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, float* outS, ref float outV)
		{
			fixed (float* poutV = &outV)
			{
				ColorConvertRGBtoHSV(r, g, b, outH, outS, (float*)poutV);
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, float* outS, ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSV(r, g, b, (float*)poutH, outS, (float*)poutV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, ref float outS, ref float outV)
		{
			fixed (float* poutS = &outS)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSV(r, g, b, outH, (float*)poutS, (float*)poutV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, ref float outS, ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					fixed (float* poutV = &outV)
					{
						ColorConvertRGBtoHSV(r, g, b, (float*)poutH, (float*)poutS, (float*)poutV);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorConvertHSVtoRGB")]
		public static extern void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, float* outG, float* outB);

		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, float* outG, float* outB)
		{
			fixed (float* poutR = &outR)
			{
				ColorConvertHSVtoRGB(h, s, v, (float*)poutR, outG, outB);
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, ref float outG, float* outB)
		{
			fixed (float* poutG = &outG)
			{
				ColorConvertHSVtoRGB(h, s, v, outR, (float*)poutG, outB);
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, ref float outG, float* outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					ColorConvertHSVtoRGB(h, s, v, (float*)poutR, (float*)poutG, outB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, float* outG, ref float outB)
		{
			fixed (float* poutB = &outB)
			{
				ColorConvertHSVtoRGB(h, s, v, outR, outG, (float*)poutB);
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, float* outG, ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGB(h, s, v, (float*)poutR, outG, (float*)poutB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, ref float outG, ref float outB)
		{
			fixed (float* poutG = &outG)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGB(h, s, v, outR, (float*)poutG, (float*)poutB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, ref float outG, ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					fixed (float* poutB = &outB)
					{
						ColorConvertHSVtoRGB(h, s, v, (float*)poutR, (float*)poutG, (float*)poutB);
					}
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyDown_Nil")]
		public static extern bool IsKeyDown(ImGuiKey key);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyPressed_Bool")]
		public static extern bool IsKeyPressed(ImGuiKey key, bool repeat);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyReleased_Nil")]
		public static extern bool IsKeyReleased(ImGuiKey key);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyPressedAmount")]
		public static extern int GetKeyPressedAmount(ImGuiKey key, float repeatDelay, float rate);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyName")]
		public static extern byte* GetKeyName(ImGuiKey key);

		public static string GetKeyNameS(ImGuiKey key)
		{
			string ret = Marshal.PtrToStringAnsi((nint)GetKeyName(key));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextFrameWantCaptureKeyboard")]
		public static extern void SetNextFrameWantCaptureKeyboard(bool wantCaptureKeyboard);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDown_Nil")]
		public static extern bool IsMouseDown(ImGuiMouseButton button);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseClicked_Bool")]
		public static extern bool IsMouseClicked(ImGuiMouseButton button, bool repeat);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseReleased_Nil")]
		public static extern bool IsMouseReleased(ImGuiMouseButton button);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDoubleClicked")]
		public static extern bool IsMouseDoubleClicked(ImGuiMouseButton button);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMouseClickedCount")]
		public static extern int GetMouseClickedCount(ImGuiMouseButton button);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseHoveringRect")]
		public static extern bool IsMouseHoveringRect(Vector2 rMin, Vector2 rMax, bool clip);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMousePosValid")]
		public static extern bool IsMousePosValid(Vector2* mousePos);

		public static bool IsMousePosValid(ref Vector2 mousePos)
		{
			fixed (Vector2* pmousePos = &mousePos)
			{
				bool ret = IsMousePosValid((Vector2*)pmousePos);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAnyMouseDown")]
		public static extern bool IsAnyMouseDown();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMousePos")]
		public static extern void GetMousePos(Vector2* output);

		public static void GetMousePos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMousePos((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMousePosOnOpeningCurrentPopup")]
		public static extern void GetMousePosOnOpeningCurrentPopup(Vector2* output);

		public static void GetMousePosOnOpeningCurrentPopup(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMousePosOnOpeningCurrentPopup((Vector2*)poutput);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDragging")]
		public static extern bool IsMouseDragging(ImGuiMouseButton button, float lockThreshold);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMouseDragDelta")]
		public static extern void GetMouseDragDelta(Vector2* output, ImGuiMouseButton button, float lockThreshold);

		public static void GetMouseDragDelta(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMouseDragDelta((Vector2*)poutput, (ImGuiMouseButton)(0), -1.0f);
			}
		}

		public static void GetMouseDragDelta(ref Vector2 output, ImGuiMouseButton button)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMouseDragDelta((Vector2*)poutput, button, -1.0f);
			}
		}

		public static void GetMouseDragDelta(ref Vector2 output, ImGuiMouseButton button, float lockThreshold)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMouseDragDelta((Vector2*)poutput, button, lockThreshold);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igResetMouseDragDelta")]
		public static extern void ResetMouseDragDelta(ImGuiMouseButton button);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMouseCursor")]
		public static extern ImGuiMouseCursor GetMouseCursor();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetMouseCursor")]
		public static extern void SetMouseCursor(ImGuiMouseCursor cursorType);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextFrameWantCaptureMouse")]
		public static extern void SetNextFrameWantCaptureMouse(bool wantCaptureMouse);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetClipboardText")]
		public static extern byte* GetClipboardText();

		public static string GetClipboardTextS()
		{
			string ret = Marshal.PtrToStringAnsi((nint)GetClipboardText());
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetClipboardText")]
		public static extern void SetClipboardText(byte* text);

		public static void SetClipboardText(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				SetClipboardText((byte*)ptext);
			}
		}

		public static void SetClipboardText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetClipboardText(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLoadIniSettingsFromDisk")]
		public static extern void LoadIniSettingsFromDisk(byte* iniFilename);

		public static void LoadIniSettingsFromDisk(ref byte iniFilename)
		{
			fixed (byte* piniFilename = &iniFilename)
			{
				LoadIniSettingsFromDisk((byte*)piniFilename);
			}
		}

		public static void LoadIniSettingsFromDisk(string iniFilename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromDisk(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLoadIniSettingsFromMemory")]
		public static extern void LoadIniSettingsFromMemory(byte* iniData, nuint iniSize);

		public static void LoadIniSettingsFromMemory(ref byte iniData)
		{
			fixed (byte* piniData = &iniData)
			{
				LoadIniSettingsFromMemory((byte*)piniData, (nuint)(0));
			}
		}

		public static void LoadIniSettingsFromMemory(ref byte iniData, nuint iniSize)
		{
			fixed (byte* piniData = &iniData)
			{
				LoadIniSettingsFromMemory((byte*)piniData, iniSize);
			}
		}

		public static void LoadIniSettingsFromMemory(string iniData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromMemory(pStr0, (nuint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LoadIniSettingsFromMemory(string iniData, nuint iniSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromMemory(pStr0, iniSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSaveIniSettingsToDisk")]
		public static extern void SaveIniSettingsToDisk(byte* iniFilename);

		public static void SaveIniSettingsToDisk(ref byte iniFilename)
		{
			fixed (byte* piniFilename = &iniFilename)
			{
				SaveIniSettingsToDisk((byte*)piniFilename);
			}
		}

		public static void SaveIniSettingsToDisk(string iniFilename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SaveIniSettingsToDisk(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSaveIniSettingsToMemory")]
		public static extern byte* SaveIniSettingsToMemory(nuint* outIniSize);

		public static string SaveIniSettingsToMemoryS()
		{
			string ret = Marshal.PtrToStringAnsi((nint)SaveIniSettingsToMemory((nuint*)(null)));
			return ret;
		}

		public static string SaveIniSettingsToMemoryS(nuint* outIniSize)
		{
			string ret = Marshal.PtrToStringAnsi((nint)SaveIniSettingsToMemory(outIniSize));
			return ret;
		}

		public static string SaveIniSettingsToMemoryS(ref nuint outIniSize)
		{
			fixed (nuint* poutIniSize = &outIniSize)
			{
				string ret = Marshal.PtrToStringAnsi((nint)SaveIniSettingsToMemory((nuint*)poutIniSize));
				return ret;
			}
		}

		public static byte* SaveIniSettingsToMemory(ref nuint outIniSize)
		{
			fixed (nuint* poutIniSize = &outIniSize)
			{
				byte* ret = SaveIniSettingsToMemory((nuint*)poutIniSize);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugTextEncoding")]
		public static extern void DebugTextEncoding(byte* text);

		public static void DebugTextEncoding(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				DebugTextEncoding((byte*)ptext);
			}
		}

		public static void DebugTextEncoding(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugTextEncoding(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugCheckVersionAndDataLayout")]
		public static extern bool DebugCheckVersionAndDataLayout(byte* versionStr, nuint szIo, nuint szStyle, nuint szVec2, nuint szVec4, nuint szDrawvert, nuint szDrawidx);

		public static bool DebugCheckVersionAndDataLayout(ref byte versionStr, nuint szIo, nuint szStyle, nuint szVec2, nuint szVec4, nuint szDrawvert, nuint szDrawidx)
		{
			fixed (byte* pversionStr = &versionStr)
			{
				bool ret = DebugCheckVersionAndDataLayout((byte*)pversionStr, szIo, szStyle, szVec2, szVec4, szDrawvert, szDrawidx);
				return ret;
			}
		}

		public static bool DebugCheckVersionAndDataLayout(string versionStr, nuint szIo, nuint szStyle, nuint szVec2, nuint szVec4, nuint szDrawvert, nuint szDrawidx)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (versionStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(versionStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(versionStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DebugCheckVersionAndDataLayout(pStr0, szIo, szStyle, szVec2, szVec4, szDrawvert, szDrawidx);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetAllocatorFunctions")]
		public static extern void SetAllocatorFunctions(delegate*<nuint, void*> allocFunc, delegate*<void*, void*> freeFunc, void* userData);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetAllocatorFunctions")]
		public static extern void GetAllocatorFunctions(delegate*<nuint, void*>* pAllocFunc, delegate*<void*, void*>* pFreeFunc, void** pUserData);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMemAlloc")]
		public static extern void* MemAlloc(nuint size);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMemFree")]
		public static extern void MemFree(void* ptr);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetPlatformIO")]
		public static extern ImGuiPlatformIO* GetPlatformIO();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdatePlatformWindows")]
		public static extern void UpdatePlatformWindows();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderPlatformWindowsDefault")]
		public static extern void RenderPlatformWindowsDefault(void* platformRenderArg, void* rendererRenderArg);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDestroyPlatformWindows")]
		public static extern void DestroyPlatformWindows();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindViewportByID")]
		public static extern ImGuiViewport* FindViewportByID(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindViewportByPlatformHandle")]
		public static extern ImGuiViewport* FindViewportByPlatformHandle(void* platformHandle);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyle_ImGuiStyle")]
		public static extern ImGuiStyle* ImGuiStyle();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyle_destroy")]
		public static extern void Destroy(ImGuiStyle* self);

		public static void Destroy(ref ImGuiStyle self)
		{
			fixed (ImGuiStyle* pself = &self)
			{
				Destroy((ImGuiStyle*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyle_ScaleAllSizes")]
		public static extern void ScaleAllSizes(ImGuiStyle* self, float scaleFactor);

		public static void ScaleAllSizes(ref ImGuiStyle self, float scaleFactor)
		{
			fixed (ImGuiStyle* pself = &self)
			{
				ScaleAllSizes((ImGuiStyle*)pself, scaleFactor);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddKeyEvent")]
		public static extern void AddKeyEvent(ImGuiIO* self, ImGuiKey key, bool down);

		public static void AddKeyEvent(ref ImGuiIO self, ImGuiKey key, bool down)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddKeyEvent((ImGuiIO*)pself, key, down);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddKeyAnalogEvent")]
		public static extern void AddKeyAnalogEvent(ImGuiIO* self, ImGuiKey key, bool down, float v);

		public static void AddKeyAnalogEvent(ref ImGuiIO self, ImGuiKey key, bool down, float v)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddKeyAnalogEvent((ImGuiIO*)pself, key, down, v);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMousePosEvent")]
		public static extern void AddMousePosEvent(ImGuiIO* self, float x, float y);

		public static void AddMousePosEvent(ref ImGuiIO self, float x, float y)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMousePosEvent((ImGuiIO*)pself, x, y);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMouseButtonEvent")]
		public static extern void AddMouseButtonEvent(ImGuiIO* self, int button, bool down);

		public static void AddMouseButtonEvent(ref ImGuiIO self, int button, bool down)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseButtonEvent((ImGuiIO*)pself, button, down);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMouseWheelEvent")]
		public static extern void AddMouseWheelEvent(ImGuiIO* self, float wheelX, float wheelY);

		public static void AddMouseWheelEvent(ref ImGuiIO self, float wheelX, float wheelY)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseWheelEvent((ImGuiIO*)pself, wheelX, wheelY);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMouseSourceEvent")]
		public static extern void AddMouseSourceEvent(ImGuiIO* self, ImGuiMouseSource source);

		public static void AddMouseSourceEvent(ref ImGuiIO self, ImGuiMouseSource source)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseSourceEvent((ImGuiIO*)pself, source);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMouseViewportEvent")]
		public static extern void AddMouseViewportEvent(ImGuiIO* self, int id);

		public static void AddMouseViewportEvent(ref ImGuiIO self, int id)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseViewportEvent((ImGuiIO*)pself, id);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddFocusEvent")]
		public static extern void AddFocusEvent(ImGuiIO* self, bool focused);

		public static void AddFocusEvent(ref ImGuiIO self, bool focused)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddFocusEvent((ImGuiIO*)pself, focused);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddInputCharacter")]
		public static extern void AddInputCharacter(ImGuiIO* self, uint c);

		public static void AddInputCharacter(ref ImGuiIO self, uint c)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharacter((ImGuiIO*)pself, c);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddInputCharacterUTF16")]
		public static extern void AddInputCharacterUTF16(ImGuiIO* self, char c);

		public static void AddInputCharacterUTF16(ref ImGuiIO self, char c)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharacterUTF16((ImGuiIO*)pself, c);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddInputCharactersUTF8")]
		public static extern void AddInputCharactersUTF8(ImGuiIO* self, byte* str);

		public static void AddInputCharactersUTF8(ref ImGuiIO self, byte* str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharactersUTF8((ImGuiIO*)pself, str);
			}
		}

		public static void AddInputCharactersUTF8(ImGuiIO* self, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				AddInputCharactersUTF8(self, (byte*)pstr);
			}
		}

		public static void AddInputCharactersUTF8(ImGuiIO* self, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddInputCharactersUTF8(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddInputCharactersUTF8(ref ImGuiIO self, ref byte str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					AddInputCharactersUTF8((ImGuiIO*)pself, (byte*)pstr);
				}
			}
		}

		public static void AddInputCharactersUTF8(ref ImGuiIO self, string str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddInputCharactersUTF8((ImGuiIO*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_SetKeyEventNativeData")]
		public static extern void SetKeyEventNativeData(ImGuiIO* self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex);

		public static void SetKeyEventNativeData(ref ImGuiIO self, ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetKeyEventNativeData((ImGuiIO*)pself, key, nativeKeycode, nativeScancode, -1);
			}
		}

		public static void SetKeyEventNativeData(ref ImGuiIO self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetKeyEventNativeData((ImGuiIO*)pself, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_SetAppAcceptingEvents")]
		public static extern void SetAppAcceptingEvents(ImGuiIO* self, bool acceptingEvents);

		public static void SetAppAcceptingEvents(ref ImGuiIO self, bool acceptingEvents)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetAppAcceptingEvents((ImGuiIO*)pself, acceptingEvents);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_ClearInputCharacters")]
		public static extern void ClearInputCharacters(ImGuiIO* self);

		public static void ClearInputCharacters(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ClearInputCharacters((ImGuiIO*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_ClearInputKeys")]
		public static extern void ClearInputKeys(ImGuiIO* self);

		public static void ClearInputKeys(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ClearInputKeys((ImGuiIO*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_ImGuiIO")]
		public static extern ImGuiIO* ImGuiIO();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_destroy")]
		public static extern void Destroy(ImGuiIO* self);

		public static void Destroy(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				Destroy((ImGuiIO*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_ImGuiInputTextCallbackData")]
		public static extern ImGuiInputTextCallbackData* ImGuiInputTextCallbackData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_destroy")]
		public static extern void Destroy(ImGuiInputTextCallbackData* self);

		public static void Destroy(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				Destroy((ImGuiInputTextCallbackData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_DeleteChars")]
		public static extern void DeleteChars(ImGuiInputTextCallbackData* self, int pos, int bytesCount);

		public static void DeleteChars(ref ImGuiInputTextCallbackData self, int pos, int bytesCount)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				DeleteChars((ImGuiInputTextCallbackData*)pself, pos, bytesCount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_InsertChars")]
		public static extern void InsertChars(ImGuiInputTextCallbackData* self, int pos, byte* text, byte* textEnd);

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				InsertChars((ImGuiInputTextCallbackData*)pself, pos, text, (string)null);
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				InsertChars((ImGuiInputTextCallbackData*)pself, pos, text, textEnd);
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				InsertChars(self, pos, (byte*)ptext, (string)null);
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				InsertChars(self, pos, (byte*)ptext, textEnd);
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertChars(self, pos, pStr0, (string)null);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertChars(self, pos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					InsertChars((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, (string)null);
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					InsertChars((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, textEnd);
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, string text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertChars((ImGuiInputTextCallbackData*)pself, pos, pStr0, (string)null);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, string text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertChars((ImGuiInputTextCallbackData*)pself, pos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				InsertChars(self, pos, text, (byte*)ptextEnd);
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, byte* text)
		{
			InsertChars(self, pos, text, (string)null);
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertChars(self, pos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					InsertChars((ImGuiInputTextCallbackData*)pself, pos, text, (byte*)ptextEnd);
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertChars((ImGuiInputTextCallbackData*)pself, pos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					InsertChars(self, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			InsertChars(self, pos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						InsertChars((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, string text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				InsertChars((ImGuiInputTextCallbackData*)pself, pos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_SelectAll")]
		public static extern void SelectAll(ImGuiInputTextCallbackData* self);

		public static void SelectAll(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				SelectAll((ImGuiInputTextCallbackData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_ClearSelection")]
		public static extern void ClearSelection(ImGuiInputTextCallbackData* self);

		public static void ClearSelection(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				ClearSelection((ImGuiInputTextCallbackData*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_HasSelection")]
		public static extern bool HasSelection(ImGuiInputTextCallbackData* self);

		public static bool HasSelection(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				bool ret = HasSelection((ImGuiInputTextCallbackData*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowClass_ImGuiWindowClass")]
		public static extern ImGuiWindowClass* ImGuiWindowClass();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowClass_destroy")]
		public static extern void Destroy(ImGuiWindowClass* self);

		public static void Destroy(ref ImGuiWindowClass self)
		{
			fixed (ImGuiWindowClass* pself = &self)
			{
				Destroy((ImGuiWindowClass*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_ImGuiPayload")]
		public static extern ImGuiPayload* ImGuiPayload();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_destroy")]
		public static extern void Destroy(ImGuiPayload* self);

		public static void Destroy(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				Destroy((ImGuiPayload*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_Clear")]
		public static extern void Clear(ImGuiPayload* self);

		public static void Clear(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				Clear((ImGuiPayload*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_IsDataType")]
		public static extern bool IsDataType(ImGuiPayload* self, byte* type);

		public static bool IsDataType(ref ImGuiPayload self, byte* type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				bool ret = IsDataType((ImGuiPayload*)pself, type);
				return ret;
			}
		}

		public static bool IsDataType(ImGuiPayload* self, ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				bool ret = IsDataType(self, (byte*)ptype);
				return ret;
			}
		}

		public static bool IsDataType(ImGuiPayload* self, string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = IsDataType(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool IsDataType(ref ImGuiPayload self, ref byte type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				fixed (byte* ptype = &type)
				{
					bool ret = IsDataType((ImGuiPayload*)pself, (byte*)ptype);
					return ret;
				}
			}
		}

		public static bool IsDataType(ref ImGuiPayload self, string type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = IsDataType((ImGuiPayload*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_IsPreview")]
		public static extern bool IsPreview(ImGuiPayload* self);

		public static bool IsPreview(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				bool ret = IsPreview((ImGuiPayload*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_IsDelivery")]
		public static extern bool IsDelivery(ImGuiPayload* self);

		public static bool IsDelivery(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				bool ret = IsDelivery((ImGuiPayload*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs")]
		public static extern ImGuiTableColumnSortSpecs* ImGuiTableColumnSortSpecs();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumnSortSpecs_destroy")]
		public static extern void Destroy(ImGuiTableColumnSortSpecs* self);

		public static void Destroy(ref ImGuiTableColumnSortSpecs self)
		{
			fixed (ImGuiTableColumnSortSpecs* pself = &self)
			{
				Destroy((ImGuiTableColumnSortSpecs*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSortSpecs_ImGuiTableSortSpecs")]
		public static extern ImGuiTableSortSpecs* ImGuiTableSortSpecs();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSortSpecs_destroy")]
		public static extern void Destroy(ImGuiTableSortSpecs* self);

		public static void Destroy(ref ImGuiTableSortSpecs self)
		{
			fixed (ImGuiTableSortSpecs* pself = &self)
			{
				Destroy((ImGuiTableSortSpecs*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOnceUponAFrame_ImGuiOnceUponAFrame")]
		public static extern ImGuiOnceUponAFrame* ImGuiOnceUponAFrame();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOnceUponAFrame_destroy")]
		public static extern void Destroy(ImGuiOnceUponAFrame* self);

		public static void Destroy(ref ImGuiOnceUponAFrame self)
		{
			fixed (ImGuiOnceUponAFrame* pself = &self)
			{
				Destroy((ImGuiOnceUponAFrame*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_ImGuiTextFilter")]
		public static extern ImGuiTextFilter* ImGuiTextFilter(byte* defaultFilter);

		public static ImGuiTextFilter* ImGuiTextFilter(ref byte defaultFilter)
		{
			fixed (byte* pdefaultFilter = &defaultFilter)
			{
				ImGuiTextFilter* ret = ImGuiTextFilter((byte*)pdefaultFilter);
				return ret;
			}
		}

		public static ImGuiTextFilter* ImGuiTextFilter()
		{
			ImGuiTextFilter* ret = ImGuiTextFilter((string)"");
			return ret;
		}

		public static ImGuiTextFilter* ImGuiTextFilter(string defaultFilter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultFilter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultFilter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultFilter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextFilter* ret = ImGuiTextFilter(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_destroy")]
		public static extern void Destroy(ImGuiTextFilter* self);

		public static void Destroy(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				Destroy((ImGuiTextFilter*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_Draw")]
		public static extern bool Draw(ImGuiTextFilter* self, byte* label, float width);

		public static bool Draw(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = Draw((ImGuiTextFilter*)pself, (string)"Filter(inc,-exc)", 0.0f);
				return ret;
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, byte* label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = Draw((ImGuiTextFilter*)pself, label, 0.0f);
				return ret;
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, byte* label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = Draw((ImGuiTextFilter*)pself, label, width);
				return ret;
			}
		}

		public static bool Draw(ImGuiTextFilter* self, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Draw(self, (byte*)plabel, 0.0f);
				return ret;
			}
		}

		public static bool Draw(ImGuiTextFilter* self, ref byte label, float width)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = Draw(self, (byte*)plabel, width);
				return ret;
			}
		}

		public static bool Draw(ImGuiTextFilter* self)
		{
			bool ret = Draw(self, (string)"Filter(inc,-exc)", 0.0f);
			return ret;
		}

		public static bool Draw(ImGuiTextFilter* self, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Draw(self, pStr0, 0.0f);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Draw(ImGuiTextFilter* self, string label, float width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = Draw(self, pStr0, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool Draw(ref ImGuiTextFilter self, ref byte label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					bool ret = Draw((ImGuiTextFilter*)pself, (byte*)plabel, 0.0f);
					return ret;
				}
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, ref byte label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					bool ret = Draw((ImGuiTextFilter*)pself, (byte*)plabel, width);
					return ret;
				}
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, string label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = Draw((ImGuiTextFilter*)pself, pStr0, 0.0f);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, string label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = Draw((ImGuiTextFilter*)pself, pStr0, width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_PassFilter")]
		public static extern bool PassFilter(ImGuiTextFilter* self, byte* text, byte* textEnd);

		public static bool PassFilter(ref ImGuiTextFilter self, byte* text)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = PassFilter((ImGuiTextFilter*)pself, text, (string)null);
				return ret;
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, byte* text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = PassFilter((ImGuiTextFilter*)pself, text, textEnd);
				return ret;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				bool ret = PassFilter(self, (byte*)ptext, (string)null);
				return ret;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				bool ret = PassFilter(self, (byte*)ptext, textEnd);
				return ret;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = PassFilter(self, pStr0, (string)null);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool PassFilter(ImGuiTextFilter* self, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = PassFilter(self, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool PassFilter(ref ImGuiTextFilter self, ref byte text)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					bool ret = PassFilter((ImGuiTextFilter*)pself, (byte*)ptext, (string)null);
					return ret;
				}
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, ref byte text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					bool ret = PassFilter((ImGuiTextFilter*)pself, (byte*)ptext, textEnd);
					return ret;
				}
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, string text)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = PassFilter((ImGuiTextFilter*)pself, pStr0, (string)null);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, string text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = PassFilter((ImGuiTextFilter*)pself, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				bool ret = PassFilter(self, text, (byte*)ptextEnd);
				return ret;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, byte* text)
		{
			bool ret = PassFilter(self, text, (string)null);
			return ret;
		}

		public static bool PassFilter(ImGuiTextFilter* self, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = PassFilter(self, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool PassFilter(ref ImGuiTextFilter self, byte* text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					bool ret = PassFilter((ImGuiTextFilter*)pself, text, (byte*)ptextEnd);
					return ret;
				}
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, byte* text, string textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = PassFilter((ImGuiTextFilter*)pself, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					bool ret = PassFilter(self, (byte*)ptext, (byte*)ptextEnd);
					return ret;
				}
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = PassFilter(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool PassFilter(ref ImGuiTextFilter self, ref byte text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						bool ret = PassFilter((ImGuiTextFilter*)pself, (byte*)ptext, (byte*)ptextEnd);
						return ret;
					}
				}
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, string text, string textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				bool ret = PassFilter((ImGuiTextFilter*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_Build")]
		public static extern void Build(ImGuiTextFilter* self);

		public static void Build(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				Build((ImGuiTextFilter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_Clear")]
		public static extern void Clear(ImGuiTextFilter* self);

		public static void Clear(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				Clear((ImGuiTextFilter*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_IsActive")]
		public static extern bool IsActive(ImGuiTextFilter* self);

		public static bool IsActive(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = IsActive((ImGuiTextFilter*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_ImGuiTextRange_Nil")]
		public static extern ImGuiTextRange* ImGuiTextRange();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_destroy")]
		public static extern void Destroy(ImGuiTextRange* self);

		public static void Destroy(ref ImGuiTextRange self)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				Destroy((ImGuiTextRange*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_ImGuiTextRange_Str")]
		public static extern ImGuiTextRange* ImGuiTextRange(byte* b, byte* e);

		public static ImGuiTextRange* ImGuiTextRange(ref byte b, byte* e)
		{
			fixed (byte* pb = &b)
			{
				ImGuiTextRange* ret = ImGuiTextRange((byte*)pb, e);
				return ret;
			}
		}

		public static ImGuiTextRange* ImGuiTextRange(string b, byte* e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (b != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(b);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(b, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextRange* ret = ImGuiTextRange(pStr0, e);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImGuiTextRange* ImGuiTextRange(byte* b, ref byte e)
		{
			fixed (byte* pe = &e)
			{
				ImGuiTextRange* ret = ImGuiTextRange(b, (byte*)pe);
				return ret;
			}
		}

		public static ImGuiTextRange* ImGuiTextRange(byte* b, string e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (e != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(e);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(e, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextRange* ret = ImGuiTextRange(b, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImGuiTextRange* ImGuiTextRange(ref byte b, ref byte e)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pe = &e)
				{
					ImGuiTextRange* ret = ImGuiTextRange((byte*)pb, (byte*)pe);
					return ret;
				}
			}
		}

		public static ImGuiTextRange* ImGuiTextRange(string b, string e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (b != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(b);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(b, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (e != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(e);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(e, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGuiTextRange* ret = ImGuiTextRange(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_empty")]
		public static extern bool empty(ImGuiTextRange* self);

		public static bool empty(ref ImGuiTextRange self)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				bool ret = empty((ImGuiTextRange*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_split")]
		public static extern void split(ImGuiTextRange* self, byte separator, ImVectorImGuiTextRange* output);

		public static void split(ref ImGuiTextRange self, byte separator, ImVectorImGuiTextRange* output)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				split((ImGuiTextRange*)pself, separator, output);
			}
		}

		public static void split(ImGuiTextRange* self, byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImVectorImGuiTextRange* poutput = &output)
			{
				split(self, separator, (ImVectorImGuiTextRange*)poutput);
			}
		}

		public static void split(ref ImGuiTextRange self, byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				fixed (ImVectorImGuiTextRange* poutput = &output)
				{
					split((ImGuiTextRange*)pself, separator, (ImVectorImGuiTextRange*)poutput);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_ImGuiTextBuffer")]
		public static extern ImGuiTextBuffer* ImGuiTextBuffer();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_destroy")]
		public static extern void Destroy(ImGuiTextBuffer* self);

		public static void Destroy(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				Destroy((ImGuiTextBuffer*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_begin")]
		public static extern byte* begin(ImGuiTextBuffer* self);

		public static string beginS(ImGuiTextBuffer* self)
		{
			string ret = Marshal.PtrToStringAnsi((nint)begin(self));
			return ret;
		}

		public static string beginS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Marshal.PtrToStringAnsi((nint)begin((ImGuiTextBuffer*)pself));
				return ret;
			}
		}

		public static byte* begin(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = begin((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_end")]
		public static extern byte* end(ImGuiTextBuffer* self);

		public static string endS(ImGuiTextBuffer* self)
		{
			string ret = Marshal.PtrToStringAnsi((nint)end(self));
			return ret;
		}

		public static string endS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Marshal.PtrToStringAnsi((nint)end((ImGuiTextBuffer*)pself));
				return ret;
			}
		}

		public static byte* end(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = end((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_size")]
		public static extern int size(ImGuiTextBuffer* self);

		public static int size(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				int ret = size((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_empty")]
		public static extern bool empty(ImGuiTextBuffer* self);

		public static bool empty(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				bool ret = empty((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_clear")]
		public static extern void clear(ImGuiTextBuffer* self);

		public static void clear(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				clear((ImGuiTextBuffer*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_reserve")]
		public static extern void reserve(ImGuiTextBuffer* self, int capacity);

		public static void reserve(ref ImGuiTextBuffer self, int capacity)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				reserve((ImGuiTextBuffer*)pself, capacity);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_c_str")]
		public static extern byte* c_str(ImGuiTextBuffer* self);

		public static string c_strS(ImGuiTextBuffer* self)
		{
			string ret = Marshal.PtrToStringAnsi((nint)c_str(self));
			return ret;
		}

		public static string c_strS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Marshal.PtrToStringAnsi((nint)c_str((ImGuiTextBuffer*)pself));
				return ret;
			}
		}

		public static byte* c_str(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = c_str((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_append")]
		public static extern void append(ImGuiTextBuffer* self, byte* str, byte* strEnd);

		public static void append(ref ImGuiTextBuffer self, byte* str)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				append((ImGuiTextBuffer*)pself, str, (string)null);
			}
		}

		public static void append(ref ImGuiTextBuffer self, byte* str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				append((ImGuiTextBuffer*)pself, str, strEnd);
			}
		}

		public static void append(ImGuiTextBuffer* self, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				append(self, (byte*)pstr, (string)null);
			}
		}

		public static void append(ImGuiTextBuffer* self, ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				append(self, (byte*)pstr, strEnd);
			}
		}

		public static void append(ImGuiTextBuffer* self, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			append(self, pStr0, (string)null);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append(ImGuiTextBuffer* self, string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			append(self, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append(ref ImGuiTextBuffer self, ref byte str)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					append((ImGuiTextBuffer*)pself, (byte*)pstr, (string)null);
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, ref byte str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					append((ImGuiTextBuffer*)pself, (byte*)pstr, strEnd);
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, string str)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				append((ImGuiTextBuffer*)pself, pStr0, (string)null);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, string str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				append((ImGuiTextBuffer*)pself, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void append(ImGuiTextBuffer* self, byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				append(self, str, (byte*)pstrEnd);
			}
		}

		public static void append(ImGuiTextBuffer* self, byte* str)
		{
			append(self, str, (string)null);
		}

		public static void append(ImGuiTextBuffer* self, byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			append(self, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append(ref ImGuiTextBuffer self, byte* str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					append((ImGuiTextBuffer*)pself, str, (byte*)pstrEnd);
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, byte* str, string strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				append((ImGuiTextBuffer*)pself, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void append(ImGuiTextBuffer* self, ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					append(self, (byte*)pstr, (byte*)pstrEnd);
				}
			}
		}

		public static void append(ImGuiTextBuffer* self, string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			append(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append(ref ImGuiTextBuffer self, ref byte str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						append((ImGuiTextBuffer*)pself, (byte*)pstr, (byte*)pstrEnd);
					}
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, string str, string strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				append((ImGuiTextBuffer*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_appendfv")]
		public static extern void appendfv(ImGuiTextBuffer* self, byte* fmt, nuint args);

		public static void appendfv(ref ImGuiTextBuffer self, byte* fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				appendfv((ImGuiTextBuffer*)pself, fmt, args);
			}
		}

		public static void appendfv(ImGuiTextBuffer* self, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				appendfv(self, (byte*)pfmt, args);
			}
		}

		public static void appendfv(ImGuiTextBuffer* self, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendfv(self, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void appendfv(ref ImGuiTextBuffer self, ref byte fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pfmt = &fmt)
				{
					appendfv((ImGuiTextBuffer*)pself, (byte*)pfmt, args);
				}
			}
		}

		public static void appendfv(ref ImGuiTextBuffer self, string fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendfv((ImGuiTextBuffer*)pself, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Int")]
		public static extern ImGuiStoragePair* ImGuiStoragePair(int key, int valI);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStoragePair_destroy")]
		public static extern void Destroy(ImGuiStoragePair* self);

		public static void Destroy(ref ImGuiStoragePair self)
		{
			fixed (ImGuiStoragePair* pself = &self)
			{
				Destroy((ImGuiStoragePair*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Float")]
		public static extern ImGuiStoragePair* ImGuiStoragePair(int key, float valF);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Ptr")]
		public static extern ImGuiStoragePair* ImGuiStoragePair(int key, void* valP);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_Clear")]
		public static extern void Clear(ImGuiStorage* self);

		public static void Clear(ref ImGuiStorage self)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				Clear((ImGuiStorage*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetInt")]
		public static extern int GetInt(ImGuiStorage* self, int key, int defaultVal);

		public static int GetInt(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int ret = GetInt((ImGuiStorage*)pself, key, 0);
				return ret;
			}
		}

		public static int GetInt(ref ImGuiStorage self, int key, int defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int ret = GetInt((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetInt")]
		public static extern void SetInt(ImGuiStorage* self, int key, int val);

		public static void SetInt(ref ImGuiStorage self, int key, int val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetInt((ImGuiStorage*)pself, key, val);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetBool")]
		public static extern bool GetBool(ImGuiStorage* self, int key, bool defaultVal);

		public static bool GetBool(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				bool ret = GetBool((ImGuiStorage*)pself, key, false);
				return ret;
			}
		}

		public static bool GetBool(ref ImGuiStorage self, int key, bool defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				bool ret = GetBool((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetBool")]
		public static extern void SetBool(ImGuiStorage* self, int key, bool val);

		public static void SetBool(ref ImGuiStorage self, int key, bool val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetBool((ImGuiStorage*)pself, key, val);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetFloat")]
		public static extern float GetFloat(ImGuiStorage* self, int key, float defaultVal);

		public static float GetFloat(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float ret = GetFloat((ImGuiStorage*)pself, key, 0.0f);
				return ret;
			}
		}

		public static float GetFloat(ref ImGuiStorage self, int key, float defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float ret = GetFloat((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetFloat")]
		public static extern void SetFloat(ImGuiStorage* self, int key, float val);

		public static void SetFloat(ref ImGuiStorage self, int key, float val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetFloat((ImGuiStorage*)pself, key, val);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetVoidPtr")]
		public static extern void* GetVoidPtr(ImGuiStorage* self, int key);

		public static void* GetVoidPtr(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				void* ret = GetVoidPtr((ImGuiStorage*)pself, key);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetVoidPtr")]
		public static extern void SetVoidPtr(ImGuiStorage* self, int key, void* val);

		public static void SetVoidPtr(ref ImGuiStorage self, int key, void* val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetVoidPtr((ImGuiStorage*)pself, key, val);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetIntRef")]
		public static extern int* GetIntRef(ImGuiStorage* self, int key, int defaultVal);

		public static int* GetIntRef(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int* ret = GetIntRef((ImGuiStorage*)pself, key, 0);
				return ret;
			}
		}

		public static int* GetIntRef(ref ImGuiStorage self, int key, int defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int* ret = GetIntRef((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetBoolRef")]
		public static extern bool* GetBoolRef(ImGuiStorage* self, int key, bool defaultVal);

		public static bool* GetBoolRef(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				bool* ret = GetBoolRef((ImGuiStorage*)pself, key, false);
				return ret;
			}
		}

		public static bool* GetBoolRef(ref ImGuiStorage self, int key, bool defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				bool* ret = GetBoolRef((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetFloatRef")]
		public static extern float* GetFloatRef(ImGuiStorage* self, int key, float defaultVal);

		public static float* GetFloatRef(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float* ret = GetFloatRef((ImGuiStorage*)pself, key, 0.0f);
				return ret;
			}
		}

		public static float* GetFloatRef(ref ImGuiStorage self, int key, float defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float* ret = GetFloatRef((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetVoidPtrRef")]
		public static extern void** GetVoidPtrRef(ImGuiStorage* self, int key, void* defaultVal);

		public static void** GetVoidPtrRef(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				void** ret = GetVoidPtrRef((ImGuiStorage*)pself, key, (void*)(null));
				return ret;
			}
		}

		public static void** GetVoidPtrRef(ref ImGuiStorage self, int key, void* defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				void** ret = GetVoidPtrRef((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetAllInt")]
		public static extern void SetAllInt(ImGuiStorage* self, int val);

		public static void SetAllInt(ref ImGuiStorage self, int val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetAllInt((ImGuiStorage*)pself, val);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_BuildSortByKey")]
		public static extern void BuildSortByKey(ImGuiStorage* self);

		public static void BuildSortByKey(ref ImGuiStorage self)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				BuildSortByKey((ImGuiStorage*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_ImGuiListClipper")]
		public static extern ImGuiListClipper* ImGuiListClipper();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_destroy")]
		public static extern void Destroy(ImGuiListClipper* self);

		public static void Destroy(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				Destroy((ImGuiListClipper*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_Begin")]
		public static extern void Begin(ImGuiListClipper* self, int itemsCount, float itemsHeight);

		public static void Begin(ref ImGuiListClipper self, int itemsCount)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				Begin((ImGuiListClipper*)pself, itemsCount, -1.0f);
			}
		}

		public static void Begin(ref ImGuiListClipper self, int itemsCount, float itemsHeight)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				Begin((ImGuiListClipper*)pself, itemsCount, itemsHeight);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_End")]
		public static extern void End(ImGuiListClipper* self);

		public static void End(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				End((ImGuiListClipper*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_Step")]
		public static extern bool Step(ImGuiListClipper* self);

		public static bool Step(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				bool ret = Step((ImGuiListClipper*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_ForceDisplayRangeByIndices")]
		public static extern void ForceDisplayRangeByIndices(ImGuiListClipper* self, int itemMin, int itemMax);

		public static void ForceDisplayRangeByIndices(ref ImGuiListClipper self, int itemMin, int itemMax)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				ForceDisplayRangeByIndices((ImGuiListClipper*)pself, itemMin, itemMax);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_Nil")]
		public static extern ImColor* ImColor();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_destroy")]
		public static extern void Destroy(ImColor* self);

		public static void Destroy(ref ImColor self)
		{
			fixed (ImColor* pself = &self)
			{
				Destroy((ImColor*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_Float")]
		public static extern ImColor* ImColor(float r, float g, float b, float a);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_Vec4")]
		public static extern ImColor* ImColor(Vector4 col);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_Int")]
		public static extern ImColor* ImColor(int r, int g, int b, int a);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_U32")]
		public static extern ImColor* ImColor(uint rgba);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_SetHSV")]
		public static extern void SetHSV(ImColor* self, float h, float s, float v, float a);

		public static void SetHSV(ref ImColor self, float h, float s, float v)
		{
			fixed (ImColor* pself = &self)
			{
				SetHSV((ImColor*)pself, h, s, v, 1.0f);
			}
		}

		public static void SetHSV(ref ImColor self, float h, float s, float v, float a)
		{
			fixed (ImColor* pself = &self)
			{
				SetHSV((ImColor*)pself, h, s, v, a);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_HSV")]
		public static extern void HSV(ImColor* output, float h, float s, float v, float a);

		public static void HSV(ref ImColor output, float h, float s, float v)
		{
			fixed (ImColor* poutput = &output)
			{
				HSV((ImColor*)poutput, h, s, v, 1.0f);
			}
		}

		public static void HSV(ref ImColor output, float h, float s, float v, float a)
		{
			fixed (ImColor* poutput = &output)
			{
				HSV((ImColor*)poutput, h, s, v, a);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawCmd_ImDrawCmd")]
		public static extern ImDrawCmd* ImDrawCmd();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawCmd_destroy")]
		public static extern void Destroy(ImDrawCmd* self);

		public static void Destroy(ref ImDrawCmd self)
		{
			fixed (ImDrawCmd* pself = &self)
			{
				Destroy((ImDrawCmd*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawCmd_GetTexID")]
		public static extern ImTextureID GetTexID(ImDrawCmd* self);

		public static ImTextureID GetTexID(ref ImDrawCmd self)
		{
			fixed (ImDrawCmd* pself = &self)
			{
				ImTextureID ret = GetTexID((ImDrawCmd*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_ImDrawListSplitter")]
		public static extern ImDrawListSplitter* ImDrawListSplitter();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_destroy")]
		public static extern void Destroy(ImDrawListSplitter* self);

		public static void Destroy(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				Destroy((ImDrawListSplitter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_Clear")]
		public static extern void Clear(ImDrawListSplitter* self);

		public static void Clear(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				Clear((ImDrawListSplitter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_ClearFreeMemory")]
		public static extern void ClearFreeMemory(ImDrawListSplitter* self);

		public static void ClearFreeMemory(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ClearFreeMemory((ImDrawListSplitter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_Split")]
		public static extern void Split(ImDrawListSplitter* self, ImDrawList* drawList, int count);

		public static void Split(ref ImDrawListSplitter self, ImDrawList* drawList, int count)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				Split((ImDrawListSplitter*)pself, drawList, count);
			}
		}

		public static void Split(ImDrawListSplitter* self, ref ImDrawList drawList, int count)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				Split(self, (ImDrawList*)pdrawList, count);
			}
		}

		public static void Split(ref ImDrawListSplitter self, ref ImDrawList drawList, int count)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					Split((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList, count);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_Merge")]
		public static extern void Merge(ImDrawListSplitter* self, ImDrawList* drawList);

		public static void Merge(ref ImDrawListSplitter self, ImDrawList* drawList)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				Merge((ImDrawListSplitter*)pself, drawList);
			}
		}

		public static void Merge(ImDrawListSplitter* self, ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				Merge(self, (ImDrawList*)pdrawList);
			}
		}

		public static void Merge(ref ImDrawListSplitter self, ref ImDrawList drawList)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					Merge((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_SetCurrentChannel")]
		public static extern void SetCurrentChannel(ImDrawListSplitter* self, ImDrawList* drawList, int channelIdx);

		public static void SetCurrentChannel(ref ImDrawListSplitter self, ImDrawList* drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				SetCurrentChannel((ImDrawListSplitter*)pself, drawList, channelIdx);
			}
		}

		public static void SetCurrentChannel(ImDrawListSplitter* self, ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				SetCurrentChannel(self, (ImDrawList*)pdrawList, channelIdx);
			}
		}

		public static void SetCurrentChannel(ref ImDrawListSplitter self, ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					SetCurrentChannel((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList, channelIdx);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_ImDrawList")]
		public static extern ImDrawList* ImDrawList(ImDrawListSharedData* sharedData);

		public static ImDrawList* ImDrawList(ref ImDrawListSharedData sharedData)
		{
			fixed (ImDrawListSharedData* psharedData = &sharedData)
			{
				ImDrawList* ret = ImDrawList((ImDrawListSharedData*)psharedData);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_destroy")]
		public static extern void Destroy(ImDrawList* self);

		public static void Destroy(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				Destroy((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PushClipRect")]
		public static extern void PushClipRect(ImDrawList* self, Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect);

		public static void PushClipRect(ref ImDrawList self, Vector2 clipRectMin, Vector2 clipRectMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				PushClipRect((ImDrawList*)pself, clipRectMin, clipRectMax, false);
			}
		}

		public static void PushClipRect(ref ImDrawList self, Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				PushClipRect((ImDrawList*)pself, clipRectMin, clipRectMax, intersectWithCurrentClipRect);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PushClipRectFullScreen")]
		public static extern void PushClipRectFullScreen(ImDrawList* self);

		public static void PushClipRectFullScreen(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				PushClipRectFullScreen((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PopClipRect")]
		public static extern void PopClipRect(ImDrawList* self);

		public static void PopClipRect(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				PopClipRect((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PushTextureID")]
		public static extern void PushTextureID(ImDrawList* self, ImTextureID textureId);

		public static void PushTextureID(ref ImDrawList self, ImTextureID textureId)
		{
			fixed (ImDrawList* pself = &self)
			{
				PushTextureID((ImDrawList*)pself, textureId);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PopTextureID")]
		public static extern void PopTextureID(ImDrawList* self);

		public static void PopTextureID(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				PopTextureID((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_GetClipRectMin")]
		public static extern void GetClipRectMin(Vector2* output, ImDrawList* self);

		public static void GetClipRectMin(ref Vector2 output, ImDrawList* self)
		{
			fixed (Vector2* poutput = &output)
			{
				GetClipRectMin((Vector2*)poutput, self);
			}
		}

		public static void GetClipRectMin(Vector2* output, ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				GetClipRectMin(output, (ImDrawList*)pself);
			}
		}

		public static void GetClipRectMin(ref Vector2 output, ref ImDrawList self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImDrawList* pself = &self)
				{
					GetClipRectMin((Vector2*)poutput, (ImDrawList*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_GetClipRectMax")]
		public static extern void GetClipRectMax(Vector2* output, ImDrawList* self);

		public static void GetClipRectMax(ref Vector2 output, ImDrawList* self)
		{
			fixed (Vector2* poutput = &output)
			{
				GetClipRectMax((Vector2*)poutput, self);
			}
		}

		public static void GetClipRectMax(Vector2* output, ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				GetClipRectMax(output, (ImDrawList*)pself);
			}
		}

		public static void GetClipRectMax(ref Vector2 output, ref ImDrawList self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImDrawList* pself = &self)
				{
					GetClipRectMax((Vector2*)poutput, (ImDrawList*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddLine")]
		public static extern void AddLine(ImDrawList* self, Vector2 p1, Vector2 p2, uint col, float thickness);

		public static void AddLine(ref ImDrawList self, Vector2 p1, Vector2 p2, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddLine((ImDrawList*)pself, p1, p2, col, 1.0f);
			}
		}

		public static void AddLine(ref ImDrawList self, Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddLine((ImDrawList*)pself, p1, p2, col, thickness);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddRect")]
		public static extern void AddRect(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness);

		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRect((ImDrawList*)pself, pMin, pMax, col, 0.0f, (ImDrawFlags)(0), 1.0f);
			}
		}

		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRect((ImDrawList*)pself, pMin, pMax, col, rounding, (ImDrawFlags)(0), 1.0f);
			}
		}

		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRect((ImDrawList*)pself, pMin, pMax, col, rounding, flags, 1.0f);
			}
		}

		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRect((ImDrawList*)pself, pMin, pMax, col, rounding, flags, thickness);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddRectFilled")]
		public static extern void AddRectFilled(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags);

		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectFilled((ImDrawList*)pself, pMin, pMax, col, 0.0f, (ImDrawFlags)(0));
			}
		}

		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectFilled((ImDrawList*)pself, pMin, pMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectFilled((ImDrawList*)pself, pMin, pMax, col, rounding, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddRectFilledMultiColor")]
		public static extern void AddRectFilledMultiColor(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft);

		public static void AddRectFilledMultiColor(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectFilledMultiColor((ImDrawList*)pself, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddQuad")]
		public static extern void AddQuad(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness);

		public static void AddQuad(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddQuad((ImDrawList*)pself, p1, p2, p3, p4, col, 1.0f);
			}
		}

		public static void AddQuad(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddQuad((ImDrawList*)pself, p1, p2, p3, p4, col, thickness);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddQuadFilled")]
		public static extern void AddQuadFilled(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col);

		public static void AddQuadFilled(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddQuadFilled((ImDrawList*)pself, p1, p2, p3, p4, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddTriangle")]
		public static extern void AddTriangle(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness);

		public static void AddTriangle(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTriangle((ImDrawList*)pself, p1, p2, p3, col, 1.0f);
			}
		}

		public static void AddTriangle(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTriangle((ImDrawList*)pself, p1, p2, p3, col, thickness);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddTriangleFilled")]
		public static extern void AddTriangleFilled(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col);

		public static void AddTriangleFilled(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTriangleFilled((ImDrawList*)pself, p1, p2, p3, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddCircle")]
		public static extern void AddCircle(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments, float thickness);

		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircle((ImDrawList*)pself, center, radius, col, 0, 1.0f);
			}
		}

		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircle((ImDrawList*)pself, center, radius, col, numSegments, 1.0f);
			}
		}

		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircle((ImDrawList*)pself, center, radius, col, numSegments, thickness);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddCircleFilled")]
		public static extern void AddCircleFilled(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments);

		public static void AddCircleFilled(ref ImDrawList self, Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircleFilled((ImDrawList*)pself, center, radius, col, 0);
			}
		}

		public static void AddCircleFilled(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircleFilled((ImDrawList*)pself, center, radius, col, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddNgon")]
		public static extern void AddNgon(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments, float thickness);

		public static void AddNgon(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddNgon((ImDrawList*)pself, center, radius, col, numSegments, 1.0f);
			}
		}

		public static void AddNgon(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddNgon((ImDrawList*)pself, center, radius, col, numSegments, thickness);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddNgonFilled")]
		public static extern void AddNgonFilled(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments);

		public static void AddNgonFilled(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddNgonFilled((ImDrawList*)pself, center, radius, col, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddText_Vec2")]
		public static extern void AddText(ImDrawList* self, Vector2 pos, uint col, byte* textBegin, byte* textEnd);

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddText((ImDrawList*)pself, pos, col, textBegin, (string)null);
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddText((ImDrawList*)pself, pos, col, textBegin, textEnd);
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddText(self, pos, col, (byte*)ptextBegin, (string)null);
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddText(self, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, pos, col, pStr0, (string)null);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, pos, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText((ImDrawList*)pself, pos, col, (byte*)ptextBegin, (string)null);
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText((ImDrawList*)pself, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, pos, col, pStr0, (string)null);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddText(self, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, byte* textBegin)
		{
			AddText(self, pos, col, textBegin, (string)null);
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, pos, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText((ImDrawList*)pself, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText(self, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddText(self, pos, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText((ImDrawList*)pself, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddText((ImDrawList*)pself, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddText_FontPtr")]
		public static extern void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect);

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (string)null, 0.0f, (Vector4*)(null));
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, textEnd, 0.0f, (Vector4*)(null));
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(null));
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (string)null, 0.0f, (Vector4*)(null));
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, 0.0f, (Vector4*)(null));
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(null));
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (string)null, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, (string)null, 0.0f, (Vector4*)(null));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, 0.0f, (Vector4*)(null));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(null));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, font, fontSize, pos, col, pStr0, (string)null, 0.0f, (Vector4*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, font, fontSize, pos, col, pStr0, textEnd, 0.0f, (Vector4*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (string)null, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, (string)null, 0.0f, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, textEnd, 0.0f, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (string)null, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, (string)null, 0.0f, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, 0.0f, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (string)null, 0.0f, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, 0.0f, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, (string)null, 0.0f, (Vector4*)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, 0.0f, (Vector4*)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddText(self, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, 0.0f, (Vector4*)(null));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddText(self, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(null));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddText(self, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			AddText(self, font, fontSize, pos, col, textBegin, (string)null, 0.0f, (Vector4*)(null));
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, font, fontSize, pos, col, textBegin, pStr0, 0.0f, (Vector4*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, pStr0, 0.0f, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, 0.0f, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, 0.0f, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, 0.0f, (Vector4*)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, 0.0f, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(null));
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddText(self, font, fontSize, pos, col, pStr0, pStr1, 0.0f, (Vector4*)(null));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddText(self, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(null));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddText(self, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, 0.0f, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, pStr1, 0.0f, (Vector4*)(null));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(null));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, 0.0f, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(null));
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, 0.0f, (Vector4*)(null));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(null));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, 0.0f, (Vector4*)(null));
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(null));
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, 0.0f, (Vector4*)(null));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(null));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				AddText(self, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				AddText(self, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText(self, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				AddText(self, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				AddText(self, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							AddText((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText((ImDrawList*)pself, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							AddText(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddText(self, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddText((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddPolyline")]
		public static extern void AddPolyline(ImDrawList* self, Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness);

		public static void AddPolyline(ref ImDrawList self, Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddPolyline((ImDrawList*)pself, points, numPoints, col, flags, thickness);
			}
		}

		public static void AddPolyline(ImDrawList* self, ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (Vector2* ppoints = &points)
			{
				AddPolyline(self, (Vector2*)ppoints, numPoints, col, flags, thickness);
			}
		}

		public static void AddPolyline(ref ImDrawList self, ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (Vector2* ppoints = &points)
				{
					AddPolyline((ImDrawList*)pself, (Vector2*)ppoints, numPoints, col, flags, thickness);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddConvexPolyFilled")]
		public static extern void AddConvexPolyFilled(ImDrawList* self, Vector2* points, int numPoints, uint col);

		public static void AddConvexPolyFilled(ref ImDrawList self, Vector2* points, int numPoints, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddConvexPolyFilled((ImDrawList*)pself, points, numPoints, col);
			}
		}

		public static void AddConvexPolyFilled(ImDrawList* self, ref Vector2 points, int numPoints, uint col)
		{
			fixed (Vector2* ppoints = &points)
			{
				AddConvexPolyFilled(self, (Vector2*)ppoints, numPoints, col);
			}
		}

		public static void AddConvexPolyFilled(ref ImDrawList self, ref Vector2 points, int numPoints, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (Vector2* ppoints = &points)
				{
					AddConvexPolyFilled((ImDrawList*)pself, (Vector2*)ppoints, numPoints, col);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddBezierCubic")]
		public static extern void AddBezierCubic(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments);

		public static void AddBezierCubic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddBezierCubic((ImDrawList*)pself, p1, p2, p3, p4, col, thickness, 0);
			}
		}

		public static void AddBezierCubic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddBezierCubic((ImDrawList*)pself, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddBezierQuadratic")]
		public static extern void AddBezierQuadratic(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments);

		public static void AddBezierQuadratic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddBezierQuadratic((ImDrawList*)pself, p1, p2, p3, col, thickness, 0);
			}
		}

		public static void AddBezierQuadratic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddBezierQuadratic((ImDrawList*)pself, p1, p2, p3, col, thickness, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddImage")]
		public static extern void AddImage(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col);

		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, new Vector2(0,0), new Vector2(1,1), (uint)(4294967295));
			}
		}

		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, new Vector2(1,1), (uint)(4294967295));
			}
		}

		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
			}
		}

		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddImageQuad")]
		public static extern void AddImageQuad(ImDrawList* self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col);

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, new Vector2(0,0), new Vector2(1,0), new Vector2(1,1), new Vector2(0,1), (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, new Vector2(1,0), new Vector2(1,1), new Vector2(0,1), (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, new Vector2(1,1), new Vector2(0,1), (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, new Vector2(0,1), (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddImageRounded")]
		public static extern void AddImageRounded(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags);

		public static void AddImageRounded(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageRounded((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		public static void AddImageRounded(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageRounded((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathClear")]
		public static extern void PathClear(ImDrawList* self);

		public static void PathClear(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathClear((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathLineTo")]
		public static extern void PathLineTo(ImDrawList* self, Vector2 pos);

		public static void PathLineTo(ref ImDrawList self, Vector2 pos)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathLineTo((ImDrawList*)pself, pos);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathLineToMergeDuplicate")]
		public static extern void PathLineToMergeDuplicate(ImDrawList* self, Vector2 pos);

		public static void PathLineToMergeDuplicate(ref ImDrawList self, Vector2 pos)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathLineToMergeDuplicate((ImDrawList*)pself, pos);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathFillConvex")]
		public static extern void PathFillConvex(ImDrawList* self, uint col);

		public static void PathFillConvex(ref ImDrawList self, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathFillConvex((ImDrawList*)pself, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathStroke")]
		public static extern void PathStroke(ImDrawList* self, uint col, ImDrawFlags flags, float thickness);

		public static void PathStroke(ref ImDrawList self, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathStroke((ImDrawList*)pself, col, (ImDrawFlags)(0), 1.0f);
			}
		}

		public static void PathStroke(ref ImDrawList self, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathStroke((ImDrawList*)pself, col, flags, 1.0f);
			}
		}

		public static void PathStroke(ref ImDrawList self, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathStroke((ImDrawList*)pself, col, flags, thickness);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathArcTo")]
		public static extern void PathArcTo(ImDrawList* self, Vector2 center, float radius, float aMin, float aMax, int numSegments);

		public static void PathArcTo(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathArcTo((ImDrawList*)pself, center, radius, aMin, aMax, 0);
			}
		}

		public static void PathArcTo(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathArcTo((ImDrawList*)pself, center, radius, aMin, aMax, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathArcToFast")]
		public static extern void PathArcToFast(ImDrawList* self, Vector2 center, float radius, int aMinOf12, int aMaxOf12);

		public static void PathArcToFast(ref ImDrawList self, Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathArcToFast((ImDrawList*)pself, center, radius, aMinOf12, aMaxOf12);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathBezierCubicCurveTo")]
		public static extern void PathBezierCubicCurveTo(ImDrawList* self, Vector2 p2, Vector2 p3, Vector2 p4, int numSegments);

		public static void PathBezierCubicCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathBezierCubicCurveTo((ImDrawList*)pself, p2, p3, p4, 0);
			}
		}

		public static void PathBezierCubicCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathBezierCubicCurveTo((ImDrawList*)pself, p2, p3, p4, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathBezierQuadraticCurveTo")]
		public static extern void PathBezierQuadraticCurveTo(ImDrawList* self, Vector2 p2, Vector2 p3, int numSegments);

		public static void PathBezierQuadraticCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathBezierQuadraticCurveTo((ImDrawList*)pself, p2, p3, 0);
			}
		}

		public static void PathBezierQuadraticCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathBezierQuadraticCurveTo((ImDrawList*)pself, p2, p3, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathRect")]
		public static extern void PathRect(ImDrawList* self, Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags);

		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathRect((ImDrawList*)pself, rectMin, rectMax, 0.0f, (ImDrawFlags)(0));
			}
		}

		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathRect((ImDrawList*)pself, rectMin, rectMax, rounding, (ImDrawFlags)(0));
			}
		}

		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathRect((ImDrawList*)pself, rectMin, rectMax, rounding, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddCallback")]
		public static extern void AddCallback(ImDrawList* self, delegate*<ImDrawList*, ImDrawCmd*> callback, void* callbackData);

		public static void AddCallback(ref ImDrawList self, delegate*<ImDrawList*, ImDrawCmd*> callback, void* callbackData)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCallback((ImDrawList*)pself, callback, callbackData);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddDrawCmd")]
		public static extern void AddDrawCmd(ImDrawList* self);

		public static void AddDrawCmd(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddDrawCmd((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_CloneOutput")]
		public static extern ImDrawList* CloneOutput(ImDrawList* self);

		public static ImDrawList* CloneOutput(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImDrawList* ret = CloneOutput((ImDrawList*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_ChannelsSplit")]
		public static extern void ChannelsSplit(ImDrawList* self, int count);

		public static void ChannelsSplit(ref ImDrawList self, int count)
		{
			fixed (ImDrawList* pself = &self)
			{
				ChannelsSplit((ImDrawList*)pself, count);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_ChannelsMerge")]
		public static extern void ChannelsMerge(ImDrawList* self);

		public static void ChannelsMerge(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ChannelsMerge((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_ChannelsSetCurrent")]
		public static extern void ChannelsSetCurrent(ImDrawList* self, int n);

		public static void ChannelsSetCurrent(ref ImDrawList self, int n)
		{
			fixed (ImDrawList* pself = &self)
			{
				ChannelsSetCurrent((ImDrawList*)pself, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimReserve")]
		public static extern void PrimReserve(ImDrawList* self, int idxCount, int vtxCount);

		public static void PrimReserve(ref ImDrawList self, int idxCount, int vtxCount)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimReserve((ImDrawList*)pself, idxCount, vtxCount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimUnreserve")]
		public static extern void PrimUnreserve(ImDrawList* self, int idxCount, int vtxCount);

		public static void PrimUnreserve(ref ImDrawList self, int idxCount, int vtxCount)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimUnreserve((ImDrawList*)pself, idxCount, vtxCount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimRect")]
		public static extern void PrimRect(ImDrawList* self, Vector2 a, Vector2 b, uint col);

		public static void PrimRect(ref ImDrawList self, Vector2 a, Vector2 b, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimRect((ImDrawList*)pself, a, b, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimRectUV")]
		public static extern void PrimRectUV(ImDrawList* self, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col);

		public static void PrimRectUV(ref ImDrawList self, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimRectUV((ImDrawList*)pself, a, b, uvA, uvB, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimQuadUV")]
		public static extern void PrimQuadUV(ImDrawList* self, Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col);

		public static void PrimQuadUV(ref ImDrawList self, Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimQuadUV((ImDrawList*)pself, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimWriteVtx")]
		public static extern void PrimWriteVtx(ImDrawList* self, Vector2 pos, Vector2 uv, uint col);

		public static void PrimWriteVtx(ref ImDrawList self, Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimWriteVtx((ImDrawList*)pself, pos, uv, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimWriteIdx")]
		public static extern void PrimWriteIdx(ImDrawList* self, ushort idx);

		public static void PrimWriteIdx(ref ImDrawList self, ushort idx)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimWriteIdx((ImDrawList*)pself, idx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimVtx")]
		public static extern void PrimVtx(ImDrawList* self, Vector2 pos, Vector2 uv, uint col);

		public static void PrimVtx(ref ImDrawList self, Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimVtx((ImDrawList*)pself, pos, uv, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__ResetForNewFrame")]
		public static extern void _ResetForNewFrame(ImDrawList* self);

		public static void _ResetForNewFrame(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_ResetForNewFrame((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__ClearFreeMemory")]
		public static extern void _ClearFreeMemory(ImDrawList* self);

		public static void _ClearFreeMemory(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_ClearFreeMemory((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__PopUnusedDrawCmd")]
		public static extern void _PopUnusedDrawCmd(ImDrawList* self);

		public static void _PopUnusedDrawCmd(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_PopUnusedDrawCmd((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__TryMergeDrawCmds")]
		public static extern void _TryMergeDrawCmds(ImDrawList* self);

		public static void _TryMergeDrawCmds(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_TryMergeDrawCmds((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__OnChangedClipRect")]
		public static extern void _OnChangedClipRect(ImDrawList* self);

		public static void _OnChangedClipRect(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_OnChangedClipRect((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__OnChangedTextureID")]
		public static extern void _OnChangedTextureID(ImDrawList* self);

		public static void _OnChangedTextureID(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_OnChangedTextureID((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__OnChangedVtxOffset")]
		public static extern void _OnChangedVtxOffset(ImDrawList* self);

		public static void _OnChangedVtxOffset(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_OnChangedVtxOffset((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__CalcCircleAutoSegmentCount")]
		public static extern int _CalcCircleAutoSegmentCount(ImDrawList* self, float radius);

		public static int _CalcCircleAutoSegmentCount(ref ImDrawList self, float radius)
		{
			fixed (ImDrawList* pself = &self)
			{
				int ret = _CalcCircleAutoSegmentCount((ImDrawList*)pself, radius);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__PathArcToFastEx")]
		public static extern void _PathArcToFastEx(ImDrawList* self, Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep);

		public static void _PathArcToFastEx(ref ImDrawList self, Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			fixed (ImDrawList* pself = &self)
			{
				_PathArcToFastEx((ImDrawList*)pself, center, radius, aMinSample, aMaxSample, aStep);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__PathArcToN")]
		public static extern void _PathArcToN(ImDrawList* self, Vector2 center, float radius, float aMin, float aMax, int numSegments);

		public static void _PathArcToN(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				_PathArcToN((ImDrawList*)pself, center, radius, aMin, aMax, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_ImDrawData")]
		public static extern ImDrawData* ImDrawData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_destroy")]
		public static extern void Destroy(ImDrawData* self);

		public static void Destroy(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				Destroy((ImDrawData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_Clear")]
		public static extern void Clear(ImDrawData* self);

		public static void Clear(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				Clear((ImDrawData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_DeIndexAllBuffers")]
		public static extern void DeIndexAllBuffers(ImDrawData* self);

		public static void DeIndexAllBuffers(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				DeIndexAllBuffers((ImDrawData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_ScaleClipRects")]
		public static extern void ScaleClipRects(ImDrawData* self, Vector2 fbScale);

		public static void ScaleClipRects(ref ImDrawData self, Vector2 fbScale)
		{
			fixed (ImDrawData* pself = &self)
			{
				ScaleClipRects((ImDrawData*)pself, fbScale);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontConfig_ImFontConfig")]
		public static extern ImFontConfig* ImFontConfig();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontConfig_destroy")]
		public static extern void Destroy(ImFontConfig* self);

		public static void Destroy(ref ImFontConfig self)
		{
			fixed (ImFontConfig* pself = &self)
			{
				Destroy((ImFontConfig*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder")]
		public static extern ImFontGlyphRangesBuilder* ImFontGlyphRangesBuilder();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_destroy")]
		public static extern void Destroy(ImFontGlyphRangesBuilder* self);

		public static void Destroy(ref ImFontGlyphRangesBuilder self)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				Destroy((ImFontGlyphRangesBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_Clear")]
		public static extern void Clear(ImFontGlyphRangesBuilder* self);

		public static void Clear(ref ImFontGlyphRangesBuilder self)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				Clear((ImFontGlyphRangesBuilder*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_GetBit")]
		public static extern bool GetBit(ImFontGlyphRangesBuilder* self, nuint n);

		public static bool GetBit(ref ImFontGlyphRangesBuilder self, nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				bool ret = GetBit((ImFontGlyphRangesBuilder*)pself, n);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_SetBit")]
		public static extern void SetBit(ImFontGlyphRangesBuilder* self, nuint n);

		public static void SetBit(ref ImFontGlyphRangesBuilder self, nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				SetBit((ImFontGlyphRangesBuilder*)pself, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_AddChar")]
		public static extern void AddChar(ImFontGlyphRangesBuilder* self, char c);

		public static void AddChar(ref ImFontGlyphRangesBuilder self, char c)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				AddChar((ImFontGlyphRangesBuilder*)pself, c);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_AddText")]
		public static extern void AddText(ImFontGlyphRangesBuilder* self, byte* text, byte* textEnd);

		public static void AddText(ref ImFontGlyphRangesBuilder self, byte* text)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				AddText((ImFontGlyphRangesBuilder*)pself, text, (string)null);
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, byte* text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				AddText((ImFontGlyphRangesBuilder*)pself, text, textEnd);
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				AddText(self, (byte*)ptext, (string)null);
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				AddText(self, (byte*)ptext, textEnd);
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, pStr0, (string)null);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, ref byte text)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					AddText((ImFontGlyphRangesBuilder*)pself, (byte*)ptext, (string)null);
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, ref byte text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					AddText((ImFontGlyphRangesBuilder*)pself, (byte*)ptext, textEnd);
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, string text)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImFontGlyphRangesBuilder*)pself, pStr0, (string)null);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, string text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImFontGlyphRangesBuilder*)pself, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddText(self, text, (byte*)ptextEnd);
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, byte* text)
		{
			AddText(self, text, (string)null);
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddText(self, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, byte* text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText((ImFontGlyphRangesBuilder*)pself, text, (byte*)ptextEnd);
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, byte* text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddText((ImFontGlyphRangesBuilder*)pself, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddText(self, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddText(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, ref byte text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddText((ImFontGlyphRangesBuilder*)pself, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, string text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddText((ImFontGlyphRangesBuilder*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_AddRanges")]
		public static extern void AddRanges(ImFontGlyphRangesBuilder* self, char* ranges);

		public static void AddRanges(ref ImFontGlyphRangesBuilder self, char* ranges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				AddRanges((ImFontGlyphRangesBuilder*)pself, ranges);
			}
		}

		public static void AddRanges(ImFontGlyphRangesBuilder* self, ref char ranges)
		{
			fixed (char* pranges = &ranges)
			{
				AddRanges(self, (char*)pranges);
			}
		}

		public static void AddRanges(ref ImFontGlyphRangesBuilder self, ref char ranges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (char* pranges = &ranges)
				{
					AddRanges((ImFontGlyphRangesBuilder*)pself, (char*)pranges);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_BuildRanges")]
		public static extern void BuildRanges(ImFontGlyphRangesBuilder* self, ImVectorImWchar* outRanges);

		public static void BuildRanges(ref ImFontGlyphRangesBuilder self, ImVectorImWchar* outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				BuildRanges((ImFontGlyphRangesBuilder*)pself, outRanges);
			}
		}

		public static void BuildRanges(ImFontGlyphRangesBuilder* self, ref ImVectorImWchar outRanges)
		{
			fixed (ImVectorImWchar* poutRanges = &outRanges)
			{
				BuildRanges(self, (ImVectorImWchar*)poutRanges);
			}
		}

		public static void BuildRanges(ref ImFontGlyphRangesBuilder self, ref ImVectorImWchar outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (ImVectorImWchar* poutRanges = &outRanges)
				{
					BuildRanges((ImFontGlyphRangesBuilder*)pself, (ImVectorImWchar*)poutRanges);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlasCustomRect_ImFontAtlasCustomRect")]
		public static extern ImFontAtlasCustomRect* ImFontAtlasCustomRect();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlasCustomRect_destroy")]
		public static extern void Destroy(ImFontAtlasCustomRect* self);

		public static void Destroy(ref ImFontAtlasCustomRect self)
		{
			fixed (ImFontAtlasCustomRect* pself = &self)
			{
				Destroy((ImFontAtlasCustomRect*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlasCustomRect_IsPacked")]
		public static extern bool IsPacked(ImFontAtlasCustomRect* self);

		public static bool IsPacked(ref ImFontAtlasCustomRect self)
		{
			fixed (ImFontAtlasCustomRect* pself = &self)
			{
				bool ret = IsPacked((ImFontAtlasCustomRect*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_ImFontAtlas")]
		public static extern ImFontAtlas* ImFontAtlas();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_destroy")]
		public static extern void Destroy(ImFontAtlas* self);

		public static void Destroy(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				Destroy((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFont")]
		public static extern ImFont* AddFont(ImFontAtlas* self, ImFontConfig* fontCfg);

		public static ImFont* AddFont(ref ImFontAtlas self, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFont((ImFontAtlas*)pself, fontCfg);
				return ret;
			}
		}

		public static ImFont* AddFont(ImFontAtlas* self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFont(self, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}

		public static ImFont* AddFont(ref ImFontAtlas self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFont((ImFontAtlas*)pself, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontDefault")]
		public static extern ImFont* AddFontDefault(ImFontAtlas* self, ImFontConfig* fontCfg);

		public static ImFont* AddFontDefault(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontDefault((ImFontAtlas*)pself, (ImFontConfig*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontDefault(ref ImFontAtlas self, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontDefault((ImFontAtlas*)pself, fontCfg);
				return ret;
			}
		}

		public static ImFont* AddFontDefault(ImFontAtlas* self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontDefault(self, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}

		public static ImFont* AddFontDefault(ref ImFontAtlas self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontDefault((ImFontAtlas*)pself, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontFromFileTTF")]
		public static extern ImFont* AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges);

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, filename, sizePixels, (ImFontConfig*)(null), (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, filename, sizePixels, fontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, filename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFont* ret = AddFontFromFileTTF(self, (byte*)pfilename, sizePixels, (ImFontConfig*)(null), (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFont* ret = AddFontFromFileTTF(self, (byte*)pfilename, sizePixels, fontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFont* ret = AddFontFromFileTTF(self, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFont* ret = AddFontFromFileTTF(self, pStr0, sizePixels, (ImFontConfig*)(null), (char*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ImFontConfig* fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFont* ret = AddFontFromFileTTF(self, pStr0, sizePixels, fontCfg, (char*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFont* ret = AddFontFromFileTTF(self, pStr0, sizePixels, fontCfg, glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, (ImFontConfig*)(null), (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, fontCfg, (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)(null), (char*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, (char*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromFileTTF(self, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromFileTTF(self, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromFileTTF(self, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromFileTTF(self, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromFileTTF(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromFileTTF(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFont* ret = AddFontFromFileTTF(self, filename, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, filename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromFileTTF(self, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFont* ret = AddFontFromFileTTF(self, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromFileTTF(self, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromFileTTF(self, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromFileTTF(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public static ImFont* AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromFileTTF((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontFromMemoryTTF")]
		public static extern ImFont* AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges);

		public static ImFont* AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryTTF((ImFontAtlas*)pself, fontData, fontSize, sizePixels, (ImFontConfig*)(null), (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryTTF((ImFontAtlas*)pself, fontData, fontSize, sizePixels, fontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryTTF((ImFontAtlas*)pself, fontData, fontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromMemoryTTF(self, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromMemoryTTF(self, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryTTF((ImFontAtlas*)pself, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryTTF((ImFontAtlas*)pself, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFont* ret = AddFontFromMemoryTTF(self, fontData, fontSize, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryTTF((ImFontAtlas*)pself, fontData, fontSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryTTF(self, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromMemoryTTF((ImFontAtlas*)pself, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedTTF")]
		public static extern ImFont* AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges);

		public static ImFont* AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryCompressedTTF((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(null), (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryCompressedTTF((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryCompressedTTF((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromMemoryCompressedTTF(self, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromMemoryCompressedTTF(self, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryCompressedTTF((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryCompressedTTF((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFont* ret = AddFontFromMemoryCompressedTTF(self, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryCompressedTTF((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryCompressedTTF(self, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromMemoryCompressedTTF((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedBase85TTF")]
		public static extern ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges);

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, (ImFontConfig*)(null), (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, fontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(null), (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, pStr0, sizePixels, (ImFontConfig*)(null), (char*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, pStr0, sizePixels, fontCfg, (char*)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, pStr0, sizePixels, fontCfg, glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(null), (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)(null), (char*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, (char*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, compressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = AddFontFromMemoryCompressedBase85TTF(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public static ImFont* AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = AddFontFromMemoryCompressedBase85TTF((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_ClearInputData")]
		public static extern void ClearInputData(ImFontAtlas* self);

		public static void ClearInputData(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ClearInputData((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_ClearTexData")]
		public static extern void ClearTexData(ImFontAtlas* self);

		public static void ClearTexData(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ClearTexData((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_ClearFonts")]
		public static extern void ClearFonts(ImFontAtlas* self);

		public static void ClearFonts(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ClearFonts((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_Clear")]
		public static extern void Clear(ImFontAtlas* self);

		public static void Clear(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				Clear((ImFontAtlas*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_Build")]
		public static extern bool Build(ImFontAtlas* self);

		public static bool Build(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				bool ret = Build((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetTexDataAsAlpha8")]
		public static extern void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel);

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, outWidth, outHeight, (int*)(null));
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsAlpha8(self, (byte**)poutPixels, outWidth, outHeight, (int*)(null));
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsAlpha8(self, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsAlpha8(self, outPixels, (int*)poutWidth, outHeight, (int*)(null));
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsAlpha8(self, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8(self, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(null));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsAlpha8(self, outPixels, outWidth, (int*)poutHeight, (int*)(null));
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsAlpha8(self, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8(self, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(null));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8(self, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(null));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(null));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(null));
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				GetTexDataAsAlpha8(self, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8(self, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8(self, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8(self, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								GetTexDataAsAlpha8((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetTexDataAsRGBA32")]
		public static extern void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel);

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, outWidth, outHeight, (int*)(null));
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsRGBA32(self, (byte**)poutPixels, outWidth, outHeight, (int*)(null));
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsRGBA32(self, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsRGBA32(self, outPixels, (int*)poutWidth, outHeight, (int*)(null));
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsRGBA32(self, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32(self, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(null));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsRGBA32(self, outPixels, outWidth, (int*)poutHeight, (int*)(null));
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsRGBA32(self, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32(self, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(null));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(null));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32(self, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(null));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(null));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(null));
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				GetTexDataAsRGBA32(self, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32(self, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32(self, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32(self, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								GetTexDataAsRGBA32((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_IsBuilt")]
		public static extern bool IsBuilt(ImFontAtlas* self);

		public static bool IsBuilt(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				bool ret = IsBuilt((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_SetTexID")]
		public static extern void SetTexID(ImFontAtlas* self, ImTextureID id);

		public static void SetTexID(ref ImFontAtlas self, ImTextureID id)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				SetTexID((ImFontAtlas*)pself, id);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesDefault")]
		public static extern char* GetGlyphRangesDefault(ImFontAtlas* self);

		public static char* GetGlyphRangesDefault(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesDefault((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesGreek")]
		public static extern char* GetGlyphRangesGreek(ImFontAtlas* self);

		public static char* GetGlyphRangesGreek(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesGreek((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesKorean")]
		public static extern char* GetGlyphRangesKorean(ImFontAtlas* self);

		public static char* GetGlyphRangesKorean(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesKorean((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesJapanese")]
		public static extern char* GetGlyphRangesJapanese(ImFontAtlas* self);

		public static char* GetGlyphRangesJapanese(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesJapanese((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesChineseFull")]
		public static extern char* GetGlyphRangesChineseFull(ImFontAtlas* self);

		public static char* GetGlyphRangesChineseFull(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesChineseFull((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon")]
		public static extern char* GetGlyphRangesChineseSimplifiedCommon(ImFontAtlas* self);

		public static char* GetGlyphRangesChineseSimplifiedCommon(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesChineseSimplifiedCommon((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesCyrillic")]
		public static extern char* GetGlyphRangesCyrillic(ImFontAtlas* self);

		public static char* GetGlyphRangesCyrillic(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesCyrillic((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesThai")]
		public static extern char* GetGlyphRangesThai(ImFontAtlas* self);

		public static char* GetGlyphRangesThai(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesThai((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesVietnamese")]
		public static extern char* GetGlyphRangesVietnamese(ImFontAtlas* self);

		public static char* GetGlyphRangesVietnamese(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesVietnamese((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddCustomRectRegular")]
		public static extern int AddCustomRectRegular(ImFontAtlas* self, int width, int height);

		public static int AddCustomRectRegular(ref ImFontAtlas self, int width, int height)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = AddCustomRectRegular((ImFontAtlas*)pself, width, height);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddCustomRectFontGlyph")]
		public static extern int AddCustomRectFontGlyph(ImFontAtlas* self, ImFont* font, char id, int width, int height, float advanceX, Vector2 offset);

		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ImFont* font, char id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = AddCustomRectFontGlyph((ImFontAtlas*)pself, font, id, width, height, advanceX, new Vector2(0,0));
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ImFont* font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = AddCustomRectFontGlyph((ImFontAtlas*)pself, font, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph(ImFontAtlas* self, ref ImFont font, char id, int width, int height, float advanceX)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = AddCustomRectFontGlyph(self, (ImFont*)pfont, id, width, height, advanceX, new Vector2(0,0));
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph(ImFontAtlas* self, ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = AddCustomRectFontGlyph(self, (ImFont*)pfont, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ref ImFont font, char id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = AddCustomRectFontGlyph((ImFontAtlas*)pself, (ImFont*)pfont, id, width, height, advanceX, new Vector2(0,0));
					return ret;
				}
			}
		}

		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = AddCustomRectFontGlyph((ImFontAtlas*)pself, (ImFont*)pfont, id, width, height, advanceX, offset);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetCustomRectByIndex")]
		public static extern ImFontAtlasCustomRect* GetCustomRectByIndex(ImFontAtlas* self, int index);

		public static ImFontAtlasCustomRect* GetCustomRectByIndex(ref ImFontAtlas self, int index)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontAtlasCustomRect* ret = GetCustomRectByIndex((ImFontAtlas*)pself, index);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_CalcCustomRectUV")]
		public static extern void CalcCustomRectUV(ImFontAtlas* self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax);

		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				CalcCustomRectUV((ImFontAtlas*)pself, rect, outUvMin, outUvMax);
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				CalcCustomRectUV(self, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					CalcCustomRectUV((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				CalcCustomRectUV(self, rect, (Vector2*)poutUvMin, outUvMax);
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					CalcCustomRectUV((ImFontAtlas*)pself, rect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					CalcCustomRectUV(self, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						CalcCustomRectUV((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
					}
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMax = &outUvMax)
			{
				CalcCustomRectUV(self, rect, outUvMin, (Vector2*)poutUvMax);
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					CalcCustomRectUV((ImFontAtlas*)pself, rect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					CalcCustomRectUV(self, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						CalcCustomRectUV((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					CalcCustomRectUV(self, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						CalcCustomRectUV((ImFontAtlas*)pself, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						CalcCustomRectUV(self, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						fixed (Vector2* poutUvMax = &outUvMax)
						{
							CalcCustomRectUV((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
						}
					}
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetMouseCursorTexData")]
		public static extern bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill);

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, outUvFill);
				return ret;
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				bool ret = GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
				return ret;
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				bool ret = GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
				return ret;
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					bool ret = GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				bool ret = GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
				return ret;
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					bool ret = GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					bool ret = GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						bool ret = GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
							return ret;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvFill = &outUvFill)
			{
				bool ret = GetMouseCursorTexData(self, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
				return ret;
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					bool ret = GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					bool ret = GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
							return ret;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					bool ret = GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
					return ret;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						bool ret = GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							bool ret = GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								bool ret = GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
								return ret;
							}
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_ImFont")]
		public static extern ImFont* ImFont();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_destroy")]
		public static extern void Destroy(ImFont* self);

		public static void Destroy(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				Destroy((ImFont*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_FindGlyph")]
		public static extern ImFontGlyph* FindGlyph(ImFont* self, char c);

		public static ImFontGlyph* FindGlyph(ref ImFont self, char c)
		{
			fixed (ImFont* pself = &self)
			{
				ImFontGlyph* ret = FindGlyph((ImFont*)pself, c);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_FindGlyphNoFallback")]
		public static extern ImFontGlyph* FindGlyphNoFallback(ImFont* self, char c);

		public static ImFontGlyph* FindGlyphNoFallback(ref ImFont self, char c)
		{
			fixed (ImFont* pself = &self)
			{
				ImFontGlyph* ret = FindGlyphNoFallback((ImFont*)pself, c);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_GetCharAdvance")]
		public static extern float GetCharAdvance(ImFont* self, char c);

		public static float GetCharAdvance(ref ImFont self, char c)
		{
			fixed (ImFont* pself = &self)
			{
				float ret = GetCharAdvance((ImFont*)pself, c);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_IsLoaded")]
		public static extern bool IsLoaded(ImFont* self);

		public static bool IsLoaded(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				bool ret = IsLoaded((ImFont*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_GetDebugName")]
		public static extern byte* GetDebugName(ImFont* self);

		public static string GetDebugNameS(ImFont* self)
		{
			string ret = Marshal.PtrToStringAnsi((nint)GetDebugName(self));
			return ret;
		}

		public static string GetDebugNameS(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				string ret = Marshal.PtrToStringAnsi((nint)GetDebugName((ImFont*)pself));
				return ret;
			}
		}

		public static byte* GetDebugName(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				byte* ret = GetDebugName((ImFont*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_CalcTextSizeA")]
		public static extern void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining);

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, (string)null, (byte**)(null));
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(null));
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (string)null, (byte**)(null));
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(null));
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (string)null, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (string)null, (byte**)(null));
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(null));
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, (string)null, (byte**)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (string)null, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, (string)null, (byte**)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (string)null, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, (string)null, (byte**)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (string)null, (byte**)(null));
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(null));
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, (string)null, (byte**)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(null));
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin)
		{
			CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, (string)null, (byte**)(null));
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(null));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(null));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(null));
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(null));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeA(output, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(null));
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeA(output, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(null));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(null));
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(null));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(null));
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(null));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(null));
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(null));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA(output, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte** premaining = &remaining)
						{
							CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA(output, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeA(output, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(Vector2* output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeA(output, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (byte** premaining = &remaining)
							{
								CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
							}
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeA((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_CalcWordWrapPositionA")]
		public static extern byte* CalcWordWrapPositionA(ImFont* self, float scale, byte* text, byte* textEnd, float wrapWidth);

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA(self, scale, text, textEnd, wrapWidth));
			return ret;
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA((ImFont*)pself, scale, text, textEnd, wrapWidth));
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* ret = CalcWordWrapPositionA((ImFont*)pself, scale, text, textEnd, wrapWidth);
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA(self, scale, (byte*)ptext, textEnd, wrapWidth));
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = CalcWordWrapPositionA(self, scale, (byte*)ptext, textEnd, wrapWidth);
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA(self, scale, pStr0, textEnd, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = CalcWordWrapPositionA(self, scale, pStr0, textEnd, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA((ImFont*)pself, scale, (byte*)ptext, textEnd, wrapWidth));
					return ret;
				}
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					byte* ret = CalcWordWrapPositionA((ImFont*)pself, scale, (byte*)ptext, textEnd, wrapWidth);
					return ret;
				}
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA((ImFont*)pself, scale, pStr0, textEnd, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = CalcWordWrapPositionA((ImFont*)pself, scale, pStr0, textEnd, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA(self, scale, text, (byte*)ptextEnd, wrapWidth));
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte* ret = CalcWordWrapPositionA(self, scale, text, (byte*)ptextEnd, wrapWidth);
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA(self, scale, text, pStr0, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = CalcWordWrapPositionA(self, scale, text, pStr0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA((ImFont*)pself, scale, text, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = CalcWordWrapPositionA((ImFont*)pself, scale, text, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA((ImFont*)pself, scale, text, pStr0, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = CalcWordWrapPositionA((ImFont*)pself, scale, text, pStr0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA(self, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = CalcWordWrapPositionA(self, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA(self, scale, pStr0, pStr1, wrapWidth));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = CalcWordWrapPositionA(self, scale, pStr0, pStr1, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA((ImFont*)pself, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
						return ret;
					}
				}
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte* ret = CalcWordWrapPositionA((ImFont*)pself, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
						return ret;
					}
				}
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)CalcWordWrapPositionA((ImFont*)pself, scale, pStr0, pStr1, wrapWidth));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = CalcWordWrapPositionA((ImFont*)pself, scale, pStr0, pStr1, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_RenderChar")]
		public static extern void RenderChar(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, char c);

		public static void RenderChar(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* pself = &self)
			{
				RenderChar((ImFont*)pself, drawList, size, pos, col, c);
			}
		}

		public static void RenderChar(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderChar(self, (ImDrawList*)pdrawList, size, pos, col, c);
			}
		}

		public static void RenderChar(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderChar((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, c);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_RenderText")]
		public static extern void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip);

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, textEnd, 0.0f, false);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, false);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip);
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, 0.0f, false);
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, false);
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip);
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, 0.0f, false);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, false);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderText(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, 0.0f, false);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderText(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, false);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderText(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, pStr0, textEnd, 0.0f, false);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, false);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, 0.0f, false);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, false);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, textEnd, 0.0f, false);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, false);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, 0.0f, false);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, false);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, 0.0f, false);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, false);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, 0.0f, false);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, false);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, 0.0f, false);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, false);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderText(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, 0.0f, false);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderText(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, false);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderText(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, textBegin, pStr0, 0.0f, false);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, false);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, 0.0f, false);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, false);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, pStr0, 0.0f, false);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, false);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, 0.0f, false);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, false);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, 0.0f, false);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, false);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, 0.0f, false);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, false);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, 0.0f, false);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, false);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, 0.0f, false);
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, false);
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip);
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, pStr0, pStr1, 0.0f, false);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, false);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderText(self, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, 0.0f, false);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, false);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, pStr1, 0.0f, false);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, false);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderText((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, 0.0f, false);
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, false);
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip);
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, 0.0f, false);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, false);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderText(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, 0.0f, false);
						}
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, false);
						}
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip);
						}
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, 0.0f, false);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, false);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					RenderText((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_BuildLookupTable")]
		public static extern void BuildLookupTable(ImFont* self);

		public static void BuildLookupTable(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				BuildLookupTable((ImFont*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_ClearOutputData")]
		public static extern void ClearOutputData(ImFont* self);

		public static void ClearOutputData(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				ClearOutputData((ImFont*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_GrowIndex")]
		public static extern void GrowIndex(ImFont* self, int newSize);

		public static void GrowIndex(ref ImFont self, int newSize)
		{
			fixed (ImFont* pself = &self)
			{
				GrowIndex((ImFont*)pself, newSize);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_AddGlyph")]
		public static extern void AddGlyph(ImFont* self, ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX);

		public static void AddGlyph(ref ImFont self, ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* pself = &self)
			{
				AddGlyph((ImFont*)pself, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public static void AddGlyph(ImFont* self, ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFontConfig* psrcCfg = &srcCfg)
			{
				AddGlyph(self, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public static void AddGlyph(ref ImFont self, ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImFontConfig* psrcCfg = &srcCfg)
				{
					AddGlyph((ImFont*)pself, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_AddRemapChar")]
		public static extern void AddRemapChar(ImFont* self, char dst, char src, bool overwriteDst);

		public static void AddRemapChar(ref ImFont self, char dst, char src)
		{
			fixed (ImFont* pself = &self)
			{
				AddRemapChar((ImFont*)pself, dst, src, true);
			}
		}

		public static void AddRemapChar(ref ImFont self, char dst, char src, bool overwriteDst)
		{
			fixed (ImFont* pself = &self)
			{
				AddRemapChar((ImFont*)pself, dst, src, overwriteDst);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_SetGlyphVisible")]
		public static extern void SetGlyphVisible(ImFont* self, char c, bool visible);

		public static void SetGlyphVisible(ref ImFont self, char c, bool visible)
		{
			fixed (ImFont* pself = &self)
			{
				SetGlyphVisible((ImFont*)pself, c, visible);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_IsGlyphRangeUnused")]
		public static extern bool IsGlyphRangeUnused(ImFont* self, uint cBegin, uint cLast);

		public static bool IsGlyphRangeUnused(ref ImFont self, uint cBegin, uint cLast)
		{
			fixed (ImFont* pself = &self)
			{
				bool ret = IsGlyphRangeUnused((ImFont*)pself, cBegin, cLast);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewport_ImGuiViewport")]
		public static extern ImGuiViewport* ImGuiViewport();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewport_destroy")]
		public static extern void Destroy(ImGuiViewport* self);

		public static void Destroy(ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				Destroy((ImGuiViewport*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewport_GetCenter")]
		public static extern void GetCenter(Vector2* output, ImGuiViewport* self);

		public static void GetCenter(ref Vector2 output, ImGuiViewport* self)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCenter((Vector2*)poutput, self);
			}
		}

		public static void GetCenter(Vector2* output, ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				GetCenter(output, (ImGuiViewport*)pself);
			}
		}

		public static void GetCenter(ref Vector2 output, ref ImGuiViewport self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewport* pself = &self)
				{
					GetCenter((Vector2*)poutput, (ImGuiViewport*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewport_GetWorkCenter")]
		public static extern void GetWorkCenter(Vector2* output, ImGuiViewport* self);

		public static void GetWorkCenter(ref Vector2 output, ImGuiViewport* self)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWorkCenter((Vector2*)poutput, self);
			}
		}

		public static void GetWorkCenter(Vector2* output, ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				GetWorkCenter(output, (ImGuiViewport*)pself);
			}
		}

		public static void GetWorkCenter(ref Vector2 output, ref ImGuiViewport self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewport* pself = &self)
				{
					GetWorkCenter((Vector2*)poutput, (ImGuiViewport*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformIO_ImGuiPlatformIO")]
		public static extern ImGuiPlatformIO* ImGuiPlatformIO();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformIO_destroy")]
		public static extern void Destroy(ImGuiPlatformIO* self);

		public static void Destroy(ref ImGuiPlatformIO self)
		{
			fixed (ImGuiPlatformIO* pself = &self)
			{
				Destroy((ImGuiPlatformIO*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformMonitor_ImGuiPlatformMonitor")]
		public static extern ImGuiPlatformMonitor* ImGuiPlatformMonitor();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformMonitor_destroy")]
		public static extern void Destroy(ImGuiPlatformMonitor* self);

		public static void Destroy(ref ImGuiPlatformMonitor self)
		{
			fixed (ImGuiPlatformMonitor* pself = &self)
			{
				Destroy((ImGuiPlatformMonitor*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformImeData_ImGuiPlatformImeData")]
		public static extern ImGuiPlatformImeData* ImGuiPlatformImeData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformImeData_destroy")]
		public static extern void Destroy(ImGuiPlatformImeData* self);

		public static void Destroy(ref ImGuiPlatformImeData self)
		{
			fixed (ImGuiPlatformImeData* pself = &self)
			{
				Destroy((ImGuiPlatformImeData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyIndex")]
		public static extern ImGuiKey GetKeyIndex(ImGuiKey key);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImHashData")]
		public static extern int ImHashData(void* data, nuint dataSize, int seed);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImHashStr")]
		public static extern int ImHash(byte* data, nuint dataSize, int seed);

		public static int ImHash(ref byte data, nuint dataSize, int seed)
		{
			fixed (byte* pdata = &data)
			{
				int ret = ImHash((byte*)pdata, dataSize, seed);
				return ret;
			}
		}

		public static int ImHash(string data, nuint dataSize, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImHash(pStr0, dataSize, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImQsort")]
		public static extern void ImQsort(void* baseValue, nuint count, nuint sizeOfElement, delegate*<void*, nuint, nuint, delegate*<void*, void*>> compareFunc);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImAlphaBlendColors")]
		public static extern uint ImAlphaBlendColors(uint colA, uint colB);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImIsPowerOfTwo_Int")]
		public static extern bool ImIsPowerOfTwoInt(int v);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImIsPowerOfTwo_U64")]
		public static extern bool ImIsPowerOfTwoU64(ulong v);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImUpperPowerOfTwo")]
		public static extern int ImUpperPowerOfTwo(int v);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStricmp")]
		public static extern int ImStricmp(byte* str1, byte* str2);

		public static int ImStricmp(ref byte str1, byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = ImStricmp((byte*)pstr1, str2);
				return ret;
			}
		}

		public static int ImStricmp(string str1, byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStricmp(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImStricmp(byte* str1, ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImStricmp(str1, (byte*)pstr2);
				return ret;
			}
		}

		public static int ImStricmp(byte* str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStricmp(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImStricmp(ref byte str1, ref byte str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = ImStricmp((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		public static int ImStricmp(string str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImStricmp(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrnicmp")]
		public static extern int ImStrnicmp(byte* str1, byte* str2, nuint count);

		public static int ImStrnicmp(ref byte str1, byte* str2, nuint count)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = ImStrnicmp((byte*)pstr1, str2, count);
				return ret;
			}
		}

		public static int ImStrnicmp(string str1, byte* str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStrnicmp(pStr0, str2, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImStrnicmp(byte* str1, ref byte str2, nuint count)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImStrnicmp(str1, (byte*)pstr2, count);
				return ret;
			}
		}

		public static int ImStrnicmp(byte* str1, string str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStrnicmp(str1, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImStrnicmp(ref byte str1, ref byte str2, nuint count)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = ImStrnicmp((byte*)pstr1, (byte*)pstr2, count);
					return ret;
				}
			}
		}

		public static int ImStrnicmp(string str1, string str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImStrnicmp(pStr0, pStr1, count);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrncpy")]
		public static extern void ImStrncpy(byte* dst, byte* src, nuint count);

		public static void ImStrncpy(ref byte dst, byte* src, nuint count)
		{
			fixed (byte* pdst = &dst)
			{
				ImStrncpy((byte*)pdst, src, count);
			}
		}

		public static void ImStrncpy(ref string dst, byte* src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImStrncpy(pStr0, src, count);
			dst = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImStrncpy(byte* dst, ref byte src, nuint count)
		{
			fixed (byte* psrc = &src)
			{
				ImStrncpy(dst, (byte*)psrc, count);
			}
		}

		public static void ImStrncpy(byte* dst, string src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImStrncpy(dst, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImStrncpy(ref byte dst, ref byte src, nuint count)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					ImStrncpy((byte*)pdst, (byte*)psrc, count);
				}
			}
		}

		public static void ImStrncpy(ref string dst, string src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImStrncpy(pStr0, pStr1, count);
			dst = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrdup")]
		public static extern byte* ImStrdup(byte* str);

		public static string ImStrdupS(byte* str)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImStrdup(str));
			return ret;
		}

		public static string ImStrdupS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStrdup((byte*)pstr));
				return ret;
			}
		}

		public static byte* ImStrdup(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImStrdup((byte*)pstr);
				return ret;
			}
		}

		public static string ImStrdupS(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStrdup(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrdup(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrdup(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrdupcpy")]
		public static extern byte* ImStrdupcpy(byte* dst, nuint* pDstSize, byte* str);

		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, byte* str)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(dst, pDstSize, str));
			return ret;
		}

		public static string ImStrdupcpyS(ref byte dst, nuint* pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy((byte*)pdst, pDstSize, str));
				return ret;
			}
		}

		public static byte* ImStrdupcpy(ref byte dst, nuint* pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				byte* ret = ImStrdupcpy((byte*)pdst, pDstSize, str);
				return ret;
			}
		}

		public static string ImStrdupcpyS(ref string dst, nuint* pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(pStr0, pDstSize, str));
			dst = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrdupcpy(ref string dst, nuint* pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrdupcpy(pStr0, pDstSize, str);
			dst = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrdupcpyS(byte* dst, ref nuint pDstSize, byte* str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(dst, (nuint*)ppDstSize, str));
				return ret;
			}
		}

		public static byte* ImStrdupcpy(byte* dst, ref nuint pDstSize, byte* str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* ret = ImStrdupcpy(dst, (nuint*)ppDstSize, str);
				return ret;
			}
		}

		public static string ImStrdupcpyS(ref byte dst, ref nuint pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (nuint* ppDstSize = &pDstSize)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy((byte*)pdst, (nuint*)ppDstSize, str));
					return ret;
				}
			}
		}

		public static byte* ImStrdupcpy(ref byte dst, ref nuint pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (nuint* ppDstSize = &pDstSize)
				{
					byte* ret = ImStrdupcpy((byte*)pdst, (nuint*)ppDstSize, str);
					return ret;
				}
			}
		}

		public static string ImStrdupcpyS(ref string dst, ref nuint pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppDstSize = &pDstSize)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(pStr0, (nuint*)ppDstSize, str));
				dst = Marshal.PtrToStringAnsi((nint)pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* ImStrdupcpy(ref string dst, ref nuint pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* ret = ImStrdupcpy(pStr0, (nuint*)ppDstSize, str);
				dst = Marshal.PtrToStringAnsi((nint)pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(dst, pDstSize, (byte*)pstr));
				return ret;
			}
		}

		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImStrdupcpy(dst, pDstSize, (byte*)pstr);
				return ret;
			}
		}

		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(dst, pDstSize, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrdupcpy(dst, pDstSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrdupcpyS(ref byte dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* pstr = &str)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy((byte*)pdst, pDstSize, (byte*)pstr));
					return ret;
				}
			}
		}

		public static byte* ImStrdupcpy(ref byte dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* pstr = &str)
				{
					byte* ret = ImStrdupcpy((byte*)pdst, pDstSize, (byte*)pstr);
					return ret;
				}
			}
		}

		public static string ImStrdupcpyS(ref string dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(pStr0, pDstSize, pStr1));
			dst = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrdupcpy(ref string dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStrdupcpy(pStr0, pDstSize, pStr1);
			dst = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrdupcpyS(byte* dst, ref nuint pDstSize, ref byte str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				fixed (byte* pstr = &str)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(dst, (nuint*)ppDstSize, (byte*)pstr));
					return ret;
				}
			}
		}

		public static byte* ImStrdupcpy(byte* dst, ref nuint pDstSize, ref byte str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				fixed (byte* pstr = &str)
				{
					byte* ret = ImStrdupcpy(dst, (nuint*)ppDstSize, (byte*)pstr);
					return ret;
				}
			}
		}

		public static string ImStrdupcpyS(byte* dst, ref nuint pDstSize, string str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(dst, (nuint*)ppDstSize, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* ImStrdupcpy(byte* dst, ref nuint pDstSize, string str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImStrdupcpy(dst, (nuint*)ppDstSize, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string ImStrdupcpyS(ref byte dst, ref nuint pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (nuint* ppDstSize = &pDstSize)
				{
					fixed (byte* pstr = &str)
					{
						string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy((byte*)pdst, (nuint*)ppDstSize, (byte*)pstr));
						return ret;
					}
				}
			}
		}

		public static byte* ImStrdupcpy(ref byte dst, ref nuint pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (nuint* ppDstSize = &pDstSize)
				{
					fixed (byte* pstr = &str)
					{
						byte* ret = ImStrdupcpy((byte*)pdst, (nuint*)ppDstSize, (byte*)pstr);
						return ret;
					}
				}
			}
		}

		public static string ImStrdupcpyS(ref string dst, ref nuint pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (str != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(str);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)ImStrdupcpy(pStr0, (nuint*)ppDstSize, pStr1));
				dst = Marshal.PtrToStringAnsi((nint)pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* ImStrdupcpy(ref string dst, ref nuint pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (str != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(str);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImStrdupcpy(pStr0, (nuint*)ppDstSize, pStr1);
				dst = Marshal.PtrToStringAnsi((nint)pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrchrRange")]
		public static extern byte* ImStrchrRange(byte* strBegin, byte* strEnd, byte c);

		public static string ImStrchrRangeS(byte* strBegin, byte* strEnd, byte c)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImStrchrRange(strBegin, strEnd, c));
			return ret;
		}

		public static string ImStrchrRangeS(ref byte strBegin, byte* strEnd, byte c)
		{
			fixed (byte* pstrBegin = &strBegin)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStrchrRange((byte*)pstrBegin, strEnd, c));
				return ret;
			}
		}

		public static byte* ImStrchrRange(ref byte strBegin, byte* strEnd, byte c)
		{
			fixed (byte* pstrBegin = &strBegin)
			{
				byte* ret = ImStrchrRange((byte*)pstrBegin, strEnd, c);
				return ret;
			}
		}

		public static string ImStrchrRangeS(string strBegin, byte* strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStrchrRange(pStr0, strEnd, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrchrRange(string strBegin, byte* strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrchrRange(pStr0, strEnd, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrchrRangeS(byte* strBegin, ref byte strEnd, byte c)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStrchrRange(strBegin, (byte*)pstrEnd, c));
				return ret;
			}
		}

		public static byte* ImStrchrRange(byte* strBegin, ref byte strEnd, byte c)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				byte* ret = ImStrchrRange(strBegin, (byte*)pstrEnd, c);
				return ret;
			}
		}

		public static string ImStrchrRangeS(byte* strBegin, string strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStrchrRange(strBegin, pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrchrRange(byte* strBegin, string strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrchrRange(strBegin, pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrchrRangeS(ref byte strBegin, ref byte strEnd, byte c)
		{
			fixed (byte* pstrBegin = &strBegin)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStrchrRange((byte*)pstrBegin, (byte*)pstrEnd, c));
					return ret;
				}
			}
		}

		public static byte* ImStrchrRange(ref byte strBegin, ref byte strEnd, byte c)
		{
			fixed (byte* pstrBegin = &strBegin)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					byte* ret = ImStrchrRange((byte*)pstrBegin, (byte*)pstrEnd, c);
					return ret;
				}
			}
		}

		public static string ImStrchrRangeS(string strBegin, string strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStrchrRange(pStr0, pStr1, c));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrchrRange(string strBegin, string strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStrchrRange(pStr0, pStr1, c);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrlenW")]
		public static extern int ImStrlenW(char* str);

		public static int ImStrlenW(ref char str)
		{
			fixed (char* pstr = &str)
			{
				int ret = ImStrlenW((char*)pstr);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStreolRange")]
		public static extern byte* ImStreolRange(byte* str, byte* strEnd);

		public static string ImStreolRangeS(byte* str, byte* strEnd)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImStreolRange(str, strEnd));
			return ret;
		}

		public static string ImStreolRangeS(ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStreolRange((byte*)pstr, strEnd));
				return ret;
			}
		}

		public static byte* ImStreolRange(ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImStreolRange((byte*)pstr, strEnd);
				return ret;
			}
		}

		public static string ImStreolRangeS(string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStreolRange(pStr0, strEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStreolRange(string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStreolRange(pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStreolRangeS(byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStreolRange(str, (byte*)pstrEnd));
				return ret;
			}
		}

		public static byte* ImStreolRange(byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				byte* ret = ImStreolRange(str, (byte*)pstrEnd);
				return ret;
			}
		}

		public static string ImStreolRangeS(byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStreolRange(str, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStreolRange(byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStreolRange(str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStreolRangeS(ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStreolRange((byte*)pstr, (byte*)pstrEnd));
					return ret;
				}
			}
		}

		public static byte* ImStreolRange(ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					byte* ret = ImStreolRange((byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		public static string ImStreolRangeS(string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStreolRange(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStreolRange(string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStreolRange(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrbolW")]
		public static extern char* ImStrbolW(char* bufMidLine, char* bufBegin);

		public static char* ImStrbolW(ref char bufMidLine, char* bufBegin)
		{
			fixed (char* pbufMidLine = &bufMidLine)
			{
				char* ret = ImStrbolW((char*)pbufMidLine, bufBegin);
				return ret;
			}
		}

		public static char* ImStrbolW(char* bufMidLine, ref char bufBegin)
		{
			fixed (char* pbufBegin = &bufBegin)
			{
				char* ret = ImStrbolW(bufMidLine, (char*)pbufBegin);
				return ret;
			}
		}

		public static char* ImStrbolW(ref char bufMidLine, ref char bufBegin)
		{
			fixed (char* pbufMidLine = &bufMidLine)
			{
				fixed (char* pbufBegin = &bufBegin)
				{
					char* ret = ImStrbolW((char*)pbufMidLine, (char*)pbufBegin);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStristr")]
		public static extern byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, byte* needleEnd);

		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, haystackEnd, needle, needleEnd));
			return ret;
		}

		public static string ImStristrS(ref byte haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStristr((byte*)phaystack, haystackEnd, needle, needleEnd));
				return ret;
			}
		}

		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = ImStristr((byte*)phaystack, haystackEnd, needle, needleEnd);
				return ret;
			}
		}

		public static string ImStristrS(string haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(pStr0, haystackEnd, needle, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(string haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristr(pStr0, haystackEnd, needle, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, (byte*)phaystackEnd, needle, needleEnd));
				return ret;
			}
		}

		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* ret = ImStristr(haystack, (byte*)phaystackEnd, needle, needleEnd);
				return ret;
			}
		}

		public static string ImStristrS(byte* haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, pStr0, needle, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristr(haystack, pStr0, needle, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* ret = ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(string haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(pStr0, pStr1, needle, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(string haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristr(pStr0, pStr1, needle, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, haystackEnd, (byte*)pneedle, needleEnd));
				return ret;
			}
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = ImStristr(haystack, haystackEnd, (byte*)pneedle, needleEnd);
				return ret;
			}
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, haystackEnd, pStr0, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristr(haystack, haystackEnd, pStr0, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(string haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(pStr0, haystackEnd, pStr1, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(string haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristr(pStr0, haystackEnd, pStr1, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(byte* haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, pStr0, pStr1, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristr(haystack, pStr0, pStr1, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						string ret = Marshal.PtrToStringAnsi((nint)ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}

		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* ret = ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}

		public static string ImStristrS(string haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(pStr0, pStr1, pStr2, needleEnd));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(string haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristr(pStr0, pStr1, pStr2, needleEnd);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, haystackEnd, needle, (byte*)pneedleEnd));
				return ret;
			}
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImStristr(haystack, haystackEnd, needle, (byte*)pneedleEnd);
				return ret;
			}
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needleEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, haystackEnd, needle, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needleEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristr(haystack, haystackEnd, needle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(ref byte haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(string haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(pStr0, haystackEnd, needle, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(string haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristr(pStr0, haystackEnd, needle, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(byte* haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, pStr0, needle, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristr(haystack, pStr0, needle, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Marshal.PtrToStringAnsi((nint)ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}

		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}

		public static string ImStristrS(string haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(pStr0, pStr1, needle, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(string haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristr(pStr0, pStr1, needle, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, haystackEnd, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristr(haystack, haystackEnd, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Marshal.PtrToStringAnsi((nint)ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}

		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}

		public static string ImStristrS(string haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(pStr0, haystackEnd, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(string haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristr(pStr0, haystackEnd, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}

		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}

		public static string ImStristrS(byte* haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(haystack, pStr0, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristr(haystack, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Marshal.PtrToStringAnsi((nint)ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}

		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}

		public static string ImStristrS(string haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* pStr3 = null;
			int pStrSize3 = 0;
			if (needleEnd != null)
			{
				pStrSize3 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize3 >= Utils.MaxStackallocSize)
				{
					pStr3 = Utils.Alloc<byte>(pStrSize3 + 1);
				}
				else
				{
					byte* pStrStack3 = stackalloc byte[pStrSize3 + 1];
					pStr3 = pStrStack3;
				}
				int pStrOffset3 = Utils.EncodeStringUTF8(needleEnd, pStr3, pStrSize3);
				pStr3[pStrOffset3] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImStristr(pStr0, pStr1, pStr2, pStr3));
			if (pStrSize3 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr3);
			}
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(string haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* pStr3 = null;
			int pStrSize3 = 0;
			if (needleEnd != null)
			{
				pStrSize3 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize3 >= Utils.MaxStackallocSize)
				{
					pStr3 = Utils.Alloc<byte>(pStrSize3 + 1);
				}
				else
				{
					byte* pStrStack3 = stackalloc byte[pStrSize3 + 1];
					pStr3 = pStrStack3;
				}
				int pStrOffset3 = Utils.EncodeStringUTF8(needleEnd, pStr3, pStrSize3);
				pStr3[pStrOffset3] = 0;
			}
			byte* ret = ImStristr(pStr0, pStr1, pStr2, pStr3);
			if (pStrSize3 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr3);
			}
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrTrimBlanks")]
		public static extern void ImTrimBlanks(byte* str);

		public static void ImTrimBlanks(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				ImTrimBlanks((byte*)pstr);
			}
		}

		public static void ImTrimBlanks(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImTrimBlanks(pStr0);
			str = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrSkipBlank")]
		public static extern byte* ImSkipBlank(byte* str);

		public static string ImSkipBlankS(byte* str)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImSkipBlank(str));
			return ret;
		}

		public static string ImSkipBlankS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImSkipBlank((byte*)pstr));
				return ret;
			}
		}

		public static byte* ImSkipBlank(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImSkipBlank((byte*)pstr);
				return ret;
			}
		}

		public static string ImSkipBlankS(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImSkipBlank(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImSkipBlank(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImSkipBlank(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImToUpper")]
		public static extern byte ImToUpper(byte c);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImCharIsBlankA")]
		public static extern bool ImCharIsBlankA(byte c);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImCharIsBlankW")]
		public static extern bool ImCharIsBlankW(uint c);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFormatString")]
		public static extern int ImFormatString(byte* buf, nuint bufSize, byte* fmt);

		public static int ImFormatString(ref byte buf, nuint bufSize, byte* fmt)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = ImFormatString((byte*)pbuf, bufSize, fmt);
				return ret;
			}
		}

		public static int ImFormatString(ref string buf, nuint bufSize, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImFormatString(pStr0, bufSize, fmt);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImFormatString(byte* buf, nuint bufSize, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = ImFormatString(buf, bufSize, (byte*)pfmt);
				return ret;
			}
		}

		public static int ImFormatString(byte* buf, nuint bufSize, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImFormatString(buf, bufSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImFormatString(ref byte buf, nuint bufSize, ref byte fmt)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = ImFormatString((byte*)pbuf, bufSize, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static int ImFormatString(ref string buf, nuint bufSize, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImFormatString(pStr0, bufSize, pStr1);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFormatStringV")]
		public static extern int ImFormatStringV(byte* buf, nuint bufSize, byte* fmt, nuint args);

		public static int ImFormatStringV(ref byte buf, nuint bufSize, byte* fmt, nuint args)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = ImFormatStringV((byte*)pbuf, bufSize, fmt, args);
				return ret;
			}
		}

		public static int ImFormatStringV(ref string buf, nuint bufSize, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImFormatStringV(pStr0, bufSize, fmt, args);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImFormatStringV(byte* buf, nuint bufSize, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = ImFormatStringV(buf, bufSize, (byte*)pfmt, args);
				return ret;
			}
		}

		public static int ImFormatStringV(byte* buf, nuint bufSize, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImFormatStringV(buf, bufSize, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImFormatStringV(ref byte buf, nuint bufSize, ref byte fmt, nuint args)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = ImFormatStringV((byte*)pbuf, bufSize, (byte*)pfmt, args);
					return ret;
				}
			}
		}

		public static int ImFormatStringV(ref string buf, nuint bufSize, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImFormatStringV(pStr0, bufSize, pStr1, args);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFormatStringToTempBuffer")]
		public static extern void ImFormatStringToTempBuffer(byte** outBuf, byte** outBufEnd, byte* fmt);

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, byte** outBufEnd, byte* fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				ImFormatStringToTempBuffer((byte**)poutBuf, outBufEnd, fmt);
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, ref byte* outBufEnd, byte* fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				ImFormatStringToTempBuffer(outBuf, (byte**)poutBufEnd, fmt);
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, ref byte* outBufEnd, byte* fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					ImFormatStringToTempBuffer((byte**)poutBuf, (byte**)poutBufEnd, fmt);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, byte** outBufEnd, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImFormatStringToTempBuffer(outBuf, outBufEnd, (byte*)pfmt);
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, byte** outBufEnd, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFormatStringToTempBuffer(outBuf, outBufEnd, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, byte** outBufEnd, ref byte fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBuffer((byte**)poutBuf, outBufEnd, (byte*)pfmt);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, byte** outBufEnd, string fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBuffer((byte**)poutBuf, outBufEnd, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, ref byte* outBufEnd, ref byte fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBuffer(outBuf, (byte**)poutBufEnd, (byte*)pfmt);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, ref byte* outBufEnd, string fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBuffer(outBuf, (byte**)poutBufEnd, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, ref byte* outBufEnd, ref byte fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					fixed (byte* pfmt = &fmt)
					{
						ImFormatStringToTempBuffer((byte**)poutBuf, (byte**)poutBufEnd, (byte*)pfmt);
					}
				}
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, ref byte* outBufEnd, string fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (fmt != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(fmt);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImFormatStringToTempBuffer((byte**)poutBuf, (byte**)poutBufEnd, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFormatStringToTempBufferV")]
		public static extern void ImFormatStringToTempBufferV(byte** outBuf, byte** outBufEnd, byte* fmt, nuint args);

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, byte** outBufEnd, byte* fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				ImFormatStringToTempBufferV((byte**)poutBuf, outBufEnd, fmt, args);
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, ref byte* outBufEnd, byte* fmt, nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				ImFormatStringToTempBufferV(outBuf, (byte**)poutBufEnd, fmt, args);
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, ref byte* outBufEnd, byte* fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					ImFormatStringToTempBufferV((byte**)poutBuf, (byte**)poutBufEnd, fmt, args);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, byte** outBufEnd, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImFormatStringToTempBufferV(outBuf, outBufEnd, (byte*)pfmt, args);
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, byte** outBufEnd, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFormatStringToTempBufferV(outBuf, outBufEnd, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, byte** outBufEnd, ref byte fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBufferV((byte**)poutBuf, outBufEnd, (byte*)pfmt, args);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, byte** outBufEnd, string fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBufferV((byte**)poutBuf, outBufEnd, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, ref byte* outBufEnd, ref byte fmt, nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBufferV(outBuf, (byte**)poutBufEnd, (byte*)pfmt, args);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, ref byte* outBufEnd, string fmt, nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBufferV(outBuf, (byte**)poutBufEnd, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, ref byte* outBufEnd, ref byte fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					fixed (byte* pfmt = &fmt)
					{
						ImFormatStringToTempBufferV((byte**)poutBuf, (byte**)poutBufEnd, (byte*)pfmt, args);
					}
				}
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, ref byte* outBufEnd, string fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (fmt != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(fmt);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImFormatStringToTempBufferV((byte**)poutBuf, (byte**)poutBufEnd, pStr0, args);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatFindStart")]
		public static extern byte* ImParseFormatFindStart(byte* format);

		public static string ImParseFormatFindStartS(byte* format)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatFindStart(format));
			return ret;
		}

		public static string ImParseFormatFindStartS(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatFindStart((byte*)pformat));
				return ret;
			}
		}

		public static byte* ImParseFormatFindStart(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte* ret = ImParseFormatFindStart((byte*)pformat);
				return ret;
			}
		}

		public static string ImParseFormatFindStartS(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatFindStart(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatFindStart(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatFindStart(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatFindEnd")]
		public static extern byte* ImParseFormatFindEnd(byte* format);

		public static string ImParseFormatFindEndS(byte* format)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatFindEnd(format));
			return ret;
		}

		public static string ImParseFormatFindEndS(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatFindEnd((byte*)pformat));
				return ret;
			}
		}

		public static byte* ImParseFormatFindEnd(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte* ret = ImParseFormatFindEnd((byte*)pformat);
				return ret;
			}
		}

		public static string ImParseFormatFindEndS(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatFindEnd(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatFindEnd(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatFindEnd(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatTrimDecorations")]
		public static extern byte* ImParseFormatTrimDecorations(byte* format, byte* buf, nuint bufSize);

		public static string ImParseFormatTrimDecorationsS(byte* format, byte* buf, nuint bufSize)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatTrimDecorations(format, buf, bufSize));
			return ret;
		}

		public static string ImParseFormatTrimDecorationsS(ref byte format, byte* buf, nuint bufSize)
		{
			fixed (byte* pformat = &format)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatTrimDecorations((byte*)pformat, buf, bufSize));
				return ret;
			}
		}

		public static byte* ImParseFormatTrimDecorations(ref byte format, byte* buf, nuint bufSize)
		{
			fixed (byte* pformat = &format)
			{
				byte* ret = ImParseFormatTrimDecorations((byte*)pformat, buf, bufSize);
				return ret;
			}
		}

		public static string ImParseFormatTrimDecorationsS(string format, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatTrimDecorations(pStr0, buf, bufSize));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatTrimDecorations(string format, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatTrimDecorations(pStr0, buf, bufSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatTrimDecorationsS(byte* format, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatTrimDecorations(format, (byte*)pbuf, bufSize));
				return ret;
			}
		}

		public static byte* ImParseFormatTrimDecorations(byte* format, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				byte* ret = ImParseFormatTrimDecorations(format, (byte*)pbuf, bufSize);
				return ret;
			}
		}

		public static string ImParseFormatTrimDecorationsS(byte* format, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatTrimDecorations(format, pStr0, bufSize));
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatTrimDecorations(byte* format, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatTrimDecorations(format, pStr0, bufSize);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatTrimDecorationsS(ref byte format, ref byte buf, nuint bufSize)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pbuf = &buf)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatTrimDecorations((byte*)pformat, (byte*)pbuf, bufSize));
					return ret;
				}
			}
		}

		public static byte* ImParseFormatTrimDecorations(ref byte format, ref byte buf, nuint bufSize)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pbuf = &buf)
				{
					byte* ret = ImParseFormatTrimDecorations((byte*)pformat, (byte*)pbuf, bufSize);
					return ret;
				}
			}
		}

		public static string ImParseFormatTrimDecorationsS(string format, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatTrimDecorations(pStr0, pStr1, bufSize));
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatTrimDecorations(string format, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImParseFormatTrimDecorations(pStr0, pStr1, bufSize);
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatSanitizeForPrinting")]
		public static extern void ImParseFormatSanitizeForPrinting(byte* fmtIn, byte* fmtOut, nuint fmtOutSize);

		public static void ImParseFormatSanitizeForPrinting(ref byte fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				ImParseFormatSanitizeForPrinting((byte*)pfmtIn, fmtOut, fmtOutSize);
			}
		}

		public static void ImParseFormatSanitizeForPrinting(string fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImParseFormatSanitizeForPrinting(pStr0, fmtOut, fmtOutSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImParseFormatSanitizeForPrinting(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				ImParseFormatSanitizeForPrinting(fmtIn, (byte*)pfmtOut, fmtOutSize);
			}
		}

		public static void ImParseFormatSanitizeForPrinting(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImParseFormatSanitizeForPrinting(fmtIn, pStr0, fmtOutSize);
			fmtOut = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImParseFormatSanitizeForPrinting(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					ImParseFormatSanitizeForPrinting((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
				}
			}
		}

		public static void ImParseFormatSanitizeForPrinting(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImParseFormatSanitizeForPrinting(pStr0, pStr1, fmtOutSize);
			fmtOut = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatSanitizeForScanning")]
		public static extern byte* ImParseFormatSanitizeForScanning(byte* fmtIn, byte* fmtOut, nuint fmtOutSize);

		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatSanitizeForScanning(fmtIn, fmtOut, fmtOutSize));
			return ret;
		}

		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatSanitizeForScanning((byte*)pfmtIn, fmtOut, fmtOutSize));
				return ret;
			}
		}

		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* ret = ImParseFormatSanitizeForScanning((byte*)pfmtIn, fmtOut, fmtOutSize);
				return ret;
			}
		}

		public static string ImParseFormatSanitizeForScanningS(string fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatSanitizeForScanning(pStr0, fmtOut, fmtOutSize));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanning(pStr0, fmtOut, fmtOutSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatSanitizeForScanning(fmtIn, (byte*)pfmtOut, fmtOutSize));
				return ret;
			}
		}

		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				byte* ret = ImParseFormatSanitizeForScanning(fmtIn, (byte*)pfmtOut, fmtOutSize);
				return ret;
			}
		}

		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatSanitizeForScanning(fmtIn, pStr0, fmtOutSize));
			fmtOut = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanning(fmtIn, pStr0, fmtOutSize);
			fmtOut = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatSanitizeForScanning((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize));
					return ret;
				}
			}
		}

		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					byte* ret = ImParseFormatSanitizeForScanning((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
					return ret;
				}
			}
		}

		public static string ImParseFormatSanitizeForScanningS(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImParseFormatSanitizeForScanning(pStr0, pStr1, fmtOutSize));
			fmtOut = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanning(pStr0, pStr1, fmtOutSize);
			fmtOut = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatPrecision")]
		public static extern int ImParseFormatPrecision(byte* format, int defaultValue);

		public static int ImParseFormatPrecision(ref byte format, int defaultValue)
		{
			fixed (byte* pformat = &format)
			{
				int ret = ImParseFormatPrecision((byte*)pformat, defaultValue);
				return ret;
			}
		}

		public static int ImParseFormatPrecision(string format, int defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImParseFormatPrecision(pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCharToUtf8")]
		public static extern byte* ImTextCharToUtf8(byte* outBuf, uint c);

		public static string ImTextCharToUtf8S(byte* outBuf, uint c)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImTextCharToUtf8(outBuf, c));
			return ret;
		}

		public static string ImTextCharToUtf8S(ref byte outBuf, uint c)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImTextCharToUtf8((byte*)poutBuf, c));
				return ret;
			}
		}

		public static byte* ImTextCharToUtf8(ref byte outBuf, uint c)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				byte* ret = ImTextCharToUtf8((byte*)poutBuf, c);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextStrToUtf8")]
		public static extern int ImTextToUtf8(byte* outBuf, int outBufSize, char* inText, char* inTextEnd);

		public static int ImTextToUtf8(ref byte outBuf, int outBufSize, char* inText, char* inTextEnd)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				int ret = ImTextToUtf8((byte*)poutBuf, outBufSize, inText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextToUtf8(ref string outBuf, int outBufSize, char* inText, char* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextToUtf8(pStr0, outBufSize, inText, inTextEnd);
			outBuf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextToUtf8(byte* outBuf, int outBufSize, ref char inText, char* inTextEnd)
		{
			fixed (char* pinText = &inText)
			{
				int ret = ImTextToUtf8(outBuf, outBufSize, (char*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextToUtf8(ref byte outBuf, int outBufSize, ref char inText, char* inTextEnd)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				fixed (char* pinText = &inText)
				{
					int ret = ImTextToUtf8((byte*)poutBuf, outBufSize, (char*)pinText, inTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextToUtf8(ref string outBuf, int outBufSize, ref char inText, char* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pinText = &inText)
			{
				int ret = ImTextToUtf8(pStr0, outBufSize, (char*)pinText, inTextEnd);
				outBuf = Marshal.PtrToStringAnsi((nint)pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextToUtf8(byte* outBuf, int outBufSize, char* inText, ref char inTextEnd)
		{
			fixed (char* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextToUtf8(outBuf, outBufSize, inText, (char*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextToUtf8(ref byte outBuf, int outBufSize, char* inText, ref char inTextEnd)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				fixed (char* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextToUtf8((byte*)poutBuf, outBufSize, inText, (char*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextToUtf8(ref string outBuf, int outBufSize, char* inText, ref char inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextToUtf8(pStr0, outBufSize, inText, (char*)pinTextEnd);
				outBuf = Marshal.PtrToStringAnsi((nint)pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextToUtf8(byte* outBuf, int outBufSize, ref char inText, ref char inTextEnd)
		{
			fixed (char* pinText = &inText)
			{
				fixed (char* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextToUtf8(outBuf, outBufSize, (char*)pinText, (char*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextToUtf8(ref byte outBuf, int outBufSize, ref char inText, ref char inTextEnd)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				fixed (char* pinText = &inText)
				{
					fixed (char* pinTextEnd = &inTextEnd)
					{
						int ret = ImTextToUtf8((byte*)poutBuf, outBufSize, (char*)pinText, (char*)pinTextEnd);
						return ret;
					}
				}
			}
		}

		public static int ImTextToUtf8(ref string outBuf, int outBufSize, ref char inText, ref char inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pinText = &inText)
			{
				fixed (char* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextToUtf8(pStr0, outBufSize, (char*)pinText, (char*)pinTextEnd);
					outBuf = Marshal.PtrToStringAnsi((nint)pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCharFromUtf8")]
		public static extern int ImTextCharFromUtf8(uint* outChar, byte* inText, byte* inTextEnd);

		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				int ret = ImTextCharFromUtf8((uint*)poutChar, inText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCharFromUtf8(outChar, (byte*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCharFromUtf8(outChar, pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					int ret = ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, inTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCharFromUtf8(ref uint outChar, string inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCharFromUtf8((uint*)poutChar, pStr0, inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCharFromUtf8(outChar, inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCharFromUtf8(outChar, inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8((uint*)poutChar, inText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCharFromUtf8((uint*)poutChar, inText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCharFromUtf8(outChar, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						int ret = ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}

		public static int ImTextCharFromUtf8(ref uint outChar, string inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (inTextEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImTextCharFromUtf8((uint*)poutChar, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextStrFromUtf8")]
		public static extern int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, byte* inTextEnd, byte** inRemaining);

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, byte* inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, inText, inTextEnd, inRemaining);
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, ref byte inText, byte* inTextEnd, byte** inRemaining)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextFromUtf8(outBuf, outBufSize, (byte*)pinText, inTextEnd, inRemaining);
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, string inText, byte* inTextEnd, byte** inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextFromUtf8(outBuf, outBufSize, pStr0, inTextEnd, inRemaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, ref byte inText, byte* inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinText = &inText)
				{
					int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, (byte*)pinText, inTextEnd, inRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, string inText, byte* inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, pStr0, inTextEnd, inRemaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, ref byte inTextEnd, byte** inRemaining)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextFromUtf8(outBuf, outBufSize, inText, (byte*)pinTextEnd, inRemaining);
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, string inTextEnd, byte** inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextFromUtf8(outBuf, outBufSize, inText, pStr0, inRemaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, ref byte inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, inText, (byte*)pinTextEnd, inRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, string inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, inText, pStr0, inRemaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, ref byte inText, ref byte inTextEnd, byte** inRemaining)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextFromUtf8(outBuf, outBufSize, (byte*)pinText, (byte*)pinTextEnd, inRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, string inText, string inTextEnd, byte** inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextFromUtf8(outBuf, outBufSize, pStr0, pStr1, inRemaining);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, ref byte inText, ref byte inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, (byte*)pinText, (byte*)pinTextEnd, inRemaining);
						return ret;
					}
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, string inText, string inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (inTextEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, pStr0, pStr1, inRemaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (byte** pinRemaining = &inRemaining)
			{
				int ret = ImTextFromUtf8(outBuf, outBufSize, inText, inTextEnd, (byte**)pinRemaining);
				return ret;
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, inText, inTextEnd, (byte**)pinRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, ref byte inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8(outBuf, outBufSize, (byte*)pinText, inTextEnd, (byte**)pinRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, string inText, byte* inTextEnd, ref byte* inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pinRemaining = &inRemaining)
			{
				int ret = ImTextFromUtf8(outBuf, outBufSize, pStr0, inTextEnd, (byte**)pinRemaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, ref byte inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte** pinRemaining = &inRemaining)
					{
						int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, (byte*)pinText, inTextEnd, (byte**)pinRemaining);
						return ret;
					}
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, string inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, pStr0, inTextEnd, (byte**)pinRemaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, ref byte inTextEnd, ref byte* inRemaining)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8(outBuf, outBufSize, inText, (byte*)pinTextEnd, (byte**)pinRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, string inTextEnd, ref byte* inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pinRemaining = &inRemaining)
			{
				int ret = ImTextFromUtf8(outBuf, outBufSize, inText, pStr0, (byte**)pinRemaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, ref byte inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					fixed (byte** pinRemaining = &inRemaining)
					{
						int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, inText, (byte*)pinTextEnd, (byte**)pinRemaining);
						return ret;
					}
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, string inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, inText, pStr0, (byte**)pinRemaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, ref byte inText, ref byte inTextEnd, ref byte* inRemaining)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					fixed (byte** pinRemaining = &inRemaining)
					{
						int ret = ImTextFromUtf8(outBuf, outBufSize, (byte*)pinText, (byte*)pinTextEnd, (byte**)pinRemaining);
						return ret;
					}
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, string inText, string inTextEnd, ref byte* inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** pinRemaining = &inRemaining)
			{
				int ret = ImTextFromUtf8(outBuf, outBufSize, pStr0, pStr1, (byte**)pinRemaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, ref byte inText, ref byte inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						fixed (byte** pinRemaining = &inRemaining)
						{
							int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, (byte*)pinText, (byte*)pinTextEnd, (byte**)pinRemaining);
							return ret;
						}
					}
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, string inText, string inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (inTextEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8((char*)poutBuf, outBufSize, pStr0, pStr1, (byte**)pinRemaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCountCharsFromUtf8")]
		public static extern int ImTextCountCharsFromUtf8(byte* inText, byte* inTextEnd);

		public static int ImTextCountCharsFromUtf8(ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCountCharsFromUtf8((byte*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCountCharsFromUtf8(string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountCharsFromUtf8(pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCountCharsFromUtf8(byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountCharsFromUtf8(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextCountCharsFromUtf8(byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountCharsFromUtf8(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCountCharsFromUtf8(ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountCharsFromUtf8((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCountCharsFromUtf8(string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCountCharsFromUtf8(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCountUtf8BytesFromChar")]
		public static extern int ImTextCountUtf8BytesFromChar(byte* inText, byte* inTextEnd);

		public static int ImTextCountUtf8BytesFromChar(ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCountUtf8BytesFromChar((byte*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCountUtf8BytesFromChar(string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountUtf8BytesFromChar(pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCountUtf8BytesFromChar(byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromChar(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextCountUtf8BytesFromChar(byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountUtf8BytesFromChar(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCountUtf8BytesFromChar(ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFromChar((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCountUtf8BytesFromChar(string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCountUtf8BytesFromChar(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCountUtf8BytesFromStr")]
		public static extern int ImTextCountUtf8BytesFrom(char* inText, char* inTextEnd);

		public static int ImTextCountUtf8BytesFrom(ref char inText, char* inTextEnd)
		{
			fixed (char* pinText = &inText)
			{
				int ret = ImTextCountUtf8BytesFrom((char*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCountUtf8BytesFrom(char* inText, ref char inTextEnd)
		{
			fixed (char* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFrom(inText, (char*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextCountUtf8BytesFrom(ref char inText, ref char inTextEnd)
		{
			fixed (char* pinText = &inText)
			{
				fixed (char* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFrom((char*)pinText, (char*)pinTextEnd);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileOpen")]
		public static extern ImFileHandle ImFileOpen(byte* filename, byte* mode);

		public static ImFileHandle ImFileOpen(ref byte filename, byte* mode)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFileHandle ret = ImFileOpen((byte*)pfilename, mode);
				return ret;
			}
		}

		public static ImFileHandle ImFileOpen(string filename, byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImFileOpen(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFileHandle ImFileOpen(byte* filename, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				ImFileHandle ret = ImFileOpen(filename, (byte*)pmode);
				return ret;
			}
		}

		public static ImFileHandle ImFileOpen(byte* filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImFileOpen(filename, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFileHandle ImFileOpen(ref byte filename, ref byte mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					ImFileHandle ret = ImFileOpen((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}

		public static ImFileHandle ImFileOpen(string filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImFileHandle ret = ImFileOpen(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileClose")]
		public static extern bool ImFileClose(ImFileHandle file);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileGetSize")]
		public static extern ulong ImFileGetSize(ImFileHandle file);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileRead")]
		public static extern ulong ImFileRead(void* data, ulong size, ulong count, ImFileHandle file);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileWrite")]
		public static extern ulong ImFileWrite(void* data, ulong size, ulong count, ImFileHandle file);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileLoadToMemory")]
		public static extern void* ImFileLoadToMemory(byte* filename, byte* mode, nuint* outFileSize, int paddingBytes);

		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImFileLoadToMemory((byte*)pfilename, mode, outFileSize, paddingBytes);
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(string filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemory(pStr0, mode, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemory(filename, (byte*)pmode, outFileSize, paddingBytes);
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(byte* filename, string mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemory(filename, pStr0, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}

		public static void* ImFileLoadToMemory(string filename, string mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImFileLoadToMemory(pStr0, pStr1, outFileSize, paddingBytes);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* ImFileLoadToMemory(byte* filename, byte* mode, ref nuint outFileSize, int paddingBytes)
		{
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemory(filename, mode, (nuint*)poutFileSize, paddingBytes);
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, ref nuint outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (nuint* poutFileSize = &outFileSize)
				{
					void* ret = ImFileLoadToMemory((byte*)pfilename, mode, (nuint*)poutFileSize, paddingBytes);
					return ret;
				}
			}
		}

		public static void* ImFileLoadToMemory(string filename, byte* mode, ref nuint outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemory(pStr0, mode, (nuint*)poutFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, ref nuint outFileSize, int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				fixed (nuint* poutFileSize = &outFileSize)
				{
					void* ret = ImFileLoadToMemory(filename, (byte*)pmode, (nuint*)poutFileSize, paddingBytes);
					return ret;
				}
			}
		}

		public static void* ImFileLoadToMemory(byte* filename, string mode, ref nuint outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemory(filename, pStr0, (nuint*)poutFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, ref nuint outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					fixed (nuint* poutFileSize = &outFileSize)
					{
						void* ret = ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)poutFileSize, paddingBytes);
						return ret;
					}
				}
			}
		}

		public static void* ImFileLoadToMemory(string filename, string mode, ref nuint outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemory(pStr0, pStr1, (nuint*)poutFileSize, paddingBytes);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImPow_Float")]
		public static extern float ImPowFloat(float x, float y);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImPow_double")]
		public static extern double ImPowDouble(double x, double y);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLog_Float")]
		public static extern float ImLogFloat(float x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLog_double")]
		public static extern double ImLogDouble(double x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImAbs_Int")]
		public static extern int ImAbsInt(int x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImAbs_Float")]
		public static extern float ImAbsFloat(float x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImAbs_double")]
		public static extern double ImAbsDouble(double x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImSign_Float")]
		public static extern float ImSignFloat(float x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImSign_double")]
		public static extern double ImSignDouble(double x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImRsqrt_Float")]
		public static extern float ImRsqrtFloat(float x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImRsqrt_double")]
		public static extern double ImRsqrtDouble(double x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImMin")]
		public static extern void ImMin(Vector2* output, Vector2 lhs, Vector2 rhs);

		public static void ImMin(ref Vector2 output, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* poutput = &output)
			{
				ImMin((Vector2*)poutput, lhs, rhs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImMax")]
		public static extern void ImMax(Vector2* output, Vector2 lhs, Vector2 rhs);

		public static void ImMax(ref Vector2 output, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* poutput = &output)
			{
				ImMax((Vector2*)poutput, lhs, rhs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImClamp")]
		public static extern void ImClamp(Vector2* output, Vector2 v, Vector2 mn, Vector2 mx);

		public static void ImClamp(ref Vector2 output, Vector2 v, Vector2 mn, Vector2 mx)
		{
			fixed (Vector2* poutput = &output)
			{
				ImClamp((Vector2*)poutput, v, mn, mx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLerp_Vec2Float")]
		public static extern void ImLerpVec2Float(Vector2* output, Vector2 a, Vector2 b, float t);

		public static void ImLerpVec2Float(ref Vector2 output, Vector2 a, Vector2 b, float t)
		{
			fixed (Vector2* poutput = &output)
			{
				ImLerpVec2Float((Vector2*)poutput, a, b, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLerp_Vec2Vec2")]
		public static extern void ImLerpVec2Vec2(Vector2* output, Vector2 a, Vector2 b, Vector2 t);

		public static void ImLerpVec2Vec2(ref Vector2 output, Vector2 a, Vector2 b, Vector2 t)
		{
			fixed (Vector2* poutput = &output)
			{
				ImLerpVec2Vec2((Vector2*)poutput, a, b, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLerp_Vec4")]
		public static extern void ImLerpVec4(Vector4* output, Vector4 a, Vector4 b, float t);

		public static void ImLerpVec4(ref Vector4 output, Vector4 a, Vector4 b, float t)
		{
			fixed (Vector4* poutput = &output)
			{
				ImLerpVec4((Vector4*)poutput, a, b, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImSaturate")]
		public static extern float ImSaturate(float f);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLengthSqr_Vec2")]
		public static extern float ImLengthSqrVec2(Vector2 lhs);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLengthSqr_Vec4")]
		public static extern float ImLengthSqrVec4(Vector4 lhs);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImInvLength")]
		public static extern float ImInvLength(Vector2 lhs, float failValue);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFloor_Float")]
		public static extern float ImFloorFloat(float f);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFloorSigned_Float")]
		public static extern float ImFloorSignedFloat(float f);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFloor_Vec2")]
		public static extern void ImFloorVec2(Vector2* output, Vector2 v);

		public static void ImFloorVec2(ref Vector2 output, Vector2 v)
		{
			fixed (Vector2* poutput = &output)
			{
				ImFloorVec2((Vector2*)poutput, v);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFloorSigned_Vec2")]
		public static extern void ImFloorSignedVec2(Vector2* output, Vector2 v);

		public static void ImFloorSignedVec2(ref Vector2 output, Vector2 v)
		{
			fixed (Vector2* poutput = &output)
			{
				ImFloorSignedVec2((Vector2*)poutput, v);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImModPositive")]
		public static extern int ImModPositive(int a, int b);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImDot")]
		public static extern float ImDot(Vector2 a, Vector2 b);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImRotate")]
		public static extern void ImRotate(Vector2* output, Vector2 v, float cosA, float sinA);

		public static void ImRotate(ref Vector2 output, Vector2 v, float cosA, float sinA)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRotate((Vector2*)poutput, v, cosA, sinA);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLinearSweep")]
		public static extern float ImLinearSweep(float current, float target, float speed);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImMul")]
		public static extern void ImMul(Vector2* output, Vector2 lhs, Vector2 rhs);

		public static void ImMul(ref Vector2 output, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* poutput = &output)
			{
				ImMul((Vector2*)poutput, lhs, rhs);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImIsFloatAboveGuaranteedIntegerPrecision")]
		public static extern bool ImIsFloatAboveGuaranteedIntegerPrecision(float f);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImExponentialMovingAverage")]
		public static extern float ImExponentialMovingAverage(float avg, float sample, int n);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBezierCubicCalc")]
		public static extern void ImBezierCubicCalc(Vector2* output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);

		public static void ImBezierCubicCalc(ref Vector2 output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			fixed (Vector2* poutput = &output)
			{
				ImBezierCubicCalc((Vector2*)poutput, p1, p2, p3, p4, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBezierCubicClosestPoint")]
		public static extern void ImBezierCubicClosestPoint(Vector2* output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments);

		public static void ImBezierCubicClosestPoint(ref Vector2 output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			fixed (Vector2* poutput = &output)
			{
				ImBezierCubicClosestPoint((Vector2*)poutput, p1, p2, p3, p4, p, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBezierCubicClosestPointCasteljau")]
		public static extern void ImBezierCubicClosestPointCasteljau(Vector2* output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol);

		public static void ImBezierCubicClosestPointCasteljau(ref Vector2 output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			fixed (Vector2* poutput = &output)
			{
				ImBezierCubicClosestPointCasteljau((Vector2*)poutput, p1, p2, p3, p4, p, tessTol);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBezierQuadraticCalc")]
		public static extern void ImBezierQuadraticCalc(Vector2* output, Vector2 p1, Vector2 p2, Vector2 p3, float t);

		public static void ImBezierQuadraticCalc(ref Vector2 output, Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			fixed (Vector2* poutput = &output)
			{
				ImBezierQuadraticCalc((Vector2*)poutput, p1, p2, p3, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLineClosestPoint")]
		public static extern void ImLineClosestPoint(Vector2* output, Vector2 a, Vector2 b, Vector2 p);

		public static void ImLineClosestPoint(ref Vector2 output, Vector2 a, Vector2 b, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				ImLineClosestPoint((Vector2*)poutput, a, b, p);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTriangleContainsPoint")]
		public static extern bool ImTriangleContainsPoint(Vector2 a, Vector2 b, Vector2 c, Vector2 p);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTriangleClosestPoint")]
		public static extern void ImTriangleClosestPoint(Vector2* output, Vector2 a, Vector2 b, Vector2 c, Vector2 p);

		public static void ImTriangleClosestPoint(ref Vector2 output, Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				ImTriangleClosestPoint((Vector2*)poutput, a, b, c, p);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTriangleBarycentricCoords")]
		public static extern void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, float* outW);

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, float* outV, float* outW)
		{
			fixed (float* poutU = &outU)
			{
				ImTriangleBarycentricCoords(a, b, c, p, (float*)poutU, outV, outW);
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, ref float outV, float* outW)
		{
			fixed (float* poutV = &outV)
			{
				ImTriangleBarycentricCoords(a, b, c, p, outU, (float*)poutV, outW);
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, ref float outV, float* outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					ImTriangleBarycentricCoords(a, b, c, p, (float*)poutU, (float*)poutV, outW);
				}
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, ref float outW)
		{
			fixed (float* poutW = &outW)
			{
				ImTriangleBarycentricCoords(a, b, c, p, outU, outV, (float*)poutW);
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, float* outV, ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutW = &outW)
				{
					ImTriangleBarycentricCoords(a, b, c, p, (float*)poutU, outV, (float*)poutW);
				}
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, ref float outV, ref float outW)
		{
			fixed (float* poutV = &outV)
			{
				fixed (float* poutW = &outW)
				{
					ImTriangleBarycentricCoords(a, b, c, p, outU, (float*)poutV, (float*)poutW);
				}
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, ref float outV, ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					fixed (float* poutW = &outW)
					{
						ImTriangleBarycentricCoords(a, b, c, p, (float*)poutU, (float*)poutV, (float*)poutW);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTriangleArea")]
		public static extern float ImTriangleArea(Vector2 a, Vector2 b, Vector2 c);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImGetDirQuadrantFromDelta")]
		public static extern ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec1_ImVec1_Nil")]
		public static extern ImVec1* ImVec1ImVec1Nil();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec1_destroy")]
		public static extern void ImVec1Destroy(ImVec1* self);

		public static void ImVec1Destroy(ref ImVec1 self)
		{
			fixed (ImVec1* pself = &self)
			{
				ImVec1Destroy((ImVec1*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec1_ImVec1_Float")]
		public static extern ImVec1* ImVec1ImVec1Float(float x);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2ih_ImVec2ih_Nil")]
		public static extern ImVec2ih* ImVec2ihImVec2ihNil();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2ih_destroy")]
		public static extern void ImVec2ihDestroy(ImVec2ih* self);

		public static void ImVec2ihDestroy(ref ImVec2ih self)
		{
			fixed (ImVec2ih* pself = &self)
			{
				ImVec2ihDestroy((ImVec2ih*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2ih_ImVec2ih_short")]
		public static extern ImVec2ih* ImVec2ihImVec2ihShort(short x, short y);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2ih_ImVec2ih_Vec2")]
		public static extern ImVec2ih* ImVec2ihImVec2ihVec2(Vector2 rhs);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ImRect_Nil")]
		public static extern ImRect* ImRectImRectNil();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_destroy")]
		public static extern void ImRectDestroy(ImRect* self);

		public static void ImRectDestroy(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectDestroy((ImRect*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ImRect_Vec2")]
		public static extern ImRect* ImRectImRectVec2(Vector2 min, Vector2 max);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ImRect_Vec4")]
		public static extern ImRect* ImRectImRectVec4(Vector4 v);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ImRect_Float")]
		public static extern ImRect* ImRectImRectFloat(float x1, float y1, float x2, float y2);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetCenter")]
		public static extern void ImRectGetCenter(Vector2* output, ImRect* self);

		public static void ImRectGetCenter(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetCenter((Vector2*)poutput, self);
			}
		}

		public static void ImRectGetCenter(Vector2* output, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetCenter(output, (ImRect*)pself);
			}
		}

		public static void ImRectGetCenter(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetCenter((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetSize")]
		public static extern void ImRectGetSize(Vector2* output, ImRect* self);

		public static void ImRectGetSize(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetSize((Vector2*)poutput, self);
			}
		}

		public static void ImRectGetSize(Vector2* output, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetSize(output, (ImRect*)pself);
			}
		}

		public static void ImRectGetSize(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetSize((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetWidth")]
		public static extern float ImRectGetWidth(ImRect* self);

		public static float ImRectGetWidth(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImRectGetWidth((ImRect*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetHeight")]
		public static extern float ImRectGetHeight(ImRect* self);

		public static float ImRectGetHeight(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImRectGetHeight((ImRect*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetArea")]
		public static extern float ImRectGetArea(ImRect* self);

		public static float ImRectGetArea(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImRectGetArea((ImRect*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetTL")]
		public static extern void ImRectGetTL(Vector2* output, ImRect* self);

		public static void ImRectGetTL(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetTL((Vector2*)poutput, self);
			}
		}

		public static void ImRectGetTL(Vector2* output, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetTL(output, (ImRect*)pself);
			}
		}

		public static void ImRectGetTL(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetTL((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetTR")]
		public static extern void ImRectGetTR(Vector2* output, ImRect* self);

		public static void ImRectGetTR(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetTR((Vector2*)poutput, self);
			}
		}

		public static void ImRectGetTR(Vector2* output, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetTR(output, (ImRect*)pself);
			}
		}

		public static void ImRectGetTR(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetTR((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetBL")]
		public static extern void ImRectGetBL(Vector2* output, ImRect* self);

		public static void ImRectGetBL(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetBL((Vector2*)poutput, self);
			}
		}

		public static void ImRectGetBL(Vector2* output, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetBL(output, (ImRect*)pself);
			}
		}

		public static void ImRectGetBL(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetBL((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetBR")]
		public static extern void ImRectGetBR(Vector2* output, ImRect* self);

		public static void ImRectGetBR(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetBR((Vector2*)poutput, self);
			}
		}

		public static void ImRectGetBR(Vector2* output, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetBR(output, (ImRect*)pself);
			}
		}

		public static void ImRectGetBR(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetBR((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Contains_Vec2")]
		public static extern bool ImRectContainsVec2(ImRect* self, Vector2 p);

		public static bool ImRectContainsVec2(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				bool ret = ImRectContainsVec2((ImRect*)pself, p);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Contains_Rect")]
		public static extern bool ImRectContainsRect(ImRect* self, ImRect r);

		public static bool ImRectContainsRect(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				bool ret = ImRectContainsRect((ImRect*)pself, r);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Overlaps")]
		public static extern bool ImRectOverlaps(ImRect* self, ImRect r);

		public static bool ImRectOverlaps(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				bool ret = ImRectOverlaps((ImRect*)pself, r);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Add_Vec2")]
		public static extern void ImRectAddVec2(ImRect* self, Vector2 p);

		public static void ImRectAddVec2(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectAddVec2((ImRect*)pself, p);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Add_Rect")]
		public static extern void ImRectAddRect(ImRect* self, ImRect r);

		public static void ImRectAddRect(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectAddRect((ImRect*)pself, r);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Expand_Float")]
		public static extern void ImRectExpandFloat(ImRect* self, float amount);

		public static void ImRectExpandFloat(ref ImRect self, float amount)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectExpandFloat((ImRect*)pself, amount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Expand_Vec2")]
		public static extern void ImRectExpandVec2(ImRect* self, Vector2 amount);

		public static void ImRectExpandVec2(ref ImRect self, Vector2 amount)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectExpandVec2((ImRect*)pself, amount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Translate")]
		public static extern void ImRectTranslate(ImRect* self, Vector2 d);

		public static void ImRectTranslate(ref ImRect self, Vector2 d)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectTranslate((ImRect*)pself, d);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_TranslateX")]
		public static extern void ImRectTranslateX(ImRect* self, float dx);

		public static void ImRectTranslateX(ref ImRect self, float dx)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectTranslateX((ImRect*)pself, dx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_TranslateY")]
		public static extern void ImRectTranslateY(ImRect* self, float dy);

		public static void ImRectTranslateY(ref ImRect self, float dy)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectTranslateY((ImRect*)pself, dy);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ClipWith")]
		public static extern void ImRectClipWith(ImRect* self, ImRect r);

		public static void ImRectClipWith(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectClipWith((ImRect*)pself, r);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ClipWithFull")]
		public static extern void ImRectClipWithFull(ImRect* self, ImRect r);

		public static void ImRectClipWithFull(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectClipWithFull((ImRect*)pself, r);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Floor")]
		public static extern void ImRectFloor(ImRect* self);

		public static void ImRectFloor(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectFloor((ImRect*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_IsInverted")]
		public static extern bool ImRectIsInverted(ImRect* self);

		public static bool ImRectIsInverted(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				bool ret = ImRectIsInverted((ImRect*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ToVec4")]
		public static extern void ImRectToVec4(Vector4* output, ImRect* self);

		public static void ImRectToVec4(ref Vector4 output, ImRect* self)
		{
			fixed (Vector4* poutput = &output)
			{
				ImRectToVec4((Vector4*)poutput, self);
			}
		}

		public static void ImRectToVec4(Vector4* output, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectToVec4(output, (ImRect*)pself);
			}
		}

		public static void ImRectToVec4(ref Vector4 output, ref ImRect self)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectToVec4((Vector4*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArrayGetStorageSizeInBytes")]
		public static extern nuint ImBitArrayGetStorageSizeInBytes(int bitcount);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArrayClearAllBits")]
		public static extern void ImBitArrayClearAllBits(uint* arr, int bitcount);

		public static void ImBitArrayClearAllBits(ref uint arr, int bitcount)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArrayClearAllBits((uint*)parr, bitcount);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArrayTestBit")]
		public static extern bool ImBitArrayTestBit(uint* arr, int n);

		public static bool ImBitArrayTestBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				bool ret = ImBitArrayTestBit((uint*)parr, n);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArrayClearBit")]
		public static extern void ImBitArrayClearBit(uint* arr, int n);

		public static void ImBitArrayClearBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArrayClearBit((uint*)parr, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArraySetBit")]
		public static extern void ImBitArraySetBit(uint* arr, int n);

		public static void ImBitArraySetBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArraySetBit((uint*)parr, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArraySetBitRange")]
		public static extern void ImBitArraySetBitRange(uint* arr, int n, int n2);

		public static void ImBitArraySetBitRange(ref uint arr, int n, int n2)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArraySetBitRange((uint*)parr, n, n2);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_Create")]
		public static extern void ImBitVectorCreate(ImBitVector* self, int sz);

		public static void ImBitVectorCreate(ref ImBitVector self, int sz)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImBitVectorCreate((ImBitVector*)pself, sz);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_Clear")]
		public static extern void ImBitVectorClear(ImBitVector* self);

		public static void ImBitVectorClear(ref ImBitVector self)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImBitVectorClear((ImBitVector*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_TestBit")]
		public static extern bool ImBitVectorTestBit(ImBitVector* self, int n);

		public static bool ImBitVectorTestBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				bool ret = ImBitVectorTestBit((ImBitVector*)pself, n);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_SetBit")]
		public static extern void ImBitVectorSetBit(ImBitVector* self, int n);

		public static void ImBitVectorSetBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImBitVectorSetBit((ImBitVector*)pself, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_ClearBit")]
		public static extern void ImBitVectorClearBit(ImBitVector* self, int n);

		public static void ImBitVectorClearBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImBitVectorClearBit((ImBitVector*)pself, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_clear")]
		public static extern void ImGuiTextIndexClear(ImGuiTextIndex* self);

		public static void ImGuiTextIndexClear(ref ImGuiTextIndex self)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				ImGuiTextIndexClear((ImGuiTextIndex*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_size")]
		public static extern int ImGuiTextIndexSize(ImGuiTextIndex* self);

		public static int ImGuiTextIndexSize(ref ImGuiTextIndex self)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				int ret = ImGuiTextIndexSize((ImGuiTextIndex*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_get_line_begin")]
		public static extern byte* ImGuiTextIndexGetLineBegin(ImGuiTextIndex* self, byte* baseValue, int n);

		public static string ImGuiTextIndexGetLineBeginS(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineBegin(self, baseValue, n));
			return ret;
		}

		public static string ImGuiTextIndexGetLineBeginS(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineBegin((ImGuiTextIndex*)pself, baseValue, n));
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineBegin(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* ret = ImGuiTextIndexGetLineBegin((ImGuiTextIndex*)pself, baseValue, n);
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineBeginS(ImGuiTextIndex* self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineBegin(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineBegin(ImGuiTextIndex* self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = ImGuiTextIndexGetLineBegin(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineBeginS(ImGuiTextIndex* self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineBegin(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImGuiTextIndexGetLineBegin(ImGuiTextIndex* self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiTextIndexGetLineBegin(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImGuiTextIndexGetLineBeginS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineBegin((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		public static byte* ImGuiTextIndexGetLineBegin(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = ImGuiTextIndexGetLineBegin((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		public static string ImGuiTextIndexGetLineBeginS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineBegin((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineBegin(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiTextIndexGetLineBegin((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_get_line_end")]
		public static extern byte* ImGuiTextIndexGetLineEnd(ImGuiTextIndex* self, byte* baseValue, int n);

		public static string ImGuiTextIndexGetLineEndS(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineEnd(self, baseValue, n));
			return ret;
		}

		public static string ImGuiTextIndexGetLineEndS(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineEnd((ImGuiTextIndex*)pself, baseValue, n));
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineEnd(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* ret = ImGuiTextIndexGetLineEnd((ImGuiTextIndex*)pself, baseValue, n);
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineEndS(ImGuiTextIndex* self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineEnd(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineEnd(ImGuiTextIndex* self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = ImGuiTextIndexGetLineEnd(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineEndS(ImGuiTextIndex* self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineEnd(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImGuiTextIndexGetLineEnd(ImGuiTextIndex* self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiTextIndexGetLineEnd(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImGuiTextIndexGetLineEndS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineEnd((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		public static byte* ImGuiTextIndexGetLineEnd(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = ImGuiTextIndexGetLineEnd((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		public static string ImGuiTextIndexGetLineEndS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Marshal.PtrToStringAnsi((nint)ImGuiTextIndexGetLineEnd((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineEnd(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiTextIndexGetLineEnd((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_append")]
		public static extern void ImGuiTextIndexAppend(ImGuiTextIndex* self, byte* baseValue, int oldSize, int newSize);

		public static void ImGuiTextIndexAppend(ref ImGuiTextIndex self, byte* baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				ImGuiTextIndexAppend((ImGuiTextIndex*)pself, baseValue, oldSize, newSize);
			}
		}

		public static void ImGuiTextIndexAppend(ImGuiTextIndex* self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				ImGuiTextIndexAppend(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		public static void ImGuiTextIndexAppend(ImGuiTextIndex* self, string baseValue, int oldSize, int newSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextIndexAppend(self, pStr0, oldSize, newSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImGuiTextIndexAppend(ref ImGuiTextIndex self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					ImGuiTextIndexAppend((ImGuiTextIndex*)pself, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		public static void ImGuiTextIndexAppend(ref ImGuiTextIndex self, string baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiTextIndexAppend((ImGuiTextIndex*)pself, pStr0, oldSize, newSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSharedData_ImDrawListSharedData")]
		public static extern ImDrawListSharedData* ImDrawListSharedDataImDrawListSharedData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSharedData_destroy")]
		public static extern void ImDrawListSharedDataDestroy(ImDrawListSharedData* self);

		public static void ImDrawListSharedDataDestroy(ref ImDrawListSharedData self)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				ImDrawListSharedDataDestroy((ImDrawListSharedData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSharedData_SetCircleTessellationMaxError")]
		public static extern void ImDrawListSharedDataSetCircleTessellationMaxError(ImDrawListSharedData* self, float maxError);

		public static void ImDrawListSharedDataSetCircleTessellationMaxError(ref ImDrawListSharedData self, float maxError)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				ImDrawListSharedDataSetCircleTessellationMaxError((ImDrawListSharedData*)pself, maxError);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawDataBuilder_Clear")]
		public static extern void ImDrawDataBuilderClear(ImDrawDataBuilder* self);

		public static void ImDrawDataBuilderClear(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImDrawDataBuilderClear((ImDrawDataBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawDataBuilder_ClearFreeMemory")]
		public static extern void ImDrawDataBuilderClearFreeMemory(ImDrawDataBuilder* self);

		public static void ImDrawDataBuilderClearFreeMemory(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImDrawDataBuilderClearFreeMemory((ImDrawDataBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawDataBuilder_GetDrawListCount")]
		public static extern int ImDrawDataBuilderGetDrawListCount(ImDrawDataBuilder* self);

		public static int ImDrawDataBuilderGetDrawListCount(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				int ret = ImDrawDataBuilderGetDrawListCount((ImDrawDataBuilder*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawDataBuilder_FlattenIntoSingleLayer")]
		public static extern void ImDrawDataBuilderFlattenIntoSingleLayer(ImDrawDataBuilder* self);

		public static void ImDrawDataBuilderFlattenIntoSingleLayer(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImDrawDataBuilderFlattenIntoSingleLayer((ImDrawDataBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDataVarInfo_GetVarPtr")]
		public static extern void* ImGuiDataVarInfoGetVarPtr(ImGuiDataVarInfo* self, void* parent);

		public static void* ImGuiDataVarInfoGetVarPtr(ref ImGuiDataVarInfo self, void* parent)
		{
			fixed (ImGuiDataVarInfo* pself = &self)
			{
				void* ret = ImGuiDataVarInfoGetVarPtr((ImGuiDataVarInfo*)pself, parent);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Int")]
		public static extern ImGuiStyleMod* ImGuiStyleModImGuiStyleModInt(ImGuiStyleVar idx, int v);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyleMod_destroy")]
		public static extern void ImGuiStyleModDestroy(ImGuiStyleMod* self);

		public static void ImGuiStyleModDestroy(ref ImGuiStyleMod self)
		{
			fixed (ImGuiStyleMod* pself = &self)
			{
				ImGuiStyleModDestroy((ImGuiStyleMod*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Float")]
		public static extern ImGuiStyleMod* ImGuiStyleModImGuiStyleModFloat(ImGuiStyleVar idx, float v);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Vec2")]
		public static extern ImGuiStyleMod* ImGuiStyleModImGuiStyleModVec2(ImGuiStyleVar idx, Vector2 v);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiComboPreviewData_ImGuiComboPreviewData")]
		public static extern ImGuiComboPreviewData* ImGuiComboPreviewDataImGuiComboPreviewData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiComboPreviewData_destroy")]
		public static extern void ImGuiComboPreviewDataDestroy(ImGuiComboPreviewData* self);

		public static void ImGuiComboPreviewDataDestroy(ref ImGuiComboPreviewData self)
		{
			fixed (ImGuiComboPreviewData* pself = &self)
			{
				ImGuiComboPreviewDataDestroy((ImGuiComboPreviewData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_ImGuiMenuColumns")]
		public static extern ImGuiMenuColumns* ImGuiMenuColumnsImGuiMenuColumns();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_destroy")]
		public static extern void ImGuiMenuColumnsDestroy(ImGuiMenuColumns* self);

		public static void ImGuiMenuColumnsDestroy(ref ImGuiMenuColumns self)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiMenuColumnsDestroy((ImGuiMenuColumns*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_Update")]
		public static extern void ImGuiMenuColumnsUpdate(ImGuiMenuColumns* self, float spacing, bool windowReappearing);

		public static void ImGuiMenuColumnsUpdate(ref ImGuiMenuColumns self, float spacing, bool windowReappearing)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiMenuColumnsUpdate((ImGuiMenuColumns*)pself, spacing, windowReappearing);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_DeclColumns")]
		public static extern float ImGuiMenuColumnsDeclColumns(ImGuiMenuColumns* self, float wIcon, float wLabel, float wShortcut, float wMark);

		public static float ImGuiMenuColumnsDeclColumns(ref ImGuiMenuColumns self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				float ret = ImGuiMenuColumnsDeclColumns((ImGuiMenuColumns*)pself, wIcon, wLabel, wShortcut, wMark);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_CalcNextTotalWidth")]
		public static extern void ImGuiMenuColumnsCalcNextTotalWidth(ImGuiMenuColumns* self, bool updateOffsets);

		public static void ImGuiMenuColumnsCalcNextTotalWidth(ref ImGuiMenuColumns self, bool updateOffsets)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiMenuColumnsCalcNextTotalWidth((ImGuiMenuColumns*)pself, updateOffsets);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState")]
		public static extern ImGuiInputTextDeactivatedState* ImGuiInputTextDeactivatedStateImGuiInputTextDeactivatedState();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextDeactivatedState_destroy")]
		public static extern void ImGuiInputTextDeactivatedStateDestroy(ImGuiInputTextDeactivatedState* self);

		public static void ImGuiInputTextDeactivatedStateDestroy(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				ImGuiInputTextDeactivatedStateDestroy((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextDeactivatedState_ClearFreeMemory")]
		public static extern void ImGuiInputTextDeactivatedStateClearFreeMemory(ImGuiInputTextDeactivatedState* self);

		public static void ImGuiInputTextDeactivatedStateClearFreeMemory(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				ImGuiInputTextDeactivatedStateClearFreeMemory((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_ImGuiInputTextState")]
		public static extern ImGuiInputTextState* ImGuiInputTextStateImGuiInputTextState();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_destroy")]
		public static extern void ImGuiInputTextStateDestroy(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateDestroy(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateDestroy((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_ClearText")]
		public static extern void ImGuiInputTextStateClearText(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateClearText(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateClearText((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_ClearFreeMemory")]
		public static extern void ImGuiInputTextStateClearFreeMemory(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateClearFreeMemory(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateClearFreeMemory((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetUndoAvailCount")]
		public static extern int ImGuiInputTextStateGetUndoAvailCount(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetUndoAvailCount(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetUndoAvailCount((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetRedoAvailCount")]
		public static extern int ImGuiInputTextStateGetRedoAvailCount(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetRedoAvailCount(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetRedoAvailCount((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_OnKeyPressed")]
		public static extern void ImGuiInputTextStateOnKeyPressed(ImGuiInputTextState* self, int key);

		public static void ImGuiInputTextStateOnKeyPressed(ref ImGuiInputTextState self, int key)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateOnKeyPressed((ImGuiInputTextState*)pself, key);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_CursorAnimReset")]
		public static extern void ImGuiInputTextStateCursorAnimReset(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateCursorAnimReset(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateCursorAnimReset((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_CursorClamp")]
		public static extern void ImGuiInputTextStateCursorClamp(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateCursorClamp(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateCursorClamp((ImGuiInputTextState*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_HasSelection")]
		public static extern bool ImGuiInputTextStateHasSelection(ImGuiInputTextState* self);

		public static bool ImGuiInputTextStateHasSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				bool ret = ImGuiInputTextStateHasSelection((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_ClearSelection")]
		public static extern void ImGuiInputTextStateClearSelection(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateClearSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateClearSelection((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetCursorPos")]
		public static extern int ImGuiInputTextStateGetCursorPos(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetCursorPos(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetCursorPos((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetSelectionStart")]
		public static extern int ImGuiInputTextStateGetSelectionStart(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetSelectionStart(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetSelectionStart((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetSelectionEnd")]
		public static extern int ImGuiInputTextStateGetSelectionEnd(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetSelectionEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetSelectionEnd((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_SelectAll")]
		public static extern void ImGuiInputTextStateSelectAll(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateSelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateSelectAll((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPopupData_ImGuiPopupData")]
		public static extern ImGuiPopupData* ImGuiPopupDataImGuiPopupData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPopupData_destroy")]
		public static extern void ImGuiPopupDataDestroy(ImGuiPopupData* self);

		public static void ImGuiPopupDataDestroy(ref ImGuiPopupData self)
		{
			fixed (ImGuiPopupData* pself = &self)
			{
				ImGuiPopupDataDestroy((ImGuiPopupData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextWindowData_ImGuiNextWindowData")]
		public static extern ImGuiNextWindowData* ImGuiNextWindowDataImGuiNextWindowData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextWindowData_destroy")]
		public static extern void ImGuiNextWindowDataDestroy(ImGuiNextWindowData* self);

		public static void ImGuiNextWindowDataDestroy(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ImGuiNextWindowDataDestroy((ImGuiNextWindowData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextWindowData_ClearFlags")]
		public static extern void ImGuiNextWindowDataClearFlags(ImGuiNextWindowData* self);

		public static void ImGuiNextWindowDataClearFlags(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ImGuiNextWindowDataClearFlags((ImGuiNextWindowData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextItemData_ImGuiNextItemData")]
		public static extern ImGuiNextItemData* ImGuiNextItemDataImGuiNextItemData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextItemData_destroy")]
		public static extern void ImGuiNextItemDataDestroy(ImGuiNextItemData* self);

		public static void ImGuiNextItemDataDestroy(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ImGuiNextItemDataDestroy((ImGuiNextItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextItemData_ClearFlags")]
		public static extern void ImGuiNextItemDataClearFlags(ImGuiNextItemData* self);

		public static void ImGuiNextItemDataClearFlags(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ImGuiNextItemDataClearFlags((ImGuiNextItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiLastItemData_ImGuiLastItemData")]
		public static extern ImGuiLastItemData* ImGuiLastItemDataImGuiLastItemData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiLastItemData_destroy")]
		public static extern void ImGuiLastItemDataDestroy(ImGuiLastItemData* self);

		public static void ImGuiLastItemDataDestroy(ref ImGuiLastItemData self)
		{
			fixed (ImGuiLastItemData* pself = &self)
			{
				ImGuiLastItemDataDestroy((ImGuiLastItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackSizes_ImGuiStackSizes")]
		public static extern ImGuiStackSizes* ImGuiStackSizesImGuiStackSizes();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackSizes_destroy")]
		public static extern void ImGuiStackSizesDestroy(ImGuiStackSizes* self);

		public static void ImGuiStackSizesDestroy(ref ImGuiStackSizes self)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiStackSizesDestroy((ImGuiStackSizes*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackSizes_SetToContextState")]
		public static extern void ImGuiStackSizesSetToContextState(ImGuiStackSizes* self, ImGuiContext* ctx);

		public static void ImGuiStackSizesSetToContextState(ref ImGuiStackSizes self, ImGuiContext* ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiStackSizesSetToContextState((ImGuiStackSizes*)pself, ctx);
			}
		}

		public static void ImGuiStackSizesSetToContextState(ImGuiStackSizes* self, ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiStackSizesSetToContextState(self, (ImGuiContext*)pctx);
			}
		}

		public static void ImGuiStackSizesSetToContextState(ref ImGuiStackSizes self, ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					ImGuiStackSizesSetToContextState((ImGuiStackSizes*)pself, (ImGuiContext*)pctx);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackSizes_CompareWithContextState")]
		public static extern void ImGuiStackSizesCompareWithContextState(ImGuiStackSizes* self, ImGuiContext* ctx);

		public static void ImGuiStackSizesCompareWithContextState(ref ImGuiStackSizes self, ImGuiContext* ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiStackSizesCompareWithContextState((ImGuiStackSizes*)pself, ctx);
			}
		}

		public static void ImGuiStackSizesCompareWithContextState(ImGuiStackSizes* self, ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiStackSizesCompareWithContextState(self, (ImGuiContext*)pctx);
			}
		}

		public static void ImGuiStackSizesCompareWithContextState(ref ImGuiStackSizes self, ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					ImGuiStackSizesCompareWithContextState((ImGuiStackSizes*)pself, (ImGuiContext*)pctx);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr")]
		public static extern ImGuiPtrOrIndex* ImGuiPtrOrIndexImGuiPtrOrIndexPtr(void* ptr);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPtrOrIndex_destroy")]
		public static extern void ImGuiPtrOrIndexDestroy(ImGuiPtrOrIndex* self);

		public static void ImGuiPtrOrIndexDestroy(ref ImGuiPtrOrIndex self)
		{
			fixed (ImGuiPtrOrIndex* pself = &self)
			{
				ImGuiPtrOrIndexDestroy((ImGuiPtrOrIndex*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int")]
		public static extern ImGuiPtrOrIndex* ImGuiPtrOrIndexImGuiPtrOrIndexInt(int index);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputEvent_ImGuiInputEvent")]
		public static extern ImGuiInputEvent* ImGuiInputEventImGuiInputEvent();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputEvent_destroy")]
		public static extern void ImGuiInputEventDestroy(ImGuiInputEvent* self);

		public static void ImGuiInputEventDestroy(ref ImGuiInputEvent self)
		{
			fixed (ImGuiInputEvent* pself = &self)
			{
				ImGuiInputEventDestroy((ImGuiInputEvent*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingData_ImGuiKeyRoutingData")]
		public static extern ImGuiKeyRoutingData* ImGuiKeyRoutingDataImGuiKeyRoutingData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingData_destroy")]
		public static extern void ImGuiKeyRoutingDataDestroy(ImGuiKeyRoutingData* self);

		public static void ImGuiKeyRoutingDataDestroy(ref ImGuiKeyRoutingData self)
		{
			fixed (ImGuiKeyRoutingData* pself = &self)
			{
				ImGuiKeyRoutingDataDestroy((ImGuiKeyRoutingData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingTable_ImGuiKeyRoutingTable")]
		public static extern ImGuiKeyRoutingTable* ImGuiKeyRoutingTableImGuiKeyRoutingTable();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingTable_destroy")]
		public static extern void ImGuiKeyRoutingTableDestroy(ImGuiKeyRoutingTable* self);

		public static void ImGuiKeyRoutingTableDestroy(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				ImGuiKeyRoutingTableDestroy((ImGuiKeyRoutingTable*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingTable_Clear")]
		public static extern void ImGuiKeyRoutingTableClear(ImGuiKeyRoutingTable* self);

		public static void ImGuiKeyRoutingTableClear(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				ImGuiKeyRoutingTableClear((ImGuiKeyRoutingTable*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyOwnerData_ImGuiKeyOwnerData")]
		public static extern ImGuiKeyOwnerData* ImGuiKeyOwnerDataImGuiKeyOwnerData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyOwnerData_destroy")]
		public static extern void ImGuiKeyOwnerDataDestroy(ImGuiKeyOwnerData* self);

		public static void ImGuiKeyOwnerDataDestroy(ref ImGuiKeyOwnerData self)
		{
			fixed (ImGuiKeyOwnerData* pself = &self)
			{
				ImGuiKeyOwnerDataDestroy((ImGuiKeyOwnerData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperRange_FromIndices")]
		public static extern ImGuiListClipperRange ImGuiListClipperRangeFromIndices(int min, int max);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperRange_FromPositions")]
		public static extern ImGuiListClipperRange ImGuiListClipperRangeFromPositions(float y1, float y2, int offMin, int offMax);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperData_ImGuiListClipperData")]
		public static extern ImGuiListClipperData* ImGuiListClipperDataImGuiListClipperData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperData_destroy")]
		public static extern void ImGuiListClipperDataDestroy(ImGuiListClipperData* self);

		public static void ImGuiListClipperDataDestroy(ref ImGuiListClipperData self)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ImGuiListClipperDataDestroy((ImGuiListClipperData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperData_Reset")]
		public static extern void ImGuiListClipperDataReset(ImGuiListClipperData* self, ImGuiListClipper* clipper);

		public static void ImGuiListClipperDataReset(ref ImGuiListClipperData self, ImGuiListClipper* clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ImGuiListClipperDataReset((ImGuiListClipperData*)pself, clipper);
			}
		}

		public static void ImGuiListClipperDataReset(ImGuiListClipperData* self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipper* pclipper = &clipper)
			{
				ImGuiListClipperDataReset(self, (ImGuiListClipper*)pclipper);
			}
		}

		public static void ImGuiListClipperDataReset(ref ImGuiListClipperData self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				fixed (ImGuiListClipper* pclipper = &clipper)
				{
					ImGuiListClipperDataReset((ImGuiListClipperData*)pself, (ImGuiListClipper*)pclipper);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNavItemData_ImGuiNavItemData")]
		public static extern ImGuiNavItemData* ImGuiNavItemDataImGuiNavItemData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNavItemData_destroy")]
		public static extern void ImGuiNavItemDataDestroy(ImGuiNavItemData* self);

		public static void ImGuiNavItemDataDestroy(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ImGuiNavItemDataDestroy((ImGuiNavItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNavItemData_Clear")]
		public static extern void ImGuiNavItemDataClear(ImGuiNavItemData* self);

		public static void ImGuiNavItemDataClear(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ImGuiNavItemDataClear((ImGuiNavItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOldColumnData_ImGuiOldColumnData")]
		public static extern ImGuiOldColumnData* ImGuiOldColumnDataImGuiOldColumnData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOldColumnData_destroy")]
		public static extern void ImGuiOldColumnDataDestroy(ImGuiOldColumnData* self);

		public static void ImGuiOldColumnDataDestroy(ref ImGuiOldColumnData self)
		{
			fixed (ImGuiOldColumnData* pself = &self)
			{
				ImGuiOldColumnDataDestroy((ImGuiOldColumnData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOldColumns_ImGuiOldColumns")]
		public static extern ImGuiOldColumns* ImGuiOldColumnsImGuiOldColumns();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOldColumns_destroy")]
		public static extern void ImGuiOldColumnsDestroy(ImGuiOldColumns* self);

		public static void ImGuiOldColumnsDestroy(ref ImGuiOldColumns self)
		{
			fixed (ImGuiOldColumns* pself = &self)
			{
				ImGuiOldColumnsDestroy((ImGuiOldColumns*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_ImGuiDockNode")]
		public static extern ImGuiDockNode* ImGuiDockNodeImGuiDockNode(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_destroy")]
		public static extern void ImGuiDockNodeDestroy(ImGuiDockNode* self);

		public static void ImGuiDockNodeDestroy(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiDockNodeDestroy((ImGuiDockNode*)pself);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsRootNode")]
		public static extern bool ImGuiDockNodeIsRootNode(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsRootNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsRootNode((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsDockSpace")]
		public static extern bool ImGuiDockNodeIsDockSpace(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsDockSpace(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsDockSpace((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsFloatingNode")]
		public static extern bool ImGuiDockNodeIsFloatingNode(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsFloatingNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsFloatingNode((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsCentralNode")]
		public static extern bool ImGuiDockNodeIsCentralNode(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsCentralNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsCentralNode((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsHiddenTabBar")]
		public static extern bool ImGuiDockNodeIsHiddenTabBar(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsHiddenTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsHiddenTabBar((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsNoTabBar")]
		public static extern bool ImGuiDockNodeIsNoTabBar(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsNoTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsNoTabBar((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsSplitNode")]
		public static extern bool ImGuiDockNodeIsSplitNode(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsSplitNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsSplitNode((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsLeafNode")]
		public static extern bool ImGuiDockNodeIsLeafNode(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsLeafNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsLeafNode((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsEmpty")]
		public static extern bool ImGuiDockNodeIsEmpty(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsEmpty(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				bool ret = ImGuiDockNodeIsEmpty((ImGuiDockNode*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_Rect")]
		public static extern void ImGuiDockNodeRect(ImRect* output, ImGuiDockNode* self);

		public static void ImGuiDockNodeRect(ref ImRect output, ImGuiDockNode* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiDockNodeRect((ImRect*)poutput, self);
			}
		}

		public static void ImGuiDockNodeRect(ImRect* output, ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiDockNodeRect(output, (ImGuiDockNode*)pself);
			}
		}

		public static void ImGuiDockNodeRect(ref ImRect output, ref ImGuiDockNode self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiDockNode* pself = &self)
				{
					ImGuiDockNodeRect((ImRect*)poutput, (ImGuiDockNode*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_SetLocalFlags")]
		public static extern void ImGuiDockNodeSetLocalFlags(ImGuiDockNode* self, ImGuiDockNodeFlags flags);

		public static void ImGuiDockNodeSetLocalFlags(ref ImGuiDockNode self, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiDockNodeSetLocalFlags((ImGuiDockNode*)pself, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_UpdateMergedFlags")]
		public static extern void ImGuiDockNodeUpdateMergedFlags(ImGuiDockNode* self);

		public static void ImGuiDockNodeUpdateMergedFlags(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiDockNodeUpdateMergedFlags((ImGuiDockNode*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockContext_ImGuiDockContext")]
		public static extern ImGuiDockContext* ImGuiDockContextImGuiDockContext();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockContext_destroy")]
		public static extern void ImGuiDockContextDestroy(ImGuiDockContext* self);

		public static void ImGuiDockContextDestroy(ref ImGuiDockContext self)
		{
			fixed (ImGuiDockContext* pself = &self)
			{
				ImGuiDockContextDestroy((ImGuiDockContext*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_ImGuiViewportP")]
		public static extern ImGuiViewportP* ImGuiViewportPImGuiViewportP();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_destroy")]
		public static extern void ImGuiViewportPDestroy(ImGuiViewportP* self);

		public static void ImGuiViewportPDestroy(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPDestroy((ImGuiViewportP*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_ClearRequestFlags")]
		public static extern void ImGuiViewportPClearRequestFlags(ImGuiViewportP* self);

		public static void ImGuiViewportPClearRequestFlags(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPClearRequestFlags((ImGuiViewportP*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_CalcWorkRectPos")]
		public static extern void ImGuiViewportPCalcWorkRectPos(Vector2* output, ImGuiViewportP* self, Vector2 offMin);

		public static void ImGuiViewportPCalcWorkRectPos(ref Vector2 output, ImGuiViewportP* self, Vector2 offMin)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGuiViewportPCalcWorkRectPos((Vector2*)poutput, self, offMin);
			}
		}

		public static void ImGuiViewportPCalcWorkRectPos(Vector2* output, ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPCalcWorkRectPos(output, (ImGuiViewportP*)pself, offMin);
			}
		}

		public static void ImGuiViewportPCalcWorkRectPos(ref Vector2 output, ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPCalcWorkRectPos((Vector2*)poutput, (ImGuiViewportP*)pself, offMin);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_CalcWorkRectSize")]
		public static extern void ImGuiViewportPCalcWorkRectSize(Vector2* output, ImGuiViewportP* self, Vector2 offMin, Vector2 offMax);

		public static void ImGuiViewportPCalcWorkRectSize(ref Vector2 output, ImGuiViewportP* self, Vector2 offMin, Vector2 offMax)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGuiViewportPCalcWorkRectSize((Vector2*)poutput, self, offMin, offMax);
			}
		}

		public static void ImGuiViewportPCalcWorkRectSize(Vector2* output, ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPCalcWorkRectSize(output, (ImGuiViewportP*)pself, offMin, offMax);
			}
		}

		public static void ImGuiViewportPCalcWorkRectSize(ref Vector2 output, ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPCalcWorkRectSize((Vector2*)poutput, (ImGuiViewportP*)pself, offMin, offMax);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_UpdateWorkRect")]
		public static extern void ImGuiViewportPUpdateWorkRect(ImGuiViewportP* self);

		public static void ImGuiViewportPUpdateWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPUpdateWorkRect((ImGuiViewportP*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_GetMainRect")]
		public static extern void ImGuiViewportPGetMainRect(ImRect* output, ImGuiViewportP* self);

		public static void ImGuiViewportPGetMainRect(ref ImRect output, ImGuiViewportP* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiViewportPGetMainRect((ImRect*)poutput, self);
			}
		}

		public static void ImGuiViewportPGetMainRect(ImRect* output, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPGetMainRect(output, (ImGuiViewportP*)pself);
			}
		}

		public static void ImGuiViewportPGetMainRect(ref ImRect output, ref ImGuiViewportP self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPGetMainRect((ImRect*)poutput, (ImGuiViewportP*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_GetWorkRect")]
		public static extern void ImGuiViewportPGetWorkRect(ImRect* output, ImGuiViewportP* self);

		public static void ImGuiViewportPGetWorkRect(ref ImRect output, ImGuiViewportP* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiViewportPGetWorkRect((ImRect*)poutput, self);
			}
		}

		public static void ImGuiViewportPGetWorkRect(ImRect* output, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPGetWorkRect(output, (ImGuiViewportP*)pself);
			}
		}

		public static void ImGuiViewportPGetWorkRect(ref ImRect output, ref ImGuiViewportP self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPGetWorkRect((ImRect*)poutput, (ImGuiViewportP*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_GetBuildWorkRect")]
		public static extern void ImGuiViewportPGetBuildWorkRect(ImRect* output, ImGuiViewportP* self);

		public static void ImGuiViewportPGetBuildWorkRect(ref ImRect output, ImGuiViewportP* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiViewportPGetBuildWorkRect((ImRect*)poutput, self);
			}
		}

		public static void ImGuiViewportPGetBuildWorkRect(ImRect* output, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPGetBuildWorkRect(output, (ImGuiViewportP*)pself);
			}
		}

		public static void ImGuiViewportPGetBuildWorkRect(ref ImRect output, ref ImGuiViewportP self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPGetBuildWorkRect((ImRect*)poutput, (ImGuiViewportP*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowSettings_ImGuiWindowSettings")]
		public static extern ImGuiWindowSettings* ImGuiWindowSettingsImGuiWindowSettings();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowSettings_destroy")]
		public static extern void ImGuiWindowSettingsDestroy(ImGuiWindowSettings* self);

		public static void ImGuiWindowSettingsDestroy(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				ImGuiWindowSettingsDestroy((ImGuiWindowSettings*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowSettings_GetName")]
		public static extern byte* ImGuiWindowSettingsGetName(ImGuiWindowSettings* self);

		public static string ImGuiWindowSettingsGetNameS(ImGuiWindowSettings* self)
		{
			string ret = Marshal.PtrToStringAnsi((nint)ImGuiWindowSettingsGetName(self));
			return ret;
		}

		public static string ImGuiWindowSettingsGetNameS(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				string ret = Marshal.PtrToStringAnsi((nint)ImGuiWindowSettingsGetName((ImGuiWindowSettings*)pself));
				return ret;
			}
		}

		public static byte* ImGuiWindowSettingsGetName(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				byte* ret = ImGuiWindowSettingsGetName((ImGuiWindowSettings*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiSettingsHandler_ImGuiSettingsHandler")]
		public static extern ImGuiSettingsHandler* ImGuiSettingsHandlerImGuiSettingsHandler();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiSettingsHandler_destroy")]
		public static extern void ImGuiSettingsHandlerDestroy(ImGuiSettingsHandler* self);

		public static void ImGuiSettingsHandlerDestroy(ref ImGuiSettingsHandler self)
		{
			fixed (ImGuiSettingsHandler* pself = &self)
			{
				ImGuiSettingsHandlerDestroy((ImGuiSettingsHandler*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackLevelInfo_ImGuiStackLevelInfo")]
		public static extern ImGuiStackLevelInfo* ImGuiStackLevelInfoImGuiStackLevelInfo();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackLevelInfo_destroy")]
		public static extern void ImGuiStackLevelInfoDestroy(ImGuiStackLevelInfo* self);

		public static void ImGuiStackLevelInfoDestroy(ref ImGuiStackLevelInfo self)
		{
			fixed (ImGuiStackLevelInfo* pself = &self)
			{
				ImGuiStackLevelInfoDestroy((ImGuiStackLevelInfo*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackTool_ImGuiStackTool")]
		public static extern ImGuiStackTool* ImGuiStackToolImGuiStackTool();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackTool_destroy")]
		public static extern void ImGuiStackToolDestroy(ImGuiStackTool* self);

		public static void ImGuiStackToolDestroy(ref ImGuiStackTool self)
		{
			fixed (ImGuiStackTool* pself = &self)
			{
				ImGuiStackToolDestroy((ImGuiStackTool*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiContextHook_ImGuiContextHook")]
		public static extern ImGuiContextHook* ImGuiContextHookImGuiContextHook();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiContextHook_destroy")]
		public static extern void ImGuiContextHookDestroy(ImGuiContextHook* self);

		public static void ImGuiContextHookDestroy(ref ImGuiContextHook self)
		{
			fixed (ImGuiContextHook* pself = &self)
			{
				ImGuiContextHookDestroy((ImGuiContextHook*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiContext_ImGuiContext")]
		public static extern ImGuiContext* ImGuiContextImGuiContext(ImFontAtlas* sharedFontAtlas);

		public static ImGuiContext* ImGuiContextImGuiContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContext* ret = ImGuiContextImGuiContext((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiContext_destroy")]
		public static extern void ImGuiContextDestroy(ImGuiContext* self);

		public static void ImGuiContextDestroy(ref ImGuiContext self)
		{
			fixed (ImGuiContext* pself = &self)
			{
				ImGuiContextDestroy((ImGuiContext*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_ImGuiWindow")]
		public static extern ImGuiWindow* ImGuiWindowImGuiWindow(ImGuiContext* context, byte* name);

		public static ImGuiWindow* ImGuiWindowImGuiWindow(ref ImGuiContext context, byte* name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				ImGuiWindow* ret = ImGuiWindowImGuiWindow((ImGuiContext*)pcontext, name);
				return ret;
			}
		}

		public static ImGuiWindow* ImGuiWindowImGuiWindow(ImGuiContext* context, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindow* ret = ImGuiWindowImGuiWindow(context, (byte*)pname);
				return ret;
			}
		}

		public static ImGuiWindow* ImGuiWindowImGuiWindow(ImGuiContext* context, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindow* ret = ImGuiWindowImGuiWindow(context, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImGuiWindow* ImGuiWindowImGuiWindow(ref ImGuiContext context, ref byte name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = &name)
				{
					ImGuiWindow* ret = ImGuiWindowImGuiWindow((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}

		public static ImGuiWindow* ImGuiWindowImGuiWindow(ref ImGuiContext context, string name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiWindow* ret = ImGuiWindowImGuiWindow((ImGuiContext*)pcontext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_destroy")]
		public static extern void ImGuiWindowDestroy(ImGuiWindow* self);

		public static void ImGuiWindowDestroy(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiWindowDestroy((ImGuiWindow*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_GetID_Str")]
		public static extern int ImGuiWindowGetID(ImGuiWindow* self, byte* str, byte* strEnd);

		public static int ImGuiWindowGetID(ref ImGuiWindow self, byte* str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				int ret = ImGuiWindowGetID((ImGuiWindow*)pself, str, strEnd);
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				int ret = ImGuiWindowGetID(self, (byte*)pstr, strEnd);
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiWindowGetID(self, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, ref byte str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					int ret = ImGuiWindowGetID((ImGuiWindow*)pself, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, string str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiWindowGetID((ImGuiWindow*)pself, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				int ret = ImGuiWindowGetID(self, str, (byte*)pstrEnd);
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiWindowGetID(self, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, byte* str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					int ret = ImGuiWindowGetID((ImGuiWindow*)pself, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, byte* str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiWindowGetID((ImGuiWindow*)pself, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					int ret = ImGuiWindowGetID(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGuiWindowGetID(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, ref byte str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						int ret = ImGuiWindowGetID((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, string str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImGuiWindowGetID((ImGuiWindow*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_GetID_Ptr")]
		public static extern int ImGuiWindowGetIDPtr(ImGuiWindow* self, void* ptr);

		public static int ImGuiWindowGetIDPtr(ref ImGuiWindow self, void* ptr)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				int ret = ImGuiWindowGetIDPtr((ImGuiWindow*)pself, ptr);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_GetID_Int")]
		public static extern int ImGuiWindowGetIDInt(ImGuiWindow* self, int n);

		public static int ImGuiWindowGetIDInt(ref ImGuiWindow self, int n)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				int ret = ImGuiWindowGetIDInt((ImGuiWindow*)pself, n);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_GetIDFromRectangle")]
		public static extern int ImGuiWindowGetIDFromRectangle(ImGuiWindow* self, ImRect rAbs);

		public static int ImGuiWindowGetIDFromRectangle(ref ImGuiWindow self, ImRect rAbs)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				int ret = ImGuiWindowGetIDFromRectangle((ImGuiWindow*)pself, rAbs);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_Rect")]
		public static extern void ImGuiWindowRect(ImRect* output, ImGuiWindow* self);

		public static void ImGuiWindowRect(ref ImRect output, ImGuiWindow* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiWindowRect((ImRect*)poutput, self);
			}
		}

		public static void ImGuiWindowRect(ImRect* output, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiWindowRect(output, (ImGuiWindow*)pself);
			}
		}

		public static void ImGuiWindowRect(ref ImRect output, ref ImGuiWindow self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiWindowRect((ImRect*)poutput, (ImGuiWindow*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_CalcFontSize")]
		public static extern float ImGuiWindowCalcFontSize(ImGuiWindow* self);

		public static float ImGuiWindowCalcFontSize(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiWindowCalcFontSize((ImGuiWindow*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_TitleBarHeight")]
		public static extern float ImGuiWindowTitleBarHeight(ImGuiWindow* self);

		public static float ImGuiWindowTitleBarHeight(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiWindowTitleBarHeight((ImGuiWindow*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_TitleBarRect")]
		public static extern void ImGuiWindowTitleBarRect(ImRect* output, ImGuiWindow* self);

		public static void ImGuiWindowTitleBarRect(ref ImRect output, ImGuiWindow* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiWindowTitleBarRect((ImRect*)poutput, self);
			}
		}

		public static void ImGuiWindowTitleBarRect(ImRect* output, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiWindowTitleBarRect(output, (ImGuiWindow*)pself);
			}
		}

		public static void ImGuiWindowTitleBarRect(ref ImRect output, ref ImGuiWindow self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiWindowTitleBarRect((ImRect*)poutput, (ImGuiWindow*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_MenuBarHeight")]
		public static extern float ImGuiWindowMenuBarHeight(ImGuiWindow* self);

		public static float ImGuiWindowMenuBarHeight(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiWindowMenuBarHeight((ImGuiWindow*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_MenuBarRect")]
		public static extern void ImGuiWindowMenuBarRect(ImRect* output, ImGuiWindow* self);

		public static void ImGuiWindowMenuBarRect(ref ImRect output, ImGuiWindow* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiWindowMenuBarRect((ImRect*)poutput, self);
			}
		}

		public static void ImGuiWindowMenuBarRect(ImRect* output, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiWindowMenuBarRect(output, (ImGuiWindow*)pself);
			}
		}

		public static void ImGuiWindowMenuBarRect(ref ImRect output, ref ImGuiWindow self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiWindowMenuBarRect((ImRect*)poutput, (ImGuiWindow*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTabItem_ImGuiTabItem")]
		public static extern ImGuiTabItem* ImGuiTabItemImGuiTabItem();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTabItem_destroy")]
		public static extern void ImGuiTabItemDestroy(ImGuiTabItem* self);

		public static void ImGuiTabItemDestroy(ref ImGuiTabItem self)
		{
			fixed (ImGuiTabItem* pself = &self)
			{
				ImGuiTabItemDestroy((ImGuiTabItem*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTabBar_ImGuiTabBar")]
		public static extern ImGuiTabBar* ImGuiTabBarImGuiTabBar();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTabBar_destroy")]
		public static extern void ImGuiTabBarDestroy(ImGuiTabBar* self);

		public static void ImGuiTabBarDestroy(ref ImGuiTabBar self)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				ImGuiTabBarDestroy((ImGuiTabBar*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumn_ImGuiTableColumn")]
		public static extern ImGuiTableColumn* ImGuiTableColumnImGuiTableColumn();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumn_destroy")]
		public static extern void ImGuiTableColumnDestroy(ImGuiTableColumn* self);

		public static void ImGuiTableColumnDestroy(ref ImGuiTableColumn self)
		{
			fixed (ImGuiTableColumn* pself = &self)
			{
				ImGuiTableColumnDestroy((ImGuiTableColumn*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableInstanceData_ImGuiTableInstanceData")]
		public static extern ImGuiTableInstanceData* ImGuiTableInstanceDataImGuiTableInstanceData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableInstanceData_destroy")]
		public static extern void ImGuiTableInstanceDataDestroy(ImGuiTableInstanceData* self);

		public static void ImGuiTableInstanceDataDestroy(ref ImGuiTableInstanceData self)
		{
			fixed (ImGuiTableInstanceData* pself = &self)
			{
				ImGuiTableInstanceDataDestroy((ImGuiTableInstanceData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTable_ImGuiTable")]
		public static extern ImGuiTable* ImGuiTableImGuiTable();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTable_destroy")]
		public static extern void ImGuiTableDestroy(ImGuiTable* self);

		public static void ImGuiTableDestroy(ref ImGuiTable self)
		{
			fixed (ImGuiTable* pself = &self)
			{
				ImGuiTableDestroy((ImGuiTable*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableTempData_ImGuiTableTempData")]
		public static extern ImGuiTableTempData* ImGuiTableTempDataImGuiTableTempData();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableTempData_destroy")]
		public static extern void ImGuiTableTempDataDestroy(ImGuiTableTempData* self);

		public static void ImGuiTableTempDataDestroy(ref ImGuiTableTempData self)
		{
			fixed (ImGuiTableTempData* pself = &self)
			{
				ImGuiTableTempDataDestroy((ImGuiTableTempData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumnSettings_ImGuiTableColumnSettings")]
		public static extern ImGuiTableColumnSettings* ImGuiTableColumnSettingsImGuiTableColumnSettings();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumnSettings_destroy")]
		public static extern void ImGuiTableColumnSettingsDestroy(ImGuiTableColumnSettings* self);

		public static void ImGuiTableColumnSettingsDestroy(ref ImGuiTableColumnSettings self)
		{
			fixed (ImGuiTableColumnSettings* pself = &self)
			{
				ImGuiTableColumnSettingsDestroy((ImGuiTableColumnSettings*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSettings_ImGuiTableSettings")]
		public static extern ImGuiTableSettings* ImGuiTableSettingsImGuiTableSettings();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSettings_destroy")]
		public static extern void ImGuiTableSettingsDestroy(ImGuiTableSettings* self);

		public static void ImGuiTableSettingsDestroy(ref ImGuiTableSettings self)
		{
			fixed (ImGuiTableSettings* pself = &self)
			{
				ImGuiTableSettingsDestroy((ImGuiTableSettings*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSettings_GetColumnSettings")]
		public static extern ImGuiTableColumnSettings* ImGuiTableSettingsGetColumnSettings(ImGuiTableSettings* self);

		public static ImGuiTableColumnSettings* ImGuiTableSettingsGetColumnSettings(ref ImGuiTableSettings self)
		{
			fixed (ImGuiTableSettings* pself = &self)
			{
				ImGuiTableColumnSettings* ret = ImGuiTableSettingsGetColumnSettings((ImGuiTableSettings*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentWindowRead")]
		public static extern ImGuiWindow* GetCurrentWindowRead();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentWindow")]
		public static extern ImGuiWindow* GetCurrentWindow();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowByID")]
		public static extern ImGuiWindow* FindWindowByID(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowByName")]
		public static extern ImGuiWindow* FindWindowByName(byte* name);

		public static ImGuiWindow* FindWindowByName(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindow* ret = FindWindowByName((byte*)pname);
				return ret;
			}
		}

		public static ImGuiWindow* FindWindowByName(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindow* ret = FindWindowByName(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateWindowParentAndRootLinks")]
		public static extern void UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parentWindow);

		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ImGuiWindow* parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				UpdateWindowParentAndRootLinks((ImGuiWindow*)pwindow, flags, parentWindow);
			}
		}

		public static void UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pparentWindow = &parentWindow)
			{
				UpdateWindowParentAndRootLinks(window, flags, (ImGuiWindow*)pparentWindow);
			}
		}

		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* pparentWindow = &parentWindow)
				{
					UpdateWindowParentAndRootLinks((ImGuiWindow*)pwindow, flags, (ImGuiWindow*)pparentWindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcWindowNextAutoFitSize")]
		public static extern void CalcWindowNextAutoFitSize(Vector2* output, ImGuiWindow* window);

		public static void CalcWindowNextAutoFitSize(ref Vector2 output, ImGuiWindow* window)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcWindowNextAutoFitSize((Vector2*)poutput, window);
			}
		}

		public static void CalcWindowNextAutoFitSize(Vector2* output, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				CalcWindowNextAutoFitSize(output, (ImGuiWindow*)pwindow);
			}
		}

		public static void CalcWindowNextAutoFitSize(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					CalcWindowNextAutoFitSize((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowChildOf")]
		public static extern bool IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potentialParent, bool popupHierarchy, bool dockHierarchy);

		public static bool IsWindowChildOf(ref ImGuiWindow window, ImGuiWindow* potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				bool ret = IsWindowChildOf((ImGuiWindow*)pwindow, potentialParent, popupHierarchy, dockHierarchy);
				return ret;
			}
		}

		public static bool IsWindowChildOf(ImGuiWindow* window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				bool ret = IsWindowChildOf(window, (ImGuiWindow*)ppotentialParent, popupHierarchy, dockHierarchy);
				return ret;
			}
		}

		public static bool IsWindowChildOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					bool ret = IsWindowChildOf((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent, popupHierarchy, dockHierarchy);
					return ret;
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowWithinBeginStackOf")]
		public static extern bool IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potentialParent);

		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ImGuiWindow* potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				bool ret = IsWindowWithinBeginStackOf((ImGuiWindow*)pwindow, potentialParent);
				return ret;
			}
		}

		public static bool IsWindowWithinBeginStackOf(ImGuiWindow* window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				bool ret = IsWindowWithinBeginStackOf(window, (ImGuiWindow*)ppotentialParent);
				return ret;
			}
		}

		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					bool ret = IsWindowWithinBeginStackOf((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent);
					return ret;
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowAbove")]
		public static extern bool IsWindowAbove(ImGuiWindow* potentialAbove, ImGuiWindow* potentialBelow);

		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ImGuiWindow* potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				bool ret = IsWindowAbove((ImGuiWindow*)ppotentialAbove, potentialBelow);
				return ret;
			}
		}

		public static bool IsWindowAbove(ImGuiWindow* potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
			{
				bool ret = IsWindowAbove(potentialAbove, (ImGuiWindow*)ppotentialBelow);
				return ret;
			}
		}

		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
				{
					bool ret = IsWindowAbove((ImGuiWindow*)ppotentialAbove, (ImGuiWindow*)ppotentialBelow);
					return ret;
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowNavFocusable")]
		public static extern bool IsWindowNavFocusable(ImGuiWindow* window);

		public static bool IsWindowNavFocusable(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				bool ret = IsWindowNavFocusable((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowPos_WindowPtr")]
		public static extern void SetWindowPosWindowPtr(ImGuiWindow* window, Vector2 pos, ImGuiCond cond);

		public static void SetWindowPosWindowPtr(ref ImGuiWindow window, Vector2 pos, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowPosWindowPtr((ImGuiWindow*)pwindow, pos, cond);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowSize_WindowPtr")]
		public static extern void SetWindowSizeWindowPtr(ImGuiWindow* window, Vector2 size, ImGuiCond cond);

		public static void SetWindowSizeWindowPtr(ref ImGuiWindow window, Vector2 size, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowSizeWindowPtr((ImGuiWindow*)pwindow, size, cond);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowCollapsed_WindowPtr")]
		public static extern void SetWindowCollapsedWindowPtr(ImGuiWindow* window, bool collapsed, ImGuiCond cond);

		public static void SetWindowCollapsedWindowPtr(ref ImGuiWindow window, bool collapsed, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowCollapsedWindowPtr((ImGuiWindow*)pwindow, collapsed, cond);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowHitTestHole")]
		public static extern void SetWindowHitTestHole(ImGuiWindow* window, Vector2 pos, Vector2 size);

		public static void SetWindowHitTestHole(ref ImGuiWindow window, Vector2 pos, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHitTestHole((ImGuiWindow*)pwindow, pos, size);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowHiddendAndSkipItemsForCurrentFrame")]
		public static extern void SetWindowHiddendAndSkipItemsForCurrentFrame(ImGuiWindow* window);

		public static void SetWindowHiddendAndSkipItemsForCurrentFrame(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHiddendAndSkipItemsForCurrentFrame((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igWindowRectAbsToRel")]
		public static extern void WindowRectAbsToRel(ImRect* output, ImGuiWindow* window, ImRect r);

		public static void WindowRectAbsToRel(ref ImRect output, ImGuiWindow* window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				WindowRectAbsToRel((ImRect*)poutput, window, r);
			}
		}

		public static void WindowRectAbsToRel(ImRect* output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowRectAbsToRel(output, (ImGuiWindow*)pwindow, r);
			}
		}

		public static void WindowRectAbsToRel(ref ImRect output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectAbsToRel((ImRect*)poutput, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igWindowRectRelToAbs")]
		public static extern void WindowRectRelToAbs(ImRect* output, ImGuiWindow* window, ImRect r);

		public static void WindowRectRelToAbs(ref ImRect output, ImGuiWindow* window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				WindowRectRelToAbs((ImRect*)poutput, window, r);
			}
		}

		public static void WindowRectRelToAbs(ImRect* output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowRectRelToAbs(output, (ImGuiWindow*)pwindow, r);
			}
		}

		public static void WindowRectRelToAbs(ref ImRect output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectRelToAbs((ImRect*)poutput, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igWindowPosRelToAbs")]
		public static extern void WindowPosRelToAbs(Vector2* output, ImGuiWindow* window, Vector2 p);

		public static void WindowPosRelToAbs(ref Vector2 output, ImGuiWindow* window, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				WindowPosRelToAbs((Vector2*)poutput, window, p);
			}
		}

		public static void WindowPosRelToAbs(Vector2* output, ref ImGuiWindow window, Vector2 p)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowPosRelToAbs(output, (ImGuiWindow*)pwindow, p);
			}
		}

		public static void WindowPosRelToAbs(ref Vector2 output, ref ImGuiWindow window, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowPosRelToAbs((Vector2*)poutput, (ImGuiWindow*)pwindow, p);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFocusWindow")]
		public static extern void FocusWindow(ImGuiWindow* window, ImGuiFocusRequestFlags flags);

		public static void FocusWindow(ref ImGuiWindow window, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				FocusWindow((ImGuiWindow*)pwindow, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFocusTopMostWindowUnderOne")]
		public static extern void FocusTopMostWindowUnderOne(ImGuiWindow* underThisWindow, ImGuiWindow* ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags);

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindow* ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				FocusTopMostWindowUnderOne((ImGuiWindow*)punderThisWindow, ignoreWindow, filterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindow* underThisWindow, ref ImGuiWindow ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				FocusTopMostWindowUnderOne(underThisWindow, (ImGuiWindow*)pignoreWindow, filterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					FocusTopMostWindowUnderOne((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow, filterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindow* underThisWindow, ImGuiWindow* ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiViewport* pfilterViewport = &filterViewport)
			{
				FocusTopMostWindowUnderOne(underThisWindow, ignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindow* ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiViewport* pfilterViewport = &filterViewport)
				{
					FocusTopMostWindowUnderOne((ImGuiWindow*)punderThisWindow, ignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindow* underThisWindow, ref ImGuiWindow ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				fixed (ImGuiViewport* pfilterViewport = &filterViewport)
				{
					FocusTopMostWindowUnderOne(underThisWindow, (ImGuiWindow*)pignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					fixed (ImGuiViewport* pfilterViewport = &filterViewport)
					{
						FocusTopMostWindowUnderOne((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBringWindowToFocusFront")]
		public static extern void BringWindowToFocusFront(ImGuiWindow* window);

		public static void BringWindowToFocusFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToFocusFront((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBringWindowToDisplayFront")]
		public static extern void BringWindowToDisplayFront(ImGuiWindow* window);

		public static void BringWindowToDisplayFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayFront((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBringWindowToDisplayBack")]
		public static extern void BringWindowToDisplayBack(ImGuiWindow* window);

		public static void BringWindowToDisplayBack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayBack((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBringWindowToDisplayBehind")]
		public static extern void BringWindowToDisplayBehind(ImGuiWindow* window, ImGuiWindow* aboveWindow);

		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ImGuiWindow* aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayBehind((ImGuiWindow*)pwindow, aboveWindow);
			}
		}

		public static void BringWindowToDisplayBehind(ImGuiWindow* window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* paboveWindow = &aboveWindow)
			{
				BringWindowToDisplayBehind(window, (ImGuiWindow*)paboveWindow);
			}
		}

		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* paboveWindow = &aboveWindow)
				{
					BringWindowToDisplayBehind((ImGuiWindow*)pwindow, (ImGuiWindow*)paboveWindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowDisplayIndex")]
		public static extern int FindWindowDisplayIndex(ImGuiWindow* window);

		public static int FindWindowDisplayIndex(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = FindWindowDisplayIndex((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindBottomMostVisibleWindowWithinBeginStack")]
		public static extern ImGuiWindow* FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* window);

		public static ImGuiWindow* FindBottomMostVisibleWindowWithinBeginStack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindow* ret = FindBottomMostVisibleWindowWithinBeginStack((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCurrentFont")]
		public static extern void SetCurrentFont(ImFont* font);

		public static void SetCurrentFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				SetCurrentFont((ImFont*)pfont);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetDefaultFont")]
		public static extern ImFont* GetDefaultFont();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetForegroundDrawList_WindowPtr")]
		public static extern ImDrawList* GetForegroundDrawListWindowPtr(ImGuiWindow* window);

		public static ImDrawList* GetForegroundDrawListWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImDrawList* ret = GetForegroundDrawListWindowPtr((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInitialize")]
		public static extern void Initialize();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShutdown")]
		public static extern void Shutdown();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateInputEvents")]
		public static extern void UpdateInputEvents(bool trickleFastInputs);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateHoveredWindowAndCaptureFlags")]
		public static extern void UpdateHoveredWindowAndCaptureFlags();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStartMouseMovingWindow")]
		public static extern void StartMouseMovingWindow(ImGuiWindow* window);

		public static void StartMouseMovingWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				StartMouseMovingWindow((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStartMouseMovingWindowOrNode")]
		public static extern void StartMouseMovingWindowOrNode(ImGuiWindow* window, ImGuiDockNode* node, bool undockFloatingNode);

		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ImGuiDockNode* node, bool undockFloatingNode)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				StartMouseMovingWindowOrNode((ImGuiWindow*)pwindow, node, undockFloatingNode);
			}
		}

		public static void StartMouseMovingWindowOrNode(ImGuiWindow* window, ref ImGuiDockNode node, bool undockFloatingNode)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				StartMouseMovingWindowOrNode(window, (ImGuiDockNode*)pnode, undockFloatingNode);
			}
		}

		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ref ImGuiDockNode node, bool undockFloatingNode)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					StartMouseMovingWindowOrNode((ImGuiWindow*)pwindow, (ImGuiDockNode*)pnode, undockFloatingNode);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateMouseMovingWindowNewFrame")]
		public static extern void UpdateMouseMovingWindowNewFrame();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateMouseMovingWindowEndFrame")]
		public static extern void UpdateMouseMovingWindowEndFrame();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igAddContextHook")]
		public static extern int AddContextHook(ImGuiContext* context, ImGuiContextHook* hook);

		public static int AddContextHook(ref ImGuiContext context, ImGuiContextHook* hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				int ret = AddContextHook((ImGuiContext*)pcontext, hook);
				return ret;
			}
		}

		public static int AddContextHook(ImGuiContext* context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContextHook* phook = &hook)
			{
				int ret = AddContextHook(context, (ImGuiContextHook*)phook);
				return ret;
			}
		}

		public static int AddContextHook(ref ImGuiContext context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (ImGuiContextHook* phook = &hook)
				{
					int ret = AddContextHook((ImGuiContext*)pcontext, (ImGuiContextHook*)phook);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRemoveContextHook")]
		public static extern void RemoveContextHook(ImGuiContext* context, int hookToRemove);

		public static void RemoveContextHook(ref ImGuiContext context, int hookToRemove)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				RemoveContextHook((ImGuiContext*)pcontext, hookToRemove);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCallContextHooks")]
		public static extern void CallContextHooks(ImGuiContext* context, ImGuiContextHookType type);

		public static void CallContextHooks(ref ImGuiContext context, ImGuiContextHookType type)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				CallContextHooks((ImGuiContext*)pcontext, type);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTranslateWindowsInViewport")]
		public static extern void TranslateWindowsInViewport(ImGuiViewportP* viewport, Vector2 oldPos, Vector2 newPos);

		public static void TranslateWindowsInViewport(ref ImGuiViewportP viewport, Vector2 oldPos, Vector2 newPos)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				TranslateWindowsInViewport((ImGuiViewportP*)pviewport, oldPos, newPos);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScaleWindowsInViewport")]
		public static extern void ScaleWindowsInViewport(ImGuiViewportP* viewport, float scale);

		public static void ScaleWindowsInViewport(ref ImGuiViewportP viewport, float scale)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ScaleWindowsInViewport((ImGuiViewportP*)pviewport, scale);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDestroyPlatformWindow")]
		public static extern void DestroyPlatformWindow(ImGuiViewportP* viewport);

		public static void DestroyPlatformWindow(ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DestroyPlatformWindow((ImGuiViewportP*)pviewport);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowViewport")]
		public static extern void SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport);

		public static void SetWindowViewport(ref ImGuiWindow window, ImGuiViewportP* viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowViewport((ImGuiWindow*)pwindow, viewport);
			}
		}

		public static void SetWindowViewport(ImGuiWindow* window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				SetWindowViewport(window, (ImGuiViewportP*)pviewport);
			}
		}

		public static void SetWindowViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					SetWindowViewport((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCurrentViewport")]
		public static extern void SetCurrentViewport(ImGuiWindow* window, ImGuiViewportP* viewport);

		public static void SetCurrentViewport(ref ImGuiWindow window, ImGuiViewportP* viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetCurrentViewport((ImGuiWindow*)pwindow, viewport);
			}
		}

		public static void SetCurrentViewport(ImGuiWindow* window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				SetCurrentViewport(window, (ImGuiViewportP*)pviewport);
			}
		}

		public static void SetCurrentViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					SetCurrentViewport((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetViewportPlatformMonitor")]
		public static extern ImGuiPlatformMonitor* GetViewportPlatformMonitor(ImGuiViewport* viewport);

		public static ImGuiPlatformMonitor* GetViewportPlatformMonitor(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImGuiPlatformMonitor* ret = GetViewportPlatformMonitor((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindHoveredViewportFromPlatformWindowStack")]
		public static extern ImGuiViewportP* FindHoveredViewportFromPlatformWindowStack(Vector2 mousePlatformPos);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMarkIniSettingsDirty_Nil")]
		public static extern void MarkIniSettingsDirtyNil();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMarkIniSettingsDirty_WindowPtr")]
		public static extern void MarkIniSettingsDirtyWindowPtr(ImGuiWindow* window);

		public static void MarkIniSettingsDirtyWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				MarkIniSettingsDirtyWindowPtr((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClearIniSettings")]
		public static extern void ClearIniSettings();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igAddSettingsHandler")]
		public static extern void AddSettingsHandler(ImGuiSettingsHandler* handler);

		public static void AddSettingsHandler(ref ImGuiSettingsHandler handler)
		{
			fixed (ImGuiSettingsHandler* phandler = &handler)
			{
				AddSettingsHandler((ImGuiSettingsHandler*)phandler);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRemoveSettingsHandler")]
		public static extern void RemoveSettingsHandler(byte* typeName);

		public static void RemoveSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				RemoveSettingsHandler((byte*)ptypeName);
			}
		}

		public static void RemoveSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RemoveSettingsHandler(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindSettingsHandler")]
		public static extern ImGuiSettingsHandler* FindSettingsHandler(byte* typeName);

		public static ImGuiSettingsHandler* FindSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				ImGuiSettingsHandler* ret = FindSettingsHandler((byte*)ptypeName);
				return ret;
			}
		}

		public static ImGuiSettingsHandler* FindSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiSettingsHandler* ret = FindSettingsHandler(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCreateNewWindowSettings")]
		public static extern ImGuiWindowSettings* CreateNewWindowSettings(byte* name);

		public static ImGuiWindowSettings* CreateNewWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowSettings* ret = CreateNewWindowSettings((byte*)pname);
				return ret;
			}
		}

		public static ImGuiWindowSettings* CreateNewWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowSettings* ret = CreateNewWindowSettings(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowSettingsByID")]
		public static extern ImGuiWindowSettings* FindWindowSettingsByID(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowSettingsByWindow")]
		public static extern ImGuiWindowSettings* FindWindowSettingsByWindow(ImGuiWindow* window);

		public static ImGuiWindowSettings* FindWindowSettingsByWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowSettings* ret = FindWindowSettingsByWindow((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClearWindowSettings")]
		public static extern void ClearWindowSettings(byte* name);

		public static void ClearWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ClearWindowSettings((byte*)pname);
			}
		}

		public static void ClearWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ClearWindowSettings(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLocalizeRegisterEntries")]
		public static extern void LocalizeRegisterEntries(ImGuiLocEntry* entries, int count);

		public static void LocalizeRegisterEntries(ref ImGuiLocEntry entries, int count)
		{
			fixed (ImGuiLocEntry* pentries = &entries)
			{
				LocalizeRegisterEntries((ImGuiLocEntry*)pentries, count);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLocalizeGetMsg")]
		public static extern byte* LocalizeGetMsg(ImGuiLocKey key);

		public static string LocalizeGetMsgS(ImGuiLocKey key)
		{
			string ret = Marshal.PtrToStringAnsi((nint)LocalizeGetMsg(key));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollX_WindowPtr")]
		public static extern void SetScrollXWindowPtr(ImGuiWindow* window, float scrollX);

		public static void SetScrollXWindowPtr(ref ImGuiWindow window, float scrollX)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollXWindowPtr((ImGuiWindow*)pwindow, scrollX);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollY_WindowPtr")]
		public static extern void SetScrollYWindowPtr(ImGuiWindow* window, float scrollY);

		public static void SetScrollYWindowPtr(ref ImGuiWindow window, float scrollY)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollYWindowPtr((ImGuiWindow*)pwindow, scrollY);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollFromPosX_WindowPtr")]
		public static extern void SetScrollFromPosXWindowPtr(ImGuiWindow* window, float localX, float centerXRatio);

		public static void SetScrollFromPosXWindowPtr(ref ImGuiWindow window, float localX, float centerXRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollFromPosXWindowPtr((ImGuiWindow*)pwindow, localX, centerXRatio);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollFromPosY_WindowPtr")]
		public static extern void SetScrollFromPosYWindowPtr(ImGuiWindow* window, float localY, float centerYRatio);

		public static void SetScrollFromPosYWindowPtr(ref ImGuiWindow window, float localY, float centerYRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollFromPosYWindowPtr((ImGuiWindow*)pwindow, localY, centerYRatio);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollToItem")]
		public static extern void ScrollToItem(ImGuiScrollFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollToRect")]
		public static extern void ScrollToRect(ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags);

		public static void ScrollToRect(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRect((ImGuiWindow*)pwindow, rect, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollToRectEx")]
		public static extern void ScrollToRectEx(Vector2* output, ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags);

		public static void ScrollToRectEx(ref Vector2 output, ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* poutput = &output)
			{
				ScrollToRectEx((Vector2*)poutput, window, rect, flags);
			}
		}

		public static void ScrollToRectEx(Vector2* output, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRectEx(output, (ImGuiWindow*)pwindow, rect, flags);
			}
		}

		public static void ScrollToRectEx(ref Vector2 output, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ScrollToRectEx((Vector2*)poutput, (ImGuiWindow*)pwindow, rect, flags);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollToBringRectIntoView")]
		public static extern void ScrollToBringRectIntoView(ImGuiWindow* window, ImRect rect);

		public static void ScrollToBringRectIntoView(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToBringRectIntoView((ImGuiWindow*)pwindow, rect);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemStatusFlags")]
		public static extern ImGuiItemStatusFlags GetItemStatusFlags();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemFlags")]
		public static extern ImGuiItemFlags GetItemFlags();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetActiveID")]
		public static extern int GetActiveID();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFocusID")]
		public static extern int GetFocusID();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetActiveID")]
		public static extern void SetActiveID(int id, ImGuiWindow* window);

		public static void SetActiveID(int id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetActiveID(id, (ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetFocusID")]
		public static extern void SetFocusID(int id, ImGuiWindow* window);

		public static void SetFocusID(int id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetFocusID(id, (ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClearActiveID")]
		public static extern void ClearActiveID();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetHoveredID")]
		public static extern int GetHoveredID();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetHoveredID")]
		public static extern void SetHoveredID(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igKeepAliveID")]
		public static extern void KeepAliveID(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMarkItemEdited")]
		public static extern void MarkItemEdited(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushOverrideID")]
		public static extern void PushOverrideID(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetIDWithSeed_Str")]
		public static extern int GetIDWithSeed(byte* strIdBegin, byte* strIdEnd, int seed);

		public static int GetIDWithSeed(ref byte strIdBegin, byte* strIdEnd, int seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				int ret = GetIDWithSeed((byte*)pstrIdBegin, strIdEnd, seed);
				return ret;
			}
		}

		public static int GetIDWithSeed(string strIdBegin, byte* strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDWithSeed(pStr0, strIdEnd, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetIDWithSeed(byte* strIdBegin, ref byte strIdEnd, int seed)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				int ret = GetIDWithSeed(strIdBegin, (byte*)pstrIdEnd, seed);
				return ret;
			}
		}

		public static int GetIDWithSeed(byte* strIdBegin, string strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDWithSeed(strIdBegin, pStr0, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetIDWithSeed(ref byte strIdBegin, ref byte strIdEnd, int seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					int ret = GetIDWithSeed((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		public static int GetIDWithSeed(string strIdBegin, string strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = GetIDWithSeed(pStr0, pStr1, seed);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetIDWithSeed_Int")]
		public static extern int GetIDWithSeedInt(int n, int seed);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igItemSize_Vec2")]
		public static extern void ItemSizeVec2(Vector2 size, float textBaselineY);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igItemSize_Rect")]
		public static extern void ItemSizeRect(ImRect bb, float textBaselineY);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igItemAdd")]
		public static extern bool ItemAdd(ImRect bb, int id, ImRect* navBb, ImGuiItemFlags extraFlags);

		public static bool ItemAdd(ImRect bb, int id, ref ImRect navBb, ImGuiItemFlags extraFlags)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				bool ret = ItemAdd(bb, id, (ImRect*)pnavBb, extraFlags);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igItemHoverable")]
		public static extern bool ItemHoverable(ImRect bb, int id);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowContentHoverable")]
		public static extern bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags);

		public static bool IsWindowContentHoverable(ref ImGuiWindow window, ImGuiHoveredFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				bool ret = IsWindowContentHoverable((ImGuiWindow*)pwindow, flags);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsClippedEx")]
		public static extern bool IsClippedEx(ImRect bb, int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetLastItemData")]
		public static extern void SetLastItemData(int itemId, ImGuiItemFlags inFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcItemSize")]
		public static extern void CalcItemSize(Vector2* output, Vector2 size, float defaultW, float defaultH);

		public static void CalcItemSize(ref Vector2 output, Vector2 size, float defaultW, float defaultH)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcItemSize((Vector2*)poutput, size, defaultW, defaultH);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcWrapWidthForPos")]
		public static extern float CalcWrapWidthForPos(Vector2 pos, float wrapPosX);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushMultiItemsWidths")]
		public static extern void PushMultiItemsWidths(int components, float widthFull);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemToggledSelection")]
		public static extern bool IsItemToggledSelection();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetContentRegionMaxAbs")]
		public static extern void GetContentRegionMaxAbs(Vector2* output);

		public static void GetContentRegionMaxAbs(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionMaxAbs((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShrinkWidths")]
		public static extern void ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float widthExcess);

		public static void ShrinkWidths(ref ImGuiShrinkWidthItem items, int count, float widthExcess)
		{
			fixed (ImGuiShrinkWidthItem* pitems = &items)
			{
				ShrinkWidths((ImGuiShrinkWidthItem*)pitems, count, widthExcess);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushItemFlag")]
		public static extern void PushItemFlag(ImGuiItemFlags option, bool enabled);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopItemFlag")]
		public static extern void PopItemFlag();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStyleVarInfo")]
		public static extern ImGuiDataVarInfo* GetStyleVarInfo(ImGuiStyleVar idx);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogBegin")]
		public static extern void LogBegin(ImGuiLogType type, int autoOpenDepth);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogToBuffer")]
		public static extern void LogToBuffer(int autoOpenDepth);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogRenderedText")]
		public static extern void LogRenderedText(Vector2* refPos, byte* text, byte* textEnd);

		public static void LogRenderedText(ref Vector2 refPos, byte* text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				LogRenderedText((Vector2*)prefPos, text, textEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				LogRenderedText(refPos, (byte*)ptext, textEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedText(refPos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, ref byte text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					LogRenderedText((Vector2*)prefPos, (byte*)ptext, textEnd);
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, string text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedText((Vector2*)prefPos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				LogRenderedText(refPos, text, (byte*)ptextEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedText(refPos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, byte* text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedText((Vector2*)prefPos, text, (byte*)ptextEnd);
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, byte* text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedText((Vector2*)prefPos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedText(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogRenderedText(refPos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, ref byte text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						LogRenderedText((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, string text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				LogRenderedText((Vector2*)prefPos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogSetNextTextDecoration")]
		public static extern void LogSetNextTextDecoration(byte* prefix, byte* suffix);

		public static void LogSetNextTextDecoration(ref byte prefix, byte* suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				LogSetNextTextDecoration((byte*)pprefix, suffix);
			}
		}

		public static void LogSetNextTextDecoration(string prefix, byte* suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogSetNextTextDecoration(pStr0, suffix);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogSetNextTextDecoration(byte* prefix, ref byte suffix)
		{
			fixed (byte* psuffix = &suffix)
			{
				LogSetNextTextDecoration(prefix, (byte*)psuffix);
			}
		}

		public static void LogSetNextTextDecoration(byte* prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (suffix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogSetNextTextDecoration(prefix, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogSetNextTextDecoration(ref byte prefix, ref byte suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* psuffix = &suffix)
				{
					LogSetNextTextDecoration((byte*)pprefix, (byte*)psuffix);
				}
			}
		}

		public static void LogSetNextTextDecoration(string prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (suffix != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(suffix, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogSetNextTextDecoration(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginChildEx")]
		public static extern bool BeginChildEx(byte* name, int id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags);

		public static bool BeginChildEx(ref byte name, int id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				bool ret = BeginChildEx((byte*)pname, id, sizeArg, border, flags);
				return ret;
			}
		}

		public static bool BeginChildEx(string name, int id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginChildEx(pStr0, id, sizeArg, border, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igOpenPopupEx")]
		public static extern void OpenPopupEx(int id, ImGuiPopupFlags popupFlags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClosePopupToLevel")]
		public static extern void ClosePopupToLevel(int remaining, bool restoreFocusToWindowUnderPopup);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClosePopupsOverWindow")]
		public static extern void ClosePopupsOverWindow(ImGuiWindow* refWindow, bool restoreFocusToWindowUnderPopup);

		public static void ClosePopupsOverWindow(ref ImGuiWindow refWindow, bool restoreFocusToWindowUnderPopup)
		{
			fixed (ImGuiWindow* prefWindow = &refWindow)
			{
				ClosePopupsOverWindow((ImGuiWindow*)prefWindow, restoreFocusToWindowUnderPopup);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClosePopupsExceptModals")]
		public static extern void ClosePopupsExceptModals();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsPopupOpen_ID")]
		public static extern bool IsPopupOpenID(int id, ImGuiPopupFlags popupFlags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupEx")]
		public static extern bool BeginPopupEx(int id, ImGuiWindowFlags extraFlags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTooltipEx")]
		public static extern bool BeginTooltipEx(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetPopupAllowedExtentRect")]
		public static extern void GetPopupAllowedExtentRect(ImRect* output, ImGuiWindow* window);

		public static void GetPopupAllowedExtentRect(ref ImRect output, ImGuiWindow* window)
		{
			fixed (ImRect* poutput = &output)
			{
				GetPopupAllowedExtentRect((ImRect*)poutput, window);
			}
		}

		public static void GetPopupAllowedExtentRect(ImRect* output, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				GetPopupAllowedExtentRect(output, (ImGuiWindow*)pwindow);
			}
		}

		public static void GetPopupAllowedExtentRect(ref ImRect output, ref ImGuiWindow window)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					GetPopupAllowedExtentRect((ImRect*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTopMostPopupModal")]
		public static extern ImGuiWindow* GetTopMostPopupModal();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTopMostAndVisiblePopupModal")]
		public static extern ImGuiWindow* GetTopMostAndVisiblePopupModal();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindBlockingModal")]
		public static extern ImGuiWindow* FindBlockingModal(ImGuiWindow* window);

		public static ImGuiWindow* FindBlockingModal(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindow* ret = FindBlockingModal((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindBestWindowPosForPopup")]
		public static extern void FindBestWindowPosForPopup(Vector2* output, ImGuiWindow* window);

		public static void FindBestWindowPosForPopup(ref Vector2 output, ImGuiWindow* window)
		{
			fixed (Vector2* poutput = &output)
			{
				FindBestWindowPosForPopup((Vector2*)poutput, window);
			}
		}

		public static void FindBestWindowPosForPopup(Vector2* output, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				FindBestWindowPosForPopup(output, (ImGuiWindow*)pwindow);
			}
		}

		public static void FindBestWindowPosForPopup(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					FindBestWindowPosForPopup((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindBestWindowPosForPopupEx")]
		public static extern void FindBestWindowPosForPopupEx(Vector2* output, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy);

		public static void FindBestWindowPosForPopupEx(ref Vector2 output, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* poutput = &output)
			{
				FindBestWindowPosForPopupEx((Vector2*)poutput, refPos, size, lastDir, rOuter, rAvoid, policy);
			}
		}

		public static void FindBestWindowPosForPopupEx(Vector2* output, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (ImGuiDir* plastDir = &lastDir)
			{
				FindBestWindowPosForPopupEx(output, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
			}
		}

		public static void FindBestWindowPosForPopupEx(ref Vector2 output, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiDir* plastDir = &lastDir)
				{
					FindBestWindowPosForPopupEx((Vector2*)poutput, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginViewportSideBar")]
		public static extern bool BeginViewportSideBar(byte* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags);

		public static bool BeginViewportSideBar(ref byte name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				bool ret = BeginViewportSideBar((byte*)pname, viewport, dir, size, windowFlags);
				return ret;
			}
		}

		public static bool BeginViewportSideBar(string name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginViewportSideBar(pStr0, viewport, dir, size, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginViewportSideBar(byte* name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				bool ret = BeginViewportSideBar(name, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				return ret;
			}
		}

		public static bool BeginViewportSideBar(ref byte name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					bool ret = BeginViewportSideBar((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret;
				}
			}
		}

		public static bool BeginViewportSideBar(string name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				bool ret = BeginViewportSideBar(pStr0, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginMenuEx")]
		public static extern bool BeginMenuEx(byte* label, byte* icon, bool enabled);

		public static bool BeginMenuEx(ref byte label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = BeginMenuEx((byte*)plabel, icon, enabled);
				return ret;
			}
		}

		public static bool BeginMenuEx(string label, byte* icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginMenuEx(pStr0, icon, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginMenuEx(byte* label, ref byte icon, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				bool ret = BeginMenuEx(label, (byte*)picon, enabled);
				return ret;
			}
		}

		public static bool BeginMenuEx(byte* label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginMenuEx(label, pStr0, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool BeginMenuEx(ref byte label, ref byte icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					bool ret = BeginMenuEx((byte*)plabel, (byte*)picon, enabled);
					return ret;
				}
			}
		}

		public static bool BeginMenuEx(string label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = BeginMenuEx(pStr0, pStr1, enabled);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMenuItemEx")]
		public static extern bool MenuItemEx(byte* label, byte* icon, byte* shortcut, bool selected, bool enabled);

		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = MenuItemEx((byte*)plabel, icon, shortcut, selected, enabled);
				return ret;
			}
		}

		public static bool MenuItemEx(string label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItemEx(pStr0, icon, shortcut, selected, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				bool ret = MenuItemEx(label, (byte*)picon, shortcut, selected, enabled);
				return ret;
			}
		}

		public static bool MenuItemEx(byte* label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItemEx(label, pStr0, shortcut, selected, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					bool ret = MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected, enabled);
					return ret;
				}
			}
		}

		public static bool MenuItemEx(string label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = MenuItemEx(pStr0, pStr1, shortcut, selected, enabled);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				bool ret = MenuItemEx(label, icon, (byte*)pshortcut, selected, enabled);
				return ret;
			}
		}

		public static bool MenuItemEx(byte* label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = MenuItemEx(label, icon, pStr0, selected, enabled);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					bool ret = MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected, enabled);
					return ret;
				}
			}
		}

		public static bool MenuItemEx(string label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = MenuItemEx(pStr0, icon, pStr1, selected, enabled);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					bool ret = MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected, enabled);
					return ret;
				}
			}
		}

		public static bool MenuItemEx(byte* label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = MenuItemEx(label, pStr0, pStr1, selected, enabled);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						bool ret = MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected, enabled);
						return ret;
					}
				}
			}
		}

		public static bool MenuItemEx(string label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = MenuItemEx(pStr0, pStr1, pStr2, selected, enabled);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginComboPopup")]
		public static extern bool BeginComboPopup(int popupId, ImRect bb, ImGuiComboFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginComboPreview")]
		public static extern bool BeginComboPreview();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndComboPreview")]
		public static extern void EndComboPreview();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavInitWindow")]
		public static extern void NavInitWindow(ImGuiWindow* window, bool forceReinit);

		public static void NavInitWindow(ref ImGuiWindow window, bool forceReinit)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavInitWindow((ImGuiWindow*)pwindow, forceReinit);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavInitRequestApplyResult")]
		public static extern void NavInitRequestApplyResult();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestButNoResultYet")]
		public static extern bool NavMoveRequestButNoResultYet();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestSubmit")]
		public static extern void NavMoveRequestSubmit(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestForward")]
		public static extern void NavMoveRequestForward(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestResolveWithLastItem")]
		public static extern void NavMoveRequestResolveWithLastItem(ImGuiNavItemData* result);

		public static void NavMoveRequestResolveWithLastItem(ref ImGuiNavItemData result)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				NavMoveRequestResolveWithLastItem((ImGuiNavItemData*)presult);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestCancel")]
		public static extern void NavMoveRequestCancel();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestApplyResult")]
		public static extern void NavMoveRequestApplyResult();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestTryWrapping")]
		public static extern void NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags moveFlags);

		public static void NavMoveRequestTryWrapping(ref ImGuiWindow window, ImGuiNavMoveFlags moveFlags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavMoveRequestTryWrapping((ImGuiWindow*)pwindow, moveFlags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavClearPreferredPosForAxis")]
		public static extern void NavClearPreferredPosForAxis(ImGuiAxis axis);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavUpdateCurrentWindowIsScrollPushableX")]
		public static extern void NavUpdateCurrentWindowIsScrollPushableX();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igActivateItem")]
		public static extern void ActivateItem(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNavWindow")]
		public static extern void SetNavWindow(ImGuiWindow* window);

		public static void SetNavWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetNavWindow((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNavID")]
		public static extern void SetNavID(int id, ImGuiNavLayer navLayer, int focusScopeId, ImRect rectRel);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsNamedKey")]
		public static extern bool IsNamedKey(ImGuiKey key);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsNamedKeyOrModKey")]
		public static extern bool IsNamedKeyOrModKey(ImGuiKey key);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsLegacyKey")]
		public static extern bool IsLegacyKey(ImGuiKey key);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyboardKey")]
		public static extern bool IsKeyboardKey(ImGuiKey key);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsGamepadKey")]
		public static extern bool IsGamepadKey(ImGuiKey key);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseKey")]
		public static extern bool IsMouseKey(ImGuiKey key);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAliasKey")]
		public static extern bool IsAliasKey(ImGuiKey key);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igConvertShortcutMod")]
		public static extern int ConvertShortcutMod(int keyChord);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igConvertSingleModFlagToKey")]
		public static extern ImGuiKey ConvertSingleModFlagToKey(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKey ConvertSingleModFlagToKey(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKey ret = ConvertSingleModFlagToKey((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyData_ContextPtr")]
		public static extern ImGuiKeyData* GetKeyDataContextPtr(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKeyData* GetKeyDataContextPtr(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKeyData* ret = GetKeyDataContextPtr((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyData_Key")]
		public static extern ImGuiKeyData* GetKeyDataKey(ImGuiKey key);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyChordName")]
		public static extern void GetKeyChordName(int keyChord, byte* outBuf, int outBufSize);

		public static void GetKeyChordName(int keyChord, ref byte outBuf, int outBufSize)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				GetKeyChordName(keyChord, (byte*)poutBuf, outBufSize);
			}
		}

		public static void GetKeyChordName(int keyChord, ref string outBuf, int outBufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetKeyChordName(keyChord, pStr0, outBufSize);
			outBuf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMouseButtonToKey")]
		public static extern ImGuiKey MouseButtonToKey(ImGuiMouseButton button);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDragPastThreshold")]
		public static extern bool IsMouseDragPastThreshold(ImGuiMouseButton button, float lockThreshold);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyMagnitude2d")]
		public static extern void GetKeyMagnitude2d(Vector2* output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown);

		public static void GetKeyMagnitude2d(ref Vector2 output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			fixed (Vector2* poutput = &output)
			{
				GetKeyMagnitude2d((Vector2*)poutput, keyLeft, keyRight, keyUp, keyDown);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetNavTweakPressedAmount")]
		public static extern float GetNavTweakPressedAmount(ImGuiAxis axis);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcTypematicRepeatAmount")]
		public static extern int CalcTypematicRepeatAmount(float t0, float t1, float repeatDelay, float repeatRate);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTypematicRepeatRate")]
		public static extern void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeatDelay, float* repeatRate);

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, ref float repeatDelay, float* repeatRate)
		{
			fixed (float* prepeatDelay = &repeatDelay)
			{
				GetTypematicRepeatRate(flags, (float*)prepeatDelay, repeatRate);
			}
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeatDelay, ref float repeatRate)
		{
			fixed (float* prepeatRate = &repeatRate)
			{
				GetTypematicRepeatRate(flags, repeatDelay, (float*)prepeatRate);
			}
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, ref float repeatDelay, ref float repeatRate)
		{
			fixed (float* prepeatDelay = &repeatDelay)
			{
				fixed (float* prepeatRate = &repeatRate)
				{
					GetTypematicRepeatRate(flags, (float*)prepeatDelay, (float*)prepeatRate);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetActiveIdUsingAllKeyboardKeys")]
		public static extern void SetActiveIdUsingAllKeyboardKeys();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsActiveIdUsingNavDir")]
		public static extern bool IsActiveIdUsingNavDir(ImGuiDir dir);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyOwner")]
		public static extern int GetKeyOwner(ImGuiKey key);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetKeyOwner")]
		public static extern void SetKeyOwner(ImGuiKey key, int ownerId, ImGuiInputFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetKeyOwnersForKeyChord")]
		public static extern void SetKeyOwnersForKeyChord(int key, int ownerId, ImGuiInputFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetItemKeyOwner")]
		public static extern void SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTestKeyOwner")]
		public static extern bool TestKeyOwner(ImGuiKey key, int ownerId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyOwnerData")]
		public static extern ImGuiKeyOwnerData* GetKeyOwnerData(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKeyOwnerData* GetKeyOwnerData(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKeyOwnerData* ret = GetKeyOwnerData((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyDown_ID")]
		public static extern bool IsKeyDownID(ImGuiKey key, int ownerId);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyPressed_ID")]
		public static extern bool IsKeyPressedID(ImGuiKey key, int ownerId, ImGuiInputFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyReleased_ID")]
		public static extern bool IsKeyReleasedID(ImGuiKey key, int ownerId);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDown_ID")]
		public static extern bool IsMouseDownID(ImGuiMouseButton button, int ownerId);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseClicked_ID")]
		public static extern bool IsMouseClickedID(ImGuiMouseButton button, int ownerId, ImGuiInputFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseReleased_ID")]
		public static extern bool IsMouseReleasedID(ImGuiMouseButton button, int ownerId);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShortcut")]
		public static extern bool Shortcut(int keyChord, int ownerId, ImGuiInputFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetShortcutRouting")]
		public static extern bool SetShortcutRouting(int keyChord, int ownerId, ImGuiInputFlags flags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTestShortcutRouting")]
		public static extern bool TestShortcutRouting(int keyChord, int ownerId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetShortcutRoutingData")]
		public static extern ImGuiKeyRoutingData* GetShortcutRoutingData(int keyChord);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextInitialize")]
		public static extern void DockContextInitialize(ImGuiContext* ctx);

		public static void DockContextInitialize(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextInitialize((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextShutdown")]
		public static extern void DockContextShutdown(ImGuiContext* ctx);

		public static void DockContextShutdown(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextShutdown((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextClearNodes")]
		public static extern void DockContextClearNodes(ImGuiContext* ctx, int rootId, bool clearSettingsRefs);

		public static void DockContextClearNodes(ref ImGuiContext ctx, int rootId, bool clearSettingsRefs)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextClearNodes((ImGuiContext*)pctx, rootId, clearSettingsRefs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextRebuildNodes")]
		public static extern void DockContextRebuildNodes(ImGuiContext* ctx);

		public static void DockContextRebuildNodes(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextRebuildNodes((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextNewFrameUpdateUndocking")]
		public static extern void DockContextNewFrameUpdateUndocking(ImGuiContext* ctx);

		public static void DockContextNewFrameUpdateUndocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateUndocking((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextNewFrameUpdateDocking")]
		public static extern void DockContextNewFrameUpdateDocking(ImGuiContext* ctx);

		public static void DockContextNewFrameUpdateDocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateDocking((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextEndFrame")]
		public static extern void DockContextEndFrame(ImGuiContext* ctx);

		public static void DockContextEndFrame(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextEndFrame((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextGenNodeID")]
		public static extern int DockContextGenNodeID(ImGuiContext* ctx);

		public static int DockContextGenNodeID(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				int ret = DockContextGenNodeID((ImGuiContext*)pctx);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextQueueDock")]
		public static extern void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter);

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueDock((ImGuiContext*)pctx, target, targetNode, payload, splitDir, splitRatio, splitOuter);
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				DockContextQueueDock(ctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					DockContextQueueDock((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				DockContextQueueDock(ctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDock((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDock(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						DockContextQueueDock((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ppayload = &payload)
			{
				DockContextQueueDock(ctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDock((ImGuiContext*)pctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDock(ctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDock((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDock(ctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDock((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDock(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter);
					}
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						fixed (ImGuiWindow* ppayload = &payload)
						{
							DockContextQueueDock((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextQueueUndockWindow")]
		public static extern void DockContextQueueUndockWindow(ImGuiContext* ctx, ImGuiWindow* window);

		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ImGuiWindow* window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockWindow((ImGuiContext*)pctx, window);
			}
		}

		public static void DockContextQueueUndockWindow(ImGuiContext* ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextQueueUndockWindow(ctx, (ImGuiWindow*)pwindow);
			}
		}

		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextQueueUndockWindow((ImGuiContext*)pctx, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextQueueUndockNode")]
		public static extern void DockContextQueueUndockNode(ImGuiContext* ctx, ImGuiDockNode* node);

		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ImGuiDockNode* node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockNode((ImGuiContext*)pctx, node);
			}
		}

		public static void DockContextQueueUndockNode(ImGuiContext* ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextQueueUndockNode(ctx, (ImGuiDockNode*)pnode);
			}
		}

		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextQueueUndockNode((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextProcessUndockWindow")]
		public static extern void DockContextProcessUndockWindow(ImGuiContext* ctx, ImGuiWindow* window, bool clearPersistentDockingRef);

		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ImGuiWindow* window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockWindow((ImGuiContext*)pctx, window, clearPersistentDockingRef);
			}
		}

		public static void DockContextProcessUndockWindow(ImGuiContext* ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextProcessUndockWindow(ctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef);
			}
		}

		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextProcessUndockWindow((ImGuiContext*)pctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextProcessUndockNode")]
		public static extern void DockContextProcessUndockNode(ImGuiContext* ctx, ImGuiDockNode* node);

		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ImGuiDockNode* node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockNode((ImGuiContext*)pctx, node);
			}
		}

		public static void DockContextProcessUndockNode(ImGuiContext* ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextProcessUndockNode(ctx, (ImGuiDockNode*)pnode);
			}
		}

		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextProcessUndockNode((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextCalcDropPosForDocking")]
		public static extern bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos);

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter, outPos);
				return ret;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				bool ret = DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter, outPos);
				return ret;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter, outPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				bool ret = DockContextCalcDropPosForDocking(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter, outPos);
				return ret;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter, outPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					bool ret = DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter, outPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter, outPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				bool ret = DockContextCalcDropPosForDocking(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, outPos);
				return ret;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, outPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					bool ret = DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, outPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, outPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					bool ret = DockContextCalcDropPosForDocking(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, outPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, outPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						bool ret = DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, outPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, outPos);
							return ret;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (Vector2* poutPos = &outPos)
			{
				bool ret = DockContextCalcDropPosForDocking(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter, (Vector2*)poutPos);
				return ret;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter, (Vector2*)poutPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					bool ret = DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter, (Vector2*)poutPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter, (Vector2*)poutPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					bool ret = DockContextCalcDropPosForDocking(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter, (Vector2*)poutPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter, (Vector2*)poutPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						bool ret = DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter, (Vector2*)poutPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter, (Vector2*)poutPos);
							return ret;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					bool ret = DockContextCalcDropPosForDocking(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, (Vector2*)poutPos);
					return ret;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, (Vector2*)poutPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						bool ret = DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, (Vector2*)poutPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, (Vector2*)poutPos);
							return ret;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						bool ret = DockContextCalcDropPosForDocking(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, (Vector2*)poutPos);
						return ret;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, (Vector2*)poutPos);
							return ret;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							bool ret = DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, (Vector2*)poutPos);
							return ret;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							fixed (Vector2* poutPos = &outPos)
							{
								bool ret = DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter, (Vector2*)poutPos);
								return ret;
							}
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextFindNodeByID")]
		public static extern ImGuiDockNode* DockContextFindNodeByID(ImGuiContext* ctx, int id);

		public static ImGuiDockNode* DockContextFindNodeByID(ref ImGuiContext ctx, int id)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiDockNode* ret = DockContextFindNodeByID((ImGuiContext*)pctx, id);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeWindowMenuHandler_Default")]
		public static extern void DockNodeWindowMenuHandlerDefault(ImGuiContext* ctx, ImGuiDockNode* node, ImGuiTabBar* tabBar);

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ImGuiDockNode* node, ImGuiTabBar* tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockNodeWindowMenuHandlerDefault((ImGuiContext*)pctx, node, tabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContext* ctx, ref ImGuiDockNode node, ImGuiTabBar* tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockNodeWindowMenuHandlerDefault(ctx, (ImGuiDockNode*)pnode, tabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ref ImGuiDockNode node, ImGuiTabBar* tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockNodeWindowMenuHandlerDefault((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, tabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContext* ctx, ImGuiDockNode* node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				DockNodeWindowMenuHandlerDefault(ctx, node, (ImGuiTabBar*)ptabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ImGuiDockNode* node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandlerDefault((ImGuiContext*)pctx, node, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContext* ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandlerDefault(ctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					fixed (ImGuiTabBar* ptabBar = &tabBar)
					{
						DockNodeWindowMenuHandlerDefault((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
					}
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeBeginAmendTabBar")]
		public static extern bool DockNodeBeginAmendTabBar(ImGuiDockNode* node);

		public static bool DockNodeBeginAmendTabBar(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				bool ret = DockNodeBeginAmendTabBar((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeEndAmendTabBar")]
		public static extern void DockNodeEndAmendTabBar();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeGetRootNode")]
		public static extern ImGuiDockNode* DockNodeGetRootNode(ImGuiDockNode* node);

		public static ImGuiDockNode* DockNodeGetRootNode(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiDockNode* ret = DockNodeGetRootNode((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeIsInHierarchyOf")]
		public static extern bool DockNodeIsInHierarchyOf(ImGuiDockNode* node, ImGuiDockNode* parent);

		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ImGuiDockNode* parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				bool ret = DockNodeIsInHierarchyOf((ImGuiDockNode*)pnode, parent);
				return ret;
			}
		}

		public static bool DockNodeIsInHierarchyOf(ImGuiDockNode* node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pparent = &parent)
			{
				bool ret = DockNodeIsInHierarchyOf(node, (ImGuiDockNode*)pparent);
				return ret;
			}
		}

		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiDockNode* pparent = &parent)
				{
					bool ret = DockNodeIsInHierarchyOf((ImGuiDockNode*)pnode, (ImGuiDockNode*)pparent);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeGetDepth")]
		public static extern int DockNodeGetDepth(ImGuiDockNode* node);

		public static int DockNodeGetDepth(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetDepth((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeGetWindowMenuButtonId")]
		public static extern int DockNodeGetWindowMenuButtonId(ImGuiDockNode* node);

		public static int DockNodeGetWindowMenuButtonId(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetWindowMenuButtonId((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowDockNode")]
		public static extern ImGuiDockNode* GetWindowDockNode();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowAlwaysWantOwnTabBar")]
		public static extern bool GetWindowAlwaysWantOwnTabBar(ImGuiWindow* window);

		public static bool GetWindowAlwaysWantOwnTabBar(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				bool ret = GetWindowAlwaysWantOwnTabBar((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDocked")]
		public static extern void BeginDocked(ImGuiWindow* window, bool* pOpen);

		public static void BeginDocked(ref ImGuiWindow window, bool* pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDocked((ImGuiWindow*)pwindow, pOpen);
			}
		}

		public static void BeginDocked(ImGuiWindow* window, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				BeginDocked(window, (bool*)ppOpen);
			}
		}

		public static void BeginDocked(ref ImGuiWindow window, ref bool pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					BeginDocked((ImGuiWindow*)pwindow, (bool*)ppOpen);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDockableDragDropSource")]
		public static extern void BeginDockableDragDropSource(ImGuiWindow* window);

		public static void BeginDockableDragDropSource(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropSource((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDockableDragDropTarget")]
		public static extern void BeginDockableDragDropTarget(ImGuiWindow* window);

		public static void BeginDockableDragDropTarget(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropTarget((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowDock")]
		public static extern void SetWindowDock(ImGuiWindow* window, int dockId, ImGuiCond cond);

		public static void SetWindowDock(ref ImGuiWindow window, int dockId, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowDock((ImGuiWindow*)pwindow, dockId, cond);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderDockWindow")]
		public static extern void DockBuilderDockWindow(byte* windowName, int nodeId);

		public static void DockBuilderDockWindow(ref byte windowName, int nodeId)
		{
			fixed (byte* pwindowName = &windowName)
			{
				DockBuilderDockWindow((byte*)pwindowName, nodeId);
			}
		}

		public static void DockBuilderDockWindow(string windowName, int nodeId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (windowName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(windowName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(windowName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderDockWindow(pStr0, nodeId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderGetNode")]
		public static extern ImGuiDockNode* DockBuilderGetNode(int nodeId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderGetCentralNode")]
		public static extern ImGuiDockNode* DockBuilderGetCentralNode(int nodeId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderAddNode")]
		public static extern int DockBuilderAddNode(int nodeId, ImGuiDockNodeFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderRemoveNode")]
		public static extern void DockBuilderRemoveNode(int nodeId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderRemoveNodeDockedWindows")]
		public static extern void DockBuilderRemoveNodeDockedWindows(int nodeId, bool clearSettingsRefs);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderRemoveNodeChildNodes")]
		public static extern void DockBuilderRemoveNodeChildNodes(int nodeId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderSetNodePos")]
		public static extern void DockBuilderSetNodePos(int nodeId, Vector2 pos);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderSetNodeSize")]
		public static extern void DockBuilderSetNodeSize(int nodeId, Vector2 size);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderSplitNode")]
		public static extern int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, int* outIdAtOppositeDir);

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, ref int outIdAtDir, int* outIdAtOppositeDir)
		{
			fixed (int* poutIdAtDir = &outIdAtDir)
			{
				int ret = DockBuilderSplitNode(nodeId, splitDir, sizeRatioForNodeAtDir, (int*)poutIdAtDir, outIdAtOppositeDir);
				return ret;
			}
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, ref int outIdAtOppositeDir)
		{
			fixed (int* poutIdAtOppositeDir = &outIdAtOppositeDir)
			{
				int ret = DockBuilderSplitNode(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, (int*)poutIdAtOppositeDir);
				return ret;
			}
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, ref int outIdAtDir, ref int outIdAtOppositeDir)
		{
			fixed (int* poutIdAtDir = &outIdAtDir)
			{
				fixed (int* poutIdAtOppositeDir = &outIdAtOppositeDir)
				{
					int ret = DockBuilderSplitNode(nodeId, splitDir, sizeRatioForNodeAtDir, (int*)poutIdAtDir, (int*)poutIdAtOppositeDir);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderCopyDockSpace")]
		public static extern void DockBuilderCopyDockSpace(int srcDockspaceId, int dstDockspaceId, ImVectorConstCharPtr* inWindowRemapPairs);

		public static void DockBuilderCopyDockSpace(int srcDockspaceId, int dstDockspaceId, ref ImVectorConstCharPtr inWindowRemapPairs)
		{
			fixed (ImVectorConstCharPtr* pinWindowRemapPairs = &inWindowRemapPairs)
			{
				DockBuilderCopyDockSpace(srcDockspaceId, dstDockspaceId, (ImVectorConstCharPtr*)pinWindowRemapPairs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderCopyNode")]
		public static extern void DockBuilderCopyNode(int srcNodeId, int dstNodeId, ImVectorImGuiID* outNodeRemapPairs);

		public static void DockBuilderCopyNode(int srcNodeId, int dstNodeId, ref ImVectorImGuiID outNodeRemapPairs)
		{
			fixed (ImVectorImGuiID* poutNodeRemapPairs = &outNodeRemapPairs)
			{
				DockBuilderCopyNode(srcNodeId, dstNodeId, (ImVectorImGuiID*)poutNodeRemapPairs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderCopyWindowSettings")]
		public static extern void DockBuilderCopyWindowSettings(byte* srcName, byte* dstName);

		public static void DockBuilderCopyWindowSettings(ref byte srcName, byte* dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				DockBuilderCopyWindowSettings((byte*)psrcName, dstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(string srcName, byte* dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettings(pStr0, dstName);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, ref byte dstName)
		{
			fixed (byte* pdstName = &dstName)
			{
				DockBuilderCopyWindowSettings(srcName, (byte*)pdstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dstName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettings(srcName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(ref byte srcName, ref byte dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					DockBuilderCopyWindowSettings((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		public static void DockBuilderCopyWindowSettings(string srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (dstName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(dstName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			DockBuilderCopyWindowSettings(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderFinish")]
		public static extern void DockBuilderFinish(int nodeId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushFocusScope")]
		public static extern void PushFocusScope(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopFocusScope")]
		public static extern void PopFocusScope();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentFocusScope")]
		public static extern int GetCurrentFocusScope();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsDragDropActive")]
		public static extern bool IsDragDropActive();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDragDropTargetCustom")]
		public static extern bool BeginDragDropTargetCustom(ImRect bb, int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClearDragDrop")]
		public static extern void ClearDragDrop();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsDragDropPayloadBeingAccepted")]
		public static extern bool IsDragDropPayloadBeingAccepted();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderDragDropTargetRect")]
		public static extern void RenderDragDropTargetRect(ImRect bb);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowClipRectBeforeSetChannel")]
		public static extern void SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, ImRect clipRect);

		public static void SetWindowClipRectBeforeSetChannel(ref ImGuiWindow window, ImRect clipRect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowClipRectBeforeSetChannel((ImGuiWindow*)pwindow, clipRect);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginColumns")]
		public static extern void BeginColumns(byte* strId, int count, ImGuiOldColumnFlags flags);

		public static void BeginColumns(ref byte strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				BeginColumns((byte*)pstrId, count, flags);
			}
		}

		public static void BeginColumns(string strId, int count, ImGuiOldColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BeginColumns(pStr0, count, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndColumns")]
		public static extern void EndColumns();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushColumnClipRect")]
		public static extern void PushColumnClipRect(int columnIndex);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushColumnsBackground")]
		public static extern void PushColumnsBackground();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopColumnsBackground")]
		public static extern void PopColumnsBackground();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnsID")]
		public static extern int GetColumnsID(byte* strId, int count);

		public static int GetColumnsID(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				int ret = GetColumnsID((byte*)pstrId, count);
				return ret;
			}
		}

		public static int GetColumnsID(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetColumnsID(pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindOrCreateColumns")]
		public static extern ImGuiOldColumns* FindOrCreateColumns(ImGuiWindow* window, int id);

		public static ImGuiOldColumns* FindOrCreateColumns(ref ImGuiWindow window, int id)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiOldColumns* ret = FindOrCreateColumns((ImGuiWindow*)pwindow, id);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnOffsetFromNorm")]
		public static extern float GetColumnOffsetFromNorm(ImGuiOldColumns* columns, float offsetNorm);

		public static float GetColumnOffsetFromNorm(ref ImGuiOldColumns columns, float offsetNorm)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnOffsetFromNorm((ImGuiOldColumns*)pcolumns, offsetNorm);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnNormFromOffset")]
		public static extern float GetColumnNormFromOffset(ImGuiOldColumns* columns, float offset);

		public static float GetColumnNormFromOffset(ref ImGuiOldColumns columns, float offset)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnNormFromOffset((ImGuiOldColumns*)pcolumns, offset);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableOpenContextMenu")]
		public static extern void TableOpenContextMenu(int columnN);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnWidth")]
		public static extern void TableSetColumnWidth(int columnN, float width);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnSortDirection")]
		public static extern void TableSetColumnSortDirection(int columnN, ImGuiSortDirection sortDirection, bool appendToSortSpecs);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetHoveredColumn")]
		public static extern int TableGetHoveredColumn();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetHeaderRowHeight")]
		public static extern float TableGetHeaderRowHeight();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTablePushBackgroundChannel")]
		public static extern void TablePushBackgroundChannel();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTablePopBackgroundChannel")]
		public static extern void TablePopBackgroundChannel();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentTable")]
		public static extern ImGuiTable* GetCurrentTable();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableFindByID")]
		public static extern ImGuiTable* TableFindByID(int id);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTableEx")]
		public static extern bool BeginTableEx(byte* name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth);

		public static bool BeginTableEx(ref byte name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				bool ret = BeginTableEx((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret;
			}
		}

		public static bool BeginTableEx(string name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = BeginTableEx(pStr0, id, columnsCount, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginInitMemory")]
		public static extern void TableBeginInitMemory(ImGuiTable* table, int columnsCount);

		public static void TableBeginInitMemory(ref ImGuiTable table, int columnsCount)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginInitMemory((ImGuiTable*)ptable, columnsCount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginApplyRequests")]
		public static extern void TableBeginApplyRequests(ImGuiTable* table);

		public static void TableBeginApplyRequests(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginApplyRequests((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetupDrawChannels")]
		public static extern void TableSetupDrawChannels(ImGuiTable* table);

		public static void TableSetupDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetupDrawChannels((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableUpdateLayout")]
		public static extern void TableUpdateLayout(ImGuiTable* table);

		public static void TableUpdateLayout(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateLayout((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableUpdateBorders")]
		public static extern void TableUpdateBorders(ImGuiTable* table);

		public static void TableUpdateBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateBorders((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableUpdateColumnsWeightFromWidth")]
		public static extern void TableUpdateColumnsWeightFromWidth(ImGuiTable* table);

		public static void TableUpdateColumnsWeightFromWidth(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateColumnsWeightFromWidth((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableDrawBorders")]
		public static extern void TableDrawBorders(ImGuiTable* table);

		public static void TableDrawBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawBorders((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableDrawContextMenu")]
		public static extern void TableDrawContextMenu(ImGuiTable* table);

		public static void TableDrawContextMenu(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawContextMenu((ImGuiTable*)ptable);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginContextMenuPopup")]
		public static extern bool TableBeginContextMenuPopup(ImGuiTable* table);

		public static bool TableBeginContextMenuPopup(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				bool ret = TableBeginContextMenuPopup((ImGuiTable*)ptable);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableMergeDrawChannels")]
		public static extern void TableMergeDrawChannels(ImGuiTable* table);

		public static void TableMergeDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableMergeDrawChannels((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetInstanceData")]
		public static extern ImGuiTableInstanceData* TableGetInstanceData(ImGuiTable* table, int instanceNo);

		public static ImGuiTableInstanceData* TableGetInstanceData(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableInstanceData* ret = TableGetInstanceData((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetInstanceID")]
		public static extern int TableGetInstanceID(ImGuiTable* table, int instanceNo);

		public static int TableGetInstanceID(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				int ret = TableGetInstanceID((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSortSpecsSanitize")]
		public static extern void TableSortSpecsSanitize(ImGuiTable* table);

		public static void TableSortSpecsSanitize(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsSanitize((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSortSpecsBuild")]
		public static extern void TableSortSpecsBuild(ImGuiTable* table);

		public static void TableSortSpecsBuild(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsBuild((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnNextSortDirection")]
		public static extern ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumn* column);

		public static ImGuiSortDirection TableGetColumnNextSortDirection(ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				ImGuiSortDirection ret = TableGetColumnNextSortDirection((ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableFixColumnSortDirection")]
		public static extern void TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column);

		public static void TableFixColumnSortDirection(ref ImGuiTable table, ImGuiTableColumn* column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableFixColumnSortDirection((ImGuiTable*)ptable, column);
			}
		}

		public static void TableFixColumnSortDirection(ImGuiTable* table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				TableFixColumnSortDirection(table, (ImGuiTableColumn*)pcolumn);
			}
		}

		public static void TableFixColumnSortDirection(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					TableFixColumnSortDirection((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnWidthAuto")]
		public static extern float TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column);

		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ImGuiTableColumn* column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetColumnWidthAuto((ImGuiTable*)ptable, column);
				return ret;
			}
		}

		public static float TableGetColumnWidthAuto(ImGuiTable* table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				float ret = TableGetColumnWidthAuto(table, (ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					float ret = TableGetColumnWidthAuto((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginRow")]
		public static extern void TableBeginRow(ImGuiTable* table);

		public static void TableBeginRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginRow((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableEndRow")]
		public static extern void TableEndRow(ImGuiTable* table);

		public static void TableEndRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableEndRow((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginCell")]
		public static extern void TableBeginCell(ImGuiTable* table, int columnN);

		public static void TableBeginCell(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginCell((ImGuiTable*)ptable, columnN);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableEndCell")]
		public static extern void TableEndCell(ImGuiTable* table);

		public static void TableEndCell(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableEndCell((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetCellBgRect")]
		public static extern void TableGetCellBgRect(ImRect* output, ImGuiTable* table, int columnN);

		public static void TableGetCellBgRect(ref ImRect output, ImGuiTable* table, int columnN)
		{
			fixed (ImRect* poutput = &output)
			{
				TableGetCellBgRect((ImRect*)poutput, table, columnN);
			}
		}

		public static void TableGetCellBgRect(ImRect* output, ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableGetCellBgRect(output, (ImGuiTable*)ptable, columnN);
			}
		}

		public static void TableGetCellBgRect(ref ImRect output, ref ImGuiTable table, int columnN)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiTable* ptable = &table)
				{
					TableGetCellBgRect((ImRect*)poutput, (ImGuiTable*)ptable, columnN);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnName_TablePtr")]
		public static extern byte* TableGetColumnNameTablePtr(ImGuiTable* table, int columnN);

		public static string TableGetColumnNameTablePtrS(ImGuiTable* table, int columnN)
		{
			string ret = Marshal.PtrToStringAnsi((nint)TableGetColumnNameTablePtr(table, columnN));
			return ret;
		}

		public static string TableGetColumnNameTablePtrS(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				string ret = Marshal.PtrToStringAnsi((nint)TableGetColumnNameTablePtr((ImGuiTable*)ptable, columnN));
				return ret;
			}
		}

		public static byte* TableGetColumnNameTablePtr(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte* ret = TableGetColumnNameTablePtr((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnResizeID")]
		public static extern int TableGetColumnResizeID(ImGuiTable* table, int columnN, int instanceNo);

		public static int TableGetColumnResizeID(ref ImGuiTable table, int columnN, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				int ret = TableGetColumnResizeID((ImGuiTable*)ptable, columnN, instanceNo);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetMaxColumnWidth")]
		public static extern float TableGetMaxColumnWidth(ImGuiTable* table, int columnN);

		public static float TableGetMaxColumnWidth(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetMaxColumnWidth((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnWidthAutoSingle")]
		public static extern void TableSetColumnWidthAutoSingle(ImGuiTable* table, int columnN);

		public static void TableSetColumnWidthAutoSingle(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetColumnWidthAutoSingle((ImGuiTable*)ptable, columnN);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnWidthAutoAll")]
		public static extern void TableSetColumnWidthAutoAll(ImGuiTable* table);

		public static void TableSetColumnWidthAutoAll(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetColumnWidthAutoAll((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableRemove")]
		public static extern void TableRemove(ImGuiTable* table);

		public static void TableRemove(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableRemove((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGcCompactTransientBuffers_TablePtr")]
		public static extern void TableGcCompactTransientBuffersTablePtr(ImGuiTable* table);

		public static void TableGcCompactTransientBuffersTablePtr(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableGcCompactTransientBuffersTablePtr((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGcCompactTransientBuffers_TableTempDataPtr")]
		public static extern void TableGcCompactTransientBuffersTableTempDataPtr(ImGuiTableTempData* table);

		public static void TableGcCompactTransientBuffersTableTempDataPtr(ref ImGuiTableTempData table)
		{
			fixed (ImGuiTableTempData* ptable = &table)
			{
				TableGcCompactTransientBuffersTableTempDataPtr((ImGuiTableTempData*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGcCompactSettings")]
		public static extern void TableGcCompactSettings();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableLoadSettings")]
		public static extern void TableLoadSettings(ImGuiTable* table);

		public static void TableLoadSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableLoadSettings((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSaveSettings")]
		public static extern void TableSaveSettings(ImGuiTable* table);

		public static void TableSaveSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSaveSettings((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableResetSettings")]
		public static extern void TableResetSettings(ImGuiTable* table);

		public static void TableResetSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableResetSettings((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetBoundSettings")]
		public static extern ImGuiTableSettings* TableGetBoundSettings(ImGuiTable* table);

		public static ImGuiTableSettings* TableGetBoundSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableSettings* ret = TableGetBoundSettings((ImGuiTable*)ptable);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSettingsAddSettingsHandler")]
		public static extern void TableSettingsAddSettingsHandler();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSettingsCreate")]
		public static extern ImGuiTableSettings* TableSettingsCreate(int id, int columnsCount);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSettingsFindByID")]
		public static extern ImGuiTableSettings* TableSettingsFindByID(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentTabBar")]
		public static extern ImGuiTabBar* GetCurrentTabBar();

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTabBarEx")]
		public static extern bool BeginTabBarEx(ImGuiTabBar* tabBar, ImRect bb, ImGuiTabBarFlags flags, ImGuiDockNode* dockNode);

		public static bool BeginTabBarEx(ref ImGuiTabBar tabBar, ImRect bb, ImGuiTabBarFlags flags, ImGuiDockNode* dockNode)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				bool ret = BeginTabBarEx((ImGuiTabBar*)ptabBar, bb, flags, dockNode);
				return ret;
			}
		}

		public static bool BeginTabBarEx(ImGuiTabBar* tabBar, ImRect bb, ImGuiTabBarFlags flags, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiDockNode* pdockNode = &dockNode)
			{
				bool ret = BeginTabBarEx(tabBar, bb, flags, (ImGuiDockNode*)pdockNode);
				return ret;
			}
		}

		public static bool BeginTabBarEx(ref ImGuiTabBar tabBar, ImRect bb, ImGuiTabBarFlags flags, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiDockNode* pdockNode = &dockNode)
				{
					bool ret = BeginTabBarEx((ImGuiTabBar*)ptabBar, bb, flags, (ImGuiDockNode*)pdockNode);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarFindTabByID")]
		public static extern ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tabBar, int tabId);

		public static ImGuiTabItem* TabBarFindTabByID(ref ImGuiTabBar tabBar, int tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItem* ret = TabBarFindTabByID((ImGuiTabBar*)ptabBar, tabId);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarFindTabByOrder")]
		public static extern ImGuiTabItem* TabBarFindTabByOrder(ImGuiTabBar* tabBar, int order);

		public static ImGuiTabItem* TabBarFindTabByOrder(ref ImGuiTabBar tabBar, int order)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItem* ret = TabBarFindTabByOrder((ImGuiTabBar*)ptabBar, order);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarFindMostRecentlySelectedTabForActiveWindow")]
		public static extern ImGuiTabItem* TabBarFindMostRecentlySelectedTabForActiveWindow(ImGuiTabBar* tabBar);

		public static ImGuiTabItem* TabBarFindMostRecentlySelectedTabForActiveWindow(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItem* ret = TabBarFindMostRecentlySelectedTabForActiveWindow((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarGetCurrentTab")]
		public static extern ImGuiTabItem* TabBarGetCurrentTab(ImGuiTabBar* tabBar);

		public static ImGuiTabItem* TabBarGetCurrentTab(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItem* ret = TabBarGetCurrentTab((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarGetTabOrder")]
		public static extern int TabBarGetTabOrder(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static int TabBarGetTabOrder(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				int ret = TabBarGetTabOrder((ImGuiTabBar*)ptabBar, tab);
				return ret;
			}
		}

		public static int TabBarGetTabOrder(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				int ret = TabBarGetTabOrder(tabBar, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		public static int TabBarGetTabOrder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					int ret = TabBarGetTabOrder((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarGetTabName")]
		public static extern byte* TabBarGetTabName(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static string TabBarGetTabNameS(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			string ret = Marshal.PtrToStringAnsi((nint)TabBarGetTabName(tabBar, tab));
			return ret;
		}

		public static string TabBarGetTabNameS(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				string ret = Marshal.PtrToStringAnsi((nint)TabBarGetTabName((ImGuiTabBar*)ptabBar, tab));
				return ret;
			}
		}

		public static byte* TabBarGetTabName(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* ret = TabBarGetTabName((ImGuiTabBar*)ptabBar, tab);
				return ret;
			}
		}

		public static string TabBarGetTabNameS(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				string ret = Marshal.PtrToStringAnsi((nint)TabBarGetTabName(tabBar, (ImGuiTabItem*)ptab));
				return ret;
			}
		}

		public static byte* TabBarGetTabName(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				byte* ret = TabBarGetTabName(tabBar, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		public static string TabBarGetTabNameS(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					string ret = Marshal.PtrToStringAnsi((nint)TabBarGetTabName((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab));
					return ret;
				}
			}
		}

		public static byte* TabBarGetTabName(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					byte* ret = TabBarGetTabName((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarAddTab")]
		public static extern void TabBarAddTab(ImGuiTabBar* tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindow* window);

		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindow* window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarAddTab((ImGuiTabBar*)ptabBar, tabFlags, window);
			}
		}

		public static void TabBarAddTab(ImGuiTabBar* tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				TabBarAddTab(tabBar, tabFlags, (ImGuiWindow*)pwindow);
			}
		}

		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					TabBarAddTab((ImGuiTabBar*)ptabBar, tabFlags, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarRemoveTab")]
		public static extern void TabBarRemoveTab(ImGuiTabBar* tabBar, int tabId);

		public static void TabBarRemoveTab(ref ImGuiTabBar tabBar, int tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarRemoveTab((ImGuiTabBar*)ptabBar, tabId);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarCloseTab")]
		public static extern void TabBarCloseTab(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarCloseTab((ImGuiTabBar*)ptabBar, tab);
			}
		}

		public static void TabBarCloseTab(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarCloseTab(tabBar, (ImGuiTabItem*)ptab);
			}
		}

		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarCloseTab((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarQueueFocus")]
		public static extern void TabBarQueueFocus(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static void TabBarQueueFocus(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueFocus((ImGuiTabBar*)ptabBar, tab);
			}
		}

		public static void TabBarQueueFocus(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueFocus(tabBar, (ImGuiTabItem*)ptab);
			}
		}

		public static void TabBarQueueFocus(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueFocus((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarQueueReorder")]
		public static extern void TabBarQueueReorder(ImGuiTabBar* tabBar, ImGuiTabItem* tab, int offset);

		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ImGuiTabItem* tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueReorder((ImGuiTabBar*)ptabBar, tab, offset);
			}
		}

		public static void TabBarQueueReorder(ImGuiTabBar* tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueReorder(tabBar, (ImGuiTabItem*)ptab, offset);
			}
		}

		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueReorder((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, offset);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarQueueReorderFromMousePos")]
		public static extern void TabBarQueueReorderFromMousePos(ImGuiTabBar* tabBar, ImGuiTabItem* tab, Vector2 mousePos);

		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ImGuiTabItem* tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueReorderFromMousePos((ImGuiTabBar*)ptabBar, tab, mousePos);
			}
		}

		public static void TabBarQueueReorderFromMousePos(ImGuiTabBar* tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueReorderFromMousePos(tabBar, (ImGuiTabItem*)ptab, mousePos);
			}
		}

		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueReorderFromMousePos((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, mousePos);
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarProcessReorder")]
		public static extern bool TabBarProcessReorder(ImGuiTabBar* tabBar);

		public static bool TabBarProcessReorder(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				bool ret = TabBarProcessReorder((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemEx")]
		public static extern bool TabItemEx(ImGuiTabBar* tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow);

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				bool ret = TabItemEx((ImGuiTabBar*)ptabBar, label, pOpen, flags, dockedWindow);
				return ret;
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TabItemEx(tabBar, (byte*)plabel, pOpen, flags, dockedWindow);
				return ret;
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TabItemEx(tabBar, pStr0, pOpen, flags, dockedWindow);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					bool ret = TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, dockedWindow);
					return ret;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				bool ret = TabItemEx((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = TabItemEx(tabBar, label, (bool*)ppOpen, flags, dockedWindow);
				return ret;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = TabItemEx((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, dockedWindow);
					return ret;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = TabItemEx(tabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
					return ret;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				bool ret = TabItemEx(tabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						bool ret = TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
						return ret;
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					bool ret = TabItemEx((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				bool ret = TabItemEx(tabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				return ret;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					bool ret = TabItemEx((ImGuiTabBar*)ptabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					bool ret = TabItemEx(tabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				bool ret = TabItemEx(tabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						bool ret = TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret;
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					bool ret = TabItemEx((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					bool ret = TabItemEx(tabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						bool ret = TabItemEx((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret;
					}
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						bool ret = TabItemEx(tabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret;
					}
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					bool ret = TabItemEx(tabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
						{
							bool ret = TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
							return ret;
						}
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						bool ret = TabItemEx((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemCalcSize_Str")]
		public static extern void TabItemCalcSize(Vector2* output, byte* label, bool hasCloseButtonOrUnsavedMarker);

		public static void TabItemCalcSize(ref Vector2 output, byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				TabItemCalcSize((Vector2*)poutput, label, hasCloseButtonOrUnsavedMarker);
			}
		}

		public static void TabItemCalcSize(Vector2* output, ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (byte* plabel = &label)
			{
				TabItemCalcSize(output, (byte*)plabel, hasCloseButtonOrUnsavedMarker);
			}
		}

		public static void TabItemCalcSize(Vector2* output, string label, bool hasCloseButtonOrUnsavedMarker)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TabItemCalcSize(output, pStr0, hasCloseButtonOrUnsavedMarker);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TabItemCalcSize(ref Vector2 output, ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* plabel = &label)
				{
					TabItemCalcSize((Vector2*)poutput, (byte*)plabel, hasCloseButtonOrUnsavedMarker);
				}
			}
		}

		public static void TabItemCalcSize(ref Vector2 output, string label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TabItemCalcSize((Vector2*)poutput, pStr0, hasCloseButtonOrUnsavedMarker);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemCalcSize_WindowPtr")]
		public static extern void TabItemCalcSizeWindowPtr(Vector2* output, ImGuiWindow* window);

		public static void TabItemCalcSizeWindowPtr(ref Vector2 output, ImGuiWindow* window)
		{
			fixed (Vector2* poutput = &output)
			{
				TabItemCalcSizeWindowPtr((Vector2*)poutput, window);
			}
		}

		public static void TabItemCalcSizeWindowPtr(Vector2* output, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				TabItemCalcSizeWindowPtr(output, (ImGuiWindow*)pwindow);
			}
		}

		public static void TabItemCalcSizeWindowPtr(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					TabItemCalcSizeWindowPtr((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemBackground")]
		public static extern void TabItemBackground(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, uint col);

		public static void TabItemBackground(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				TabItemBackground((ImDrawList*)pdrawList, bb, flags, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemLabelAndCloseButton")]
		public static extern void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped);

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible, outJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible, outJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible, outJustClosed, outTextClipped);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible, outJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible, outJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, outTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, outTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible, outJustClosed, (bool*)poutTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible, outJustClosed, (bool*)poutTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible, outJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible, outJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						fixed (bool* poutTextClipped = &outTextClipped)
						{
							TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, (bool*)poutTextClipped);
						}
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible, (bool*)poutJustClosed, (bool*)poutTextClipped);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderText")]
		public static extern void RenderText(Vector2 pos, byte* text, byte* textEnd, bool hideTextAfterHash);

		public static void RenderText(Vector2 pos, ref byte text, byte* textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptext = &text)
			{
				RenderText(pos, (byte*)ptext, textEnd, hideTextAfterHash);
			}
		}

		public static void RenderText(Vector2 pos, string text, byte* textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderText(pos, pStr0, textEnd, hideTextAfterHash);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(Vector2 pos, byte* text, ref byte textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderText(pos, text, (byte*)ptextEnd, hideTextAfterHash);
			}
		}

		public static void RenderText(Vector2 pos, byte* text, string textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderText(pos, text, pStr0, hideTextAfterHash);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(Vector2 pos, ref byte text, ref byte textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderText(pos, (byte*)ptext, (byte*)ptextEnd, hideTextAfterHash);
				}
			}
		}

		public static void RenderText(Vector2 pos, string text, string textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderText(pos, pStr0, pStr1, hideTextAfterHash);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderTextWrapped")]
		public static extern void RenderTextWrapped(Vector2 pos, byte* text, byte* textEnd, float wrapWidth);

		public static void RenderTextWrapped(Vector2 pos, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextWrapped(pos, (byte*)ptext, textEnd, wrapWidth);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextWrapped(pos, pStr0, textEnd, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextWrapped(pos, text, (byte*)ptextEnd, wrapWidth);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextWrapped(pos, text, pStr0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextWrapped(pos, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
				}
			}
		}

		public static void RenderTextWrapped(Vector2 pos, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextWrapped(pos, pStr0, pStr1, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderTextClipped")]
		public static extern void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect);

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextClipped(posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClipped(posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextClipped(posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClipped(posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClipped(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextClipped(posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClipped(posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClipped(posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClipped(posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClipped(posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClipped(posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClipped(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClipped(posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClipped(posMin, posMax, text, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClipped(posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClipped(posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClipped(posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClipped(posMin, posMax, text, pStr0, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClipped(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClipped(posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClipped(posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClipped(posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClipped(posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClipped(posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClipped(posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClipped(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClipped(posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderTextClippedEx")]
		public static extern void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect);

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextClippedEx(drawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedEx(drawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextClippedEx(drawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedEx(drawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClippedEx(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextClippedEx(drawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedEx(drawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedEx(drawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedEx(drawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedEx(drawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedEx(drawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedEx(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedEx(drawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
						{
							RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, clipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedEx(drawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx(drawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedEx(drawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx(drawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedEx(drawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedEx(drawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx(drawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx(drawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx(drawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx(drawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx(drawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedEx(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedEx(drawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
						{
							fixed (ImRect* pclipRect = &clipRect)
							{
								RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
							}
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedEx((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderTextEllipsis")]
		public static extern void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, Vector2* textSizeIfKnown);

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, textEnd, textSizeIfKnown);
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, textEnd, textSizeIfKnown);
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, textEnd, textSizeIfKnown);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, textEnd, textSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, textEnd, textSizeIfKnown);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, ref byte textEnd, Vector2* textSizeIfKnown)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, (byte*)ptextEnd, textSizeIfKnown);
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, string textEnd, Vector2* textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, pStr0, textSizeIfKnown);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, ref byte textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, (byte*)ptextEnd, textSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, string textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, pStr0, textSizeIfKnown);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, string textEnd, Vector2* textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, pStr1, textSizeIfKnown);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, string textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, pStr1, textSizeIfKnown);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, textEnd, (Vector2*)ptextSizeIfKnown);
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, textEnd, (Vector2*)ptextSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, textEnd, (Vector2*)ptextSizeIfKnown);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, textEnd, (Vector2*)ptextSizeIfKnown);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, string textEnd, ref Vector2 textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, pStr0, (Vector2*)ptextSizeIfKnown);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, string textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, pStr0, (Vector2*)ptextSizeIfKnown);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, string textEnd, ref Vector2 textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextEllipsis(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, pStr1, (Vector2*)ptextSizeIfKnown);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
						{
							RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown);
						}
					}
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, string textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsis((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, pStr1, (Vector2*)ptextSizeIfKnown);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderFrame")]
		public static extern void RenderFrame(Vector2 pMin, Vector2 pMax, uint fillCol, bool border, float rounding);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderFrameBorder")]
		public static extern void RenderFrameBorder(Vector2 pMin, Vector2 pMax, float rounding);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderColorRectWithAlphaCheckerboard")]
		public static extern void RenderColorRectWithAlphaCheckerboard(ImDrawList* drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding, ImDrawFlags flags);

		public static void RenderColorRectWithAlphaCheckerboard(ref ImDrawList drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderColorRectWithAlphaCheckerboard((ImDrawList*)pdrawList, pMin, pMax, fillCol, gridStep, gridOff, rounding, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderNavHighlight")]
		public static extern void RenderNavHighlight(ImRect bb, int id, ImGuiNavHighlightFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindRenderedTextEnd")]
		public static extern byte* FindRenderedTextEnd(byte* text, byte* textEnd);

		public static string FindRenderedTextEndS(byte* text, byte* textEnd)
		{
			string ret = Marshal.PtrToStringAnsi((nint)FindRenderedTextEnd(text, textEnd));
			return ret;
		}

		public static string FindRenderedTextEndS(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Marshal.PtrToStringAnsi((nint)FindRenderedTextEnd((byte*)ptext, textEnd));
				return ret;
			}
		}

		public static byte* FindRenderedTextEnd(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = FindRenderedTextEnd((byte*)ptext, textEnd);
				return ret;
			}
		}

		public static string FindRenderedTextEndS(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)FindRenderedTextEnd(pStr0, textEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* FindRenderedTextEnd(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = FindRenderedTextEnd(pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string FindRenderedTextEndS(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				string ret = Marshal.PtrToStringAnsi((nint)FindRenderedTextEnd(text, (byte*)ptextEnd));
				return ret;
			}
		}

		public static byte* FindRenderedTextEnd(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte* ret = FindRenderedTextEnd(text, (byte*)ptextEnd);
				return ret;
			}
		}

		public static string FindRenderedTextEndS(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)FindRenderedTextEnd(text, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* FindRenderedTextEnd(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = FindRenderedTextEnd(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string FindRenderedTextEndS(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Marshal.PtrToStringAnsi((nint)FindRenderedTextEnd((byte*)ptext, (byte*)ptextEnd));
					return ret;
				}
			}
		}

		public static byte* FindRenderedTextEnd(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = FindRenderedTextEnd((byte*)ptext, (byte*)ptextEnd);
					return ret;
				}
			}
		}

		public static string FindRenderedTextEndS(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Marshal.PtrToStringAnsi((nint)FindRenderedTextEnd(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* FindRenderedTextEnd(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = FindRenderedTextEnd(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderMouseCursor")]
		public static extern void RenderMouseCursor(Vector2 pos, float scale, ImGuiMouseCursor mouseCursor, uint colFill, uint colBorder, uint colShadow);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderArrow")]
		public static extern void RenderArrow(ImDrawList* drawList, Vector2 pos, uint col, ImGuiDir dir, float scale);

		public static void RenderArrow(ref ImDrawList drawList, Vector2 pos, uint col, ImGuiDir dir, float scale)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderArrow((ImDrawList*)pdrawList, pos, col, dir, scale);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderBullet")]
		public static extern void RenderBullet(ImDrawList* drawList, Vector2 pos, uint col);

		public static void RenderBullet(ref ImDrawList drawList, Vector2 pos, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderBullet((ImDrawList*)pdrawList, pos, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderCheckMark")]
		public static extern void RenderCheckMark(ImDrawList* drawList, Vector2 pos, uint col, float sz);

		public static void RenderCheckMark(ref ImDrawList drawList, Vector2 pos, uint col, float sz)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderCheckMark((ImDrawList*)pdrawList, pos, col, sz);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderArrowPointingAt")]
		public static extern void RenderArrowPointingAt(ImDrawList* drawList, Vector2 pos, Vector2 halfSz, ImGuiDir direction, uint col);

		public static void RenderArrowPointingAt(ref ImDrawList drawList, Vector2 pos, Vector2 halfSz, ImGuiDir direction, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderArrowPointingAt((ImDrawList*)pdrawList, pos, halfSz, direction, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderArrowDockMenu")]
		public static extern void RenderArrowDockMenu(ImDrawList* drawList, Vector2 pMin, float sz, uint col);

		public static void RenderArrowDockMenu(ref ImDrawList drawList, Vector2 pMin, float sz, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderArrowDockMenu((ImDrawList*)pdrawList, pMin, sz, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderRectFilledRangeH")]
		public static extern void RenderRectFilledRangeH(ImDrawList* drawList, ImRect rect, uint col, float xStartNorm, float xEndNorm, float rounding);

		public static void RenderRectFilledRangeH(ref ImDrawList drawList, ImRect rect, uint col, float xStartNorm, float xEndNorm, float rounding)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderRectFilledRangeH((ImDrawList*)pdrawList, rect, col, xStartNorm, xEndNorm, rounding);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderRectFilledWithHole")]
		public static extern void RenderRectFilledWithHole(ImDrawList* drawList, ImRect outer, ImRect inner, uint col, float rounding);

		public static void RenderRectFilledWithHole(ref ImDrawList drawList, ImRect outer, ImRect inner, uint col, float rounding)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderRectFilledWithHole((ImDrawList*)pdrawList, outer, inner, col, rounding);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcRoundingFlagsForRectInRect")]
		public static extern ImDrawFlags CalcRoundingFlagsForRectInRect(ImRect rIn, ImRect rOuter, float threshold);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextEx")]
		public static extern void TextEx(byte* text, byte* textEnd, ImGuiTextFlags flags);

		public static void TextEx(ref byte text, byte* textEnd, ImGuiTextFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				TextEx((byte*)ptext, textEnd, flags);
			}
		}

		public static void TextEx(string text, byte* textEnd, ImGuiTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextEx(pStr0, textEnd, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextEx(byte* text, ref byte textEnd, ImGuiTextFlags flags)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				TextEx(text, (byte*)ptextEnd, flags);
			}
		}

		public static void TextEx(byte* text, string textEnd, ImGuiTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextEx(text, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextEx(ref byte text, ref byte textEnd, ImGuiTextFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					TextEx((byte*)ptext, (byte*)ptextEnd, flags);
				}
			}
		}

		public static void TextEx(string text, string textEnd, ImGuiTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			TextEx(pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igButtonEx")]
		public static extern bool ButtonEx(byte* label, Vector2 sizeArg, ImGuiButtonFlags flags);

		public static bool ButtonEx(ref byte label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = ButtonEx((byte*)plabel, sizeArg, flags);
				return ret;
			}
		}

		public static bool ButtonEx(string label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ButtonEx(pStr0, sizeArg, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igArrowButtonEx")]
		public static extern bool ArrowButtonEx(byte* strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags);

		public static bool ArrowButtonEx(ref byte strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				bool ret = ArrowButtonEx((byte*)pstrId, dir, sizeArg, flags);
				return ret;
			}
		}

		public static bool ArrowButtonEx(string strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = ArrowButtonEx(pStr0, dir, sizeArg, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImageButtonEx")]
		public static extern bool ImageButtonEx(int id, ImTextureID textureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol, ImGuiButtonFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSeparatorEx")]
		public static extern void SeparatorEx(ImGuiSeparatorFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSeparatorTextEx")]
		public static extern void SeparatorTextEx(int id, byte* label, byte* labelEnd, float extraWidth);

		public static void SeparatorTextEx(int id, ref byte label, byte* labelEnd, float extraWidth)
		{
			fixed (byte* plabel = &label)
			{
				SeparatorTextEx(id, (byte*)plabel, labelEnd, extraWidth);
			}
		}

		public static void SeparatorTextEx(int id, string label, byte* labelEnd, float extraWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SeparatorTextEx(id, pStr0, labelEnd, extraWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SeparatorTextEx(int id, byte* label, ref byte labelEnd, float extraWidth)
		{
			fixed (byte* plabelEnd = &labelEnd)
			{
				SeparatorTextEx(id, label, (byte*)plabelEnd, extraWidth);
			}
		}

		public static void SeparatorTextEx(int id, byte* label, string labelEnd, float extraWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SeparatorTextEx(id, label, pStr0, extraWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SeparatorTextEx(int id, ref byte label, ref byte labelEnd, float extraWidth)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* plabelEnd = &labelEnd)
				{
					SeparatorTextEx(id, (byte*)plabel, (byte*)plabelEnd, extraWidth);
				}
			}
		}

		public static void SeparatorTextEx(int id, string label, string labelEnd, float extraWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (labelEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(labelEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SeparatorTextEx(id, pStr0, pStr1, extraWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckboxFlags_S64Ptr")]
		public static extern bool CheckboxFlagsS64Ptr(byte* label, long* flags, long flagsValue);

		public static bool CheckboxFlagsS64Ptr(ref byte label, long* flags, long flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = CheckboxFlagsS64Ptr((byte*)plabel, flags, flagsValue);
				return ret;
			}
		}

		public static bool CheckboxFlagsS64Ptr(string label, long* flags, long flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = CheckboxFlagsS64Ptr(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool CheckboxFlagsS64Ptr(byte* label, ref long flags, long flagsValue)
		{
			fixed (long* pflags = &flags)
			{
				bool ret = CheckboxFlagsS64Ptr(label, (long*)pflags, flagsValue);
				return ret;
			}
		}

		public static bool CheckboxFlagsS64Ptr(ref byte label, ref long flags, long flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (long* pflags = &flags)
				{
					bool ret = CheckboxFlagsS64Ptr((byte*)plabel, (long*)pflags, flagsValue);
					return ret;
				}
			}
		}

		public static bool CheckboxFlagsS64Ptr(string label, ref long flags, long flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (long* pflags = &flags)
			{
				bool ret = CheckboxFlagsS64Ptr(pStr0, (long*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckboxFlags_U64Ptr")]
		public static extern bool CheckboxFlagsU64Ptr(byte* label, ulong* flags, ulong flagsValue);

		public static bool CheckboxFlagsU64Ptr(ref byte label, ulong* flags, ulong flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = CheckboxFlagsU64Ptr((byte*)plabel, flags, flagsValue);
				return ret;
			}
		}

		public static bool CheckboxFlagsU64Ptr(string label, ulong* flags, ulong flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = CheckboxFlagsU64Ptr(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool CheckboxFlagsU64Ptr(byte* label, ref ulong flags, ulong flagsValue)
		{
			fixed (ulong* pflags = &flags)
			{
				bool ret = CheckboxFlagsU64Ptr(label, (ulong*)pflags, flagsValue);
				return ret;
			}
		}

		public static bool CheckboxFlagsU64Ptr(ref byte label, ref ulong flags, ulong flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (ulong* pflags = &flags)
				{
					bool ret = CheckboxFlagsU64Ptr((byte*)plabel, (ulong*)pflags, flagsValue);
					return ret;
				}
			}
		}

		public static bool CheckboxFlagsU64Ptr(string label, ref ulong flags, ulong flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ulong* pflags = &flags)
			{
				bool ret = CheckboxFlagsU64Ptr(pStr0, (ulong*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCloseButton")]
		public static extern bool CloseButton(int id, Vector2 pos);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCollapseButton")]
		public static extern bool CollapseButton(int id, Vector2 pos, ImGuiDockNode* dockNode);

		public static bool CollapseButton(int id, Vector2 pos, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiDockNode* pdockNode = &dockNode)
			{
				bool ret = CollapseButton(id, pos, (ImGuiDockNode*)pdockNode);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollbar")]
		public static extern void Scrollbar(ImGuiAxis axis);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollbarEx")]
		public static extern bool ScrollbarEx(ImRect bb, int id, ImGuiAxis axis, long* pScrollV, long availV, long contentsV, ImDrawFlags flags);

		public static bool ScrollbarEx(ImRect bb, int id, ImGuiAxis axis, ref long pScrollV, long availV, long contentsV, ImDrawFlags flags)
		{
			fixed (long* ppScrollV = &pScrollV)
			{
				bool ret = ScrollbarEx(bb, id, axis, (long*)ppScrollV, availV, contentsV, flags);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowScrollbarRect")]
		public static extern void GetWindowScrollbarRect(ImRect* output, ImGuiWindow* window, ImGuiAxis axis);

		public static void GetWindowScrollbarRect(ref ImRect output, ImGuiWindow* window, ImGuiAxis axis)
		{
			fixed (ImRect* poutput = &output)
			{
				GetWindowScrollbarRect((ImRect*)poutput, window, axis);
			}
		}

		public static void GetWindowScrollbarRect(ImRect* output, ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				GetWindowScrollbarRect(output, (ImGuiWindow*)pwindow, axis);
			}
		}

		public static void GetWindowScrollbarRect(ref ImRect output, ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					GetWindowScrollbarRect((ImRect*)poutput, (ImGuiWindow*)pwindow, axis);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowScrollbarID")]
		public static extern int GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis);

		public static int GetWindowScrollbarID(ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = GetWindowScrollbarID((ImGuiWindow*)pwindow, axis);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowResizeCornerID")]
		public static extern int GetWindowResizeCornerID(ImGuiWindow* window, int n);

		public static int GetWindowResizeCornerID(ref ImGuiWindow window, int n)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = GetWindowResizeCornerID((ImGuiWindow*)pwindow, n);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowResizeBorderID")]
		public static extern int GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir);

		public static int GetWindowResizeBorderID(ref ImGuiWindow window, ImGuiDir dir)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = GetWindowResizeBorderID((ImGuiWindow*)pwindow, dir);
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igButtonBehavior")]
		public static extern bool ButtonBehavior(ImRect bb, int id, bool* outHovered, bool* outHeld, ImGuiButtonFlags flags);

		public static bool ButtonBehavior(ImRect bb, int id, ref bool outHovered, bool* outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHovered = &outHovered)
			{
				bool ret = ButtonBehavior(bb, id, (bool*)poutHovered, outHeld, flags);
				return ret;
			}
		}

		public static bool ButtonBehavior(ImRect bb, int id, bool* outHovered, ref bool outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHeld = &outHeld)
			{
				bool ret = ButtonBehavior(bb, id, outHovered, (bool*)poutHeld, flags);
				return ret;
			}
		}

		public static bool ButtonBehavior(ImRect bb, int id, ref bool outHovered, ref bool outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHovered = &outHovered)
			{
				fixed (bool* poutHeld = &outHeld)
				{
					bool ret = ButtonBehavior(bb, id, (bool*)poutHovered, (bool*)poutHeld, flags);
					return ret;
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragBehavior")]
		public static extern bool DragBehavior(int id, ImGuiDataType dataType, void* pV, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragBehavior(int id, ImGuiDataType dataType, void* pV, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DragBehavior(id, dataType, pV, vSpeed, pMin, pMax, (byte*)pformat, flags);
				return ret;
			}
		}

		public static bool DragBehavior(int id, ImGuiDataType dataType, void* pV, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragBehavior(id, dataType, pV, vSpeed, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderBehavior")]
		public static extern bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags, ImRect* outGrabBb);

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags, ImRect* outGrabBb)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = SliderBehavior(bb, id, dataType, pV, pMin, pMax, (byte*)pformat, flags, outGrabBb);
				return ret;
			}
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, string format, ImGuiSliderFlags flags, ImRect* outGrabBb)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderBehavior(bb, id, dataType, pV, pMin, pMax, pStr0, flags, outGrabBb);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags, ref ImRect outGrabBb)
		{
			fixed (ImRect* poutGrabBb = &outGrabBb)
			{
				bool ret = SliderBehavior(bb, id, dataType, pV, pMin, pMax, format, flags, (ImRect*)poutGrabBb);
				return ret;
			}
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags, ref ImRect outGrabBb)
		{
			fixed (byte* pformat = &format)
			{
				fixed (ImRect* poutGrabBb = &outGrabBb)
				{
					bool ret = SliderBehavior(bb, id, dataType, pV, pMin, pMax, (byte*)pformat, flags, (ImRect*)poutGrabBb);
					return ret;
				}
			}
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, string format, ImGuiSliderFlags flags, ref ImRect outGrabBb)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* poutGrabBb = &outGrabBb)
			{
				bool ret = SliderBehavior(bb, id, dataType, pV, pMin, pMax, pStr0, flags, (ImRect*)poutGrabBb);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSplitterBehavior")]
		public static extern bool SplitterBehavior(ImRect bb, int id, ImGuiAxis axis, float* size1, float* size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol);

		public static bool SplitterBehavior(ImRect bb, int id, ImGuiAxis axis, ref float size1, float* size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				bool ret = SplitterBehavior(bb, id, axis, (float*)psize1, size2, minSize1, minSize2, hoverExtend, hoverVisibilityDelay, bgCol);
				return ret;
			}
		}

		public static bool SplitterBehavior(ImRect bb, int id, ImGuiAxis axis, float* size1, ref float size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize2 = &size2)
			{
				bool ret = SplitterBehavior(bb, id, axis, size1, (float*)psize2, minSize1, minSize2, hoverExtend, hoverVisibilityDelay, bgCol);
				return ret;
			}
		}

		public static bool SplitterBehavior(ImRect bb, int id, ImGuiAxis axis, ref float size1, ref float size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				fixed (float* psize2 = &size2)
				{
					bool ret = SplitterBehavior(bb, id, axis, (float*)psize1, (float*)psize2, minSize1, minSize2, hoverExtend, hoverVisibilityDelay, bgCol);
					return ret;
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeBehavior")]
		public static extern bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, byte* label, byte* labelEnd);

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, ref byte label, byte* labelEnd)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TreeNodeBehavior(id, flags, (byte*)plabel, labelEnd);
				return ret;
			}
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, string label, byte* labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeBehavior(id, flags, pStr0, labelEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, byte* label, ref byte labelEnd)
		{
			fixed (byte* plabelEnd = &labelEnd)
			{
				bool ret = TreeNodeBehavior(id, flags, label, (byte*)plabelEnd);
				return ret;
			}
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, byte* label, string labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TreeNodeBehavior(id, flags, label, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, ref byte label, ref byte labelEnd)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* plabelEnd = &labelEnd)
				{
					bool ret = TreeNodeBehavior(id, flags, (byte*)plabel, (byte*)plabelEnd);
					return ret;
				}
			}
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, string label, string labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (labelEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(labelEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = TreeNodeBehavior(id, flags, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreePushOverrideID")]
		public static extern void TreePushOverrideID(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeSetOpen")]
		public static extern void TreeNodeSetOpen(int id, bool open);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeUpdateNextOpen")]
		public static extern bool TreeNodeUpdateNextOpen(int id, ImGuiTreeNodeFlags flags);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeGetInfo")]
		public static extern ImGuiDataTypeInfo* DataTypeGetInfo(ImGuiDataType dataType);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeFormatString")]
		public static extern int DataTypeFormatString(byte* buf, int bufSize, ImGuiDataType dataType, void* pData, byte* format);

		public static int DataTypeFormatString(ref byte buf, int bufSize, ImGuiDataType dataType, void* pData, byte* format)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = DataTypeFormatString((byte*)pbuf, bufSize, dataType, pData, format);
				return ret;
			}
		}

		public static int DataTypeFormatString(ref string buf, int bufSize, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = DataTypeFormatString(pStr0, bufSize, dataType, pData, format);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int DataTypeFormatString(byte* buf, int bufSize, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				int ret = DataTypeFormatString(buf, bufSize, dataType, pData, (byte*)pformat);
				return ret;
			}
		}

		public static int DataTypeFormatString(byte* buf, int bufSize, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = DataTypeFormatString(buf, bufSize, dataType, pData, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int DataTypeFormatString(ref byte buf, int bufSize, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pformat = &format)
				{
					int ret = DataTypeFormatString((byte*)pbuf, bufSize, dataType, pData, (byte*)pformat);
					return ret;
				}
			}
		}

		public static int DataTypeFormatString(ref string buf, int bufSize, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = DataTypeFormatString(pStr0, bufSize, dataType, pData, pStr1);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeApplyOp")]
		public static extern void DataTypeApplyOp(ImGuiDataType dataType, int op, void* output, void* arg1, void* arg2);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeApplyFromText")]
		public static extern bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, byte* format);

		public static bool DataTypeApplyFromText(ref byte buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = DataTypeApplyFromText((byte*)pbuf, dataType, pData, format);
				return ret;
			}
		}

		public static bool DataTypeApplyFromText(string buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DataTypeApplyFromText(pStr0, dataType, pData, format);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = DataTypeApplyFromText(buf, dataType, pData, (byte*)pformat);
				return ret;
			}
		}

		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DataTypeApplyFromText(buf, dataType, pData, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DataTypeApplyFromText(ref byte buf, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = DataTypeApplyFromText((byte*)pbuf, dataType, pData, (byte*)pformat);
					return ret;
				}
			}
		}

		public static bool DataTypeApplyFromText(string buf, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = DataTypeApplyFromText(pStr0, dataType, pData, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeCompare")]
		public static extern int DataTypeCompare(ImGuiDataType dataType, void* arg1, void* arg2);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeClamp")]
		public static extern bool DataTypeClamp(ImGuiDataType dataType, void* pData, void* pMin, void* pMax);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputTextEx")]
		public static extern bool InputTextEx(byte* label, byte* hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData);

		public static bool InputTextEx(ref byte label, byte* hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputTextEx((byte*)plabel, hint, buf, bufSize, sizeArg, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputTextEx(string label, byte* hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextEx(pStr0, hint, buf, bufSize, sizeArg, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextEx(byte* label, ref byte hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* phint = &hint)
			{
				bool ret = InputTextEx(label, (byte*)phint, buf, bufSize, sizeArg, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputTextEx(byte* label, string hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextEx(label, pStr0, buf, bufSize, sizeArg, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextEx(ref byte label, ref byte hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					bool ret = InputTextEx((byte*)plabel, (byte*)phint, buf, bufSize, sizeArg, flags, callback, userData);
					return ret;
				}
			}
		}

		public static bool InputTextEx(string label, string hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextEx(pStr0, pStr1, buf, bufSize, sizeArg, flags, callback, userData);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextEx(byte* label, byte* hint, ref byte buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = InputTextEx(label, hint, (byte*)pbuf, bufSize, sizeArg, flags, callback, userData);
				return ret;
			}
		}

		public static bool InputTextEx(byte* label, byte* hint, ref string buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputTextEx(label, hint, pStr0, bufSize, sizeArg, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextEx(ref byte label, byte* hint, ref byte buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextEx((byte*)plabel, hint, (byte*)pbuf, bufSize, sizeArg, flags, callback, userData);
					return ret;
				}
			}
		}

		public static bool InputTextEx(string label, byte* hint, ref string buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextEx(pStr0, hint, pStr1, bufSize, sizeArg, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextEx(byte* label, ref byte hint, ref byte buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = InputTextEx(label, (byte*)phint, (byte*)pbuf, bufSize, sizeArg, flags, callback, userData);
					return ret;
				}
			}
		}

		public static bool InputTextEx(byte* label, string hint, ref string buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = InputTextEx(label, pStr0, pStr1, bufSize, sizeArg, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputTextEx(ref byte label, ref byte hint, ref byte buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						bool ret = InputTextEx((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, sizeArg, flags, callback, userData);
						return ret;
					}
				}
			}
		}

		public static bool InputTextEx(string label, string hint, ref string buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, delegate*<ImGuiInputTextCallbackData*> callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			bool ret = InputTextEx(pStr0, pStr1, pStr2, bufSize, sizeArg, flags, callback, userData);
			buf = Marshal.PtrToStringAnsi((nint)pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputTextDeactivateHook")]
		public static extern void InputTextDeactivateHook(int id);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTempInputText")]
		public static extern bool TempInputText(ImRect bb, int id, byte* label, byte* buf, int bufSize, ImGuiInputTextFlags flags);

		public static bool TempInputText(ImRect bb, int id, ref byte label, byte* buf, int bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TempInputText(bb, id, (byte*)plabel, buf, bufSize, flags);
				return ret;
			}
		}

		public static bool TempInputText(ImRect bb, int id, string label, byte* buf, int bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TempInputText(bb, id, pStr0, buf, bufSize, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TempInputText(ImRect bb, int id, byte* label, ref byte buf, int bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* pbuf = &buf)
			{
				bool ret = TempInputText(bb, id, label, (byte*)pbuf, bufSize, flags);
				return ret;
			}
		}

		public static bool TempInputText(ImRect bb, int id, byte* label, ref string buf, int bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TempInputText(bb, id, label, pStr0, bufSize, flags);
			buf = Marshal.PtrToStringAnsi((nint)pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TempInputText(ImRect bb, int id, ref byte label, ref byte buf, int bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					bool ret = TempInputText(bb, id, (byte*)plabel, (byte*)pbuf, bufSize, flags);
					return ret;
				}
			}
		}

		public static bool TempInputText(ImRect bb, int id, string label, ref string buf, int bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = TempInputText(bb, id, pStr0, pStr1, bufSize, flags);
			buf = Marshal.PtrToStringAnsi((nint)pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTempInputScalar")]
		public static extern bool TempInputScalar(ImRect bb, int id, byte* label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax);

		public static bool TempInputScalar(ImRect bb, int id, ref byte label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = TempInputScalar(bb, id, (byte*)plabel, dataType, pData, format, pClampMin, pClampMax);
				return ret;
			}
		}

		public static bool TempInputScalar(ImRect bb, int id, string label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TempInputScalar(bb, id, pStr0, dataType, pData, format, pClampMin, pClampMax);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TempInputScalar(ImRect bb, int id, byte* label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* pformat = &format)
			{
				bool ret = TempInputScalar(bb, id, label, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
				return ret;
			}
		}

		public static bool TempInputScalar(ImRect bb, int id, byte* label, ImGuiDataType dataType, void* pData, string format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = TempInputScalar(bb, id, label, dataType, pData, pStr0, pClampMin, pClampMax);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool TempInputScalar(ImRect bb, int id, ref byte label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					bool ret = TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
					return ret;
				}
			}
		}

		public static bool TempInputScalar(ImRect bb, int id, string label, ImGuiDataType dataType, void* pData, string format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			bool ret = TempInputScalar(bb, id, pStr0, dataType, pData, pStr1, pClampMin, pClampMax);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTempInputIsActive")]
		public static extern bool TempInputIsActive(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetInputTextState")]
		public static extern ImGuiInputTextState* GetInputTextState(int id);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorTooltip")]
		public static extern void ColorTooltip(byte* text, float* col, ImGuiColorEditFlags flags);

		public static void ColorTooltip(ref byte text, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				ColorTooltip((byte*)ptext, col, flags);
			}
		}

		public static void ColorTooltip(string text, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColorTooltip(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ColorTooltip(byte* text, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				ColorTooltip(text, (float*)pcol, flags);
			}
		}

		public static void ColorTooltip(ref byte text, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				fixed (float* pcol = &col)
				{
					ColorTooltip((byte*)ptext, (float*)pcol, flags);
				}
			}
		}

		public static void ColorTooltip(string text, ref float col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pcol = &col)
			{
				ColorTooltip(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorEditOptionsPopup")]
		public static extern void ColorEditOptionsPopup(float* col, ImGuiColorEditFlags flags);

		public static void ColorEditOptionsPopup(ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				ColorEditOptionsPopup((float*)pcol, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorPickerOptionsPopup")]
		public static extern void ColorPickerOptionsPopup(float* refCol, ImGuiColorEditFlags flags);

		public static void ColorPickerOptionsPopup(ref float refCol, ImGuiColorEditFlags flags)
		{
			fixed (float* prefCol = &refCol)
			{
				ColorPickerOptionsPopup((float*)prefCol, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotEx")]
		public static extern int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 sizeArg);

		public static int PlotEx(ImGuiPlotType plotType, ref byte label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			fixed (byte* plabel = &label)
			{
				int ret = PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, sizeArg);
				return ret;
			}
		}

		public static int PlotEx(ImGuiPlotType plotType, string label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = PlotEx(plotType, pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, sizeArg);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				int ret = PlotEx(plotType, label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, sizeArg);
				return ret;
			}
		}

		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = PlotEx(plotType, label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, sizeArg);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int PlotEx(ImGuiPlotType plotType, ref byte label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					int ret = PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, sizeArg);
					return ret;
				}
			}
		}

		public static int PlotEx(ImGuiPlotType plotType, string label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = PlotEx(plotType, pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, sizeArg);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShadeVertsLinearColorGradientKeepAlpha")]
		public static extern void ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* drawList, int vertStartIdx, int vertEndIdx, Vector2 gradientP0, Vector2 gradientP1, uint col0, uint col1);

		public static void ShadeVertsLinearColorGradientKeepAlpha(ref ImDrawList drawList, int vertStartIdx, int vertEndIdx, Vector2 gradientP0, Vector2 gradientP1, uint col0, uint col1)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ShadeVertsLinearColorGradientKeepAlpha((ImDrawList*)pdrawList, vertStartIdx, vertEndIdx, gradientP0, gradientP1, col0, col1);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShadeVertsLinearUV")]
		public static extern void ShadeVertsLinearUV(ImDrawList* drawList, int vertStartIdx, int vertEndIdx, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, bool clamp);

		public static void ShadeVertsLinearUV(ref ImDrawList drawList, int vertStartIdx, int vertEndIdx, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, bool clamp)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ShadeVertsLinearUV((ImDrawList*)pdrawList, vertStartIdx, vertEndIdx, a, b, uvA, uvB, clamp);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGcCompactTransientMiscBuffers")]
		public static extern void GcCompactTransientMiscBuffers();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGcCompactTransientWindowBuffers")]
		public static extern void GcCompactTransientWindowBuffers(ImGuiWindow* window);

		public static void GcCompactTransientWindowBuffers(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				GcCompactTransientWindowBuffers((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGcAwakeTransientWindowBuffers")]
		public static extern void GcAwakeTransientWindowBuffers(ImGuiWindow* window);

		public static void GcAwakeTransientWindowBuffers(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				GcAwakeTransientWindowBuffers((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLog")]
		public static extern void DebugLog(byte* fmt);

		public static void DebugLog(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				DebugLog((byte*)pfmt);
			}
		}

		public static void DebugLog(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugLog(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLogV")]
		public static extern void DebugLogV(byte* fmt, nuint args);

		public static void DebugLogV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				DebugLogV((byte*)pfmt, args);
			}
		}

		public static void DebugLogV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugLogV(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igErrorCheckEndFrameRecover")]
		public static extern void ErrorCheckEndFrameRecover(delegate*<void*, byte*> logCallback, void* userData);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igErrorCheckEndWindowRecover")]
		public static extern void ErrorCheckEndWindowRecover(delegate*<void*, byte*> logCallback, void* userData);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igErrorCheckUsingSetCursorPosToExtendParentBoundaries")]
		public static extern void ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLocateItem")]
		public static extern void DebugLocateItem(int targetId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLocateItemOnHover")]
		public static extern void DebugLocateItemOnHover(int targetId);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLocateItemResolveWithLastItem")]
		public static extern void DebugLocateItemResolveWithLastItem();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugDrawItemRect")]
		public static extern void DebugDrawItemRect(uint col);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugStartItemPicker")]
		public static extern void DebugStartItemPicker();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowFontAtlas")]
		public static extern void ShowFontAtlas(ImFontAtlas* atlas);

		public static void ShowFontAtlas(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ShowFontAtlas((ImFontAtlas*)patlas);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugHookIdInfo")]
		public static extern void DebugHookIdInfo(int id, ImGuiDataType dataType, void* dataId, void* dataIdEnd);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeColumns")]
		public static extern void DebugNodeColumns(ImGuiOldColumns* columns);

		public static void DebugNodeColumns(ref ImGuiOldColumns columns)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				DebugNodeColumns((ImGuiOldColumns*)pcolumns);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeDockNode")]
		public static extern void DebugNodeDockNode(ImGuiDockNode* node, byte* label);

		public static void DebugNodeDockNode(ref ImGuiDockNode node, byte* label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DebugNodeDockNode((ImGuiDockNode*)pnode, label);
			}
		}

		public static void DebugNodeDockNode(ImGuiDockNode* node, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeDockNode(node, (byte*)plabel);
			}
		}

		public static void DebugNodeDockNode(ImGuiDockNode* node, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeDockNode(node, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeDockNode(ref ImGuiDockNode node, ref byte label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeDockNode((ImGuiDockNode*)pnode, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeDockNode(ref ImGuiDockNode node, string label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeDockNode((ImGuiDockNode*)pnode, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeDrawList")]
		public static extern void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* drawList, byte* label);

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ImDrawList* drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, drawList, label);
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ImDrawList* drawList, byte* label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, drawList, label);
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawList* drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, label);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				DebugNodeDrawList(window, viewport, (ImDrawList*)pdrawList, label);
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, label);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, label);
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, label);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* drawList, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeDrawList(window, viewport, drawList, (byte*)plabel);
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* drawList, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeDrawList(window, viewport, drawList, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ImDrawList* drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, drawList, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ImDrawList* drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, drawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ImDrawList* drawList, ref byte label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, drawList, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ImDrawList* drawList, string label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, drawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawList* drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (byte* plabel = &label)
					{
						DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, (byte*)plabel);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawList* drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeDrawList(window, viewport, (ImDrawList*)pdrawList, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeDrawList(window, viewport, (ImDrawList*)pdrawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* plabel = &label)
					{
						DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, (byte*)plabel);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* plabel = &label)
					{
						DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, (byte*)plabel);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						fixed (byte* plabel = &label)
						{
							DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, (byte*)plabel);
						}
					}
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (label != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(label);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeDrawCmdShowMeshAndBoundingBox")]
		public static extern void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* outDrawList, ImDrawList* drawList, ImDrawCmd* drawCmd, bool showMesh, bool showAabb);

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ImDrawList* drawList, ImDrawCmd* drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				DebugNodeDrawCmdShowMeshAndBoundingBox((ImDrawList*)poutDrawList, drawList, drawCmd, showMesh, showAabb);
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* outDrawList, ref ImDrawList drawList, ImDrawCmd* drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				DebugNodeDrawCmdShowMeshAndBoundingBox(outDrawList, (ImDrawList*)pdrawList, drawCmd, showMesh, showAabb);
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ref ImDrawList drawList, ImDrawCmd* drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					DebugNodeDrawCmdShowMeshAndBoundingBox((ImDrawList*)poutDrawList, (ImDrawList*)pdrawList, drawCmd, showMesh, showAabb);
				}
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* outDrawList, ImDrawList* drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawCmd* pdrawCmd = &drawCmd)
			{
				DebugNodeDrawCmdShowMeshAndBoundingBox(outDrawList, drawList, (ImDrawCmd*)pdrawCmd, showMesh, showAabb);
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ImDrawList* drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawCmd* pdrawCmd = &drawCmd)
				{
					DebugNodeDrawCmdShowMeshAndBoundingBox((ImDrawList*)poutDrawList, drawList, (ImDrawCmd*)pdrawCmd, showMesh, showAabb);
				}
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* outDrawList, ref ImDrawList drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (ImDrawCmd* pdrawCmd = &drawCmd)
				{
					DebugNodeDrawCmdShowMeshAndBoundingBox(outDrawList, (ImDrawList*)pdrawList, (ImDrawCmd*)pdrawCmd, showMesh, showAabb);
				}
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ref ImDrawList drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (ImDrawCmd* pdrawCmd = &drawCmd)
					{
						DebugNodeDrawCmdShowMeshAndBoundingBox((ImDrawList*)poutDrawList, (ImDrawList*)pdrawList, (ImDrawCmd*)pdrawCmd, showMesh, showAabb);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeFont")]
		public static extern void DebugNodeFont(ImFont* font);

		public static void DebugNodeFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				DebugNodeFont((ImFont*)pfont);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeFontGlyph")]
		public static extern void DebugNodeFontGlyph(ImFont* font, ImFontGlyph* glyph);

		public static void DebugNodeFontGlyph(ref ImFont font, ImFontGlyph* glyph)
		{
			fixed (ImFont* pfont = &font)
			{
				DebugNodeFontGlyph((ImFont*)pfont, glyph);
			}
		}

		public static void DebugNodeFontGlyph(ImFont* font, ref ImFontGlyph glyph)
		{
			fixed (ImFontGlyph* pglyph = &glyph)
			{
				DebugNodeFontGlyph(font, (ImFontGlyph*)pglyph);
			}
		}

		public static void DebugNodeFontGlyph(ref ImFont font, ref ImFontGlyph glyph)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (ImFontGlyph* pglyph = &glyph)
				{
					DebugNodeFontGlyph((ImFont*)pfont, (ImFontGlyph*)pglyph);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeStorage")]
		public static extern void DebugNodeStorage(ImGuiStorage* storage, byte* label);

		public static void DebugNodeStorage(ref ImGuiStorage storage, byte* label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				DebugNodeStorage((ImGuiStorage*)pstorage, label);
			}
		}

		public static void DebugNodeStorage(ImGuiStorage* storage, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeStorage(storage, (byte*)plabel);
			}
		}

		public static void DebugNodeStorage(ImGuiStorage* storage, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeStorage(storage, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeStorage(ref ImGuiStorage storage, ref byte label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeStorage((ImGuiStorage*)pstorage, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeStorage(ref ImGuiStorage storage, string label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeStorage((ImGuiStorage*)pstorage, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeTabBar")]
		public static extern void DebugNodeTabBar(ImGuiTabBar* tabBar, byte* label);

		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, byte* label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				DebugNodeTabBar((ImGuiTabBar*)ptabBar, label);
			}
		}

		public static void DebugNodeTabBar(ImGuiTabBar* tabBar, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeTabBar(tabBar, (byte*)plabel);
			}
		}

		public static void DebugNodeTabBar(ImGuiTabBar* tabBar, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeTabBar(tabBar, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, ref byte label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeTabBar((ImGuiTabBar*)ptabBar, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, string label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeTabBar((ImGuiTabBar*)ptabBar, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeTable")]
		public static extern void DebugNodeTable(ImGuiTable* table);

		public static void DebugNodeTable(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				DebugNodeTable((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeTableSettings")]
		public static extern void DebugNodeTableSettings(ImGuiTableSettings* settings);

		public static void DebugNodeTableSettings(ref ImGuiTableSettings settings)
		{
			fixed (ImGuiTableSettings* psettings = &settings)
			{
				DebugNodeTableSettings((ImGuiTableSettings*)psettings);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeInputTextState")]
		public static extern void DebugNodeInputTextState(ImGuiInputTextState* state);

		public static void DebugNodeInputTextState(ref ImGuiInputTextState state)
		{
			fixed (ImGuiInputTextState* pstate = &state)
			{
				DebugNodeInputTextState((ImGuiInputTextState*)pstate);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeWindow")]
		public static extern void DebugNodeWindow(ImGuiWindow* window, byte* label);

		public static void DebugNodeWindow(ref ImGuiWindow window, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DebugNodeWindow((ImGuiWindow*)pwindow, label);
			}
		}

		public static void DebugNodeWindow(ImGuiWindow* window, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeWindow(window, (byte*)plabel);
			}
		}

		public static void DebugNodeWindow(ImGuiWindow* window, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeWindow(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeWindow(ref ImGuiWindow window, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeWindow((ImGuiWindow*)pwindow, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeWindow(ref ImGuiWindow window, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeWindow((ImGuiWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeWindowSettings")]
		public static extern void DebugNodeWindowSettings(ImGuiWindowSettings* settings);

		public static void DebugNodeWindowSettings(ref ImGuiWindowSettings settings)
		{
			fixed (ImGuiWindowSettings* psettings = &settings)
			{
				DebugNodeWindowSettings((ImGuiWindowSettings*)psettings);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeWindowsList")]
		public static extern void DebugNodeWindowsList(ImVectorImGuiWindowPtr* windows, byte* label);

		public static void DebugNodeWindowsList(ref ImVectorImGuiWindowPtr windows, byte* label)
		{
			fixed (ImVectorImGuiWindowPtr* pwindows = &windows)
			{
				DebugNodeWindowsList((ImVectorImGuiWindowPtr*)pwindows, label);
			}
		}

		public static void DebugNodeWindowsList(ImVectorImGuiWindowPtr* windows, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeWindowsList(windows, (byte*)plabel);
			}
		}

		public static void DebugNodeWindowsList(ImVectorImGuiWindowPtr* windows, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeWindowsList(windows, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeWindowsList(ref ImVectorImGuiWindowPtr windows, ref byte label)
		{
			fixed (ImVectorImGuiWindowPtr* pwindows = &windows)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeWindowsList((ImVectorImGuiWindowPtr*)pwindows, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeWindowsList(ref ImVectorImGuiWindowPtr windows, string label)
		{
			fixed (ImVectorImGuiWindowPtr* pwindows = &windows)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeWindowsList((ImVectorImGuiWindowPtr*)pwindows, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeWindowsListByBeginStackParent")]
		public static extern void DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windowsSize, ImGuiWindow* parentInBeginStack);

		public static void DebugNodeWindowsListByBeginStackParent(ref ImGuiWindow* windows, int windowsSize, ImGuiWindow* parentInBeginStack)
		{
			fixed (ImGuiWindow** pwindows = &windows)
			{
				DebugNodeWindowsListByBeginStackParent((ImGuiWindow**)pwindows, windowsSize, parentInBeginStack);
			}
		}

		public static void DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windowsSize, ref ImGuiWindow parentInBeginStack)
		{
			fixed (ImGuiWindow* pparentInBeginStack = &parentInBeginStack)
			{
				DebugNodeWindowsListByBeginStackParent(windows, windowsSize, (ImGuiWindow*)pparentInBeginStack);
			}
		}

		public static void DebugNodeWindowsListByBeginStackParent(ref ImGuiWindow* windows, int windowsSize, ref ImGuiWindow parentInBeginStack)
		{
			fixed (ImGuiWindow** pwindows = &windows)
			{
				fixed (ImGuiWindow* pparentInBeginStack = &parentInBeginStack)
				{
					DebugNodeWindowsListByBeginStackParent((ImGuiWindow**)pwindows, windowsSize, (ImGuiWindow*)pparentInBeginStack);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeViewport")]
		public static extern void DebugNodeViewport(ImGuiViewportP* viewport);

		public static void DebugNodeViewport(ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DebugNodeViewport((ImGuiViewportP*)pviewport);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugRenderKeyboardPreview")]
		public static extern void DebugRenderKeyboardPreview(ImDrawList* drawList);

		public static void DebugRenderKeyboardPreview(ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				DebugRenderKeyboardPreview((ImDrawList*)pdrawList);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugRenderViewportThumbnail")]
		public static extern void DebugRenderViewportThumbnail(ImDrawList* drawList, ImGuiViewportP* viewport, ImRect bb);

		public static void DebugRenderViewportThumbnail(ref ImDrawList drawList, ImGuiViewportP* viewport, ImRect bb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				DebugRenderViewportThumbnail((ImDrawList*)pdrawList, viewport, bb);
			}
		}

		public static void DebugRenderViewportThumbnail(ImDrawList* drawList, ref ImGuiViewportP viewport, ImRect bb)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DebugRenderViewportThumbnail(drawList, (ImGuiViewportP*)pviewport, bb);
			}
		}

		public static void DebugRenderViewportThumbnail(ref ImDrawList drawList, ref ImGuiViewportP viewport, ImRect bb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					DebugRenderViewportThumbnail((ImDrawList*)pdrawList, (ImGuiViewportP*)pviewport, bb);
				}
			}
		}

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyPressedMap")]
		public static extern bool IsKeyPressedMap(ImGuiKey key, bool repeat);

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasGetBuilderForStbTruetype")]
		public static extern ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildInit")]
		public static extern void ImFontAtlasBuildInit(ImFontAtlas* atlas);

		public static void ImFontAtlasBuildInit(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildInit((ImFontAtlas*)patlas);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildSetupFont")]
		public static extern void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* fontConfig, float ascent, float descent);

		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ImFont* font, ImFontConfig* fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildSetupFont((ImFontAtlas*)patlas, font, fontConfig, ascent, descent);
			}
		}

		public static void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ref ImFont font, ImFontConfig* fontConfig, float ascent, float descent)
		{
			fixed (ImFont* pfont = &font)
			{
				ImFontAtlasBuildSetupFont(atlas, (ImFont*)pfont, fontConfig, ascent, descent);
			}
		}

		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ref ImFont font, ImFontConfig* fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFont* pfont = &font)
				{
					ImFontAtlasBuildSetupFont((ImFontAtlas*)patlas, (ImFont*)pfont, fontConfig, ascent, descent);
				}
			}
		}

		public static void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontConfig* pfontConfig = &fontConfig)
			{
				ImFontAtlasBuildSetupFont(atlas, font, (ImFontConfig*)pfontConfig, ascent, descent);
			}
		}

		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ImFont* font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFontConfig* pfontConfig = &fontConfig)
				{
					ImFontAtlasBuildSetupFont((ImFontAtlas*)patlas, font, (ImFontConfig*)pfontConfig, ascent, descent);
				}
			}
		}

		public static void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ref ImFont font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (ImFontConfig* pfontConfig = &fontConfig)
				{
					ImFontAtlasBuildSetupFont(atlas, (ImFont*)pfont, (ImFontConfig*)pfontConfig, ascent, descent);
				}
			}
		}

		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ref ImFont font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (ImFontConfig* pfontConfig = &fontConfig)
					{
						ImFontAtlasBuildSetupFont((ImFontAtlas*)patlas, (ImFont*)pfont, (ImFontConfig*)pfontConfig, ascent, descent);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildPackCustomRects")]
		public static extern void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrpContextOpaque);

		public static void ImFontAtlasBuildPackCustomRects(ref ImFontAtlas atlas, void* stbrpContextOpaque)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildPackCustomRects((ImFontAtlas*)patlas, stbrpContextOpaque);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildFinish")]
		public static extern void ImFontAtlasBuildFinish(ImFontAtlas* atlas);

		public static void ImFontAtlasBuildFinish(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildFinish((ImFontAtlas*)patlas);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildRender8bppRectFromString")]
		public static extern void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, byte inMarkerPixelValue);

		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildRender8bppRectFromString((ImFontAtlas*)patlas, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
			}
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (byte* pinStr = &inStr)
			{
				ImFontAtlasBuildRender8bppRectFromString(atlas, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
			}
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, string inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontAtlasBuildRender8bppRectFromString(atlas, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (byte* pinStr = &inStr)
				{
					ImFontAtlasBuildRender8bppRectFromString((ImFontAtlas*)patlas, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
				}
			}
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, string inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inStr != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inStr);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontAtlasBuildRender8bppRectFromString((ImFontAtlas*)patlas, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildRender32bppRectFromString")]
		public static extern void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, uint inMarkerPixelValue);

		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildRender32bppRectFromString((ImFontAtlas*)patlas, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
			}
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (byte* pinStr = &inStr)
			{
				ImFontAtlasBuildRender32bppRectFromString(atlas, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
			}
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, string inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontAtlasBuildRender32bppRectFromString(atlas, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (byte* pinStr = &inStr)
				{
					ImFontAtlasBuildRender32bppRectFromString((ImFontAtlas*)patlas, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
				}
			}
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, string inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inStr != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inStr);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontAtlasBuildRender32bppRectFromString((ImFontAtlas*)patlas, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildMultiplyCalcLookupTable")]
		public static extern void ImFontAtlasBuildMultiplyCalcLookupTable(byte* outTable, float inMultiplyFactor);

		public static void ImFontAtlasBuildMultiplyCalcLookupTable(ref byte outTable, float inMultiplyFactor)
		{
			fixed (byte* poutTable = &outTable)
			{
				ImFontAtlasBuildMultiplyCalcLookupTable((byte*)poutTable, inMultiplyFactor);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildMultiplyRectAlpha8")]
		public static extern void ImFontAtlasBuildMultiplyRectAlpha8(byte* table, byte* pixels, int x, int y, int w, int h, int stride);

		public static void ImFontAtlasBuildMultiplyRectAlpha8(ref byte table, byte* pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ptable = &table)
			{
				ImFontAtlasBuildMultiplyRectAlpha8((byte*)ptable, pixels, x, y, w, h, stride);
			}
		}

		public static void ImFontAtlasBuildMultiplyRectAlpha8(byte* table, ref byte pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ppixels = &pixels)
			{
				ImFontAtlasBuildMultiplyRectAlpha8(table, (byte*)ppixels, x, y, w, h, stride);
			}
		}

		public static void ImFontAtlasBuildMultiplyRectAlpha8(ref byte table, ref byte pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ptable = &table)
			{
				fixed (byte* ppixels = &pixels)
				{
					ImFontAtlasBuildMultiplyRectAlpha8((byte*)ptable, (byte*)ppixels, x, y, w, h, stride);
				}
			}
		}

		/// <summary>
		/// //////////////////////hand written functions
		/// no LogTextV
		/// </summary>
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogText")]
		public static extern void LogText(byte* fmt);

		/// <summary>
		/// //////////////////////hand written functions
		/// no LogTextV
		/// </summary>
		public static void LogText(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogText((byte*)pfmt);
			}
		}

		/// <summary>
		/// //////////////////////hand written functions
		/// no LogTextV
		/// </summary>
		public static void LogText(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogText(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_appendf")]
		public static extern void appendf(ImGuiTextBuffer* buffer, byte* fmt);

		/// <summary>
		/// no appendfV
		/// </summary>
		public static void appendf(ref ImGuiTextBuffer buffer, byte* fmt)
		{
			fixed (ImGuiTextBuffer* pbuffer = &buffer)
			{
				appendf((ImGuiTextBuffer*)pbuffer, fmt);
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		public static void appendf(ImGuiTextBuffer* buffer, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				appendf(buffer, (byte*)pfmt);
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		public static void appendf(ImGuiTextBuffer* buffer, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendf(buffer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		public static void appendf(ref ImGuiTextBuffer buffer, ref byte fmt)
		{
			fixed (ImGuiTextBuffer* pbuffer = &buffer)
			{
				fixed (byte* pfmt = &fmt)
				{
					appendf((ImGuiTextBuffer*)pbuffer, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		public static void appendf(ref ImGuiTextBuffer buffer, string fmt)
		{
			fixed (ImGuiTextBuffer* pbuffer = &buffer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendf((ImGuiTextBuffer*)pbuffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// for getting FLT_MAX in bindings
		/// </summary>
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGET_FLT_MAX")]
		public static extern float GETFLTMAX();

		/// <summary>
		/// for getting FLT_MIN in bindings
		/// </summary>
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGET_FLT_MIN")]
		public static extern float GETFLTMIN();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVector_ImWchar_create")]
		public static extern ImVectorImWchar* ImVectorImWcharCreate();

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVector_ImWchar_destroy")]
		public static extern void ImVectorImWcharDestroy(ImVectorImWchar* self);

		public static void ImVectorImWcharDestroy(ref ImVectorImWchar self)
		{
			fixed (ImVectorImWchar* pself = &self)
			{
				ImVectorImWcharDestroy((ImVectorImWchar*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVector_ImWchar_Init")]
		public static extern void ImVectorImWcharInit(ImVectorImWchar* p);

		public static void ImVectorImWcharInit(ref ImVectorImWchar p)
		{
			fixed (ImVectorImWchar* pp = &p)
			{
				ImVectorImWcharInit((ImVectorImWchar*)pp);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVector_ImWchar_UnInit")]
		public static extern void ImVectorImWcharUnInit(ImVectorImWchar* p);

		public static void ImVectorImWcharUnInit(ref ImVectorImWchar p)
		{
			fixed (ImVectorImWchar* pp = &p)
			{
				ImVectorImWcharUnInit((ImVectorImWchar*)pp);
			}
		}

	}
}
