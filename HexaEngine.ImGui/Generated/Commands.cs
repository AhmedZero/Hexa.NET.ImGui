// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

namespace HexaEngine.ImGuiNET
{
	public unsafe partial class ImGui
	{
		internal const string LibName = "cimgui";

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2_ImVec2_Nil")]
		internal static extern Vector2* ImVec2Native();

		public static Vector2* ImVec2()
		{
			Vector2* ret = ImVec2Native();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2_destroy")]
		internal static extern void DestroyNative(Vector2* self);

		public static void Destroy(Vector2* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref Vector2 self)
		{
			fixed (Vector2* pself = &self)
			{
				DestroyNative((Vector2*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2_ImVec2_Float")]
		internal static extern Vector2* ImVec2Native(float x, float y);

		public static Vector2* ImVec2(float x, float y)
		{
			Vector2* ret = ImVec2Native(x, y);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec4_ImVec4_Nil")]
		internal static extern Vector4* ImVec4Native();

		public static Vector4* ImVec4()
		{
			Vector4* ret = ImVec4Native();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec4_destroy")]
		internal static extern void DestroyNative(Vector4* self);

		public static void Destroy(Vector4* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref Vector4 self)
		{
			fixed (Vector4* pself = &self)
			{
				DestroyNative((Vector4*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec4_ImVec4_Float")]
		internal static extern Vector4* ImVec4Native(float x, float y, float z, float w);

		public static Vector4* ImVec4(float x, float y, float z, float w)
		{
			Vector4* ret = ImVec4Native(x, y, z, w);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCreateContext")]
		internal static extern ImGuiContext* CreateContextNative(ImFontAtlas* sharedFontAtlas);

		public static ImGuiContextPtr CreateContext(ImFontAtlas* sharedFontAtlas)
		{
			ImGuiContextPtr ret = CreateContextNative(sharedFontAtlas);
			return ret;
		}

		public static ImGuiContextPtr CreateContext()
		{
			ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)(default));
			return ret;
		}

		public static ImGuiContextPtr CreateContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDestroyContext")]
		internal static extern void DestroyContextNative(ImGuiContext* ctx);

		public static void DestroyContext(ImGuiContext* ctx)
		{
			DestroyContextNative(ctx);
		}

		public static void DestroyContext()
		{
			DestroyContextNative((ImGuiContext*)(default));
		}

		public static void DestroyContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DestroyContextNative((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentContext")]
		internal static extern ImGuiContext* GetCurrentContextNative();

		public static ImGuiContextPtr GetCurrentContext()
		{
			ImGuiContextPtr ret = GetCurrentContextNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCurrentContext")]
		internal static extern void SetCurrentContextNative(ImGuiContext* ctx);

		public static void SetCurrentContext(ImGuiContext* ctx)
		{
			SetCurrentContextNative(ctx);
		}

		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetCurrentContextNative((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetIO")]
		internal static extern ImGuiIO* GetIONative();

		public static ImGuiIOPtr GetIO()
		{
			ImGuiIOPtr ret = GetIONative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStyle")]
		internal static extern ImGuiStyle* GetStyleNative();

		public static ImGuiStylePtr GetStyle()
		{
			ImGuiStylePtr ret = GetStyleNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNewFrame")]
		internal static extern void NewFrameNative();

		public static void NewFrame()
		{
			NewFrameNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndFrame")]
		internal static extern void EndFrameNative();

		public static void EndFrame()
		{
			EndFrameNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRender")]
		internal static extern void RenderNative();

		public static void Render()
		{
			RenderNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetDrawData")]
		internal static extern ImDrawData* GetDrawDataNative();

		public static ImDrawDataPtr GetDrawData()
		{
			ImDrawDataPtr ret = GetDrawDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowDemoWindow")]
		internal static extern void ShowDemoWindowNative(bool* pOpen);

		public static void ShowDemoWindow(bool* pOpen)
		{
			ShowDemoWindowNative(pOpen);
		}

		public static void ShowDemoWindow()
		{
			ShowDemoWindowNative((bool*)(default));
		}

		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDemoWindowNative((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowMetricsWindow")]
		internal static extern void ShowMetricsWindowNative(bool* pOpen);

		public static void ShowMetricsWindow(bool* pOpen)
		{
			ShowMetricsWindowNative(pOpen);
		}

		public static void ShowMetricsWindow()
		{
			ShowMetricsWindowNative((bool*)(default));
		}

		public static void ShowMetricsWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowMetricsWindowNative((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowDebugLogWindow")]
		internal static extern void ShowDebugLogWindowNative(bool* pOpen);

		public static void ShowDebugLogWindow(bool* pOpen)
		{
			ShowDebugLogWindowNative(pOpen);
		}

		public static void ShowDebugLogWindow()
		{
			ShowDebugLogWindowNative((bool*)(default));
		}

		public static void ShowDebugLogWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDebugLogWindowNative((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowStackToolWindow")]
		internal static extern void ShowStackToolWindowNative(bool* pOpen);

		public static void ShowStackToolWindow(bool* pOpen)
		{
			ShowStackToolWindowNative(pOpen);
		}

		public static void ShowStackToolWindow()
		{
			ShowStackToolWindowNative((bool*)(default));
		}

		public static void ShowStackToolWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowStackToolWindowNative((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowAboutWindow")]
		internal static extern void ShowAboutWindowNative(bool* pOpen);

		public static void ShowAboutWindow(bool* pOpen)
		{
			ShowAboutWindowNative(pOpen);
		}

		public static void ShowAboutWindow()
		{
			ShowAboutWindowNative((bool*)(default));
		}

		public static void ShowAboutWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowAboutWindowNative((bool*)ppOpen);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowStyleEditor")]
		internal static extern void ShowStyleEditorNative(ImGuiStyle* reference);

		public static void ShowStyleEditor(ImGuiStyle* reference)
		{
			ShowStyleEditorNative(reference);
		}

		public static void ShowStyleEditor()
		{
			ShowStyleEditorNative((ImGuiStyle*)(default));
		}

		public static void ShowStyleEditor(ref ImGuiStyle reference)
		{
			fixed (ImGuiStyle* preference = &reference)
			{
				ShowStyleEditorNative((ImGuiStyle*)preference);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowStyleSelector")]
		internal static extern byte ShowStyleSelectorNative(byte* label);

		public static bool ShowStyleSelector(byte* label)
		{
			byte ret = ShowStyleSelectorNative(label);
			return ret != 0;
		}

		public static bool ShowStyleSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowStyleSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowFontSelector")]
		internal static extern void ShowFontSelectorNative(byte* label);

		public static void ShowFontSelector(byte* label)
		{
			ShowFontSelectorNative(label);
		}

		public static void ShowFontSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ShowFontSelectorNative((byte*)plabel);
			}
		}

		public static void ShowFontSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowFontSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowUserGuide")]
		internal static extern void ShowUserGuideNative();

		public static void ShowUserGuide()
		{
			ShowUserGuideNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetVersion")]
		internal static extern byte* GetVersionNative();

		public static byte* GetVersion()
		{
			byte* ret = GetVersionNative();
			return ret;
		}

		public static string GetVersionS()
		{
			string ret = Utils.DecodeStringUTF8(GetVersionNative());
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStyleColorsDark")]
		internal static extern void StyleColorsDarkNative(ImGuiStyle* dst);

		public static void StyleColorsDark(ImGuiStyle* dst)
		{
			StyleColorsDarkNative(dst);
		}

		public static void StyleColorsDark()
		{
			StyleColorsDarkNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsDark(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsDarkNative((ImGuiStyle*)pdst);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStyleColorsLight")]
		internal static extern void StyleColorsLightNative(ImGuiStyle* dst);

		public static void StyleColorsLight(ImGuiStyle* dst)
		{
			StyleColorsLightNative(dst);
		}

		public static void StyleColorsLight()
		{
			StyleColorsLightNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsLight(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsLightNative((ImGuiStyle*)pdst);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStyleColorsClassic")]
		internal static extern void StyleColorsClassicNative(ImGuiStyle* dst);

		public static void StyleColorsClassic(ImGuiStyle* dst)
		{
			StyleColorsClassicNative(dst);
		}

		public static void StyleColorsClassic()
		{
			StyleColorsClassicNative((ImGuiStyle*)(default));
		}

		public static void StyleColorsClassic(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsClassicNative((ImGuiStyle*)pdst);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBegin")]
		internal static extern byte BeginNative(byte* name, bool* pOpen, ImGuiWindowFlags flags);

		public static bool Begin(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, pOpen, flags);
			return ret != 0;
		}

		public static bool Begin(byte* name, bool* pOpen)
		{
			byte ret = BeginNative(name, pOpen, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool Begin(byte* name)
		{
			byte ret = BeginNative(name, (bool*)(default), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool Begin(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Begin(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}

		public static bool Begin(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool Begin(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		public static bool Begin(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool Begin(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Begin(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEnd")]
		internal static extern void EndNative();

		public static void End()
		{
			EndNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginChild_Str")]
		internal static extern byte BeginChildNative(byte* strId, Vector2 size, byte border, ImGuiWindowFlags flags);

		public static bool BeginChild(byte* strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			byte ret = BeginChildNative(strId, size, border ? (byte)1 : (byte)0, flags);
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, Vector2 size, bool border)
		{
			byte ret = BeginChildNative(strId, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId, Vector2 size)
		{
			byte ret = BeginChildNative(strId, size, (byte)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(byte* strId)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(ref byte strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, border ? (byte)1 : (byte)0, flags);
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size, bool border)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (byte)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginChild(string strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, border ? (byte)1 : (byte)0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, Vector2 size, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (byte)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginChild(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginChild_ID")]
		internal static extern byte BeginChildNative(int id, Vector2 size, byte border, ImGuiWindowFlags flags);

		public static bool BeginChild(int id, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			byte ret = BeginChildNative(id, size, border ? (byte)1 : (byte)0, flags);
			return ret != 0;
		}

		public static bool BeginChild(int id, Vector2 size, bool border)
		{
			byte ret = BeginChildNative(id, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id, Vector2 size)
		{
			byte ret = BeginChildNative(id, size, (byte)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginChild(int id)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndChild")]
		internal static extern void EndChildNative();

		public static void EndChild()
		{
			EndChildNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowAppearing")]
		internal static extern byte IsWindowAppearingNative();

		public static bool IsWindowAppearing()
		{
			byte ret = IsWindowAppearingNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowCollapsed")]
		internal static extern byte IsWindowCollapsedNative();

		public static bool IsWindowCollapsed()
		{
			byte ret = IsWindowCollapsedNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowFocused")]
		internal static extern byte IsWindowFocusedNative(ImGuiFocusedFlags flags);

		public static bool IsWindowFocused(ImGuiFocusedFlags flags)
		{
			byte ret = IsWindowFocusedNative(flags);
			return ret != 0;
		}

		public static bool IsWindowFocused()
		{
			byte ret = IsWindowFocusedNative((ImGuiFocusedFlags)(0));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowHovered")]
		internal static extern byte IsWindowHoveredNative(ImGuiHoveredFlags flags);

		public static bool IsWindowHovered(ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowHoveredNative(flags);
			return ret != 0;
		}

		public static bool IsWindowHovered()
		{
			byte ret = IsWindowHoveredNative((ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowDrawList")]
		internal static extern ImDrawList* GetWindowDrawListNative();

		public static ImDrawListPtr GetWindowDrawList()
		{
			ImDrawListPtr ret = GetWindowDrawListNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowDpiScale")]
		internal static extern float GetWindowDpiScaleNative();

		public static float GetWindowDpiScale()
		{
			float ret = GetWindowDpiScaleNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowPos")]
		internal static extern void GetWindowPosNative(Vector2* output);

		public static Vector2 GetWindowPos()
		{
			Vector2 ret;
			GetWindowPosNative(&ret);
			return ret;
		}

		public static void GetWindowPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowPosNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowSize")]
		internal static extern void GetWindowSizeNative(Vector2* output);

		public static Vector2 GetWindowSize()
		{
			Vector2 ret;
			GetWindowSizeNative(&ret);
			return ret;
		}

		public static void GetWindowSize(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowSizeNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowWidth")]
		internal static extern float GetWindowWidthNative();

		public static float GetWindowWidth()
		{
			float ret = GetWindowWidthNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowHeight")]
		internal static extern float GetWindowHeightNative();

		public static float GetWindowHeight()
		{
			float ret = GetWindowHeightNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowViewport")]
		internal static extern ImGuiViewport* GetWindowViewportNative();

		public static ImGuiViewportPtr GetWindowViewport()
		{
			ImGuiViewportPtr ret = GetWindowViewportNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowPos")]
		internal static extern void SetNextWindowPosNative(Vector2 pos, ImGuiCond cond, Vector2 pivot);

		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, cond, pivot);
		}

		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetNextWindowPosNative(pos, cond, (Vector2)(new Vector2(0,0)));
		}

		public static void SetNextWindowPos(Vector2 pos)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), (Vector2)(new Vector2(0,0)));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowSize")]
		internal static extern void SetNextWindowSizeNative(Vector2 size, ImGuiCond cond);

		public static void SetNextWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetNextWindowSizeNative(size, cond);
		}

		public static void SetNextWindowSize(Vector2 size)
		{
			SetNextWindowSizeNative(size, (ImGuiCond)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowSizeConstraints")]
		internal static extern void SetNextWindowSizeConstraintsNative(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData);

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, customCallbackData);
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, (void*)(default));
		}

		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), (void*)(default));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowContentSize")]
		internal static extern void SetNextWindowContentSizeNative(Vector2 size);

		public static void SetNextWindowContentSize(Vector2 size)
		{
			SetNextWindowContentSizeNative(size);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowCollapsed")]
		internal static extern void SetNextWindowCollapsedNative(byte collapsed, ImGuiCond cond);

		public static void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetNextWindowCollapsed(bool collapsed)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowFocus")]
		internal static extern void SetNextWindowFocusNative();

		public static void SetNextWindowFocus()
		{
			SetNextWindowFocusNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowScroll")]
		internal static extern void SetNextWindowScrollNative(Vector2 scroll);

		public static void SetNextWindowScroll(Vector2 scroll)
		{
			SetNextWindowScrollNative(scroll);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowBgAlpha")]
		internal static extern void SetNextWindowBgAlphaNative(float alpha);

		public static void SetNextWindowBgAlpha(float alpha)
		{
			SetNextWindowBgAlphaNative(alpha);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowViewport")]
		internal static extern void SetNextWindowViewportNative(int viewportId);

		public static void SetNextWindowViewport(int viewportId)
		{
			SetNextWindowViewportNative(viewportId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowPos_Vec2")]
		internal static extern void SetWindowPosNative(Vector2 pos, ImGuiCond cond);

		public static void SetWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(pos, cond);
		}

		public static void SetWindowPos(Vector2 pos)
		{
			SetWindowPosNative(pos, (ImGuiCond)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowSize_Vec2")]
		internal static extern void SetWindowSizeNative(Vector2 size, ImGuiCond cond);

		public static void SetWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(size, cond);
		}

		public static void SetWindowSize(Vector2 size)
		{
			SetWindowSizeNative(size, (ImGuiCond)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowCollapsed_Bool")]
		internal static extern void SetWindowCollapsedNative(byte collapsed, ImGuiCond cond);

		public static void SetWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsed(bool collapsed)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowFocus_Nil")]
		internal static extern void SetWindowFocusNative();

		public static void SetWindowFocus()
		{
			SetWindowFocusNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowFontScale")]
		internal static extern void SetWindowFontScaleNative(float scale);

		public static void SetWindowFontScale(float scale)
		{
			SetWindowFontScaleNative(scale);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowPos_Str")]
		internal static extern void SetWindowPosNative(byte* name, Vector2 pos, ImGuiCond cond);

		public static void SetWindowPos(byte* name, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(name, pos, cond);
		}

		public static void SetWindowPos(byte* name, Vector2 pos)
		{
			SetWindowPosNative(name, pos, (ImGuiCond)(0));
		}

		public static void SetWindowPos(ref byte name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, cond);
			}
		}

		public static void SetWindowPos(ref byte name, Vector2 pos)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		public static void SetWindowPos(string name, Vector2 pos, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowPos(string name, Vector2 pos)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowSize_Str")]
		internal static extern void SetWindowSizeNative(byte* name, Vector2 size, ImGuiCond cond);

		public static void SetWindowSize(byte* name, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(name, size, cond);
		}

		public static void SetWindowSize(byte* name, Vector2 size)
		{
			SetWindowSizeNative(name, size, (ImGuiCond)(0));
		}

		public static void SetWindowSize(ref byte name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, cond);
			}
		}

		public static void SetWindowSize(ref byte name, Vector2 size)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		public static void SetWindowSize(string name, Vector2 size, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowSize(string name, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowCollapsed_Str")]
		internal static extern void SetWindowCollapsedNative(byte* name, byte collapsed, ImGuiCond cond);

		public static void SetWindowCollapsed(byte* name, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsed(byte* name, bool collapsed)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		public static void SetWindowCollapsed(ref byte name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		public static void SetWindowCollapsed(ref byte name, bool collapsed)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		public static void SetWindowCollapsed(string name, bool collapsed, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SetWindowCollapsed(string name, bool collapsed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowFocus_Str")]
		internal static extern void SetWindowFocusNative(byte* name);

		public static void SetWindowFocus(byte* name)
		{
			SetWindowFocusNative(name);
		}

		public static void SetWindowFocus(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SetWindowFocusNative((byte*)pname);
			}
		}

		public static void SetWindowFocus(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowFocusNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetContentRegionAvail")]
		internal static extern void GetContentRegionAvailNative(Vector2* output);

		public static Vector2 GetContentRegionAvail()
		{
			Vector2 ret;
			GetContentRegionAvailNative(&ret);
			return ret;
		}

		public static void GetContentRegionAvail(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionAvailNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetContentRegionMax")]
		internal static extern void GetContentRegionMaxNative(Vector2* output);

		public static Vector2 GetContentRegionMax()
		{
			Vector2 ret;
			GetContentRegionMaxNative(&ret);
			return ret;
		}

		public static void GetContentRegionMax(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionMaxNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowContentRegionMin")]
		internal static extern void GetWindowContentRegionMinNative(Vector2* output);

		public static Vector2 GetWindowContentRegionMin()
		{
			Vector2 ret;
			GetWindowContentRegionMinNative(&ret);
			return ret;
		}

		public static void GetWindowContentRegionMin(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowContentRegionMinNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowContentRegionMax")]
		internal static extern void GetWindowContentRegionMaxNative(Vector2* output);

		public static Vector2 GetWindowContentRegionMax()
		{
			Vector2 ret;
			GetWindowContentRegionMaxNative(&ret);
			return ret;
		}

		public static void GetWindowContentRegionMax(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWindowContentRegionMaxNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetScrollX")]
		internal static extern float GetScrollXNative();

		public static float GetScrollX()
		{
			float ret = GetScrollXNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetScrollY")]
		internal static extern float GetScrollYNative();

		public static float GetScrollY()
		{
			float ret = GetScrollYNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollX_Float")]
		internal static extern void SetScrollXNative(float scrollX);

		public static void SetScrollX(float scrollX)
		{
			SetScrollXNative(scrollX);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollY_Float")]
		internal static extern void SetScrollYNative(float scrollY);

		public static void SetScrollY(float scrollY)
		{
			SetScrollYNative(scrollY);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetScrollMaxX")]
		internal static extern float GetScrollMaxXNative();

		public static float GetScrollMaxX()
		{
			float ret = GetScrollMaxXNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetScrollMaxY")]
		internal static extern float GetScrollMaxYNative();

		public static float GetScrollMaxY()
		{
			float ret = GetScrollMaxYNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollHereX")]
		internal static extern void SetScrollHereXNative(float centerXRatio);

		public static void SetScrollHereX(float centerXRatio)
		{
			SetScrollHereXNative(centerXRatio);
		}

		public static void SetScrollHereX()
		{
			SetScrollHereXNative((float)(0.5f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollHereY")]
		internal static extern void SetScrollHereYNative(float centerYRatio);

		public static void SetScrollHereY(float centerYRatio)
		{
			SetScrollHereYNative(centerYRatio);
		}

		public static void SetScrollHereY()
		{
			SetScrollHereYNative((float)(0.5f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollFromPosX_Float")]
		internal static extern void SetScrollFromPosXNative(float localX, float centerXRatio);

		public static void SetScrollFromPosX(float localX, float centerXRatio)
		{
			SetScrollFromPosXNative(localX, centerXRatio);
		}

		public static void SetScrollFromPosX(float localX)
		{
			SetScrollFromPosXNative(localX, (float)(0.5f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollFromPosY_Float")]
		internal static extern void SetScrollFromPosYNative(float localY, float centerYRatio);

		public static void SetScrollFromPosY(float localY, float centerYRatio)
		{
			SetScrollFromPosYNative(localY, centerYRatio);
		}

		public static void SetScrollFromPosY(float localY)
		{
			SetScrollFromPosYNative(localY, (float)(0.5f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushFont")]
		internal static extern void PushFontNative(ImFont* font);

		public static void PushFont(ImFont* font)
		{
			PushFontNative(font);
		}

		public static void PushFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				PushFontNative((ImFont*)pfont);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopFont")]
		internal static extern void PopFontNative();

		public static void PopFont()
		{
			PopFontNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushStyleColor_U32")]
		internal static extern void PushStyleColorNative(ImGuiCol idx, uint col);

		public static void PushStyleColor(ImGuiCol idx, uint col)
		{
			PushStyleColorNative(idx, col);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushStyleColor_Vec4")]
		internal static extern void PushStyleColorNative(ImGuiCol idx, Vector4 col);

		public static void PushStyleColor(ImGuiCol idx, Vector4 col)
		{
			PushStyleColorNative(idx, col);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopStyleColor")]
		internal static extern void PopStyleColorNative(int count);

		public static void PopStyleColor(int count)
		{
			PopStyleColorNative(count);
		}

		public static void PopStyleColor()
		{
			PopStyleColorNative((int)(1));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushStyleVar_Float")]
		internal static extern void PushStyleVarNative(ImGuiStyleVar idx, float val);

		public static void PushStyleVar(ImGuiStyleVar idx, float val)
		{
			PushStyleVarNative(idx, val);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushStyleVar_Vec2")]
		internal static extern void PushStyleVarNative(ImGuiStyleVar idx, Vector2 val);

		public static void PushStyleVar(ImGuiStyleVar idx, Vector2 val)
		{
			PushStyleVarNative(idx, val);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopStyleVar")]
		internal static extern void PopStyleVarNative(int count);

		public static void PopStyleVar(int count)
		{
			PopStyleVarNative(count);
		}

		public static void PopStyleVar()
		{
			PopStyleVarNative((int)(1));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushTabStop")]
		internal static extern void PushTabStopNative(byte tabStop);

		public static void PushTabStop(bool tabStop)
		{
			PushTabStopNative(tabStop ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopTabStop")]
		internal static extern void PopTabStopNative();

		public static void PopTabStop()
		{
			PopTabStopNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushButtonRepeat")]
		internal static extern void PushButtonRepeatNative(byte repeat);

		public static void PushButtonRepeat(bool repeat)
		{
			PushButtonRepeatNative(repeat ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopButtonRepeat")]
		internal static extern void PopButtonRepeatNative();

		public static void PopButtonRepeat()
		{
			PopButtonRepeatNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushItemWidth")]
		internal static extern void PushItemWidthNative(float itemWidth);

		public static void PushItemWidth(float itemWidth)
		{
			PushItemWidthNative(itemWidth);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopItemWidth")]
		internal static extern void PopItemWidthNative();

		public static void PopItemWidth()
		{
			PopItemWidthNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextItemWidth")]
		internal static extern void SetNextItemWidthNative(float itemWidth);

		public static void SetNextItemWidth(float itemWidth)
		{
			SetNextItemWidthNative(itemWidth);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcItemWidth")]
		internal static extern float CalcItemWidthNative();

		public static float CalcItemWidth()
		{
			float ret = CalcItemWidthNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushTextWrapPos")]
		internal static extern void PushTextWrapPosNative(float wrapLocalPosX);

		public static void PushTextWrapPos(float wrapLocalPosX)
		{
			PushTextWrapPosNative(wrapLocalPosX);
		}

		public static void PushTextWrapPos()
		{
			PushTextWrapPosNative((float)(0.0f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopTextWrapPos")]
		internal static extern void PopTextWrapPosNative();

		public static void PopTextWrapPos()
		{
			PopTextWrapPosNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFont")]
		internal static extern ImFont* GetFontNative();

		public static ImFontPtr GetFont()
		{
			ImFontPtr ret = GetFontNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFontSize")]
		internal static extern float GetFontSizeNative();

		public static float GetFontSize()
		{
			float ret = GetFontSizeNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFontTexUvWhitePixel")]
		internal static extern void GetFontTexUvWhitePixelNative(Vector2* output);

		public static Vector2 GetFontTexUvWhitePixel()
		{
			Vector2 ret;
			GetFontTexUvWhitePixelNative(&ret);
			return ret;
		}

		public static void GetFontTexUvWhitePixel(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetFontTexUvWhitePixelNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColorU32_Col")]
		internal static extern uint GetColorU32Native(ImGuiCol idx, float alphaMul);

		public static uint GetColorU32(ImGuiCol idx, float alphaMul)
		{
			uint ret = GetColorU32Native(idx, alphaMul);
			return ret;
		}

		public static uint GetColorU32(ImGuiCol idx)
		{
			uint ret = GetColorU32Native(idx, (float)(1.0f));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColorU32_Vec4")]
		internal static extern uint GetColorU32Native(Vector4 col);

		public static uint GetColorU32(Vector4 col)
		{
			uint ret = GetColorU32Native(col);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColorU32_U32")]
		internal static extern uint GetColorU32Native(uint col);

		public static uint GetColorU32(uint col)
		{
			uint ret = GetColorU32Native(col);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStyleColorVec4")]
		internal static extern Vector4* GetStyleColorVec4Native(ImGuiCol idx);

		public static Vector4* GetStyleColorVec4(ImGuiCol idx)
		{
			Vector4* ret = GetStyleColorVec4Native(idx);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSeparator")]
		internal static extern void SeparatorNative();

		public static void Separator()
		{
			SeparatorNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSameLine")]
		internal static extern void SameLineNative(float offsetFromStartX, float spacing);

		public static void SameLine(float offsetFromStartX, float spacing)
		{
			SameLineNative(offsetFromStartX, spacing);
		}

		public static void SameLine(float offsetFromStartX)
		{
			SameLineNative(offsetFromStartX, (float)(-1.0f));
		}

		public static void SameLine()
		{
			SameLineNative((float)(0.0f), (float)(-1.0f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNewLine")]
		internal static extern void NewLineNative();

		public static void NewLine()
		{
			NewLineNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSpacing")]
		internal static extern void SpacingNative();

		public static void Spacing()
		{
			SpacingNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDummy")]
		internal static extern void DummyNative(Vector2 size);

		public static void Dummy(Vector2 size)
		{
			DummyNative(size);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIndent")]
		internal static extern void IndentNative(float indentW);

		public static void Indent(float indentW)
		{
			IndentNative(indentW);
		}

		public static void Indent()
		{
			IndentNative((float)(0.0f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUnindent")]
		internal static extern void UnindentNative(float indentW);

		public static void Unindent(float indentW)
		{
			UnindentNative(indentW);
		}

		public static void Unindent()
		{
			UnindentNative((float)(0.0f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginGroup")]
		internal static extern void BeginGroupNative();

		public static void BeginGroup()
		{
			BeginGroupNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndGroup")]
		internal static extern void EndGroupNative();

		public static void EndGroup()
		{
			EndGroupNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorPos")]
		internal static extern void GetCursorPosNative(Vector2* output);

		public static Vector2 GetCursorPos()
		{
			Vector2 ret;
			GetCursorPosNative(&ret);
			return ret;
		}

		public static void GetCursorPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorPosNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorPosX")]
		internal static extern float GetCursorPosXNative();

		public static float GetCursorPosX()
		{
			float ret = GetCursorPosXNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorPosY")]
		internal static extern float GetCursorPosYNative();

		public static float GetCursorPosY()
		{
			float ret = GetCursorPosYNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCursorPos")]
		internal static extern void SetCursorPosNative(Vector2 localPos);

		public static void SetCursorPos(Vector2 localPos)
		{
			SetCursorPosNative(localPos);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCursorPosX")]
		internal static extern void SetCursorPosXNative(float localX);

		public static void SetCursorPosX(float localX)
		{
			SetCursorPosXNative(localX);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCursorPosY")]
		internal static extern void SetCursorPosYNative(float localY);

		public static void SetCursorPosY(float localY)
		{
			SetCursorPosYNative(localY);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorStartPos")]
		internal static extern void GetCursorStartPosNative(Vector2* output);

		public static Vector2 GetCursorStartPos()
		{
			Vector2 ret;
			GetCursorStartPosNative(&ret);
			return ret;
		}

		public static void GetCursorStartPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorStartPosNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCursorScreenPos")]
		internal static extern void GetCursorScreenPosNative(Vector2* output);

		public static Vector2 GetCursorScreenPos()
		{
			Vector2 ret;
			GetCursorScreenPosNative(&ret);
			return ret;
		}

		public static void GetCursorScreenPos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCursorScreenPosNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCursorScreenPos")]
		internal static extern void SetCursorScreenPosNative(Vector2 pos);

		public static void SetCursorScreenPos(Vector2 pos)
		{
			SetCursorScreenPosNative(pos);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igAlignTextToFramePadding")]
		internal static extern void AlignTextToFramePaddingNative();

		public static void AlignTextToFramePadding()
		{
			AlignTextToFramePaddingNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTextLineHeight")]
		internal static extern float GetTextLineHeightNative();

		public static float GetTextLineHeight()
		{
			float ret = GetTextLineHeightNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTextLineHeightWithSpacing")]
		internal static extern float GetTextLineHeightWithSpacingNative();

		public static float GetTextLineHeightWithSpacing()
		{
			float ret = GetTextLineHeightWithSpacingNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFrameHeight")]
		internal static extern float GetFrameHeightNative();

		public static float GetFrameHeight()
		{
			float ret = GetFrameHeightNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFrameHeightWithSpacing")]
		internal static extern float GetFrameHeightWithSpacingNative();

		public static float GetFrameHeightWithSpacing()
		{
			float ret = GetFrameHeightWithSpacingNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushID_Str")]
		internal static extern void PushIDNative(byte* strId);

		public static void PushID(byte* strId)
		{
			PushIDNative(strId);
		}

		public static void PushID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		public static void PushID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushID_StrStr")]
		internal static extern void PushIDNative(byte* strIdBegin, byte* strIdEnd);

		public static void PushID(byte* strIdBegin, byte* strIdEnd)
		{
			PushIDNative(strIdBegin, strIdEnd);
		}

		public static void PushID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		public static void PushID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		public static void PushID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		public static void PushID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PushIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushID_Ptr")]
		internal static extern void PushIDNative(void* ptrId);

		public static void PushID(void* ptrId)
		{
			PushIDNative(ptrId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushID_Int")]
		internal static extern void PushIDNative(int intId);

		public static void PushID(int intId)
		{
			PushIDNative(intId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopID")]
		internal static extern void PopIDNative();

		public static void PopID()
		{
			PopIDNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetID_Str")]
		internal static extern int GetIDNative(byte* strId);

		public static int GetID(byte* strId)
		{
			int ret = GetIDNative(strId);
			return ret;
		}

		public static int GetID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				int ret = GetIDNative((byte*)pstrId);
				return ret;
			}
		}

		public static int GetID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetID_StrStr")]
		internal static extern int GetIDNative(byte* strIdBegin, byte* strIdEnd);

		public static int GetID(byte* strIdBegin, byte* strIdEnd)
		{
			int ret = GetIDNative(strIdBegin, strIdEnd);
			return ret;
		}

		public static int GetID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				int ret = GetIDNative((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		public static int GetID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				int ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		public static int GetID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					int ret = GetIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
					return ret;
				}
			}
		}

		public static int GetID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = GetIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetID_Ptr")]
		internal static extern int GetIDNative(void* ptrId);

		public static int GetID(void* ptrId)
		{
			int ret = GetIDNative(ptrId);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextUnformatted")]
		internal static extern void TextUnformattedNative(byte* text, byte* textEnd);

		public static void TextUnformatted(byte* text, byte* textEnd)
		{
			TextUnformattedNative(text, textEnd);
		}

		public static void TextUnformatted(byte* text)
		{
			TextUnformattedNative(text, (byte*)(default));
		}

		public static void TextUnformatted(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				TextUnformattedNative((byte*)ptext, textEnd);
			}
		}

		public static void TextUnformatted(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				TextUnformattedNative((byte*)ptext, (byte*)(default));
			}
		}

		public static void TextUnformatted(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				TextUnformattedNative(text, (byte*)ptextEnd);
			}
		}

		public static void TextUnformatted(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextUnformatted(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					TextUnformattedNative((byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void TextUnformatted(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			TextUnformattedNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igText")]
		internal static extern void TextNative(byte* fmt);

		public static void Text(byte* fmt)
		{
			TextNative(fmt);
		}

		public static void Text(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextNative((byte*)pfmt);
			}
		}

		public static void Text(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextV")]
		internal static extern void TextVNative(byte* fmt, nuint args);

		public static void TextV(byte* fmt, nuint args)
		{
			TextVNative(fmt, args);
		}

		public static void TextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextVNative((byte*)pfmt, args);
			}
		}

		public static void TextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextColored")]
		internal static extern void TextColoredNative(Vector4 col, byte* fmt);

		public static void TextColored(Vector4 col, byte* fmt)
		{
			TextColoredNative(col, fmt);
		}

		public static void TextColored(Vector4 col, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredNative(col, (byte*)pfmt);
			}
		}

		public static void TextColored(Vector4 col, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredNative(col, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextColoredV")]
		internal static extern void TextColoredVNative(Vector4 col, byte* fmt, nuint args);

		public static void TextColoredV(Vector4 col, byte* fmt, nuint args)
		{
			TextColoredVNative(col, fmt, args);
		}

		public static void TextColoredV(Vector4 col, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredVNative(col, (byte*)pfmt, args);
			}
		}

		public static void TextColoredV(Vector4 col, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredVNative(col, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextDisabled")]
		internal static extern void TextDisabledNative(byte* fmt);

		public static void TextDisabled(byte* fmt)
		{
			TextDisabledNative(fmt);
		}

		public static void TextDisabled(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextDisabledNative((byte*)pfmt);
			}
		}

		public static void TextDisabled(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextDisabledNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextDisabledV")]
		internal static extern void TextDisabledVNative(byte* fmt, nuint args);

		public static void TextDisabledV(byte* fmt, nuint args)
		{
			TextDisabledVNative(fmt, args);
		}

		public static void TextDisabledV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextDisabledVNative((byte*)pfmt, args);
			}
		}

		public static void TextDisabledV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextDisabledVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextWrapped")]
		internal static extern void TextWrappedNative(byte* fmt);

		public static void TextWrapped(byte* fmt)
		{
			TextWrappedNative(fmt);
		}

		public static void TextWrapped(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextWrappedNative((byte*)pfmt);
			}
		}

		public static void TextWrapped(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextWrappedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextWrappedV")]
		internal static extern void TextWrappedVNative(byte* fmt, nuint args);

		public static void TextWrappedV(byte* fmt, nuint args)
		{
			TextWrappedVNative(fmt, args);
		}

		public static void TextWrappedV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextWrappedVNative((byte*)pfmt, args);
			}
		}

		public static void TextWrappedV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextWrappedVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLabelText")]
		internal static extern void LabelTextNative(byte* label, byte* fmt);

		public static void LabelText(byte* label, byte* fmt)
		{
			LabelTextNative(label, fmt);
		}

		public static void LabelText(ref byte label, byte* fmt)
		{
			fixed (byte* plabel = &label)
			{
				LabelTextNative((byte*)plabel, fmt);
			}
		}

		public static void LabelText(string label, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextNative(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(byte* label, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextNative(label, (byte*)pfmt);
			}
		}

		public static void LabelText(byte* label, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextNative(label, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelText(ref byte label, ref byte fmt)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pfmt = &fmt)
				{
					LabelTextNative((byte*)plabel, (byte*)pfmt);
				}
			}
		}

		public static void LabelText(string label, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LabelTextNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLabelTextV")]
		internal static extern void LabelTextVNative(byte* label, byte* fmt, nuint args);

		public static void LabelTextV(byte* label, byte* fmt, nuint args)
		{
			LabelTextVNative(label, fmt, args);
		}

		public static void LabelTextV(ref byte label, byte* fmt, nuint args)
		{
			fixed (byte* plabel = &label)
			{
				LabelTextVNative((byte*)plabel, fmt, args);
			}
		}

		public static void LabelTextV(string label, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextVNative(pStr0, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(byte* label, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextVNative(label, (byte*)pfmt, args);
			}
		}

		public static void LabelTextV(byte* label, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextVNative(label, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelTextV(ref byte label, ref byte fmt, nuint args)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pfmt = &fmt)
				{
					LabelTextVNative((byte*)plabel, (byte*)pfmt, args);
				}
			}
		}

		public static void LabelTextV(string label, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LabelTextVNative(pStr0, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBulletText")]
		internal static extern void BulletTextNative(byte* fmt);

		public static void BulletText(byte* fmt)
		{
			BulletTextNative(fmt);
		}

		public static void BulletText(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				BulletTextNative((byte*)pfmt);
			}
		}

		public static void BulletText(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BulletTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBulletTextV")]
		internal static extern void BulletTextVNative(byte* fmt, nuint args);

		public static void BulletTextV(byte* fmt, nuint args)
		{
			BulletTextVNative(fmt, args);
		}

		public static void BulletTextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				BulletTextVNative((byte*)pfmt, args);
			}
		}

		public static void BulletTextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BulletTextVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSeparatorText")]
		internal static extern void SeparatorTextNative(byte* label);

		public static void SeparatorText(byte* label)
		{
			SeparatorTextNative(label);
		}

		public static void SeparatorText(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				SeparatorTextNative((byte*)plabel);
			}
		}

		public static void SeparatorText(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SeparatorTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igButton")]
		internal static extern byte ButtonNative(byte* label, Vector2 size);

		public static bool Button(byte* label, Vector2 size)
		{
			byte ret = ButtonNative(label, size);
			return ret != 0;
		}

		public static bool Button(byte* label)
		{
			byte ret = ButtonNative(label, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Button(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ButtonNative((byte*)plabel, size);
				return ret != 0;
			}
		}

		public static bool Button(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ButtonNative((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Button(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ButtonNative(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Button(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ButtonNative(pStr0, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSmallButton")]
		internal static extern byte SmallButtonNative(byte* label);

		public static bool SmallButton(byte* label)
		{
			byte ret = SmallButtonNative(label);
			return ret != 0;
		}

		public static bool SmallButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SmallButtonNative((byte*)plabel);
				return ret != 0;
			}
		}

		public static bool SmallButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SmallButtonNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInvisibleButton")]
		internal static extern byte InvisibleButtonNative(byte* strId, Vector2 size, ImGuiButtonFlags flags);

		public static bool InvisibleButton(byte* strId, Vector2 size, ImGuiButtonFlags flags)
		{
			byte ret = InvisibleButtonNative(strId, size, flags);
			return ret != 0;
		}

		public static bool InvisibleButton(byte* strId, Vector2 size)
		{
			byte ret = InvisibleButtonNative(strId, size, (ImGuiButtonFlags)(0));
			return ret != 0;
		}

		public static bool InvisibleButton(ref byte strId, Vector2 size, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = InvisibleButtonNative((byte*)pstrId, size, flags);
				return ret != 0;
			}
		}

		public static bool InvisibleButton(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = InvisibleButtonNative((byte*)pstrId, size, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}

		public static bool InvisibleButton(string strId, Vector2 size, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InvisibleButtonNative(pStr0, size, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InvisibleButton(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InvisibleButtonNative(pStr0, size, (ImGuiButtonFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igArrowButton")]
		internal static extern byte ArrowButtonNative(byte* strId, ImGuiDir dir);

		public static bool ArrowButton(byte* strId, ImGuiDir dir)
		{
			byte ret = ArrowButtonNative(strId, dir);
			return ret != 0;
		}

		public static bool ArrowButton(ref byte strId, ImGuiDir dir)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ArrowButtonNative((byte*)pstrId, dir);
				return ret != 0;
			}
		}

		public static bool ArrowButton(string strId, ImGuiDir dir)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ArrowButtonNative(pStr0, dir);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckbox")]
		internal static extern byte CheckboxNative(byte* label, bool* v);

		public static bool Checkbox(byte* label, bool* v)
		{
			byte ret = CheckboxNative(label, v);
			return ret != 0;
		}

		public static bool Checkbox(ref byte label, bool* v)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CheckboxNative((byte*)plabel, v);
				return ret != 0;
			}
		}

		public static bool Checkbox(string label, bool* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CheckboxNative(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Checkbox(byte* label, ref bool v)
		{
			fixed (bool* pv = &v)
			{
				byte ret = CheckboxNative(label, (bool*)pv);
				return ret != 0;
			}
		}

		public static bool Checkbox(ref byte label, ref bool v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* pv = &v)
				{
					byte ret = CheckboxNative((byte*)plabel, (bool*)pv);
					return ret != 0;
				}
			}
		}

		public static bool Checkbox(string label, ref bool v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* pv = &v)
			{
				byte ret = CheckboxNative(pStr0, (bool*)pv);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckboxFlags_IntPtr")]
		internal static extern byte CheckboxFlagsNative(byte* label, int* flags, int flagsValue);

		public static bool CheckboxFlags(byte* label, int* flags, int flagsValue)
		{
			byte ret = CheckboxFlagsNative(label, flags, flagsValue);
			return ret != 0;
		}

		public static bool CheckboxFlags(ref byte label, int* flags, int flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CheckboxFlagsNative((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlags(string label, int* flags, int flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CheckboxFlagsNative(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CheckboxFlags(byte* label, ref int flags, int flagsValue)
		{
			fixed (int* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(label, (int*)pflags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlags(ref byte label, ref int flags, int flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pflags = &flags)
				{
					byte ret = CheckboxFlagsNative((byte*)plabel, (int*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}

		public static bool CheckboxFlags(string label, ref int flags, int flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(pStr0, (int*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckboxFlags_UintPtr")]
		internal static extern byte CheckboxFlagsNative(byte* label, uint* flags, uint flagsValue);

		public static bool CheckboxFlags(byte* label, uint* flags, uint flagsValue)
		{
			byte ret = CheckboxFlagsNative(label, flags, flagsValue);
			return ret != 0;
		}

		public static bool CheckboxFlags(ref byte label, uint* flags, uint flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CheckboxFlagsNative((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlags(string label, uint* flags, uint flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CheckboxFlagsNative(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CheckboxFlags(byte* label, ref uint flags, uint flagsValue)
		{
			fixed (uint* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(label, (uint*)pflags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlags(ref byte label, ref uint flags, uint flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (uint* pflags = &flags)
				{
					byte ret = CheckboxFlagsNative((byte*)plabel, (uint*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}

		public static bool CheckboxFlags(string label, ref uint flags, uint flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(pStr0, (uint*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRadioButton_Bool")]
		internal static extern byte RadioButtonNative(byte* label, byte active);

		public static bool RadioButton(byte* label, bool active)
		{
			byte ret = RadioButtonNative(label, active ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool RadioButton(ref byte label, bool active)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = RadioButtonNative((byte*)plabel, active ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool RadioButton(string label, bool active)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RadioButtonNative(pStr0, active ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRadioButton_IntPtr")]
		internal static extern byte RadioButtonNative(byte* label, int* v, int vButton);

		public static bool RadioButton(byte* label, int* v, int vButton)
		{
			byte ret = RadioButtonNative(label, v, vButton);
			return ret != 0;
		}

		public static bool RadioButton(ref byte label, int* v, int vButton)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = RadioButtonNative((byte*)plabel, v, vButton);
				return ret != 0;
			}
		}

		public static bool RadioButton(string label, int* v, int vButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RadioButtonNative(pStr0, v, vButton);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool RadioButton(byte* label, ref int v, int vButton)
		{
			fixed (int* pv = &v)
			{
				byte ret = RadioButtonNative(label, (int*)pv, vButton);
				return ret != 0;
			}
		}

		public static bool RadioButton(ref byte label, ref int v, int vButton)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = RadioButtonNative((byte*)plabel, (int*)pv, vButton);
					return ret != 0;
				}
			}
		}

		public static bool RadioButton(string label, ref int v, int vButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = RadioButtonNative(pStr0, (int*)pv, vButton);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igProgressBar")]
		internal static extern void ProgressBarNative(float fraction, Vector2 sizeArg, byte* overlay);

		public static void ProgressBar(float fraction, Vector2 sizeArg, byte* overlay)
		{
			ProgressBarNative(fraction, sizeArg, overlay);
		}

		public static void ProgressBar(float fraction, Vector2 sizeArg)
		{
			ProgressBarNative(fraction, sizeArg, (byte*)(default));
		}

		public static void ProgressBar(float fraction)
		{
			ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), (byte*)(default));
		}

		public static void ProgressBar(float fraction, Vector2 sizeArg, ref byte overlay)
		{
			fixed (byte* poverlay = &overlay)
			{
				ProgressBarNative(fraction, sizeArg, (byte*)poverlay);
			}
		}

		public static void ProgressBar(float fraction, Vector2 sizeArg, string overlay)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlay != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlay);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlay, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgressBarNative(fraction, sizeArg, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBullet")]
		internal static extern void BulletNative();

		public static void Bullet()
		{
			BulletNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImage")]
		internal static extern void ImageNative(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 tintCol, Vector4 borderCol);

		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 tintCol, Vector4 borderCol)
		{
			ImageNative(userTextureId, size, uv0, uv1, tintCol, borderCol);
		}

		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 tintCol)
		{
			ImageNative(userTextureId, size, uv0, uv1, tintCol, (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1)
		{
			ImageNative(userTextureId, size, uv0, uv1, (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0)
		{
			ImageNative(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}

		public static void Image(ImTextureID userTextureId, Vector2 size)
		{
			ImageNative(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImageButton")]
		internal static extern byte ImageButtonNative(byte* strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol);

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, size, uv0, uv1, bgCol, tintCol);
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, size, uv0, uv1, bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1)
		{
			byte ret = ImageButtonNative(strId, userTextureId, size, uv0, uv1, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0)
		{
			byte ret = ImageButtonNative(strId, userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(byte* strId, ImTextureID userTextureId, Vector2 size)
		{
			byte ret = ImageButtonNative(strId, userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, size, uv0, uv1, bgCol, tintCol);
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, size, uv0, uv1, bgCol, (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, size, uv0, uv1, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(ref byte strId, ImTextureID userTextureId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImageButtonNative((byte*)pstrId, userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
				return ret != 0;
			}
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, size, uv0, uv1, bgCol, tintCol);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, size, uv0, uv1, bgCol, (Vector4)(new Vector4(1,1,1,1)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, size, uv0, uv1, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size, Vector2 uv0)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ImageButton(string strId, ImTextureID userTextureId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImageButtonNative(pStr0, userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginCombo")]
		internal static extern byte BeginComboNative(byte* label, byte* previewValue, ImGuiComboFlags flags);

		public static bool BeginCombo(byte* label, byte* previewValue, ImGuiComboFlags flags)
		{
			byte ret = BeginComboNative(label, previewValue, flags);
			return ret != 0;
		}

		public static bool BeginCombo(byte* label, byte* previewValue)
		{
			byte ret = BeginComboNative(label, previewValue, (ImGuiComboFlags)(0));
			return ret != 0;
		}

		public static bool BeginCombo(ref byte label, byte* previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginComboNative((byte*)plabel, previewValue, flags);
				return ret != 0;
			}
		}

		public static bool BeginCombo(ref byte label, byte* previewValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginComboNative((byte*)plabel, previewValue, (ImGuiComboFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginCombo(string label, byte* previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginComboNative(pStr0, previewValue, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginCombo(string label, byte* previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginComboNative(pStr0, previewValue, (ImGuiComboFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginCombo(byte* label, ref byte previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* ppreviewValue = &previewValue)
			{
				byte ret = BeginComboNative(label, (byte*)ppreviewValue, flags);
				return ret != 0;
			}
		}

		public static bool BeginCombo(byte* label, ref byte previewValue)
		{
			fixed (byte* ppreviewValue = &previewValue)
			{
				byte ret = BeginComboNative(label, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginCombo(byte* label, string previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (previewValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginComboNative(label, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginCombo(byte* label, string previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (previewValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginComboNative(label, pStr0, (ImGuiComboFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginCombo(ref byte label, ref byte previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* ppreviewValue = &previewValue)
				{
					byte ret = BeginComboNative((byte*)plabel, (byte*)ppreviewValue, flags);
					return ret != 0;
				}
			}
		}

		public static bool BeginCombo(ref byte label, ref byte previewValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* ppreviewValue = &previewValue)
				{
					byte ret = BeginComboNative((byte*)plabel, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool BeginCombo(string label, string previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (previewValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(previewValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = BeginComboNative(pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginCombo(string label, string previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (previewValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(previewValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = BeginComboNative(pStr0, pStr1, (ImGuiComboFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndCombo")]
		internal static extern void EndComboNative();

		public static void EndCombo()
		{
			EndComboNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCombo_Str_arr")]
		internal static extern byte ComboNative(byte* label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems);

		public static bool Combo(byte* label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			byte ret = ComboNative(label, currentItem, items, itemsCount, popupMaxHeightInItems);
			return ret != 0;
		}

		public static bool Combo(byte* label, int* currentItem, byte** items, int itemsCount)
		{
			byte ret = ComboNative(label, currentItem, items, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool Combo(ref byte label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ComboNative((byte*)plabel, currentItem, items, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo(ref byte label, int* currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ComboNative((byte*)plabel, currentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo(string label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(pStr0, currentItem, items, itemsCount, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(string label, int* currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(pStr0, currentItem, items, itemsCount, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(byte* label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ComboNative((byte*)plabel, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ComboNative((byte*)plabel, (int*)pcurrentItem, items, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}

		public static bool Combo(string label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(string label, ref int currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, int* currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			byte ret = ComboNative(label, currentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}

		public static bool Combo(byte* label, int* currentItem, string[] items, int itemsCount)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			byte ret = ComboNative(label, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}

		public static bool Combo(string label, int* currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			byte ret = ComboNative(pStr0, currentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(string label, int* currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			byte ret = ComboNative(pStr0, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(byte* label, ref int currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				byte ret = ComboNative(label, (int*)pcurrentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, string[] items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				byte ret = ComboNative(label, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(string label, ref int currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(string label, ref int currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCombo_Str")]
		internal static extern byte ComboNative(byte* label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems);

		public static bool Combo(byte* label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte ret = ComboNative(label, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
			return ret != 0;
		}

		public static bool Combo(byte* label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			byte ret = ComboNative(label, currentItem, itemsSeparatedByZeros, (int)(-1));
			return ret != 0;
		}

		public static bool Combo(ref byte label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ComboNative((byte*)plabel, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo(ref byte label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ComboNative((byte*)plabel, currentItem, itemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo(string label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(pStr0, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(string label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(pStr0, currentItem, itemsSeparatedByZeros, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(byte* label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, itemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ComboNative((byte*)plabel, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ComboNative((byte*)plabel, (int*)pcurrentItem, itemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}

		public static bool Combo(string label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(string label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, itemsSeparatedByZeros, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, int* currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				byte ret = ComboNative(label, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, int* currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				byte ret = ComboNative(label, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, int* currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(label, currentItem, pStr0, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(byte* label, int* currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(label, currentItem, pStr0, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(ref byte label, int* currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ComboNative((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}

		public static bool Combo(ref byte label, int* currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ComboNative((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}

		public static bool Combo(string label, int* currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ComboNative(pStr0, currentItem, pStr1, popupMaxHeightInItems);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(string label, int* currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ComboNative(pStr0, currentItem, pStr1, (int)(-1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(byte* label, ref int currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ComboNative(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}

		public static bool Combo(byte* label, ref int currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ComboNative(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}

		public static bool Combo(byte* label, ref int currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ComboNative(label, (int*)pcurrentItem, pStr0, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, string itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ComboNative(label, (int*)pcurrentItem, pStr0, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
					{
						byte ret = ComboNative((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
						return ret != 0;
					}
				}
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
					{
						byte ret = ComboNative((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
						return ret != 0;
					}
				}
			}
		}

		public static bool Combo(string label, ref int currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, pStr1, popupMaxHeightInItems);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(string label, ref int currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, pStr1, (int)(-1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCombo_FnBoolPtr")]
		internal static extern byte ComboNative(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems);

		public static bool Combo(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			byte ret = ComboNative(label, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
			return ret != 0;
		}

		public static bool Combo(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte ret = ComboNative(label, currentItem, itemsGetter, data, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool Combo(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ComboNative((byte*)plabel, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ComboNative((byte*)plabel, currentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(pStr0, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(pStr0, currentItem, itemsGetter, data, itemsCount, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ComboNative((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}

		public static bool Combo(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ComboNative((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}

		public static bool Combo(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloat")]
		internal static extern byte DragFloatNative(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloat(label, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin)
		{
			bool ret = DragFloat(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed)
		{
			bool ret = DragFloat(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat(byte* label, float* v)
		{
			bool ret = DragFloat(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloatNative((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloatNative((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat((byte*)plabel, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat(pStr0, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = DragFloatNative((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = DragFloatNative((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat((byte*)plabel, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(pStr0, (float*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(pStr0, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(string label, ref float v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(pStr0, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat(byte* label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatNative(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat(string label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatNative(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat(byte* label, ref float v, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatNative((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloat(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatNative((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatNative(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat(string label, ref float v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatNative(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloat2")]
		internal static extern byte DragFloat2Native(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloat2(label, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin)
		{
			bool ret = DragFloat2(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed)
		{
			bool ret = DragFloat2(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat2(byte* label, float* v)
		{
			bool ret = DragFloat2(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloat2Native((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloat2Native((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat2((byte*)plabel, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat2(pStr0, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = DragFloat2Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = DragFloat2Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat2((byte*)plabel, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(pStr0, (float*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(pStr0, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(pStr0, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2(byte* label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloat2Native(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2(string label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloat2Native(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2(byte* label, ref Vector2 v, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloat2Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloat2(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloat2Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloat2Native(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2(string label, ref Vector2 v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloat2Native(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloat3")]
		internal static extern byte DragFloat3Native(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragFloat3Native(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte ret = DragFloat3Native(label, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloat3(label, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin)
		{
			bool ret = DragFloat3(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed)
		{
			bool ret = DragFloat3(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat3(byte* label, float* v)
		{
			bool ret = DragFloat3(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloat3Native((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloat3Native((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat3((byte*)plabel, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat3Native(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat3Native(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat3(pStr0, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat3Native(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat3Native(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte ret = DragFloat3Native(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (Vector3* pv = &v)
			{
				byte ret = DragFloat3Native(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = DragFloat3Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = DragFloat3Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat3((byte*)plabel, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte ret = DragFloat3Native(pStr0, (float*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte ret = DragFloat3Native(pStr0, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = DragFloat3(pStr0, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat3Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat3Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat3Native(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat3(byte* label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat3Native(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat3Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat3(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat3Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloat3Native(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat3(string label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloat3Native(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat3Native(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat3(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat3Native(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat3Native(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat3(byte* label, ref Vector3 v, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat3Native(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloat3Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloat3(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloat3Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloat3Native(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat3(string label, ref Vector3 v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloat3Native(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloat4")]
		internal static extern byte DragFloat4Native(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragFloat4Native(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte ret = DragFloat4Native(label, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloat4(label, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin)
		{
			bool ret = DragFloat4(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed)
		{
			bool ret = DragFloat4(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat4(byte* label, float* v)
		{
			bool ret = DragFloat4(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloat4Native((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloat4Native((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloat4((byte*)plabel, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat4Native(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat4Native(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloat4(pStr0, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat4Native(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat4Native(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte ret = DragFloat4Native(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (Vector4* pv = &v)
			{
				byte ret = DragFloat4Native(label, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = DragFloat4Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = DragFloat4Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = DragFloat4((byte*)plabel, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte ret = DragFloat4Native(pStr0, (float*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte ret = DragFloat4Native(pStr0, (float*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = DragFloat4(pStr0, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat4Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat4Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat4Native(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat4(byte* label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat4Native(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat4Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat4(ref byte label, float* v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat4Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloat4Native(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat4(string label, float* v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloat4Native(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat4Native(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat4(byte* label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat4Native(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat4Native(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat4(byte* label, ref Vector4 v, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat4Native(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloat4Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloat4(ref byte label, ref float v, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloat4Native((byte*)plabel, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloat4Native(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat4(string label, ref Vector4 v, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloat4Native(pStr0, (float*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragFloatRange2")]
		internal static extern byte DragFloatRange2Native(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags);

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax)
		{
			bool ret = DragFloatRange2(label, vCurrentMin, vCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, vCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragFloatRange2(pStr0, vCurrentMin, vCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(label, (float*)pvCurrentMin, vCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, vCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(label, vCurrentMin, (float*)pvCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragFloatRange2(pStr0, vCurrentMin, (float*)pvCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(label, (float*)pvCurrentMin, (float*)pvCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragFloatRange2((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragFloatRange2(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformatMax = &formatMax)
			{
				byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* pformatMax = &formatMax)
			{
				byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (formatMax != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (formatMax != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (formatMax != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (formatMax != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragFloatRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (formatMax != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (formatMax != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = DragFloatRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, float* vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragFloatRange2Native(label, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragFloatRange2Native((byte*)plabel, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(string label, float* vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte ret = DragFloatRange2Native(pStr0, vCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(byte* label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragFloatRange2Native(label, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							fixed (byte* pformatMax = &formatMax)
							{
								byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(ref byte label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvCurrentMin = &vCurrentMin)
				{
					fixed (float* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							fixed (byte* pformatMax = &formatMax)
							{
								byte ret = DragFloatRange2Native((byte*)plabel, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
								return ret != 0;
							}
						}
					}
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (formatMax != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragFloatRange2(string label, ref float vCurrentMin, ref float vCurrentMax, float vSpeed, float vMin, float vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvCurrentMin = &vCurrentMin)
			{
				fixed (float* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (formatMax != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					byte ret = DragFloatRange2Native(pStr0, (float*)pvCurrentMin, (float*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragInt")]
		internal static extern byte DragIntNative(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragIntNative(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte ret = DragIntNative(label, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragInt(label, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin)
		{
			bool ret = DragInt(label, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed)
		{
			bool ret = DragInt(label, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt(byte* label, int* v)
		{
			bool ret = DragInt(label, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragIntNative((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragIntNative((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt((byte*)plabel, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntNative(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntNative(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt(pStr0, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = DragIntNative(label, (int*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = DragIntNative(label, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt(label, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = DragIntNative((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = DragIntNative((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt((byte*)plabel, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = DragIntNative(pStr0, (int*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = DragIntNative(pStr0, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt(pStr0, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragIntNative(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragIntNative(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntNative(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt(byte* label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntNative(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntNative((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntNative((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntNative(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt(string label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntNative(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntNative(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntNative(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntNative(label, (int*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntNative(label, (int*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntNative((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragInt(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntNative((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntNative(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt(string label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntNative(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragInt2")]
		internal static extern byte DragInt2Native(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragInt2Native(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte ret = DragInt2Native(label, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragInt2(label, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin)
		{
			bool ret = DragInt2(label, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed)
		{
			bool ret = DragInt2(label, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt2(byte* label, int* v)
		{
			bool ret = DragInt2(label, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragInt2Native((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragInt2Native((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt2((byte*)plabel, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt2Native(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt2Native(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt2(pStr0, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = DragInt2Native(label, (int*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = DragInt2Native(label, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(label, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = DragInt2Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = DragInt2Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt2((byte*)plabel, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = DragInt2Native(pStr0, (int*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = DragInt2Native(pStr0, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt2(pStr0, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragInt2Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragInt2Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt2Native(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt2(byte* label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt2Native(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt2Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt2(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt2Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragInt2Native(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt2(string label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragInt2Native(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt2Native(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt2Native(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragInt2Native(label, (int*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt2(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragInt2Native(label, (int*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragInt2Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragInt2(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragInt2Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragInt2Native(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt2(string label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragInt2Native(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragInt3")]
		internal static extern byte DragInt3Native(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragInt3Native(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte ret = DragInt3Native(label, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragInt3(label, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin)
		{
			bool ret = DragInt3(label, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed)
		{
			bool ret = DragInt3(label, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt3(byte* label, int* v)
		{
			bool ret = DragInt3(label, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragInt3Native((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragInt3Native((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt3((byte*)plabel, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt3Native(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt3Native(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt3(pStr0, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = DragInt3Native(label, (int*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = DragInt3Native(label, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(label, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = DragInt3Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = DragInt3Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt3((byte*)plabel, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = DragInt3Native(pStr0, (int*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = DragInt3Native(pStr0, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt3(pStr0, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragInt3Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragInt3Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt3Native(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt3(byte* label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt3Native(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt3Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt3(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt3Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragInt3Native(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt3(string label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragInt3Native(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt3Native(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt3Native(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragInt3Native(label, (int*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt3(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragInt3Native(label, (int*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragInt3Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragInt3(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragInt3Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragInt3Native(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt3(string label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragInt3Native(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragInt4")]
		internal static extern byte DragInt4Native(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragInt4Native(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte ret = DragInt4Native(label, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragInt4(label, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin)
		{
			bool ret = DragInt4(label, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed)
		{
			bool ret = DragInt4(label, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt4(byte* label, int* v)
		{
			bool ret = DragInt4(label, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragInt4Native((byte*)plabel, v, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragInt4Native((byte*)plabel, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragInt4((byte*)plabel, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt4Native(pStr0, v, vSpeed, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt4Native(pStr0, v, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragInt4(pStr0, v, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = DragInt4Native(label, (int*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = DragInt4Native(label, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(label, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = DragInt4Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = DragInt4Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = DragInt4((byte*)plabel, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = DragInt4Native(pStr0, (int*)pv, vSpeed, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = DragInt4Native(pStr0, (int*)pv, vSpeed, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, vMin, (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, vSpeed, (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = DragInt4(pStr0, (int*)pv, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragInt4Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragInt4Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt4Native(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt4(byte* label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragInt4Native(label, v, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt4Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt4(ref byte label, int* v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt4Native((byte*)plabel, v, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragInt4Native(pStr0, v, vSpeed, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt4(string label, int* v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragInt4Native(pStr0, v, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt4Native(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragInt4Native(label, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragInt4Native(label, (int*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt4(byte* label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragInt4Native(label, (int*)pv, vSpeed, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragInt4Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragInt4(ref byte label, ref int v, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragInt4Native((byte*)plabel, (int*)pv, vSpeed, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragInt4Native(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragInt4(string label, ref int v, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragInt4Native(pStr0, (int*)pv, vSpeed, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragIntRange2")]
		internal static extern byte DragIntRange2Native(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags);

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax)
		{
			bool ret = DragIntRange2(label, vCurrentMin, vCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = DragIntRange2((byte*)plabel, vCurrentMin, vCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = DragIntRange2(pStr0, vCurrentMin, vCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(label, (int*)pvCurrentMin, vCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, vCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(label, vCurrentMin, (int*)pvCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				bool ret = DragIntRange2(pStr0, vCurrentMin, (int*)pvCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(label, (int*)pvCurrentMin, (int*)pvCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						bool ret = DragIntRange2((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
						return ret;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					bool ret = DragIntRange2(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, (float)(1.0f), (int)(0), (int)(0), (string)"%d", (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, (byte*)(default), (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, byte* formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, formatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)(default), (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, byte* formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, formatMax, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, (byte*)(default), (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformatMax = &formatMax)
			{
				byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* pformatMax = &formatMax)
			{
				byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (formatMax != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (formatMax != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (formatMax != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (formatMax != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, flags);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (formatMax != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(formatMax, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr0, (ImGuiSliderFlags)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, byte* format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, format, pStr1, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pformatMax = &formatMax)
				{
					byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (formatMax != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragIntRange2Native(label, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (formatMax != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (formatMax != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(formatMax);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = DragIntRange2Native(pStr0, vCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, int* vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, vCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				fixed (byte* pformat = &format)
				{
					fixed (byte* pformatMax = &formatMax)
					{
						byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (formatMax != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = DragIntRange2Native(label, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragIntRange2Native((byte*)plabel, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(string label, int* vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMax = &vCurrentMax)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (formatMax != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(formatMax);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte ret = DragIntRange2Native(pStr0, vCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					fixed (byte* pformat = &format)
					{
						fixed (byte* pformatMax = &formatMax)
						{
							byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, flags);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(byte* label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (format != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(format);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (formatMax != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(formatMax, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte ret = DragIntRange2Native(label, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr0, pStr1, (ImGuiSliderFlags)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							fixed (byte* pformatMax = &formatMax)
							{
								byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, flags);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		public static bool DragIntRange2(ref byte label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, ref byte format, ref byte formatMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pvCurrentMin = &vCurrentMin)
				{
					fixed (int* pvCurrentMax = &vCurrentMax)
					{
						fixed (byte* pformat = &format)
						{
							fixed (byte* pformatMax = &formatMax)
							{
								byte ret = DragIntRange2Native((byte*)plabel, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, (byte*)pformat, (byte*)pformatMax, (ImGuiSliderFlags)(0));
								return ret != 0;
							}
						}
					}
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (formatMax != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, flags);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool DragIntRange2(string label, ref int vCurrentMin, ref int vCurrentMax, float vSpeed, int vMin, int vMax, string format, string formatMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pvCurrentMin = &vCurrentMin)
			{
				fixed (int* pvCurrentMax = &vCurrentMax)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (format != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(format);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* pStr2 = null;
					int pStrSize2 = 0;
					if (formatMax != null)
					{
						pStrSize2 = Utils.GetByteCountUTF8(formatMax);
						if (pStrSize2 >= Utils.MaxStackallocSize)
						{
							pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
						}
						else
						{
							byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
							pStr2 = pStrStack2;
						}
						int pStrOffset2 = Utils.EncodeStringUTF8(formatMax, pStr2, pStrSize2);
						pStr2[pStrOffset2] = 0;
					}
					byte ret = DragIntRange2Native(pStr0, (int*)pvCurrentMin, (int*)pvCurrentMax, vSpeed, vMin, vMax, pStr1, pStr2, (ImGuiSliderFlags)(0));
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr2);
					}
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragScalar")]
		internal static extern byte DragScalarNative(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragScalarNative(label, dataType, pData, vSpeed, pMin, pMax, format, flags);
			return ret != 0;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			byte ret = DragScalarNative(label, dataType, pData, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax)
		{
			byte ret = DragScalarNative(label, dataType, pData, vSpeed, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin)
		{
			byte ret = DragScalarNative(label, dataType, pData, vSpeed, pMin, (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed)
		{
			byte ret = DragScalarNative(label, dataType, pData, vSpeed, (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData)
		{
			byte ret = DragScalarNative(label, dataType, pData, (float)(1.0f), (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNative((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNative((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNative((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNative((byte*)plabel, dataType, pData, vSpeed, pMin, (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNative((byte*)plabel, dataType, pData, vSpeed, (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNative((byte*)plabel, dataType, pData, (float)(1.0f), (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNative(pStr0, dataType, pData, vSpeed, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNative(pStr0, dataType, pData, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNative(pStr0, dataType, pData, vSpeed, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNative(pStr0, dataType, pData, vSpeed, pMin, (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNative(pStr0, dataType, pData, vSpeed, (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNative(pStr0, dataType, pData, (float)(1.0f), (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragScalarNative(label, dataType, pData, vSpeed, pMin, pMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragScalarNative(label, dataType, pData, vSpeed, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNative(label, dataType, pData, vSpeed, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(byte* label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNative(label, dataType, pData, vSpeed, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragScalarNative((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragScalar(ref byte label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragScalarNative((byte*)plabel, dataType, pData, vSpeed, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragScalarNative(pStr0, dataType, pData, vSpeed, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalar(string label, ImGuiDataType dataType, void* pData, float vSpeed, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragScalarNative(pStr0, dataType, pData, vSpeed, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragScalarN")]
		internal static extern byte DragScalarNNative(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, pMin, pMax, format, flags);
			return ret != 0;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax)
		{
			byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin)
		{
			byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, pMin, (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed)
		{
			byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components)
		{
			byte ret = DragScalarNNative(label, dataType, pData, components, (float)(1.0f), (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNNative((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNNative((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNNative((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNNative((byte*)plabel, dataType, pData, components, vSpeed, pMin, (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNNative((byte*)plabel, dataType, pData, components, vSpeed, (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DragScalarNNative((byte*)plabel, dataType, pData, components, (float)(1.0f), (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNNative(pStr0, dataType, pData, components, vSpeed, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNNative(pStr0, dataType, pData, components, vSpeed, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNNative(pStr0, dataType, pData, components, vSpeed, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNNative(pStr0, dataType, pData, components, vSpeed, pMin, (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNNative(pStr0, dataType, pData, components, vSpeed, (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNNative(pStr0, dataType, pData, components, (float)(1.0f), (void*)(default), (void*)(default), (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, pMin, pMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragScalarNNative(label, dataType, pData, components, vSpeed, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragScalarNNative((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragScalarNNative((byte*)plabel, dataType, pData, components, vSpeed, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragScalarNNative(pStr0, dataType, pData, components, vSpeed, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragScalarN(string label, ImGuiDataType dataType, void* pData, int components, float vSpeed, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DragScalarNNative(pStr0, dataType, pData, components, vSpeed, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderFloat")]
		internal static extern byte SliderFloatNative(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderFloatNative(label, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, byte* format)
		{
			byte ret = SliderFloatNative(label, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax)
		{
			bool ret = SliderFloat(label, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderFloatNative((byte*)plabel, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderFloatNative((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat((byte*)plabel, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloatNative(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloatNative(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat(pStr0, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = SliderFloatNative(label, (float*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = SliderFloatNative(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = SliderFloatNative((byte*)plabel, (float*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = SliderFloatNative((byte*)plabel, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat((byte*)plabel, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte ret = SliderFloatNative(pStr0, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte ret = SliderFloatNative(pStr0, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat(pStr0, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderFloatNative(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderFloatNative(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloatNative(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat(byte* label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloatNative(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloatNative((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat(ref byte label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloatNative((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderFloatNative(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat(string label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderFloatNative(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloatNative(label, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloatNative(label, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderFloatNative(label, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat(byte* label, ref float v, float vMin, float vMax, string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderFloatNative(label, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderFloatNative((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderFloat(ref byte label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderFloatNative((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderFloatNative(pStr0, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat(string label, ref float v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderFloatNative(pStr0, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderFloat2")]
		internal static extern byte SliderFloat2Native(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderFloat2Native(label, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, byte* format)
		{
			byte ret = SliderFloat2Native(label, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax)
		{
			bool ret = SliderFloat2(label, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderFloat2Native((byte*)plabel, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderFloat2Native((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat2((byte*)plabel, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat2Native(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat2Native(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat2(pStr0, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = SliderFloat2Native(label, (float*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = SliderFloat2Native(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = SliderFloat2Native(label, (float*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax, byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = SliderFloat2Native(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = SliderFloat2(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = SliderFloat2Native((byte*)plabel, (float*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = SliderFloat2Native((byte*)plabel, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat2((byte*)plabel, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte ret = SliderFloat2Native(pStr0, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte ret = SliderFloat2Native(pStr0, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = SliderFloat2(pStr0, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderFloat2Native(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderFloat2Native(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat2Native(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat2(byte* label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat2Native(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat2Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat2(ref byte label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat2Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderFloat2Native(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat2(string label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderFloat2Native(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat2Native(label, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat2(byte* label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat2Native(label, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderFloat2Native(label, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat2(byte* label, ref Vector2 v, float vMin, float vMax, string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderFloat2Native(label, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderFloat2Native((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderFloat2(ref byte label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderFloat2Native((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderFloat2Native(pStr0, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat2(string label, ref Vector2 v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderFloat2Native(pStr0, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderFloat3")]
		internal static extern byte SliderFloat3Native(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderFloat3Native(label, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, byte* format)
		{
			byte ret = SliderFloat3Native(label, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax)
		{
			bool ret = SliderFloat3(label, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderFloat3Native((byte*)plabel, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderFloat3Native((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat3((byte*)plabel, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat3Native(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat3Native(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat3(pStr0, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = SliderFloat3Native(label, (float*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = SliderFloat3Native(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte ret = SliderFloat3Native(label, (float*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax, byte* format)
		{
			fixed (Vector3* pv = &v)
			{
				byte ret = SliderFloat3Native(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = SliderFloat3(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = SliderFloat3Native((byte*)plabel, (float*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = SliderFloat3Native((byte*)plabel, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat3((byte*)plabel, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte ret = SliderFloat3Native(pStr0, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte ret = SliderFloat3Native(pStr0, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = SliderFloat3(pStr0, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderFloat3Native(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderFloat3Native(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat3Native(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat3(byte* label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat3Native(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat3Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat3(ref byte label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat3Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderFloat3Native(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat3(string label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderFloat3Native(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat3Native(label, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat3(byte* label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat3Native(label, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderFloat3Native(label, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat3(byte* label, ref Vector3 v, float vMin, float vMax, string format)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderFloat3Native(label, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderFloat3Native((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderFloat3(ref byte label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderFloat3Native((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderFloat3Native(pStr0, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat3(string label, ref Vector3 v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderFloat3Native(pStr0, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderFloat4")]
		internal static extern byte SliderFloat4Native(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderFloat4Native(label, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, byte* format)
		{
			byte ret = SliderFloat4Native(label, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax)
		{
			bool ret = SliderFloat4(label, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderFloat4Native((byte*)plabel, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderFloat4Native((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderFloat4((byte*)plabel, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat4Native(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat4Native(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderFloat4(pStr0, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = SliderFloat4Native(label, (float*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = SliderFloat4Native(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte ret = SliderFloat4Native(label, (float*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax, byte* format)
		{
			fixed (Vector4* pv = &v)
			{
				byte ret = SliderFloat4Native(label, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = SliderFloat4(label, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = SliderFloat4Native((byte*)plabel, (float*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = SliderFloat4Native((byte*)plabel, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = SliderFloat4((byte*)plabel, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte ret = SliderFloat4Native(pStr0, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte ret = SliderFloat4Native(pStr0, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = SliderFloat4(pStr0, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderFloat4Native(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderFloat4Native(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat4Native(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat4(byte* label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderFloat4Native(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat4Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat4(ref byte label, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat4Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderFloat4Native(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat4(string label, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderFloat4Native(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat4Native(label, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat4(byte* label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderFloat4Native(label, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderFloat4Native(label, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat4(byte* label, ref Vector4 v, float vMin, float vMax, string format)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderFloat4Native(label, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderFloat4Native((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderFloat4(ref byte label, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderFloat4Native((byte*)plabel, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderFloat4Native(pStr0, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderFloat4(string label, ref Vector4 v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderFloat4Native(pStr0, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderAngle")]
		internal static extern byte SliderAngleNative(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderAngleNative(label, vRad, vDegreesMin, vDegreesMax, format, flags);
			return ret != 0;
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			byte ret = SliderAngleNative(label, vRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax)
		{
			bool ret = SliderAngle(label, vRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin)
		{
			bool ret = SliderAngle(label, vRad, vDegreesMin, (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderAngle(byte* label, float* vRad)
		{
			bool ret = SliderAngle(label, vRad, (float)(-360.0f), (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderAngleNative((byte*)plabel, vRad, vDegreesMin, vDegreesMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderAngleNative((byte*)plabel, vRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderAngle((byte*)plabel, vRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderAngle((byte*)plabel, vRad, vDegreesMin, (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderAngle((byte*)plabel, vRad, (float)(-360.0f), (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderAngleNative(pStr0, vRad, vDegreesMin, vDegreesMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderAngleNative(pStr0, vRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, vDegreesMin, (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(string label, float* vRad)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderAngle(pStr0, vRad, (float)(-360.0f), (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pvRad = &vRad)
			{
				byte ret = SliderAngleNative(label, (float*)pvRad, vDegreesMin, vDegreesMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			fixed (float* pvRad = &vRad)
			{
				byte ret = SliderAngleNative(label, (float*)pvRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax)
		{
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin)
		{
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(label, (float*)pvRad, vDegreesMin, (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad)
		{
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(label, (float*)pvRad, (float)(-360.0f), (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					byte ret = SliderAngleNative((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					byte ret = SliderAngleNative((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					bool ret = SliderAngle((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					bool ret = SliderAngle((byte*)plabel, (float*)pvRad, vDegreesMin, (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					bool ret = SliderAngle((byte*)plabel, (float*)pvRad, (float)(-360.0f), (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				byte ret = SliderAngleNative(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				byte ret = SliderAngleNative(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, (string)"%.0f deg", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(pStr0, (float*)pvRad, vDegreesMin, (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(string label, ref float vRad)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				bool ret = SliderAngle(pStr0, (float*)pvRad, (float)(-360.0f), (float)(+360.0f), (string)"%.0f deg", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderAngleNative(label, vRad, vDegreesMin, vDegreesMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderAngleNative(label, vRad, vDegreesMin, vDegreesMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderAngleNative(label, vRad, vDegreesMin, vDegreesMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderAngle(byte* label, float* vRad, float vDegreesMin, float vDegreesMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderAngleNative(label, vRad, vDegreesMin, vDegreesMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderAngleNative((byte*)plabel, vRad, vDegreesMin, vDegreesMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderAngle(ref byte label, float* vRad, float vDegreesMin, float vDegreesMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderAngleNative((byte*)plabel, vRad, vDegreesMin, vDegreesMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderAngleNative(pStr0, vRad, vDegreesMin, vDegreesMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderAngle(string label, float* vRad, float vDegreesMin, float vDegreesMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderAngleNative(pStr0, vRad, vDegreesMin, vDegreesMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pvRad = &vRad)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderAngleNative(label, (float*)pvRad, vDegreesMin, vDegreesMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, ref byte format)
		{
			fixed (float* pvRad = &vRad)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderAngleNative(label, (float*)pvRad, vDegreesMin, vDegreesMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, string format, ImGuiSliderFlags flags)
		{
			fixed (float* pvRad = &vRad)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderAngleNative(label, (float*)pvRad, vDegreesMin, vDegreesMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderAngle(byte* label, ref float vRad, float vDegreesMin, float vDegreesMax, string format)
		{
			fixed (float* pvRad = &vRad)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderAngleNative(label, (float*)pvRad, vDegreesMin, vDegreesMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderAngleNative((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderAngle(ref byte label, ref float vRad, float vDegreesMin, float vDegreesMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvRad = &vRad)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderAngleNative((byte*)plabel, (float*)pvRad, vDegreesMin, vDegreesMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderAngleNative(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderAngle(string label, ref float vRad, float vDegreesMin, float vDegreesMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvRad = &vRad)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderAngleNative(pStr0, (float*)pvRad, vDegreesMin, vDegreesMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderInt")]
		internal static extern byte SliderIntNative(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderIntNative(label, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, byte* format)
		{
			byte ret = SliderIntNative(label, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax)
		{
			bool ret = SliderInt(label, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderIntNative((byte*)plabel, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderIntNative((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt((byte*)plabel, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderIntNative(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderIntNative(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt(pStr0, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = SliderIntNative(label, (int*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = SliderIntNative(label, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt(label, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = SliderIntNative((byte*)plabel, (int*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = SliderIntNative((byte*)plabel, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt((byte*)plabel, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = SliderIntNative(pStr0, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = SliderIntNative(pStr0, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt(pStr0, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderIntNative(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderIntNative(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderIntNative(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt(byte* label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderIntNative(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderIntNative((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt(ref byte label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderIntNative((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderIntNative(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt(string label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderIntNative(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderIntNative(label, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderIntNative(label, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderIntNative(label, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt(byte* label, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderIntNative(label, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderIntNative((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderInt(ref byte label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderIntNative((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderIntNative(pStr0, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt(string label, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderIntNative(pStr0, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderInt2")]
		internal static extern byte SliderInt2Native(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderInt2Native(label, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, byte* format)
		{
			byte ret = SliderInt2Native(label, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax)
		{
			bool ret = SliderInt2(label, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderInt2Native((byte*)plabel, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderInt2Native((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt2((byte*)plabel, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt2Native(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt2Native(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt2(pStr0, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = SliderInt2Native(label, (int*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = SliderInt2Native(label, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt2(label, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = SliderInt2Native((byte*)plabel, (int*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = SliderInt2Native((byte*)plabel, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt2((byte*)plabel, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = SliderInt2Native(pStr0, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = SliderInt2Native(pStr0, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt2(pStr0, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderInt2Native(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderInt2Native(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt2Native(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt2(byte* label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt2Native(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt2Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt2(ref byte label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt2Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderInt2Native(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt2(string label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderInt2Native(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt2Native(label, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt2Native(label, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderInt2Native(label, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt2(byte* label, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderInt2Native(label, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderInt2Native((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderInt2(ref byte label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderInt2Native((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderInt2Native(pStr0, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt2(string label, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderInt2Native(pStr0, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderInt3")]
		internal static extern byte SliderInt3Native(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderInt3Native(label, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, byte* format)
		{
			byte ret = SliderInt3Native(label, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax)
		{
			bool ret = SliderInt3(label, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderInt3Native((byte*)plabel, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderInt3Native((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt3((byte*)plabel, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt3Native(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt3Native(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt3(pStr0, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = SliderInt3Native(label, (int*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = SliderInt3Native(label, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt3(label, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = SliderInt3Native((byte*)plabel, (int*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = SliderInt3Native((byte*)plabel, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt3((byte*)plabel, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = SliderInt3Native(pStr0, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = SliderInt3Native(pStr0, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt3(pStr0, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderInt3Native(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderInt3Native(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt3Native(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt3(byte* label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt3Native(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt3Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt3(ref byte label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt3Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderInt3Native(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt3(string label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderInt3Native(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt3Native(label, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt3Native(label, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderInt3Native(label, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt3(byte* label, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderInt3Native(label, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderInt3Native((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderInt3(ref byte label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderInt3Native((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderInt3Native(pStr0, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt3(string label, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderInt3Native(pStr0, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderInt4")]
		internal static extern byte SliderInt4Native(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderInt4Native(label, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, byte* format)
		{
			byte ret = SliderInt4Native(label, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax)
		{
			bool ret = SliderInt4(label, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderInt4Native((byte*)plabel, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderInt4Native((byte*)plabel, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = SliderInt4((byte*)plabel, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt4Native(pStr0, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt4Native(pStr0, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = SliderInt4(pStr0, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = SliderInt4Native(label, (int*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = SliderInt4Native(label, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = SliderInt4(label, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = SliderInt4Native((byte*)plabel, (int*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = SliderInt4Native((byte*)plabel, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = SliderInt4((byte*)plabel, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = SliderInt4Native(pStr0, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = SliderInt4Native(pStr0, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = SliderInt4(pStr0, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderInt4Native(label, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderInt4Native(label, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt4Native(label, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt4(byte* label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderInt4Native(label, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt4Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt4(ref byte label, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt4Native((byte*)plabel, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderInt4Native(pStr0, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt4(string label, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderInt4Native(pStr0, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt4Native(label, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderInt4Native(label, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderInt4Native(label, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt4(byte* label, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SliderInt4Native(label, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderInt4Native((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderInt4(ref byte label, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = SliderInt4Native((byte*)plabel, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderInt4Native(pStr0, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool SliderInt4(string label, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SliderInt4Native(pStr0, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderScalar")]
		internal static extern byte SliderScalarNative(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderScalarNative(label, dataType, pData, pMin, pMax, format, flags);
			return ret != 0;
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			byte ret = SliderScalarNative(label, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			byte ret = SliderScalarNative(label, dataType, pData, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderScalarNative((byte*)plabel, dataType, pData, pMin, pMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderScalarNative((byte*)plabel, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderScalarNative((byte*)plabel, dataType, pData, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNative(pStr0, dataType, pData, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNative(pStr0, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNative(pStr0, dataType, pData, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderScalarNative(label, dataType, pData, pMin, pMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderScalarNative(label, dataType, pData, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNative(label, dataType, pData, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalar(byte* label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNative(label, dataType, pData, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderScalarNative((byte*)plabel, dataType, pData, pMin, pMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderScalarNative((byte*)plabel, dataType, pData, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderScalarNative(pStr0, dataType, pData, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalar(string label, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderScalarNative(pStr0, dataType, pData, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderScalarN")]
		internal static extern byte SliderScalarNNative(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = SliderScalarNNative(label, dataType, pData, components, pMin, pMax, format, flags);
			return ret != 0;
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format)
		{
			byte ret = SliderScalarNNative(label, dataType, pData, components, pMin, pMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax)
		{
			byte ret = SliderScalarNNative(label, dataType, pData, components, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderScalarNNative((byte*)plabel, dataType, pData, components, pMin, pMax, format, flags);
				return ret != 0;
			}
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderScalarNNative((byte*)plabel, dataType, pData, components, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SliderScalarNNative((byte*)plabel, dataType, pData, components, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNNative(pStr0, dataType, pData, components, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNNative(pStr0, dataType, pData, components, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNNative(pStr0, dataType, pData, components, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderScalarNNative(label, dataType, pData, components, pMin, pMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderScalarNNative(label, dataType, pData, components, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNNative(label, dataType, pData, components, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderScalarNNative(label, dataType, pData, components, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderScalarNNative((byte*)plabel, dataType, pData, components, pMin, pMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool SliderScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = SliderScalarNNative((byte*)plabel, dataType, pData, components, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderScalarNNative(pStr0, dataType, pData, components, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SliderScalarNNative(pStr0, dataType, pData, components, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igVSliderFloat")]
		internal static extern byte VSliderFloatNative(byte* label, Vector2 size, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags);

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = VSliderFloatNative(label, size, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, byte* format)
		{
			byte ret = VSliderFloatNative(label, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax)
		{
			bool ret = VSliderFloat(label, size, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = VSliderFloatNative((byte*)plabel, size, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = VSliderFloatNative((byte*)plabel, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderFloat((byte*)plabel, size, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderFloatNative(pStr0, size, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderFloatNative(pStr0, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderFloat(pStr0, size, v, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = VSliderFloatNative(label, size, (float*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = VSliderFloatNative(label, size, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = VSliderFloat(label, size, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = VSliderFloatNative((byte*)plabel, size, (float*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = VSliderFloatNative((byte*)plabel, size, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = VSliderFloat((byte*)plabel, size, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte ret = VSliderFloatNative(pStr0, size, (float*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte ret = VSliderFloatNative(pStr0, size, (float*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = VSliderFloat(pStr0, size, (float*)pv, vMin, vMax, (string)"%.3f", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = VSliderFloatNative(label, size, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = VSliderFloatNative(label, size, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderFloatNative(label, size, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderFloatNative(label, size, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderFloatNative((byte*)plabel, size, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, float* v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderFloatNative((byte*)plabel, size, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = VSliderFloatNative(pStr0, size, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderFloat(string label, Vector2 size, float* v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = VSliderFloatNative(pStr0, size, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderFloatNative(label, size, (float*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderFloatNative(label, size, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = VSliderFloatNative(label, size, (float*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderFloat(byte* label, Vector2 size, ref float v, float vMin, float vMax, string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = VSliderFloatNative(label, size, (float*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = VSliderFloatNative((byte*)plabel, size, (float*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool VSliderFloat(ref byte label, Vector2 size, ref float v, float vMin, float vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = VSliderFloatNative((byte*)plabel, size, (float*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = VSliderFloatNative(pStr0, size, (float*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderFloat(string label, Vector2 size, ref float v, float vMin, float vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = VSliderFloatNative(pStr0, size, (float*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igVSliderInt")]
		internal static extern byte VSliderIntNative(byte* label, Vector2 size, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags);

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = VSliderIntNative(label, size, v, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, byte* format)
		{
			byte ret = VSliderIntNative(label, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax)
		{
			bool ret = VSliderInt(label, size, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			return ret;
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = VSliderIntNative((byte*)plabel, size, v, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = VSliderIntNative((byte*)plabel, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = VSliderInt((byte*)plabel, size, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderIntNative(pStr0, size, v, vMin, vMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderIntNative(pStr0, size, v, vMin, vMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = VSliderInt(pStr0, size, v, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = VSliderIntNative(label, size, (int*)pv, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (int* pv = &v)
			{
				byte ret = VSliderIntNative(label, size, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax)
		{
			fixed (int* pv = &v)
			{
				bool ret = VSliderInt(label, size, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				return ret;
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = VSliderIntNative((byte*)plabel, size, (int*)pv, vMin, vMax, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = VSliderIntNative((byte*)plabel, size, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					bool ret = VSliderInt((byte*)plabel, size, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
					return ret;
				}
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = VSliderIntNative(pStr0, size, (int*)pv, vMin, vMax, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = VSliderIntNative(pStr0, size, (int*)pv, vMin, vMax, format, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				bool ret = VSliderInt(pStr0, size, (int*)pv, vMin, vMax, (string)"%d", (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = VSliderIntNative(label, size, v, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = VSliderIntNative(label, size, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderIntNative(label, size, v, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderInt(byte* label, Vector2 size, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderIntNative(label, size, v, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderIntNative((byte*)plabel, size, v, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, int* v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderIntNative((byte*)plabel, size, v, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = VSliderIntNative(pStr0, size, v, vMin, vMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderInt(string label, Vector2 size, int* v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = VSliderIntNative(pStr0, size, v, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderIntNative(label, size, (int*)pv, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (int* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderIntNative(label, size, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = VSliderIntNative(label, size, (int*)pv, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderInt(byte* label, Vector2 size, ref int v, int vMin, int vMax, string format)
		{
			fixed (int* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = VSliderIntNative(label, size, (int*)pv, vMin, vMax, pStr0, (ImGuiSliderFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = VSliderIntNative((byte*)plabel, size, (int*)pv, vMin, vMax, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool VSliderInt(ref byte label, Vector2 size, ref int v, int vMin, int vMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = VSliderIntNative((byte*)plabel, size, (int*)pv, vMin, vMax, (byte*)pformat, (ImGuiSliderFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = VSliderIntNative(pStr0, size, (int*)pv, vMin, vMax, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool VSliderInt(string label, Vector2 size, ref int v, int vMin, int vMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = VSliderIntNative(pStr0, size, (int*)pv, vMin, vMax, pStr1, (ImGuiSliderFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igVSliderScalar")]
		internal static extern byte VSliderScalarNative(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = VSliderScalarNative(label, size, dataType, pData, pMin, pMax, format, flags);
			return ret != 0;
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			byte ret = VSliderScalarNative(label, size, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			byte ret = VSliderScalarNative(label, size, dataType, pData, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			return ret != 0;
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = VSliderScalarNative((byte*)plabel, size, dataType, pData, pMin, pMax, format, flags);
				return ret != 0;
			}
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = VSliderScalarNative((byte*)plabel, size, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = VSliderScalarNative((byte*)plabel, size, dataType, pData, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderScalarNative(pStr0, size, dataType, pData, pMin, pMax, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderScalarNative(pStr0, size, dataType, pData, pMin, pMax, format, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderScalarNative(pStr0, size, dataType, pData, pMin, pMax, (byte*)(default), (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = VSliderScalarNative(label, size, dataType, pData, pMin, pMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = VSliderScalarNative(label, size, dataType, pData, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
				return ret != 0;
			}
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderScalarNative(label, size, dataType, pData, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderScalar(byte* label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VSliderScalarNative(label, size, dataType, pData, pMin, pMax, pStr0, (ImGuiSliderFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderScalarNative((byte*)plabel, size, dataType, pData, pMin, pMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool VSliderScalar(ref byte label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = VSliderScalarNative((byte*)plabel, size, dataType, pData, pMin, pMax, (byte*)pformat, (ImGuiSliderFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = VSliderScalarNative(pStr0, size, dataType, pData, pMin, pMax, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool VSliderScalar(string label, Vector2 size, ImGuiDataType dataType, void* pData, void* pMin, void* pMax, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = VSliderScalarNative(pStr0, size, dataType, pData, pMin, pMax, pStr1, (ImGuiSliderFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputText")]
		internal static extern byte InputTextNative(byte* label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData);

		public static bool InputText(byte* label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte ret = InputTextNative(label, buf, bufSize, flags, callback, userData);
			return ret != 0;
		}

		public static bool InputText(byte* label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte ret = InputTextNative(label, buf, bufSize, flags, callback, (void*)(default));
			return ret != 0;
		}

		public static bool InputText(byte* label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte ret = InputTextNative(label, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			return ret != 0;
		}

		public static bool InputText(byte* label, byte* buf, nuint bufSize)
		{
			byte ret = InputTextNative(label, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			return ret != 0;
		}

		public static bool InputText(ref byte label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextNative((byte*)plabel, buf, bufSize, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputText(ref byte label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextNative((byte*)plabel, buf, bufSize, flags, callback, (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputText(ref byte label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextNative((byte*)plabel, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputText(ref byte label, byte* buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextNative((byte*)plabel, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputText(string label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextNative(pStr0, buf, bufSize, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(string label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextNative(pStr0, buf, bufSize, flags, callback, (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(string label, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextNative(pStr0, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(string label, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextNative(pStr0, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(byte* label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextNative(label, (byte*)pbuf, bufSize, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputText(byte* label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextNative(label, (byte*)pbuf, bufSize, flags, callback, (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputText(byte* label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextNative(label, (byte*)pbuf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputText(byte* label, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextNative(label, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputText(byte* label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextNative(label, pStr0, bufSize, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(byte* label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextNative(label, pStr0, bufSize, flags, callback, (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(byte* label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextNative(label, pStr0, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(byte* label, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextNative(label, pStr0, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(ref byte label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextNative((byte*)plabel, (byte*)pbuf, bufSize, flags, callback, userData);
					return ret != 0;
				}
			}
		}

		public static bool InputText(ref byte label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextNative((byte*)plabel, (byte*)pbuf, bufSize, flags, callback, (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputText(ref byte label, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextNative((byte*)plabel, (byte*)pbuf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputText(ref byte label, ref byte buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextNative((byte*)plabel, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputText(string label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextNative(pStr0, pStr1, bufSize, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(string label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextNative(pStr0, pStr1, bufSize, flags, callback, (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(string label, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextNative(pStr0, pStr1, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputText(string label, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextNative(pStr0, pStr1, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputTextMultiline")]
		internal static extern byte InputTextMultilineNative(byte* label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData);

		public static bool InputTextMultiline(byte* label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte ret = InputTextMultilineNative(label, buf, bufSize, size, flags, callback, userData);
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte ret = InputTextMultilineNative(label, buf, bufSize, size, flags, callback, (void*)(default));
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			byte ret = InputTextMultilineNative(label, buf, bufSize, size, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, byte* buf, nuint bufSize, Vector2 size)
		{
			byte ret = InputTextMultilineNative(label, buf, bufSize, size, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, byte* buf, nuint bufSize)
		{
			byte ret = InputTextMultilineNative(label, buf, bufSize, (Vector2)(new Vector2(0,0)), (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			return ret != 0;
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextMultilineNative((byte*)plabel, buf, bufSize, size, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextMultilineNative((byte*)plabel, buf, bufSize, size, flags, callback, (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextMultilineNative((byte*)plabel, buf, bufSize, size, flags, (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextMultilineNative((byte*)plabel, buf, bufSize, size, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(ref byte label, byte* buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextMultilineNative((byte*)plabel, buf, bufSize, (Vector2)(new Vector2(0,0)), (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, buf, bufSize, size, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, buf, bufSize, size, flags, callback, (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, buf, bufSize, size, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, buf, bufSize, size, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(string label, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, buf, bufSize, (Vector2)(new Vector2(0,0)), (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextMultilineNative(label, (byte*)pbuf, bufSize, size, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextMultilineNative(label, (byte*)pbuf, bufSize, size, flags, callback, (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextMultilineNative(label, (byte*)pbuf, bufSize, size, flags, (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize, Vector2 size)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextMultilineNative(label, (byte*)pbuf, bufSize, size, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(byte* label, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextMultilineNative(label, (byte*)pbuf, bufSize, (Vector2)(new Vector2(0,0)), (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(label, pStr0, bufSize, size, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(label, pStr0, bufSize, size, flags, callback, (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(label, pStr0, bufSize, size, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(label, pStr0, bufSize, size, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(byte* label, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextMultilineNative(label, pStr0, bufSize, (Vector2)(new Vector2(0,0)), (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextMultilineNative((byte*)plabel, (byte*)pbuf, bufSize, size, flags, callback, userData);
					return ret != 0;
				}
			}
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextMultilineNative((byte*)plabel, (byte*)pbuf, bufSize, size, flags, callback, (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextMultilineNative((byte*)plabel, (byte*)pbuf, bufSize, size, flags, (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextMultilineNative((byte*)plabel, (byte*)pbuf, bufSize, size, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextMultiline(ref byte label, ref byte buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextMultilineNative((byte*)plabel, (byte*)pbuf, bufSize, (Vector2)(new Vector2(0,0)), (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, pStr1, bufSize, size, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, pStr1, bufSize, size, flags, callback, (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize, Vector2 size, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, pStr1, bufSize, size, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, pStr1, bufSize, size, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextMultiline(string label, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextMultilineNative(pStr0, pStr1, bufSize, (Vector2)(new Vector2(0,0)), (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputTextWithHint")]
		internal static extern byte InputTextWithHintNative(byte* label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData);

		public static bool InputTextWithHint(byte* label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte ret = InputTextWithHintNative(label, hint, buf, bufSize, flags, callback, userData);
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte ret = InputTextWithHintNative(label, hint, buf, bufSize, flags, callback, (void*)(default));
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte ret = InputTextWithHintNative(label, hint, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, byte* buf, nuint bufSize)
		{
			byte ret = InputTextWithHintNative(label, hint, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			return ret != 0;
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextWithHintNative((byte*)plabel, hint, buf, bufSize, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextWithHintNative((byte*)plabel, hint, buf, bufSize, flags, callback, (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextWithHintNative((byte*)plabel, hint, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, byte* buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextWithHintNative((byte*)plabel, hint, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(string label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, hint, buf, bufSize, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, hint, buf, bufSize, flags, callback, (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, byte* hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, hint, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, byte* hint, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, hint, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* phint = &hint)
			{
				byte ret = InputTextWithHintNative(label, (byte*)phint, buf, bufSize, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* phint = &hint)
			{
				byte ret = InputTextWithHintNative(label, (byte*)phint, buf, bufSize, flags, callback, (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* phint = &hint)
			{
				byte ret = InputTextWithHintNative(label, (byte*)phint, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, byte* buf, nuint bufSize)
		{
			fixed (byte* phint = &hint)
			{
				byte ret = InputTextWithHintNative(label, (byte*)phint, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(byte* label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(label, pStr0, buf, bufSize, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(label, pStr0, buf, bufSize, flags, callback, (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(label, pStr0, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, string hint, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(label, pStr0, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					byte ret = InputTextWithHintNative((byte*)plabel, (byte*)phint, buf, bufSize, flags, callback, userData);
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					byte ret = InputTextWithHintNative((byte*)plabel, (byte*)phint, buf, bufSize, flags, callback, (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					byte ret = InputTextWithHintNative((byte*)plabel, (byte*)phint, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, byte* buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					byte ret = InputTextWithHintNative((byte*)plabel, (byte*)phint, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(string label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, pStr1, buf, bufSize, flags, callback, userData);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, pStr1, buf, bufSize, flags, callback, (void*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, string hint, byte* buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, pStr1, buf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, string hint, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, pStr1, buf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextWithHintNative(label, hint, (byte*)pbuf, bufSize, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextWithHintNative(label, hint, (byte*)pbuf, bufSize, flags, callback, (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextWithHintNative(label, hint, (byte*)pbuf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextWithHintNative(label, hint, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
				return ret != 0;
			}
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(label, hint, pStr0, bufSize, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(label, hint, pStr0, bufSize, flags, callback, (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(label, hint, pStr0, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, byte* hint, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextWithHintNative(label, hint, pStr0, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextWithHintNative((byte*)plabel, hint, (byte*)pbuf, bufSize, flags, callback, userData);
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextWithHintNative((byte*)plabel, hint, (byte*)pbuf, bufSize, flags, callback, (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextWithHintNative((byte*)plabel, hint, (byte*)pbuf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, byte* hint, ref byte buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextWithHintNative((byte*)plabel, hint, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(string label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, hint, pStr1, bufSize, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, hint, pStr1, bufSize, flags, callback, (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, byte* hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, hint, pStr1, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, byte* hint, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, hint, pStr1, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextWithHintNative(label, (byte*)phint, (byte*)pbuf, bufSize, flags, callback, userData);
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextWithHintNative(label, (byte*)phint, (byte*)pbuf, bufSize, flags, callback, (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextWithHintNative(label, (byte*)phint, (byte*)pbuf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(byte* label, ref byte hint, ref byte buf, nuint bufSize)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextWithHintNative(label, (byte*)phint, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
					return ret != 0;
				}
			}
		}

		public static bool InputTextWithHint(byte* label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(label, pStr0, pStr1, bufSize, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(label, pStr0, pStr1, bufSize, flags, callback, (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(label, pStr0, pStr1, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(byte* label, string hint, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextWithHintNative(label, pStr0, pStr1, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						byte ret = InputTextWithHintNative((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, flags, callback, userData);
						return ret != 0;
					}
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						byte ret = InputTextWithHintNative((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, flags, callback, (void*)(default));
						return ret != 0;
					}
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, ref byte buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						byte ret = InputTextWithHintNative((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
						return ret != 0;
					}
				}
			}
		}

		public static bool InputTextWithHint(ref byte label, ref byte hint, ref byte buf, nuint bufSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						byte ret = InputTextWithHintNative((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
						return ret != 0;
					}
				}
			}
		}

		public static bool InputTextWithHint(string label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, pStr1, pStr2, bufSize, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, pStr1, pStr2, bufSize, flags, callback, (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, string hint, ref string buf, nuint bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, pStr1, pStr2, bufSize, flags, (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextWithHint(string label, string hint, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = InputTextWithHintNative(pStr0, pStr1, pStr2, bufSize, (ImGuiInputTextFlags)(0), (ImGuiInputTextCallback)(default), (void*)(default));
			buf = Utils.DecodeStringUTF8(pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputFloat")]
		internal static extern byte InputFloatNative(byte* label, float* v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags);

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte ret = InputFloatNative(label, v, step, stepFast, format, flags);
			return ret != 0;
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, byte* format)
		{
			byte ret = InputFloatNative(label, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast)
		{
			bool ret = InputFloat(label, v, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat(byte* label, float* v, float step)
		{
			bool ret = InputFloat(label, v, step, (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat(byte* label, float* v)
		{
			bool ret = InputFloat(label, v, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputFloatNative((byte*)plabel, v, step, stepFast, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputFloatNative((byte*)plabel, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat((byte*)plabel, v, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat((byte*)plabel, v, step, (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat((byte*)plabel, v, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloatNative(pStr0, v, step, stepFast, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloatNative(pStr0, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(pStr0, v, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(string label, float* v, float step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(pStr0, v, step, (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat(pStr0, v, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = InputFloatNative(label, (float*)pv, step, stepFast, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = InputFloatNative(label, (float*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(label, (float*)pv, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(label, (float*)pv, step, (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(label, (float*)pv, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = InputFloatNative((byte*)plabel, (float*)pv, step, stepFast, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = InputFloatNative((byte*)plabel, (float*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat((byte*)plabel, (float*)pv, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat((byte*)plabel, (float*)pv, step, (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat((byte*)plabel, (float*)pv, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte ret = InputFloatNative(pStr0, (float*)pv, step, stepFast, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte ret = InputFloatNative(pStr0, (float*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(pStr0, (float*)pv, step, stepFast, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(string label, ref float v, float step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(pStr0, (float*)pv, step, (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(string label, ref float v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				bool ret = InputFloat(pStr0, (float*)pv, (float)(0.0f), (float)(0.0f), (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloatNative(label, v, step, stepFast, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloatNative(label, v, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloatNative(label, v, step, stepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat(byte* label, float* v, float step, float stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloatNative(label, v, step, stepFast, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloatNative((byte*)plabel, v, step, stepFast, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat(ref byte label, float* v, float step, float stepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloatNative((byte*)plabel, v, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputFloatNative(pStr0, v, step, stepFast, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat(string label, float* v, float step, float stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputFloatNative(pStr0, v, step, stepFast, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloatNative(label, (float*)pv, step, stepFast, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloatNative(label, (float*)pv, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, string format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloatNative(label, (float*)pv, step, stepFast, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat(byte* label, ref float v, float step, float stepFast, string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloatNative(label, (float*)pv, step, stepFast, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputFloatNative((byte*)plabel, (float*)pv, step, stepFast, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool InputFloat(ref byte label, ref float v, float step, float stepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputFloatNative((byte*)plabel, (float*)pv, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputFloatNative(pStr0, (float*)pv, step, stepFast, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat(string label, ref float v, float step, float stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputFloatNative(pStr0, (float*)pv, step, stepFast, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputFloat2")]
		internal static extern byte InputFloat2Native(byte* label, float* v, byte* format, ImGuiInputTextFlags flags);

		public static bool InputFloat2(byte* label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte ret = InputFloat2Native(label, v, format, flags);
			return ret != 0;
		}

		public static bool InputFloat2(byte* label, float* v, byte* format)
		{
			byte ret = InputFloat2Native(label, v, format, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputFloat2(byte* label, float* v)
		{
			bool ret = InputFloat2(label, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat2(ref byte label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputFloat2Native((byte*)plabel, v, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat2(ref byte label, float* v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputFloat2Native((byte*)plabel, v, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat2(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat2((byte*)plabel, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(string label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat2Native(pStr0, v, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat2(string label, float* v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat2Native(pStr0, v, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat2(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat2(pStr0, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat2(byte* label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = InputFloat2Native(label, (float*)pv, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat2(byte* label, ref float v, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = InputFloat2Native(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat2(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat2(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = InputFloat2Native(label, (float*)pv, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v, byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = InputFloat2Native(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = InputFloat2(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat2(ref byte label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = InputFloat2Native((byte*)plabel, (float*)pv, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat2(ref byte label, ref float v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = InputFloat2Native((byte*)plabel, (float*)pv, format, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat2(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat2((byte*)plabel, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte ret = InputFloat2Native(pStr0, (float*)pv, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte ret = InputFloat2Native(pStr0, (float*)pv, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				bool ret = InputFloat2(pStr0, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat2(byte* label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloat2Native(label, v, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat2(byte* label, float* v, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloat2Native(label, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat2(byte* label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat2Native(label, v, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat2(byte* label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat2Native(label, v, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat2(ref byte label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat2Native((byte*)plabel, v, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat2(ref byte label, float* v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat2Native((byte*)plabel, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat2(string label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputFloat2Native(pStr0, v, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat2(string label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputFloat2Native(pStr0, v, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat2(byte* label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat2Native(label, (float*)pv, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat2(byte* label, ref float v, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat2Native(label, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v, string format, ImGuiInputTextFlags flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloat2Native(label, (float*)pv, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat2(byte* label, ref Vector2 v, string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloat2Native(label, (float*)pv, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat2(ref byte label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputFloat2Native((byte*)plabel, (float*)pv, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool InputFloat2(ref byte label, ref float v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputFloat2Native((byte*)plabel, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputFloat2Native(pStr0, (float*)pv, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat2(string label, ref Vector2 v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputFloat2Native(pStr0, (float*)pv, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputFloat3")]
		internal static extern byte InputFloat3Native(byte* label, float* v, byte* format, ImGuiInputTextFlags flags);

		public static bool InputFloat3(byte* label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte ret = InputFloat3Native(label, v, format, flags);
			return ret != 0;
		}

		public static bool InputFloat3(byte* label, float* v, byte* format)
		{
			byte ret = InputFloat3Native(label, v, format, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputFloat3(byte* label, float* v)
		{
			bool ret = InputFloat3(label, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat3(ref byte label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputFloat3Native((byte*)plabel, v, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat3(ref byte label, float* v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputFloat3Native((byte*)plabel, v, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat3(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat3((byte*)plabel, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(string label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat3Native(pStr0, v, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat3(string label, float* v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat3Native(pStr0, v, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat3(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat3(pStr0, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat3(byte* label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = InputFloat3Native(label, (float*)pv, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat3(byte* label, ref float v, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = InputFloat3Native(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat3(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat3(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte ret = InputFloat3Native(label, (float*)pv, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v, byte* format)
		{
			fixed (Vector3* pv = &v)
			{
				byte ret = InputFloat3Native(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				bool ret = InputFloat3(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat3(ref byte label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = InputFloat3Native((byte*)plabel, (float*)pv, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat3(ref byte label, ref float v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = InputFloat3Native((byte*)plabel, (float*)pv, format, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat3(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat3((byte*)plabel, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte ret = InputFloat3Native(pStr0, (float*)pv, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte ret = InputFloat3Native(pStr0, (float*)pv, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				bool ret = InputFloat3(pStr0, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat3(byte* label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloat3Native(label, v, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat3(byte* label, float* v, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloat3Native(label, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat3(byte* label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat3Native(label, v, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat3(byte* label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat3Native(label, v, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat3(ref byte label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat3Native((byte*)plabel, v, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat3(ref byte label, float* v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat3Native((byte*)plabel, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat3(string label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputFloat3Native(pStr0, v, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat3(string label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputFloat3Native(pStr0, v, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat3(byte* label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat3Native(label, (float*)pv, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat3(byte* label, ref float v, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat3Native(label, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v, string format, ImGuiInputTextFlags flags)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloat3Native(label, (float*)pv, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat3(byte* label, ref Vector3 v, string format)
		{
			fixed (Vector3* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloat3Native(label, (float*)pv, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat3(ref byte label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputFloat3Native((byte*)plabel, (float*)pv, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool InputFloat3(ref byte label, ref float v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputFloat3Native((byte*)plabel, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputFloat3Native(pStr0, (float*)pv, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat3(string label, ref Vector3 v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputFloat3Native(pStr0, (float*)pv, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputFloat4")]
		internal static extern byte InputFloat4Native(byte* label, float* v, byte* format, ImGuiInputTextFlags flags);

		public static bool InputFloat4(byte* label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte ret = InputFloat4Native(label, v, format, flags);
			return ret != 0;
		}

		public static bool InputFloat4(byte* label, float* v, byte* format)
		{
			byte ret = InputFloat4Native(label, v, format, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputFloat4(byte* label, float* v)
		{
			bool ret = InputFloat4(label, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputFloat4(ref byte label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputFloat4Native((byte*)plabel, v, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat4(ref byte label, float* v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputFloat4Native((byte*)plabel, v, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat4(ref byte label, float* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputFloat4((byte*)plabel, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(string label, float* v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat4Native(pStr0, v, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat4(string label, float* v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat4Native(pStr0, v, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat4(string label, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputFloat4(pStr0, v, (string)"%.3f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputFloat4(byte* label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = InputFloat4Native(label, (float*)pv, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat4(byte* label, ref float v, byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = InputFloat4Native(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat4(byte* label, ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte ret = InputFloat4Native(label, (float*)pv, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v, byte* format)
		{
			fixed (Vector4* pv = &v)
			{
				byte ret = InputFloat4Native(label, (float*)pv, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputFloat4(ref byte label, ref float v, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = InputFloat4Native((byte*)plabel, (float*)pv, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat4(ref byte label, ref float v, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					byte ret = InputFloat4Native((byte*)plabel, (float*)pv, format, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat4(ref byte label, ref float v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					bool ret = InputFloat4((byte*)plabel, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte ret = InputFloat4Native(pStr0, (float*)pv, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte ret = InputFloat4Native(pStr0, (float*)pv, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(pStr0, (float*)pv, (string)"%.3f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputFloat4(byte* label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloat4Native(label, v, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat4(byte* label, float* v, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloat4Native(label, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat4(byte* label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat4Native(label, v, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat4(byte* label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat4Native(label, v, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat4(ref byte label, float* v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat4Native((byte*)plabel, v, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat4(ref byte label, float* v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat4Native((byte*)plabel, v, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat4(string label, float* v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputFloat4Native(pStr0, v, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat4(string label, float* v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputFloat4Native(pStr0, v, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat4(byte* label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat4Native(label, (float*)pv, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat4(byte* label, ref float v, ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat4Native(label, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v, string format, ImGuiInputTextFlags flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloat4Native(label, (float*)pv, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat4(byte* label, ref Vector4 v, string format)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloat4Native(label, (float*)pv, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat4(ref byte label, ref float v, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputFloat4Native((byte*)plabel, (float*)pv, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool InputFloat4(ref byte label, ref float v, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputFloat4Native((byte*)plabel, (float*)pv, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputFloat4Native(pStr0, (float*)pv, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat4(string label, ref Vector4 v, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputFloat4Native(pStr0, (float*)pv, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputInt")]
		internal static extern byte InputIntNative(byte* label, int* v, int step, int stepFast, ImGuiInputTextFlags flags);

		public static bool InputInt(byte* label, int* v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			byte ret = InputIntNative(label, v, step, stepFast, flags);
			return ret != 0;
		}

		public static bool InputInt(byte* label, int* v, int step, int stepFast)
		{
			byte ret = InputIntNative(label, v, step, stepFast, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputInt(byte* label, int* v, int step)
		{
			byte ret = InputIntNative(label, v, step, (int)(100), (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputInt(byte* label, int* v)
		{
			byte ret = InputIntNative(label, v, (int)(1), (int)(100), (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputInt(ref byte label, int* v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputIntNative((byte*)plabel, v, step, stepFast, flags);
				return ret != 0;
			}
		}

		public static bool InputInt(ref byte label, int* v, int step, int stepFast)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputIntNative((byte*)plabel, v, step, stepFast, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt(ref byte label, int* v, int step)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputIntNative((byte*)plabel, v, step, (int)(100), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputIntNative((byte*)plabel, v, (int)(1), (int)(100), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt(string label, int* v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputIntNative(pStr0, v, step, stepFast, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt(string label, int* v, int step, int stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputIntNative(pStr0, v, step, stepFast, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt(string label, int* v, int step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputIntNative(pStr0, v, step, (int)(100), (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputIntNative(pStr0, v, (int)(1), (int)(100), (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt(byte* label, ref int v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(label, (int*)pv, step, stepFast, flags);
				return ret != 0;
			}
		}

		public static bool InputInt(byte* label, ref int v, int step, int stepFast)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(label, (int*)pv, step, stepFast, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt(byte* label, ref int v, int step)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(label, (int*)pv, step, (int)(100), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(label, (int*)pv, (int)(1), (int)(100), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt(ref byte label, ref int v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputIntNative((byte*)plabel, (int*)pv, step, stepFast, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputInt(ref byte label, ref int v, int step, int stepFast)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputIntNative((byte*)plabel, (int*)pv, step, stepFast, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputInt(ref byte label, ref int v, int step)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputIntNative((byte*)plabel, (int*)pv, step, (int)(100), (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputInt(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputIntNative((byte*)plabel, (int*)pv, (int)(1), (int)(100), (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputInt(string label, ref int v, int step, int stepFast, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(pStr0, (int*)pv, step, stepFast, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputInt(string label, ref int v, int step, int stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(pStr0, (int*)pv, step, stepFast, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputInt(string label, ref int v, int step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(pStr0, (int*)pv, step, (int)(100), (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputInt(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(pStr0, (int*)pv, (int)(1), (int)(100), (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputInt2")]
		internal static extern byte InputInt2Native(byte* label, int* v, ImGuiInputTextFlags flags);

		public static bool InputInt2(byte* label, int* v, ImGuiInputTextFlags flags)
		{
			byte ret = InputInt2Native(label, v, flags);
			return ret != 0;
		}

		public static bool InputInt2(byte* label, int* v)
		{
			byte ret = InputInt2Native(label, v, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputInt2(ref byte label, int* v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputInt2Native((byte*)plabel, v, flags);
				return ret != 0;
			}
		}

		public static bool InputInt2(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputInt2Native((byte*)plabel, v, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt2(string label, int* v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputInt2Native(pStr0, v, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt2(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputInt2Native(pStr0, v, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt2(byte* label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt2Native(label, (int*)pv, flags);
				return ret != 0;
			}
		}

		public static bool InputInt2(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt2Native(label, (int*)pv, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt2(ref byte label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputInt2Native((byte*)plabel, (int*)pv, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputInt2(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputInt2Native((byte*)plabel, (int*)pv, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputInt2(string label, ref int v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputInt2Native(pStr0, (int*)pv, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputInt2(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputInt2Native(pStr0, (int*)pv, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputInt3")]
		internal static extern byte InputInt3Native(byte* label, int* v, ImGuiInputTextFlags flags);

		public static bool InputInt3(byte* label, int* v, ImGuiInputTextFlags flags)
		{
			byte ret = InputInt3Native(label, v, flags);
			return ret != 0;
		}

		public static bool InputInt3(byte* label, int* v)
		{
			byte ret = InputInt3Native(label, v, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputInt3(ref byte label, int* v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputInt3Native((byte*)plabel, v, flags);
				return ret != 0;
			}
		}

		public static bool InputInt3(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputInt3Native((byte*)plabel, v, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt3(string label, int* v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputInt3Native(pStr0, v, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt3(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputInt3Native(pStr0, v, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt3(byte* label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt3Native(label, (int*)pv, flags);
				return ret != 0;
			}
		}

		public static bool InputInt3(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt3Native(label, (int*)pv, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt3(ref byte label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputInt3Native((byte*)plabel, (int*)pv, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputInt3(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputInt3Native((byte*)plabel, (int*)pv, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputInt3(string label, ref int v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputInt3Native(pStr0, (int*)pv, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputInt3(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputInt3Native(pStr0, (int*)pv, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputInt4")]
		internal static extern byte InputInt4Native(byte* label, int* v, ImGuiInputTextFlags flags);

		public static bool InputInt4(byte* label, int* v, ImGuiInputTextFlags flags)
		{
			byte ret = InputInt4Native(label, v, flags);
			return ret != 0;
		}

		public static bool InputInt4(byte* label, int* v)
		{
			byte ret = InputInt4Native(label, v, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputInt4(ref byte label, int* v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputInt4Native((byte*)plabel, v, flags);
				return ret != 0;
			}
		}

		public static bool InputInt4(ref byte label, int* v)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputInt4Native((byte*)plabel, v, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt4(string label, int* v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputInt4Native(pStr0, v, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt4(string label, int* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputInt4Native(pStr0, v, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputInt4(byte* label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt4Native(label, (int*)pv, flags);
				return ret != 0;
			}
		}

		public static bool InputInt4(byte* label, ref int v)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt4Native(label, (int*)pv, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputInt4(ref byte label, ref int v, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputInt4Native((byte*)plabel, (int*)pv, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputInt4(ref byte label, ref int v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = InputInt4Native((byte*)plabel, (int*)pv, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputInt4(string label, ref int v, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputInt4Native(pStr0, (int*)pv, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputInt4(string label, ref int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = InputInt4Native(pStr0, (int*)pv, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputDouble")]
		internal static extern byte InputDoubleNative(byte* label, double* v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags);

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte ret = InputDoubleNative(label, v, step, stepFast, format, flags);
			return ret != 0;
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, byte* format)
		{
			byte ret = InputDoubleNative(label, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast)
		{
			bool ret = InputDouble(label, v, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputDouble(byte* label, double* v, double step)
		{
			bool ret = InputDouble(label, v, step, (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputDouble(byte* label, double* v)
		{
			bool ret = InputDouble(label, v, (double)(0.0), (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
			return ret;
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputDoubleNative((byte*)plabel, v, step, stepFast, format, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputDoubleNative((byte*)plabel, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputDouble((byte*)plabel, v, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputDouble((byte*)plabel, v, step, (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, double* v)
		{
			fixed (byte* plabel = &label)
			{
				bool ret = InputDouble((byte*)plabel, v, (double)(0.0), (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(pStr0, v, step, stepFast, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(pStr0, v, step, stepFast, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(pStr0, v, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(string label, double* v, double step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(pStr0, v, step, (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(string label, double* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			bool ret = InputDouble(pStr0, v, (double)(0.0), (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, format, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, byte* format)
		{
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(byte* label, ref double v)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, (double)(0.0), (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
				return ret;
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					byte ret = InputDoubleNative((byte*)plabel, (double*)pv, step, stepFast, format, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					byte ret = InputDoubleNative((byte*)plabel, (double*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					bool ret = InputDouble((byte*)plabel, (double*)pv, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					bool ret = InputDouble((byte*)plabel, (double*)pv, step, (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					bool ret = InputDouble((byte*)plabel, (double*)pv, (double)(0.0), (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
					return ret;
				}
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(pStr0, (double*)pv, step, stepFast, format, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(pStr0, (double*)pv, step, stepFast, format, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(pStr0, (double*)pv, step, stepFast, (string)"%.6f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(string label, ref double v, double step)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(pStr0, (double*)pv, step, (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(string label, ref double v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(pStr0, (double*)pv, (double)(0.0), (double)(0.0), (string)"%.6f", (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputDoubleNative(label, v, step, stepFast, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputDoubleNative(label, v, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(label, v, step, stepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble(byte* label, double* v, double step, double stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(label, v, step, stepFast, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative((byte*)plabel, v, step, stepFast, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputDouble(ref byte label, double* v, double step, double stepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative((byte*)plabel, v, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputDoubleNative(pStr0, v, step, stepFast, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble(string label, double* v, double step, double stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputDoubleNative(pStr0, v, step, stepFast, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, ref byte format)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, string format, ImGuiInputTextFlags flags)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble(byte* label, ref double v, double step, double stepFast, string format)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, pStr0, (ImGuiInputTextFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputDoubleNative((byte*)plabel, (double*)pv, step, stepFast, (byte*)pformat, flags);
						return ret != 0;
					}
				}
			}
		}

		public static bool InputDouble(ref byte label, ref double v, double step, double stepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (double* pv = &v)
				{
					fixed (byte* pformat = &format)
					{
						byte ret = InputDoubleNative((byte*)plabel, (double*)pv, step, stepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
						return ret != 0;
					}
				}
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputDoubleNative(pStr0, (double*)pv, step, stepFast, pStr1, flags);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble(string label, ref double v, double step, double stepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* pv = &v)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (format != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(format);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = InputDoubleNative(pStr0, (double*)pv, step, stepFast, pStr1, (ImGuiInputTextFlags)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputScalar")]
		internal static extern byte InputScalarNative(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags);

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, format, flags);
			return ret != 0;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, (byte*)(default), (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData)
		{
			byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNative((byte*)plabel, dataType, pData, pStep, pStepFast, format, flags);
				return ret != 0;
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNative((byte*)plabel, dataType, pData, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNative((byte*)plabel, dataType, pData, pStep, pStepFast, (byte*)(default), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNative((byte*)plabel, dataType, pData, pStep, (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNative((byte*)plabel, dataType, pData, (void*)(default), (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(pStr0, dataType, pData, pStep, pStepFast, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(pStr0, dataType, pData, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(pStr0, dataType, pData, pStep, pStepFast, (byte*)(default), (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(pStr0, dataType, pData, pStep, (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(pStr0, dataType, pData, (void*)(default), (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar(byte* label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputScalarNative((byte*)plabel, dataType, pData, pStep, pStepFast, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputScalar(ref byte label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputScalarNative((byte*)plabel, dataType, pData, pStep, pStepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputScalarNative(pStr0, dataType, pData, pStep, pStepFast, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar(string label, ImGuiDataType dataType, void* pData, void* pStep, void* pStepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputScalarNative(pStr0, dataType, pData, pStep, pStepFast, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputScalarN")]
		internal static extern byte InputScalarNNative(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags);

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, format, flags);
			return ret != 0;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, (byte*)(default), (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
			return ret != 0;
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNNative((byte*)plabel, dataType, pData, components, pStep, pStepFast, format, flags);
				return ret != 0;
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNNative((byte*)plabel, dataType, pData, components, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNNative((byte*)plabel, dataType, pData, components, pStep, pStepFast, (byte*)(default), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNNative((byte*)plabel, dataType, pData, components, pStep, (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputScalarNNative((byte*)plabel, dataType, pData, components, (void*)(default), (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(pStr0, dataType, pData, components, pStep, pStepFast, format, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(pStr0, dataType, pData, components, pStep, pStepFast, format, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(pStr0, dataType, pData, components, pStep, pStepFast, (byte*)(default), (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(pStr0, dataType, pData, components, pStep, (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(pStr0, dataType, pData, components, (void*)(default), (void*)(default), (byte*)(default), (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
				return ret != 0;
			}
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN(byte* label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, pStr0, (ImGuiInputTextFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, ref byte format, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputScalarNNative((byte*)plabel, dataType, pData, components, pStep, pStepFast, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputScalarN(ref byte label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputScalarNNative((byte*)plabel, dataType, pData, components, pStep, pStepFast, (byte*)pformat, (ImGuiInputTextFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, string format, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputScalarNNative(pStr0, dataType, pData, components, pStep, pStepFast, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN(string label, ImGuiDataType dataType, void* pData, int components, void* pStep, void* pStepFast, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputScalarNNative(pStr0, dataType, pData, components, pStep, pStepFast, pStr1, (ImGuiInputTextFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorEdit3")]
		internal static extern byte ColorEdit3Native(byte* label, float* col, ImGuiColorEditFlags flags);

		public static bool ColorEdit3(byte* label, float* col, ImGuiColorEditFlags flags)
		{
			byte ret = ColorEdit3Native(label, col, flags);
			return ret != 0;
		}

		public static bool ColorEdit3(byte* label, float* col)
		{
			byte ret = ColorEdit3Native(label, col, (ImGuiColorEditFlags)(0));
			return ret != 0;
		}

		public static bool ColorEdit3(ref byte label, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorEdit3Native((byte*)plabel, col, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit3(ref byte label, float* col)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorEdit3Native((byte*)plabel, col, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorEdit3(string label, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorEdit3Native(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorEdit3(string label, float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorEdit3Native(pStr0, col, (ImGuiColorEditFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorEdit3(byte* label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorEdit3Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit3(byte* label, ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorEdit3Native(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorEdit3(byte* label, ref Vector3 col, ImGuiColorEditFlags flags)
		{
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorEdit3Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit3(byte* label, ref Vector3 col)
		{
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorEdit3Native(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorEdit3(ref byte label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorEdit3Native((byte*)plabel, (float*)pcol, flags);
					return ret != 0;
				}
			}
		}

		public static bool ColorEdit3(ref byte label, ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorEdit3Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool ColorEdit3(string label, ref Vector3 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorEdit3Native(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ColorEdit3(string label, ref Vector3 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorEdit3Native(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorEdit4")]
		internal static extern byte ColorEdit4Native(byte* label, float* col, ImGuiColorEditFlags flags);

		public static bool ColorEdit4(byte* label, float* col, ImGuiColorEditFlags flags)
		{
			byte ret = ColorEdit4Native(label, col, flags);
			return ret != 0;
		}

		public static bool ColorEdit4(byte* label, float* col)
		{
			byte ret = ColorEdit4Native(label, col, (ImGuiColorEditFlags)(0));
			return ret != 0;
		}

		public static bool ColorEdit4(ref byte label, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorEdit4Native((byte*)plabel, col, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit4(ref byte label, float* col)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorEdit4Native((byte*)plabel, col, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorEdit4(string label, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorEdit4Native(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorEdit4(string label, float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorEdit4Native(pStr0, col, (ImGuiColorEditFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorEdit4(byte* label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorEdit4Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit4(byte* label, ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorEdit4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorEdit4(byte* label, ref Vector4 col, ImGuiColorEditFlags flags)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorEdit4Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit4(byte* label, ref Vector4 col)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorEdit4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorEdit4(ref byte label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorEdit4Native((byte*)plabel, (float*)pcol, flags);
					return ret != 0;
				}
			}
		}

		public static bool ColorEdit4(ref byte label, ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorEdit4Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool ColorEdit4(string label, ref Vector4 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorEdit4Native(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ColorEdit4(string label, ref Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorEdit4Native(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorPicker3")]
		internal static extern byte ColorPicker3Native(byte* label, float* col, ImGuiColorEditFlags flags);

		public static bool ColorPicker3(byte* label, float* col, ImGuiColorEditFlags flags)
		{
			byte ret = ColorPicker3Native(label, col, flags);
			return ret != 0;
		}

		public static bool ColorPicker3(byte* label, float* col)
		{
			byte ret = ColorPicker3Native(label, col, (ImGuiColorEditFlags)(0));
			return ret != 0;
		}

		public static bool ColorPicker3(ref byte label, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorPicker3Native((byte*)plabel, col, flags);
				return ret != 0;
			}
		}

		public static bool ColorPicker3(ref byte label, float* col)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorPicker3Native((byte*)plabel, col, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorPicker3(string label, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker3Native(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorPicker3(string label, float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker3Native(pStr0, col, (ImGuiColorEditFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorPicker3(byte* label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker3Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorPicker3(byte* label, ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker3Native(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorPicker3(byte* label, ref Vector3 col, ImGuiColorEditFlags flags)
		{
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorPicker3Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorPicker3(byte* label, ref Vector3 col)
		{
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorPicker3Native(label, (float*)pcol, (ImGuiColorEditFlags)(0));
				return ret != 0;
			}
		}

		public static bool ColorPicker3(ref byte label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker3Native((byte*)plabel, (float*)pcol, flags);
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker3(ref byte label, ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker3Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker3(string label, ref Vector3 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorPicker3Native(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ColorPicker3(string label, ref Vector3 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorPicker3Native(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorPicker4")]
		internal static extern byte ColorPicker4Native(byte* label, float* col, ImGuiColorEditFlags flags, float* refCol);

		public static bool ColorPicker4(byte* label, float* col, ImGuiColorEditFlags flags, float* refCol)
		{
			byte ret = ColorPicker4Native(label, col, flags, refCol);
			return ret != 0;
		}

		public static bool ColorPicker4(byte* label, float* col, ImGuiColorEditFlags flags)
		{
			byte ret = ColorPicker4Native(label, col, flags, (float*)(default));
			return ret != 0;
		}

		public static bool ColorPicker4(byte* label, float* col)
		{
			byte ret = ColorPicker4Native(label, col, (ImGuiColorEditFlags)(0), (float*)(default));
			return ret != 0;
		}

		public static bool ColorPicker4(ref byte label, float* col, ImGuiColorEditFlags flags, float* refCol)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorPicker4Native((byte*)plabel, col, flags, refCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4(ref byte label, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorPicker4Native((byte*)plabel, col, flags, (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4(ref byte label, float* col)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorPicker4Native((byte*)plabel, col, (ImGuiColorEditFlags)(0), (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4(string label, float* col, ImGuiColorEditFlags flags, float* refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker4Native(pStr0, col, flags, refCol);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorPicker4(string label, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker4Native(pStr0, col, flags, (float*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorPicker4(string label, float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker4Native(pStr0, col, (ImGuiColorEditFlags)(0), (float*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorPicker4(byte* label, ref float col, ImGuiColorEditFlags flags, float* refCol)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, refCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4(byte* label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4(byte* label, ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4(byte* label, ref Vector4 col, ImGuiColorEditFlags flags, float* refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, refCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4(byte* label, ref Vector4 col, ImGuiColorEditFlags flags)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4(byte* label, ref Vector4 col)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4(ref byte label, ref float col, ImGuiColorEditFlags flags, float* refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, refCol);
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4(ref byte label, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, (float*)(default));
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4(ref byte label, ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4(string label, ref Vector4 col, ImGuiColorEditFlags flags, float* refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(pStr0, (float*)pcol, flags, refCol);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ColorPicker4(string label, ref Vector4 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(pStr0, (float*)pcol, flags, (float*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ColorPicker4(string label, ref Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ColorPicker4(byte* label, float* col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (float* prefCol = &refCol)
			{
				byte ret = ColorPicker4Native(label, col, flags, (float*)prefCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4(ref byte label, float* col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native((byte*)plabel, col, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4(string label, float* col, ImGuiColorEditFlags flags, ref float refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* prefCol = &refCol)
			{
				byte ret = ColorPicker4Native(pStr0, col, flags, (float*)prefCol);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ColorPicker4(byte* label, ref float col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (float* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4(byte* label, ref Vector4 col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4(ref byte label, ref float col, ImGuiColorEditFlags flags, ref float refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					fixed (float* prefCol = &refCol)
					{
						byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, (float*)prefCol);
						return ret != 0;
					}
				}
			}
		}

		public static bool ColorPicker4(string label, ref Vector4 col, ImGuiColorEditFlags flags, ref float refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(pStr0, (float*)pcol, flags, (float*)prefCol);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorButton")]
		internal static extern byte ColorButtonNative(byte* descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size);

		public static bool ColorButton(byte* descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			byte ret = ColorButtonNative(descId, col, flags, size);
			return ret != 0;
		}

		public static bool ColorButton(byte* descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			byte ret = ColorButtonNative(descId, col, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool ColorButton(byte* descId, Vector4 col)
		{
			byte ret = ColorButtonNative(descId, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool ColorButton(ref byte descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, flags, size);
				return ret != 0;
			}
		}

		public static bool ColorButton(ref byte descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool ColorButton(ref byte descId, Vector4 col)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool ColorButton(string descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorButtonNative(pStr0, col, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorButton(string descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorButtonNative(pStr0, col, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ColorButton(string descId, Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorButtonNative(pStr0, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetColorEditOptions")]
		internal static extern void SetColorEditOptionsNative(ImGuiColorEditFlags flags);

		public static void SetColorEditOptions(ImGuiColorEditFlags flags)
		{
			SetColorEditOptionsNative(flags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNode_Str")]
		internal static extern byte TreeNodeNative(byte* label);

		public static bool TreeNode(byte* label)
		{
			byte ret = TreeNodeNative(label);
			return ret != 0;
		}

		public static bool TreeNode(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TreeNodeNative((byte*)plabel);
				return ret != 0;
			}
		}

		public static bool TreeNode(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNode_StrStr")]
		internal static extern byte TreeNodeNative(byte* strId, byte* fmt);

		public static bool TreeNode(byte* strId, byte* fmt)
		{
			byte ret = TreeNodeNative(strId, fmt);
			return ret != 0;
		}

		public static bool TreeNode(ref byte strId, byte* fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = TreeNodeNative((byte*)pstrId, fmt);
				return ret != 0;
			}
		}

		public static bool TreeNode(string strId, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNode(byte* strId, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeNative(strId, (byte*)pfmt);
				return ret != 0;
			}
		}

		public static bool TreeNode(byte* strId, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(strId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNode(ref byte strId, ref byte fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					byte ret = TreeNodeNative((byte*)pstrId, (byte*)pfmt);
					return ret != 0;
				}
			}
		}

		public static bool TreeNode(string strId, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNode_Ptr")]
		internal static extern byte TreeNodeNative(void* ptrId, byte* fmt);

		public static bool TreeNode(void* ptrId, byte* fmt)
		{
			byte ret = TreeNodeNative(ptrId, fmt);
			return ret != 0;
		}

		public static bool TreeNode(void* ptrId, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeNative(ptrId, (byte*)pfmt);
				return ret != 0;
			}
		}

		public static bool TreeNode(void* ptrId, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(ptrId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeV_Str")]
		internal static extern byte TreeNodeVNative(byte* strId, byte* fmt, nuint args);

		public static bool TreeNodeV(byte* strId, byte* fmt, nuint args)
		{
			byte ret = TreeNodeVNative(strId, fmt, args);
			return ret != 0;
		}

		public static bool TreeNodeV(ref byte strId, byte* fmt, nuint args)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = TreeNodeVNative((byte*)pstrId, fmt, args);
				return ret != 0;
			}
		}

		public static bool TreeNodeV(string strId, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeVNative(pStr0, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeV(byte* strId, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeVNative(strId, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		public static bool TreeNodeV(byte* strId, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeVNative(strId, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeV(ref byte strId, ref byte fmt, nuint args)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					byte ret = TreeNodeVNative((byte*)pstrId, (byte*)pfmt, args);
					return ret != 0;
				}
			}
		}

		public static bool TreeNodeV(string strId, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeVNative(pStr0, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeV_Ptr")]
		internal static extern byte TreeNodeVNative(void* ptrId, byte* fmt, nuint args);

		public static bool TreeNodeV(void* ptrId, byte* fmt, nuint args)
		{
			byte ret = TreeNodeVNative(ptrId, fmt, args);
			return ret != 0;
		}

		public static bool TreeNodeV(void* ptrId, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeVNative(ptrId, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		public static bool TreeNodeV(void* ptrId, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeVNative(ptrId, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeEx_Str")]
		internal static extern byte TreeNodeExNative(byte* label, ImGuiTreeNodeFlags flags);

		public static bool TreeNodeEx(byte* label, ImGuiTreeNodeFlags flags)
		{
			byte ret = TreeNodeExNative(label, flags);
			return ret != 0;
		}

		public static bool TreeNodeEx(byte* label)
		{
			byte ret = TreeNodeExNative(label, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}

		public static bool TreeNodeEx(ref byte label, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TreeNodeExNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		public static bool TreeNodeEx(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TreeNodeExNative((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		public static bool TreeNodeEx(string label, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeEx(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(pStr0, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeEx_StrStr")]
		internal static extern byte TreeNodeExNative(byte* strId, ImGuiTreeNodeFlags flags, byte* fmt);

		public static bool TreeNodeEx(byte* strId, ImGuiTreeNodeFlags flags, byte* fmt)
		{
			byte ret = TreeNodeExNative(strId, flags, fmt);
			return ret != 0;
		}

		public static bool TreeNodeEx(ref byte strId, ImGuiTreeNodeFlags flags, byte* fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = TreeNodeExNative((byte*)pstrId, flags, fmt);
				return ret != 0;
			}
		}

		public static bool TreeNodeEx(string strId, ImGuiTreeNodeFlags flags, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(pStr0, flags, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeEx(byte* strId, ImGuiTreeNodeFlags flags, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExNative(strId, flags, (byte*)pfmt);
				return ret != 0;
			}
		}

		public static bool TreeNodeEx(byte* strId, ImGuiTreeNodeFlags flags, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(strId, flags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeEx(ref byte strId, ImGuiTreeNodeFlags flags, ref byte fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					byte ret = TreeNodeExNative((byte*)pstrId, flags, (byte*)pfmt);
					return ret != 0;
				}
			}
		}

		public static bool TreeNodeEx(string strId, ImGuiTreeNodeFlags flags, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeExNative(pStr0, flags, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeEx_Ptr")]
		internal static extern byte TreeNodeExNative(void* ptrId, ImGuiTreeNodeFlags flags, byte* fmt);

		public static bool TreeNodeEx(void* ptrId, ImGuiTreeNodeFlags flags, byte* fmt)
		{
			byte ret = TreeNodeExNative(ptrId, flags, fmt);
			return ret != 0;
		}

		public static bool TreeNodeEx(void* ptrId, ImGuiTreeNodeFlags flags, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExNative(ptrId, flags, (byte*)pfmt);
				return ret != 0;
			}
		}

		public static bool TreeNodeEx(void* ptrId, ImGuiTreeNodeFlags flags, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(ptrId, flags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeExV_Str")]
		internal static extern byte TreeNodeExVNative(byte* strId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args);

		public static bool TreeNodeExV(byte* strId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args)
		{
			byte ret = TreeNodeExVNative(strId, flags, fmt, args);
			return ret != 0;
		}

		public static bool TreeNodeExV(ref byte strId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = TreeNodeExVNative((byte*)pstrId, flags, fmt, args);
				return ret != 0;
			}
		}

		public static bool TreeNodeExV(string strId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExVNative(pStr0, flags, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeExV(byte* strId, ImGuiTreeNodeFlags flags, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExVNative(strId, flags, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		public static bool TreeNodeExV(byte* strId, ImGuiTreeNodeFlags flags, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExVNative(strId, flags, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeExV(ref byte strId, ImGuiTreeNodeFlags flags, ref byte fmt, nuint args)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					byte ret = TreeNodeExVNative((byte*)pstrId, flags, (byte*)pfmt, args);
					return ret != 0;
				}
			}
		}

		public static bool TreeNodeExV(string strId, ImGuiTreeNodeFlags flags, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeExVNative(pStr0, flags, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeExV_Ptr")]
		internal static extern byte TreeNodeExVNative(void* ptrId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args);

		public static bool TreeNodeExV(void* ptrId, ImGuiTreeNodeFlags flags, byte* fmt, nuint args)
		{
			byte ret = TreeNodeExVNative(ptrId, flags, fmt, args);
			return ret != 0;
		}

		public static bool TreeNodeExV(void* ptrId, ImGuiTreeNodeFlags flags, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExVNative(ptrId, flags, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		public static bool TreeNodeExV(void* ptrId, ImGuiTreeNodeFlags flags, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExVNative(ptrId, flags, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreePush_Str")]
		internal static extern void TreePushNative(byte* strId);

		public static void TreePush(byte* strId)
		{
			TreePushNative(strId);
		}

		public static void TreePush(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				TreePushNative((byte*)pstrId);
			}
		}

		public static void TreePush(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TreePushNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreePush_Ptr")]
		internal static extern void TreePushNative(void* ptrId);

		public static void TreePush(void* ptrId)
		{
			TreePushNative(ptrId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreePop")]
		internal static extern void TreePopNative();

		public static void TreePop()
		{
			TreePopNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTreeNodeToLabelSpacing")]
		internal static extern float GetTreeNodeToLabelSpacingNative();

		public static float GetTreeNodeToLabelSpacing()
		{
			float ret = GetTreeNodeToLabelSpacingNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCollapsingHeader_TreeNodeFlags")]
		internal static extern byte CollapsingHeaderNative(byte* label, ImGuiTreeNodeFlags flags);

		public static bool CollapsingHeader(byte* label, ImGuiTreeNodeFlags flags)
		{
			byte ret = CollapsingHeaderNative(label, flags);
			return ret != 0;
		}

		public static bool CollapsingHeader(byte* label)
		{
			byte ret = CollapsingHeaderNative(label, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}

		public static bool CollapsingHeader(ref byte label, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		public static bool CollapsingHeader(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		public static bool CollapsingHeader(string label, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CollapsingHeaderNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CollapsingHeader(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CollapsingHeaderNative(pStr0, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCollapsingHeader_BoolPtr")]
		internal static extern byte CollapsingHeaderNative(byte* label, bool* pVisible, ImGuiTreeNodeFlags flags);

		public static bool CollapsingHeader(byte* label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			byte ret = CollapsingHeaderNative(label, pVisible, flags);
			return ret != 0;
		}

		public static bool CollapsingHeader(byte* label, bool* pVisible)
		{
			byte ret = CollapsingHeaderNative(label, pVisible, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}

		public static bool CollapsingHeader(ref byte label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, pVisible, flags);
				return ret != 0;
			}
		}

		public static bool CollapsingHeader(ref byte label, bool* pVisible)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, pVisible, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		public static bool CollapsingHeader(string label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CollapsingHeaderNative(pStr0, pVisible, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CollapsingHeader(string label, bool* pVisible)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CollapsingHeaderNative(pStr0, pVisible, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CollapsingHeader(byte* label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(label, (bool*)ppVisible, flags);
				return ret != 0;
			}
		}

		public static bool CollapsingHeader(byte* label, ref bool pVisible)
		{
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(label, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		public static bool CollapsingHeader(ref byte label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = CollapsingHeaderNative((byte*)plabel, (bool*)ppVisible, flags);
					return ret != 0;
				}
			}
		}

		public static bool CollapsingHeader(ref byte label, ref bool pVisible)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = CollapsingHeaderNative((byte*)plabel, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool CollapsingHeader(string label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(pStr0, (bool*)ppVisible, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool CollapsingHeader(string label, ref bool pVisible)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(pStr0, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextItemOpen")]
		internal static extern void SetNextItemOpenNative(byte isOpen, ImGuiCond cond);

		public static void SetNextItemOpen(bool isOpen, ImGuiCond cond)
		{
			SetNextItemOpenNative(isOpen ? (byte)1 : (byte)0, cond);
		}

		public static void SetNextItemOpen(bool isOpen)
		{
			SetNextItemOpenNative(isOpen ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSelectable_Bool")]
		internal static extern byte SelectableNative(byte* label, byte selected, ImGuiSelectableFlags flags, Vector2 size);

		public static bool Selectable(byte* label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, flags, size);
			return ret != 0;
		}

		public static bool Selectable(byte* label, bool selected, ImGuiSelectableFlags flags)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable(byte* label, bool selected)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable(byte* label)
		{
			byte ret = SelectableNative(label, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable(ref byte label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, flags, size);
				return ret != 0;
			}
		}

		public static bool Selectable(ref byte label, bool selected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable(ref byte label, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable(string label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, selected ? (byte)1 : (byte)0, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Selectable(string label, bool selected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Selectable(string label, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Selectable(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSelectable_BoolPtr")]
		internal static extern byte SelectableNative(byte* label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size);

		public static bool Selectable(byte* label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte ret = SelectableNative(label, pSelected, flags, size);
			return ret != 0;
		}

		public static bool Selectable(byte* label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			byte ret = SelectableNative(label, pSelected, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable(byte* label, bool* pSelected)
		{
			byte ret = SelectableNative(label, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable(ref byte label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, flags, size);
				return ret != 0;
			}
		}

		public static bool Selectable(ref byte label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable(ref byte label, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable(string label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, pSelected, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Selectable(string label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, pSelected, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Selectable(string label, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Selectable(byte* label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (bool*)ppSelected, flags, size);
				return ret != 0;
			}
		}

		public static bool Selectable(byte* label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable(byte* label, ref bool pSelected)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable(ref byte label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, flags, size);
					return ret != 0;
				}
			}
		}

		public static bool Selectable(ref byte label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}

		public static bool Selectable(ref byte label, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}

		public static bool Selectable(string label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(pStr0, (bool*)ppSelected, flags, size);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Selectable(string label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(pStr0, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Selectable(string label, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(pStr0, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginListBox")]
		internal static extern byte BeginListBoxNative(byte* label, Vector2 size);

		public static bool BeginListBox(byte* label, Vector2 size)
		{
			byte ret = BeginListBoxNative(label, size);
			return ret != 0;
		}

		public static bool BeginListBox(byte* label)
		{
			byte ret = BeginListBoxNative(label, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool BeginListBox(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginListBoxNative((byte*)plabel, size);
				return ret != 0;
			}
		}

		public static bool BeginListBox(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginListBoxNative((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool BeginListBox(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginListBoxNative(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginListBox(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginListBoxNative(pStr0, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndListBox")]
		internal static extern void EndListBoxNative();

		public static void EndListBox()
		{
			EndListBoxNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igListBox_Str_arr")]
		internal static extern byte ListBoxNative(byte* label, int* currentItem, byte** items, int itemsCount, int heightInItems);

		public static bool ListBox(byte* label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			byte ret = ListBoxNative(label, currentItem, items, itemsCount, heightInItems);
			return ret != 0;
		}

		public static bool ListBox(byte* label, int* currentItem, byte** items, int itemsCount)
		{
			byte ret = ListBoxNative(label, currentItem, items, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool ListBox(ref byte label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ListBoxNative((byte*)plabel, currentItem, items, itemsCount, heightInItems);
				return ret != 0;
			}
		}

		public static bool ListBox(ref byte label, int* currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ListBoxNative((byte*)plabel, currentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool ListBox(string label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ListBoxNative(pStr0, currentItem, items, itemsCount, heightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ListBox(string label, int* currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ListBoxNative(pStr0, currentItem, items, itemsCount, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ListBox(byte* label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, items, itemsCount, heightInItems);
				return ret != 0;
			}
		}

		public static bool ListBox(byte* label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool ListBox(ref byte label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ListBoxNative((byte*)plabel, (int*)pcurrentItem, items, itemsCount, heightInItems);
					return ret != 0;
				}
			}
		}

		public static bool ListBox(ref byte label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ListBoxNative((byte*)plabel, (int*)pcurrentItem, items, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}

		public static bool ListBox(string label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(pStr0, (int*)pcurrentItem, items, itemsCount, heightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ListBox(string label, ref int currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(pStr0, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ListBox(byte* label, int* currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			byte ret = ListBoxNative(label, currentItem, pStrArray0, itemsCount, heightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}

		public static bool ListBox(byte* label, int* currentItem, string[] items, int itemsCount)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			byte ret = ListBoxNative(label, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}

		public static bool ListBox(string label, int* currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			byte ret = ListBoxNative(pStr0, currentItem, pStrArray0, itemsCount, heightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ListBox(string label, int* currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
			}
			byte ret = ListBoxNative(pStr0, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ListBox(byte* label, ref int currentItem, string[] items, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				byte ret = ListBoxNative(label, (int*)pcurrentItem, pStrArray0, itemsCount, heightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}

		public static bool ListBox(byte* label, ref int currentItem, string[] items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				byte ret = ListBoxNative(label, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}

		public static bool ListBox(string label, ref int currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				byte ret = ListBoxNative(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, heightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ListBox(string label, ref int currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Marshal.StringToHGlobalAnsi(items[i]);
				}
				byte ret = ListBoxNative(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igListBox_FnBoolPtr")]
		internal static extern byte ListBoxNative(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems);

		public static bool ListBox(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			byte ret = ListBoxNative(label, currentItem, itemsGetter, data, itemsCount, heightInItems);
			return ret != 0;
		}

		public static bool ListBox(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte ret = ListBoxNative(label, currentItem, itemsGetter, data, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool ListBox(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ListBoxNative((byte*)plabel, currentItem, itemsGetter, data, itemsCount, heightInItems);
				return ret != 0;
			}
		}

		public static bool ListBox(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ListBoxNative((byte*)plabel, currentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool ListBox(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ListBoxNative(pStr0, currentItem, itemsGetter, data, itemsCount, heightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ListBox(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ListBoxNative(pStr0, currentItem, itemsGetter, data, itemsCount, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool ListBox(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
				return ret != 0;
			}
		}

		public static bool ListBox(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool ListBox(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ListBoxNative((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
					return ret != 0;
				}
			}
		}

		public static bool ListBox(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ListBoxNative((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}

		public static bool ListBox(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool ListBox(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**>, void*, int, int> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotLines_FloatPtr")]
		internal static extern void PlotLinesNative(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride);

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines(byte* label, float* values, int valuesCount)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, float* values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, values, valuesCount, valuesOffset, pStr1, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
					}
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
					}
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
					}
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
					}
				}
			}
		}

		public static void PlotLines(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotLinesNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
					}
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines(string label, ref float values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotLinesNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotLines_FnFloatPtr")]
		internal static extern void PlotLinesNative(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize);

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
				}
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
				}
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
				}
			}
		}

		public static void PlotLines(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
				}
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotLinesNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotHistogram_FloatPtr")]
		internal static extern void PlotHistogramNative(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride);

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, float* values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, float* values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, pStr1, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, float* values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, values, valuesCount, valuesOffset, pStr1, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(byte* label, ref float values, int valuesCount, int valuesOffset, string overlayText)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
					}
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
					}
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
					}
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
					}
				}
			}
		}

		public static void PlotHistogram(ref byte label, ref float values, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pvalues = &values)
				{
					fixed (byte* poverlayText = &overlayText)
					{
						PlotHistogramNative((byte*)plabel, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
					}
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram(string label, ref float values, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pvalues = &values)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (overlayText != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				PlotHistogramNative(pStr0, (float*)pvalues, valuesCount, valuesOffset, pStr1, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotHistogram_FnFloatPtr")]
		internal static extern void PlotHistogramNative(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize);

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			fixed (byte* plabel = &label)
			{
				PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(byte* label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
				}
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
				}
			}
		}

		public static void PlotHistogram(ref byte label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative((byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
				}
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, graphSize);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram(string label, delegate*<byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PlotHistogramNative(pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igValue_Bool")]
		internal static extern void ValueNative(byte* prefix, byte b);

		public static void Value(byte* prefix, bool b)
		{
			ValueNative(prefix, b ? (byte)1 : (byte)0);
		}

		public static void Value(ref byte prefix, bool b)
		{
			fixed (byte* pprefix = &prefix)
			{
				ValueNative((byte*)pprefix, b ? (byte)1 : (byte)0);
			}
		}

		public static void Value(string prefix, bool b)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ValueNative(pStr0, b ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igValue_Int")]
		internal static extern void ValueNative(byte* prefix, int v);

		public static void Value(byte* prefix, int v)
		{
			ValueNative(prefix, v);
		}

		public static void Value(ref byte prefix, int v)
		{
			fixed (byte* pprefix = &prefix)
			{
				ValueNative((byte*)pprefix, v);
			}
		}

		public static void Value(string prefix, int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ValueNative(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igValue_Uint")]
		internal static extern void ValueNative(byte* prefix, uint v);

		public static void Value(byte* prefix, uint v)
		{
			ValueNative(prefix, v);
		}

		public static void Value(ref byte prefix, uint v)
		{
			fixed (byte* pprefix = &prefix)
			{
				ValueNative((byte*)pprefix, v);
			}
		}

		public static void Value(string prefix, uint v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ValueNative(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igValue_Float")]
		internal static extern void ValueNative(byte* prefix, float v, byte* floatFormat);

		public static void Value(byte* prefix, float v, byte* floatFormat)
		{
			ValueNative(prefix, v, floatFormat);
		}

		public static void Value(byte* prefix, float v)
		{
			ValueNative(prefix, v, (byte*)(default));
		}

		public static void Value(ref byte prefix, float v, byte* floatFormat)
		{
			fixed (byte* pprefix = &prefix)
			{
				ValueNative((byte*)pprefix, v, floatFormat);
			}
		}

		public static void Value(ref byte prefix, float v)
		{
			fixed (byte* pprefix = &prefix)
			{
				ValueNative((byte*)pprefix, v, (byte*)(default));
			}
		}

		public static void Value(string prefix, float v, byte* floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ValueNative(pStr0, v, floatFormat);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Value(string prefix, float v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ValueNative(pStr0, v, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Value(byte* prefix, float v, ref byte floatFormat)
		{
			fixed (byte* pfloatFormat = &floatFormat)
			{
				ValueNative(prefix, v, (byte*)pfloatFormat);
			}
		}

		public static void Value(byte* prefix, float v, string floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (floatFormat != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(floatFormat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(floatFormat, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ValueNative(prefix, v, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Value(ref byte prefix, float v, ref byte floatFormat)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* pfloatFormat = &floatFormat)
				{
					ValueNative((byte*)pprefix, v, (byte*)pfloatFormat);
				}
			}
		}

		public static void Value(string prefix, float v, string floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (floatFormat != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(floatFormat);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(floatFormat, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ValueNative(pStr0, v, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginMenuBar")]
		internal static extern byte BeginMenuBarNative();

		public static bool BeginMenuBar()
		{
			byte ret = BeginMenuBarNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndMenuBar")]
		internal static extern void EndMenuBarNative();

		public static void EndMenuBar()
		{
			EndMenuBarNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginMainMenuBar")]
		internal static extern byte BeginMainMenuBarNative();

		public static bool BeginMainMenuBar()
		{
			byte ret = BeginMainMenuBarNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndMainMenuBar")]
		internal static extern void EndMainMenuBarNative();

		public static void EndMainMenuBar()
		{
			EndMainMenuBarNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginMenu")]
		internal static extern byte BeginMenuNative(byte* label, byte enabled);

		public static bool BeginMenu(byte* label, bool enabled)
		{
			byte ret = BeginMenuNative(label, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool BeginMenu(byte* label)
		{
			byte ret = BeginMenuNative(label, (byte)(1));
			return ret != 0;
		}

		public static bool BeginMenu(ref byte label, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginMenuNative((byte*)plabel, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenu(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginMenuNative((byte*)plabel, (byte)(1));
				return ret != 0;
			}
		}

		public static bool BeginMenu(string label, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuNative(pStr0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginMenu(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuNative(pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndMenu")]
		internal static extern void EndMenuNative();

		public static void EndMenu()
		{
			EndMenuNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMenuItem_Bool")]
		internal static extern byte MenuItemNative(byte* label, byte* shortcut, byte selected, byte enabled);

		public static bool MenuItem(byte* label, byte* shortcut, bool selected, bool enabled)
		{
			byte ret = MenuItemNative(label, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool MenuItem(byte* label, byte* shortcut, bool selected)
		{
			byte ret = MenuItemNative(label, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem(byte* label, byte* shortcut)
		{
			byte ret = MenuItemNative(label, shortcut, (byte)(0), (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem(byte* label)
		{
			byte ret = MenuItemNative(label, (byte*)(default), (byte)(0), (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem(ref byte label, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemNative((byte*)plabel, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemNative((byte*)plabel, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemNative((byte*)plabel, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemNative((byte*)plabel, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem(string label, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(string label, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(pStr0, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(string label, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(pStr0, shortcut, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(pStr0, (byte*)(default), (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(byte* label, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, bool selected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem(byte* label, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(byte* label, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(byte* label, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemNative((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemNative((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemNative((byte*)plabel, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(string label, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemNative(pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(string label, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemNative(pStr0, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(string label, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemNative(pStr0, pStr1, (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMenuItem_BoolPtr")]
		internal static extern byte MenuItemNative(byte* label, byte* shortcut, bool* pSelected, byte enabled);

		public static bool MenuItem(byte* label, byte* shortcut, bool* pSelected, bool enabled)
		{
			byte ret = MenuItemNative(label, shortcut, pSelected, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool MenuItem(byte* label, byte* shortcut, bool* pSelected)
		{
			byte ret = MenuItemNative(label, shortcut, pSelected, (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem(ref byte label, byte* shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemNative((byte*)plabel, shortcut, pSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemNative((byte*)plabel, shortcut, pSelected, (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem(string label, byte* shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(pStr0, shortcut, pSelected, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(string label, byte* shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(pStr0, shortcut, pSelected, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(byte* label, ref byte shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, bool* pSelected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, pSelected, (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem(byte* label, string shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, pSelected, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(byte* label, string shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, pSelected, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemNative((byte*)plabel, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemNative((byte*)plabel, (byte*)pshortcut, pSelected, (byte)(1));
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(string label, string shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemNative(pStr0, pStr1, pSelected, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(string label, string shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemNative(pStr0, pStr1, pSelected, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem(byte* label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(label, shortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItem(byte* label, byte* shortcut, ref bool pSelected)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(label, shortcut, (bool*)ppSelected, (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = MenuItemNative((byte*)plabel, shortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(ref byte label, byte* shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = MenuItemNative((byte*)plabel, shortcut, (bool*)ppSelected, (byte)(1));
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(string label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(pStr0, shortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool MenuItem(string label, byte* shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(pStr0, shortcut, (bool*)ppSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = MenuItemNative(label, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(byte* label, ref byte shortcut, ref bool pSelected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = MenuItemNative(label, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
					return ret != 0;
				}
			}
		}

		public static bool MenuItem(byte* label, string shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(label, pStr0, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool MenuItem(byte* label, string shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(label, pStr0, (bool*)ppSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = MenuItemNative((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		public static bool MenuItem(ref byte label, ref byte shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = MenuItemNative((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
						return ret != 0;
					}
				}
			}
		}

		public static bool MenuItem(string label, string shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(pStr0, pStr1, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool MenuItem(string label, string shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(pStr0, pStr1, (bool*)ppSelected, (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTooltip")]
		internal static extern byte BeginTooltipNative();

		public static bool BeginTooltip()
		{
			byte ret = BeginTooltipNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndTooltip")]
		internal static extern void EndTooltipNative();

		public static void EndTooltip()
		{
			EndTooltipNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetTooltip")]
		internal static extern void SetTooltipNative(byte* fmt);

		public static void SetTooltip(byte* fmt)
		{
			SetTooltipNative(fmt);
		}

		public static void SetTooltip(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SetTooltipNative((byte*)pfmt);
			}
		}

		public static void SetTooltip(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTooltipNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetTooltipV")]
		internal static extern void SetTooltipVNative(byte* fmt, nuint args);

		public static void SetTooltipV(byte* fmt, nuint args)
		{
			SetTooltipVNative(fmt, args);
		}

		public static void SetTooltipV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				SetTooltipVNative((byte*)pfmt, args);
			}
		}

		public static void SetTooltipV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTooltipVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopup")]
		internal static extern byte BeginPopupNative(byte* strId, ImGuiWindowFlags flags);

		public static bool BeginPopup(byte* strId, ImGuiWindowFlags flags)
		{
			byte ret = BeginPopupNative(strId, flags);
			return ret != 0;
		}

		public static bool BeginPopup(byte* strId)
		{
			byte ret = BeginPopupNative(strId, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginPopup(ref byte strId, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginPopupNative((byte*)pstrId, flags);
				return ret != 0;
			}
		}

		public static bool BeginPopup(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginPopupNative((byte*)pstrId, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginPopup(string strId, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginPopup(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupNative(pStr0, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupModal")]
		internal static extern byte BeginPopupModalNative(byte* name, bool* pOpen, ImGuiWindowFlags flags);

		public static bool BeginPopupModal(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte ret = BeginPopupModalNative(name, pOpen, flags);
			return ret != 0;
		}

		public static bool BeginPopupModal(byte* name, bool* pOpen)
		{
			byte ret = BeginPopupModalNative(name, pOpen, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginPopupModal(byte* name)
		{
			byte ret = BeginPopupModalNative(name, (bool*)(default), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		public static bool BeginPopupModal(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginPopupModalNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		public static bool BeginPopupModal(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginPopupModalNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginPopupModal(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginPopupModalNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginPopupModal(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupModalNative(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginPopupModal(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupModalNative(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginPopupModal(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupModalNative(pStr0, (bool*)(default), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginPopupModal(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginPopupModalNative(name, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}

		public static bool BeginPopupModal(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginPopupModalNative(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginPopupModal(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginPopupModalNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		public static bool BeginPopupModal(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginPopupModalNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool BeginPopupModal(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginPopupModalNative(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool BeginPopupModal(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginPopupModalNative(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndPopup")]
		internal static extern void EndPopupNative();

		public static void EndPopup()
		{
			EndPopupNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igOpenPopup_Str")]
		internal static extern void OpenPopupNative(byte* strId, ImGuiPopupFlags popupFlags);

		public static void OpenPopup(byte* strId, ImGuiPopupFlags popupFlags)
		{
			OpenPopupNative(strId, popupFlags);
		}

		public static void OpenPopup(byte* strId)
		{
			OpenPopupNative(strId, (ImGuiPopupFlags)(0));
		}

		public static void OpenPopup(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				OpenPopupNative((byte*)pstrId, popupFlags);
			}
		}

		public static void OpenPopup(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				OpenPopupNative((byte*)pstrId, (ImGuiPopupFlags)(0));
			}
		}

		public static void OpenPopup(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenPopupNative(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void OpenPopup(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenPopupNative(pStr0, (ImGuiPopupFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igOpenPopup_ID")]
		internal static extern void OpenPopupNative(int id, ImGuiPopupFlags popupFlags);

		public static void OpenPopup(int id, ImGuiPopupFlags popupFlags)
		{
			OpenPopupNative(id, popupFlags);
		}

		public static void OpenPopup(int id)
		{
			OpenPopupNative(id, (ImGuiPopupFlags)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igOpenPopupOnItemClick")]
		internal static extern void OpenPopupOnItemClickNative(byte* strId, ImGuiPopupFlags popupFlags);

		public static void OpenPopupOnItemClick(byte* strId, ImGuiPopupFlags popupFlags)
		{
			OpenPopupOnItemClickNative(strId, popupFlags);
		}

		public static void OpenPopupOnItemClick(byte* strId)
		{
			OpenPopupOnItemClickNative(strId, (ImGuiPopupFlags)(1));
		}

		public static void OpenPopupOnItemClick()
		{
			OpenPopupOnItemClickNative((byte*)(default), (ImGuiPopupFlags)(1));
		}

		public static void OpenPopupOnItemClick(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				OpenPopupOnItemClickNative((byte*)pstrId, popupFlags);
			}
		}

		public static void OpenPopupOnItemClick(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				OpenPopupOnItemClickNative((byte*)pstrId, (ImGuiPopupFlags)(1));
			}
		}

		public static void OpenPopupOnItemClick(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenPopupOnItemClickNative(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void OpenPopupOnItemClick(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenPopupOnItemClickNative(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCloseCurrentPopup")]
		internal static extern void CloseCurrentPopupNative();

		public static void CloseCurrentPopup()
		{
			CloseCurrentPopupNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupContextItem")]
		internal static extern byte BeginPopupContextItemNative(byte* strId, ImGuiPopupFlags popupFlags);

		public static bool BeginPopupContextItem(byte* strId, ImGuiPopupFlags popupFlags)
		{
			byte ret = BeginPopupContextItemNative(strId, popupFlags);
			return ret != 0;
		}

		public static bool BeginPopupContextItem(byte* strId)
		{
			byte ret = BeginPopupContextItemNative(strId, (ImGuiPopupFlags)(1));
			return ret != 0;
		}

		public static bool BeginPopupContextItem()
		{
			byte ret = BeginPopupContextItemNative((byte*)(default), (ImGuiPopupFlags)(1));
			return ret != 0;
		}

		public static bool BeginPopupContextItem(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginPopupContextItemNative((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}

		public static bool BeginPopupContextItem(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginPopupContextItemNative((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}

		public static bool BeginPopupContextItem(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupContextItemNative(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginPopupContextItem(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupContextItemNative(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupContextWindow")]
		internal static extern byte BeginPopupContextWindowNative(byte* strId, ImGuiPopupFlags popupFlags);

		public static bool BeginPopupContextWindow(byte* strId, ImGuiPopupFlags popupFlags)
		{
			byte ret = BeginPopupContextWindowNative(strId, popupFlags);
			return ret != 0;
		}

		public static bool BeginPopupContextWindow(byte* strId)
		{
			byte ret = BeginPopupContextWindowNative(strId, (ImGuiPopupFlags)(1));
			return ret != 0;
		}

		public static bool BeginPopupContextWindow()
		{
			byte ret = BeginPopupContextWindowNative((byte*)(default), (ImGuiPopupFlags)(1));
			return ret != 0;
		}

		public static bool BeginPopupContextWindow(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginPopupContextWindowNative((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}

		public static bool BeginPopupContextWindow(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginPopupContextWindowNative((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}

		public static bool BeginPopupContextWindow(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupContextWindowNative(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginPopupContextWindow(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupContextWindowNative(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupContextVoid")]
		internal static extern byte BeginPopupContextVoidNative(byte* strId, ImGuiPopupFlags popupFlags);

		public static bool BeginPopupContextVoid(byte* strId, ImGuiPopupFlags popupFlags)
		{
			byte ret = BeginPopupContextVoidNative(strId, popupFlags);
			return ret != 0;
		}

		public static bool BeginPopupContextVoid(byte* strId)
		{
			byte ret = BeginPopupContextVoidNative(strId, (ImGuiPopupFlags)(1));
			return ret != 0;
		}

		public static bool BeginPopupContextVoid()
		{
			byte ret = BeginPopupContextVoidNative((byte*)(default), (ImGuiPopupFlags)(1));
			return ret != 0;
		}

		public static bool BeginPopupContextVoid(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginPopupContextVoidNative((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}

		public static bool BeginPopupContextVoid(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginPopupContextVoidNative((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}

		public static bool BeginPopupContextVoid(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupContextVoidNative(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginPopupContextVoid(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginPopupContextVoidNative(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsPopupOpen_Str")]
		internal static extern byte IsPopupOpenNative(byte* strId, ImGuiPopupFlags flags);

		public static bool IsPopupOpen(byte* strId, ImGuiPopupFlags flags)
		{
			byte ret = IsPopupOpenNative(strId, flags);
			return ret != 0;
		}

		public static bool IsPopupOpen(byte* strId)
		{
			byte ret = IsPopupOpenNative(strId, (ImGuiPopupFlags)(0));
			return ret != 0;
		}

		public static bool IsPopupOpen(ref byte strId, ImGuiPopupFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = IsPopupOpenNative((byte*)pstrId, flags);
				return ret != 0;
			}
		}

		public static bool IsPopupOpen(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = IsPopupOpenNative((byte*)pstrId, (ImGuiPopupFlags)(0));
				return ret != 0;
			}
		}

		public static bool IsPopupOpen(string strId, ImGuiPopupFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsPopupOpenNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool IsPopupOpen(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsPopupOpenNative(pStr0, (ImGuiPopupFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTable")]
		internal static extern byte BeginTableNative(byte* strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth);

		public static bool BeginTable(byte* strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte ret = BeginTableNative(strId, column, flags, outerSize, innerWidth);
			return ret != 0;
		}

		public static bool BeginTable(byte* strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte ret = BeginTableNative(strId, column, flags, outerSize, (float)(0.0f));
			return ret != 0;
		}

		public static bool BeginTable(byte* strId, int column, ImGuiTableFlags flags)
		{
			byte ret = BeginTableNative(strId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			return ret != 0;
		}

		public static bool BeginTable(byte* strId, int column)
		{
			byte ret = BeginTableNative(strId, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			return ret != 0;
		}

		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, column, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, column, flags, outerSize, (float)(0.0f));
				return ret != 0;
			}
		}

		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}

		public static bool BeginTable(ref byte strId, int column)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTableNative((byte*)pstrId, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}

		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, column, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, column, flags, outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginTable(string strId, int column)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableNative(pStr0, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndTable")]
		internal static extern void EndTableNative();

		public static void EndTable()
		{
			EndTableNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableNextRow")]
		internal static extern void TableNextRowNative(ImGuiTableRowFlags rowFlags, float minRowHeight);

		public static void TableNextRow(ImGuiTableRowFlags rowFlags, float minRowHeight)
		{
			TableNextRowNative(rowFlags, minRowHeight);
		}

		public static void TableNextRow(ImGuiTableRowFlags rowFlags)
		{
			TableNextRowNative(rowFlags, (float)(0.0f));
		}

		public static void TableNextRow()
		{
			TableNextRowNative((ImGuiTableRowFlags)(0), (float)(0.0f));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableNextColumn")]
		internal static extern byte TableNextColumnNative();

		public static bool TableNextColumn()
		{
			byte ret = TableNextColumnNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnIndex")]
		internal static extern byte TableSetColumnIndexNative(int columnN);

		public static bool TableSetColumnIndex(int columnN)
		{
			byte ret = TableSetColumnIndexNative(columnN);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetupColumn")]
		internal static extern void TableSetupColumnNative(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight, int userId);

		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight, int userId)
		{
			TableSetupColumnNative(label, flags, initWidthOrWeight, userId);
		}

		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			TableSetupColumnNative(label, flags, initWidthOrWeight, (int)(0));
		}

		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags)
		{
			TableSetupColumnNative(label, flags, (float)(0.0f), (int)(0));
		}

		public static void TableSetupColumn(byte* label)
		{
			TableSetupColumnNative(label, (ImGuiTableColumnFlags)(0), (float)(0.0f), (int)(0));
		}

		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, float initWidthOrWeight, int userId)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, flags, initWidthOrWeight, userId);
			}
		}

		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, flags, initWidthOrWeight, (int)(0));
			}
		}

		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, flags, (float)(0.0f), (int)(0));
			}
		}

		public static void TableSetupColumn(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				TableSetupColumnNative((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), (int)(0));
			}
		}

		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, float initWidthOrWeight, int userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, flags, initWidthOrWeight, userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, flags, initWidthOrWeight, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, flags, (float)(0.0f), (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TableSetupColumn(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableSetupColumnNative(pStr0, (ImGuiTableColumnFlags)(0), (float)(0.0f), (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetupScrollFreeze")]
		internal static extern void TableSetupScrollFreezeNative(int cols, int rows);

		public static void TableSetupScrollFreeze(int cols, int rows)
		{
			TableSetupScrollFreezeNative(cols, rows);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableHeadersRow")]
		internal static extern void TableHeadersRowNative();

		public static void TableHeadersRow()
		{
			TableHeadersRowNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableHeader")]
		internal static extern void TableHeaderNative(byte* label);

		public static void TableHeader(byte* label)
		{
			TableHeaderNative(label);
		}

		public static void TableHeader(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				TableHeaderNative((byte*)plabel);
			}
		}

		public static void TableHeader(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TableHeaderNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetSortSpecs")]
		internal static extern ImGuiTableSortSpecs* TableGetSortSpecsNative();

		public static ImGuiTableSortSpecsPtr TableGetSortSpecs()
		{
			ImGuiTableSortSpecsPtr ret = TableGetSortSpecsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnCount")]
		internal static extern int TableGetColumnCountNative();

		public static int TableGetColumnCount()
		{
			int ret = TableGetColumnCountNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnIndex")]
		internal static extern int TableGetColumnIndexNative();

		public static int TableGetColumnIndex()
		{
			int ret = TableGetColumnIndexNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetRowIndex")]
		internal static extern int TableGetRowIndexNative();

		public static int TableGetRowIndex()
		{
			int ret = TableGetRowIndexNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnName_Int")]
		internal static extern byte* TableGetColumnNameNative(int columnN);

		public static byte* TableGetColumnName(int columnN)
		{
			byte* ret = TableGetColumnNameNative(columnN);
			return ret;
		}

		public static byte* TableGetColumnName()
		{
			byte* ret = TableGetColumnNameNative((int)(-1));
			return ret;
		}

		public static string TableGetColumnNameS()
		{
			string ret = Utils.DecodeStringUTF8(TableGetColumnNameNative((int)(-1)));
			return ret;
		}

		public static string TableGetColumnNameS(int columnN)
		{
			string ret = Utils.DecodeStringUTF8(TableGetColumnNameNative(columnN));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnFlags")]
		internal static extern ImGuiTableColumnFlags TableGetColumnFlagsNative(int columnN);

		public static ImGuiTableColumnFlags TableGetColumnFlags(int columnN)
		{
			ImGuiTableColumnFlags ret = TableGetColumnFlagsNative(columnN);
			return ret;
		}

		public static ImGuiTableColumnFlags TableGetColumnFlags()
		{
			ImGuiTableColumnFlags ret = TableGetColumnFlagsNative((int)(-1));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnEnabled")]
		internal static extern void TableSetColumnEnabledNative(int columnN, byte v);

		public static void TableSetColumnEnabled(int columnN, bool v)
		{
			TableSetColumnEnabledNative(columnN, v ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetBgColor")]
		internal static extern void TableSetBgColorNative(ImGuiTableBgTarget target, uint color, int columnN);

		public static void TableSetBgColor(ImGuiTableBgTarget target, uint color, int columnN)
		{
			TableSetBgColorNative(target, color, columnN);
		}

		public static void TableSetBgColor(ImGuiTableBgTarget target, uint color)
		{
			TableSetBgColorNative(target, color, (int)(-1));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColumns")]
		internal static extern void ColumnsNative(int count, byte* id, byte border);

		public static void Columns(int count, byte* id, bool border)
		{
			ColumnsNative(count, id, border ? (byte)1 : (byte)0);
		}

		public static void Columns(int count, byte* id)
		{
			ColumnsNative(count, id, (byte)(1));
		}

		public static void Columns(int count)
		{
			ColumnsNative(count, (byte*)(default), (byte)(1));
		}

		public static void Columns()
		{
			ColumnsNative((int)(1), (byte*)(default), (byte)(1));
		}

		public static void Columns(int count, ref byte id, bool border)
		{
			fixed (byte* pid = &id)
			{
				ColumnsNative(count, (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}

		public static void Columns(int count, ref byte id)
		{
			fixed (byte* pid = &id)
			{
				ColumnsNative(count, (byte*)pid, (byte)(1));
			}
		}

		public static void Columns(int count, string id, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColumnsNative(count, pStr0, border ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Columns(int count, string id)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColumnsNative(count, pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNextColumn")]
		internal static extern void NextColumnNative();

		public static void NextColumn()
		{
			NextColumnNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnIndex")]
		internal static extern int GetColumnIndexNative();

		public static int GetColumnIndex()
		{
			int ret = GetColumnIndexNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnWidth")]
		internal static extern float GetColumnWidthNative(int columnIndex);

		public static float GetColumnWidth(int columnIndex)
		{
			float ret = GetColumnWidthNative(columnIndex);
			return ret;
		}

		public static float GetColumnWidth()
		{
			float ret = GetColumnWidthNative((int)(-1));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetColumnWidth")]
		internal static extern void SetColumnWidthNative(int columnIndex, float width);

		public static void SetColumnWidth(int columnIndex, float width)
		{
			SetColumnWidthNative(columnIndex, width);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnOffset")]
		internal static extern float GetColumnOffsetNative(int columnIndex);

		public static float GetColumnOffset(int columnIndex)
		{
			float ret = GetColumnOffsetNative(columnIndex);
			return ret;
		}

		public static float GetColumnOffset()
		{
			float ret = GetColumnOffsetNative((int)(-1));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetColumnOffset")]
		internal static extern void SetColumnOffsetNative(int columnIndex, float offsetX);

		public static void SetColumnOffset(int columnIndex, float offsetX)
		{
			SetColumnOffsetNative(columnIndex, offsetX);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnsCount")]
		internal static extern int GetColumnsCountNative();

		public static int GetColumnsCount()
		{
			int ret = GetColumnsCountNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTabBar")]
		internal static extern byte BeginTabBarNative(byte* strId, ImGuiTabBarFlags flags);

		public static bool BeginTabBar(byte* strId, ImGuiTabBarFlags flags)
		{
			byte ret = BeginTabBarNative(strId, flags);
			return ret != 0;
		}

		public static bool BeginTabBar(byte* strId)
		{
			byte ret = BeginTabBarNative(strId, (ImGuiTabBarFlags)(0));
			return ret != 0;
		}

		public static bool BeginTabBar(ref byte strId, ImGuiTabBarFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTabBarNative((byte*)pstrId, flags);
				return ret != 0;
			}
		}

		public static bool BeginTabBar(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginTabBarNative((byte*)pstrId, (ImGuiTabBarFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginTabBar(string strId, ImGuiTabBarFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabBarNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginTabBar(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabBarNative(pStr0, (ImGuiTabBarFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndTabBar")]
		internal static extern void EndTabBarNative();

		public static void EndTabBar()
		{
			EndTabBarNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTabItem")]
		internal static extern byte BeginTabItemNative(byte* label, bool* pOpen, ImGuiTabItemFlags flags);

		public static bool BeginTabItem(byte* label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			byte ret = BeginTabItemNative(label, pOpen, flags);
			return ret != 0;
		}

		public static bool BeginTabItem(byte* label, bool* pOpen)
		{
			byte ret = BeginTabItemNative(label, pOpen, (ImGuiTabItemFlags)(0));
			return ret != 0;
		}

		public static bool BeginTabItem(byte* label)
		{
			byte ret = BeginTabItemNative(label, (bool*)(default), (ImGuiTabItemFlags)(0));
			return ret != 0;
		}

		public static bool BeginTabItem(ref byte label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, pOpen, flags);
				return ret != 0;
			}
		}

		public static bool BeginTabItem(ref byte label, bool* pOpen)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, pOpen, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginTabItem(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginTabItemNative((byte*)plabel, (bool*)(default), (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginTabItem(string label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabItemNative(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginTabItem(string label, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabItemNative(pStr0, pOpen, (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginTabItem(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTabItemNative(pStr0, (bool*)(default), (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginTabItem(byte* label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(label, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}

		public static bool BeginTabItem(byte* label, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(label, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		public static bool BeginTabItem(ref byte label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginTabItemNative((byte*)plabel, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		public static bool BeginTabItem(ref byte label, ref bool pOpen)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginTabItemNative((byte*)plabel, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
					return ret != 0;
				}
			}
		}

		public static bool BeginTabItem(string label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool BeginTabItem(string label, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(pStr0, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndTabItem")]
		internal static extern void EndTabItemNative();

		public static void EndTabItem()
		{
			EndTabItemNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemButton")]
		internal static extern byte TabItemButtonNative(byte* label, ImGuiTabItemFlags flags);

		public static bool TabItemButton(byte* label, ImGuiTabItemFlags flags)
		{
			byte ret = TabItemButtonNative(label, flags);
			return ret != 0;
		}

		public static bool TabItemButton(byte* label)
		{
			byte ret = TabItemButtonNative(label, (ImGuiTabItemFlags)(0));
			return ret != 0;
		}

		public static bool TabItemButton(ref byte label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TabItemButtonNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		public static bool TabItemButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TabItemButtonNative((byte*)plabel, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}

		public static bool TabItemButton(string label, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TabItemButtonNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TabItemButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TabItemButtonNative(pStr0, (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetTabItemClosed")]
		internal static extern void SetTabItemClosedNative(byte* tabOrDockedWindowLabel);

		public static void SetTabItemClosed(byte* tabOrDockedWindowLabel)
		{
			SetTabItemClosedNative(tabOrDockedWindowLabel);
		}

		public static void SetTabItemClosed(ref byte tabOrDockedWindowLabel)
		{
			fixed (byte* ptabOrDockedWindowLabel = &tabOrDockedWindowLabel)
			{
				SetTabItemClosedNative((byte*)ptabOrDockedWindowLabel);
			}
		}

		public static void SetTabItemClosed(string tabOrDockedWindowLabel)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tabOrDockedWindowLabel != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tabOrDockedWindowLabel);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tabOrDockedWindowLabel, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTabItemClosedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockSpace")]
		internal static extern int DockSpaceNative(int id, Vector2 size, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass);

		public static int DockSpace(int id, Vector2 size, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass)
		{
			int ret = DockSpaceNative(id, size, flags, windowClass);
			return ret;
		}

		public static int DockSpace(int id, Vector2 size, ImGuiDockNodeFlags flags)
		{
			int ret = DockSpaceNative(id, size, flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		public static int DockSpace(int id, Vector2 size)
		{
			int ret = DockSpaceNative(id, size, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		public static int DockSpace(int id)
		{
			int ret = DockSpaceNative(id, (Vector2)(new Vector2(0,0)), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		public static int DockSpace(int id, Vector2 size, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				int ret = DockSpaceNative(id, size, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockSpaceOverViewport")]
		internal static extern int DockSpaceOverViewportNative(ImGuiViewport* viewport, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass);

		public static int DockSpaceOverViewport(ImGuiViewport* viewport, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass)
		{
			int ret = DockSpaceOverViewportNative(viewport, flags, windowClass);
			return ret;
		}

		public static int DockSpaceOverViewport(ImGuiViewport* viewport, ImGuiDockNodeFlags flags)
		{
			int ret = DockSpaceOverViewportNative(viewport, flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		public static int DockSpaceOverViewport(ImGuiViewport* viewport)
		{
			int ret = DockSpaceOverViewportNative(viewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		public static int DockSpaceOverViewport()
		{
			int ret = DockSpaceOverViewportNative((ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		public static int DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ImGuiWindowClass* windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				int ret = DockSpaceOverViewportNative((ImGuiViewport*)pviewport, flags, windowClass);
				return ret;
			}
		}

		public static int DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				int ret = DockSpaceOverViewportNative((ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)(default));
				return ret;
			}
		}

		public static int DockSpaceOverViewport(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				int ret = DockSpaceOverViewportNative((ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
				return ret;
			}
		}

		public static int DockSpaceOverViewport(ImGuiViewport* viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				int ret = DockSpaceOverViewportNative(viewport, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		public static int DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				fixed (ImGuiWindowClass* pwindowClass = &windowClass)
				{
					int ret = DockSpaceOverViewportNative((ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)pwindowClass);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowDockID")]
		internal static extern void SetNextWindowDockIDNative(int dockId, ImGuiCond cond);

		public static void SetNextWindowDockID(int dockId, ImGuiCond cond)
		{
			SetNextWindowDockIDNative(dockId, cond);
		}

		public static void SetNextWindowDockID(int dockId)
		{
			SetNextWindowDockIDNative(dockId, (ImGuiCond)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextWindowClass")]
		internal static extern void SetNextWindowClassNative(ImGuiWindowClass* windowClass);

		public static void SetNextWindowClass(ImGuiWindowClass* windowClass)
		{
			SetNextWindowClassNative(windowClass);
		}

		public static void SetNextWindowClass(ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				SetNextWindowClassNative((ImGuiWindowClass*)pwindowClass);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowDockID")]
		internal static extern int GetWindowDockIDNative();

		public static int GetWindowDockID()
		{
			int ret = GetWindowDockIDNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowDocked")]
		internal static extern byte IsWindowDockedNative();

		public static bool IsWindowDocked()
		{
			byte ret = IsWindowDockedNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogToTTY")]
		internal static extern void LogToTTYNative(int autoOpenDepth);

		public static void LogToTTY(int autoOpenDepth)
		{
			LogToTTYNative(autoOpenDepth);
		}

		public static void LogToTTY()
		{
			LogToTTYNative((int)(-1));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogToFile")]
		internal static extern void LogToFileNative(int autoOpenDepth, byte* filename);

		public static void LogToFile(int autoOpenDepth, byte* filename)
		{
			LogToFileNative(autoOpenDepth, filename);
		}

		public static void LogToFile(int autoOpenDepth)
		{
			LogToFileNative(autoOpenDepth, (byte*)(default));
		}

		public static void LogToFile()
		{
			LogToFileNative((int)(-1), (byte*)(default));
		}

		public static void LogToFile(int autoOpenDepth, ref byte filename)
		{
			fixed (byte* pfilename = &filename)
			{
				LogToFileNative(autoOpenDepth, (byte*)pfilename);
			}
		}

		public static void LogToFile(int autoOpenDepth, string filename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogToFileNative(autoOpenDepth, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogToClipboard")]
		internal static extern void LogToClipboardNative(int autoOpenDepth);

		public static void LogToClipboard(int autoOpenDepth)
		{
			LogToClipboardNative(autoOpenDepth);
		}

		public static void LogToClipboard()
		{
			LogToClipboardNative((int)(-1));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogFinish")]
		internal static extern void LogFinishNative();

		public static void LogFinish()
		{
			LogFinishNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogButtons")]
		internal static extern void LogButtonsNative();

		public static void LogButtons()
		{
			LogButtonsNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogTextV")]
		internal static extern void LogTextVNative(byte* fmt, nuint args);

		public static void LogTextV(byte* fmt, nuint args)
		{
			LogTextVNative(fmt, args);
		}

		public static void LogTextV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogTextVNative((byte*)pfmt, args);
			}
		}

		public static void LogTextV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogTextVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDragDropSource")]
		internal static extern byte BeginDragDropSourceNative(ImGuiDragDropFlags flags);

		public static bool BeginDragDropSource(ImGuiDragDropFlags flags)
		{
			byte ret = BeginDragDropSourceNative(flags);
			return ret != 0;
		}

		public static bool BeginDragDropSource()
		{
			byte ret = BeginDragDropSourceNative((ImGuiDragDropFlags)(0));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetDragDropPayload")]
		internal static extern byte SetDragDropPayloadNative(byte* type, void* data, nuint sz, ImGuiCond cond);

		public static bool SetDragDropPayload(byte* type, void* data, nuint sz, ImGuiCond cond)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, cond);
			return ret != 0;
		}

		public static bool SetDragDropPayload(byte* type, void* data, nuint sz)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, (ImGuiCond)(0));
			return ret != 0;
		}

		public static bool SetDragDropPayload(ref byte type, void* data, nuint sz, ImGuiCond cond)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}

		public static bool SetDragDropPayload(ref byte type, void* data, nuint sz)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}

		public static bool SetDragDropPayload(string type, void* data, nuint sz, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetDragDropPayloadNative(pStr0, data, sz, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SetDragDropPayload(string type, void* data, nuint sz)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetDragDropPayloadNative(pStr0, data, sz, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndDragDropSource")]
		internal static extern void EndDragDropSourceNative();

		public static void EndDragDropSource()
		{
			EndDragDropSourceNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDragDropTarget")]
		internal static extern byte BeginDragDropTargetNative();

		public static bool BeginDragDropTarget()
		{
			byte ret = BeginDragDropTargetNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igAcceptDragDropPayload")]
		internal static extern ImGuiPayload* AcceptDragDropPayloadNative(byte* type, ImGuiDragDropFlags flags);

		public static ImGuiPayloadPtr AcceptDragDropPayload(byte* type, ImGuiDragDropFlags flags)
		{
			ImGuiPayloadPtr ret = AcceptDragDropPayloadNative(type, flags);
			return ret;
		}

		public static ImGuiPayloadPtr AcceptDragDropPayload(byte* type)
		{
			ImGuiPayloadPtr ret = AcceptDragDropPayloadNative(type, (ImGuiDragDropFlags)(0));
			return ret;
		}

		public static ImGuiPayloadPtr AcceptDragDropPayload(ref byte type, ImGuiDragDropFlags flags)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayloadPtr ret = AcceptDragDropPayloadNative((byte*)ptype, flags);
				return ret;
			}
		}

		public static ImGuiPayloadPtr AcceptDragDropPayload(ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayloadPtr ret = AcceptDragDropPayloadNative((byte*)ptype, (ImGuiDragDropFlags)(0));
				return ret;
			}
		}

		public static ImGuiPayloadPtr AcceptDragDropPayload(string type, ImGuiDragDropFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayloadPtr ret = AcceptDragDropPayloadNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImGuiPayloadPtr AcceptDragDropPayload(string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayloadPtr ret = AcceptDragDropPayloadNative(pStr0, (ImGuiDragDropFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndDragDropTarget")]
		internal static extern void EndDragDropTargetNative();

		public static void EndDragDropTarget()
		{
			EndDragDropTargetNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetDragDropPayload")]
		internal static extern ImGuiPayload* GetDragDropPayloadNative();

		public static ImGuiPayloadPtr GetDragDropPayload()
		{
			ImGuiPayloadPtr ret = GetDragDropPayloadNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDisabled")]
		internal static extern void BeginDisabledNative(byte disabled);

		public static void BeginDisabled(bool disabled)
		{
			BeginDisabledNative(disabled ? (byte)1 : (byte)0);
		}

		public static void BeginDisabled()
		{
			BeginDisabledNative((byte)(1));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndDisabled")]
		internal static extern void EndDisabledNative();

		public static void EndDisabled()
		{
			EndDisabledNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushClipRect")]
		internal static extern void PushClipRectNative(Vector2 clipRectMin, Vector2 clipRectMax, byte intersectWithCurrentClipRect);

		public static void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			PushClipRectNative(clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopClipRect")]
		internal static extern void PopClipRectNative();

		public static void PopClipRect()
		{
			PopClipRectNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetItemDefaultFocus")]
		internal static extern void SetItemDefaultFocusNative();

		public static void SetItemDefaultFocus()
		{
			SetItemDefaultFocusNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetKeyboardFocusHere")]
		internal static extern void SetKeyboardFocusHereNative(int offset);

		public static void SetKeyboardFocusHere(int offset)
		{
			SetKeyboardFocusHereNative(offset);
		}

		public static void SetKeyboardFocusHere()
		{
			SetKeyboardFocusHereNative((int)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemHovered")]
		internal static extern byte IsItemHoveredNative(ImGuiHoveredFlags flags);

		public static bool IsItemHovered(ImGuiHoveredFlags flags)
		{
			byte ret = IsItemHoveredNative(flags);
			return ret != 0;
		}

		public static bool IsItemHovered()
		{
			byte ret = IsItemHoveredNative((ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemActive")]
		internal static extern byte IsItemActiveNative();

		public static bool IsItemActive()
		{
			byte ret = IsItemActiveNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemFocused")]
		internal static extern byte IsItemFocusedNative();

		public static bool IsItemFocused()
		{
			byte ret = IsItemFocusedNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemClicked")]
		internal static extern byte IsItemClickedNative(ImGuiMouseButton mouseButton);

		public static bool IsItemClicked(ImGuiMouseButton mouseButton)
		{
			byte ret = IsItemClickedNative(mouseButton);
			return ret != 0;
		}

		public static bool IsItemClicked()
		{
			byte ret = IsItemClickedNative((ImGuiMouseButton)(0));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemVisible")]
		internal static extern byte IsItemVisibleNative();

		public static bool IsItemVisible()
		{
			byte ret = IsItemVisibleNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemEdited")]
		internal static extern byte IsItemEditedNative();

		public static bool IsItemEdited()
		{
			byte ret = IsItemEditedNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemActivated")]
		internal static extern byte IsItemActivatedNative();

		public static bool IsItemActivated()
		{
			byte ret = IsItemActivatedNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemDeactivated")]
		internal static extern byte IsItemDeactivatedNative();

		public static bool IsItemDeactivated()
		{
			byte ret = IsItemDeactivatedNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemDeactivatedAfterEdit")]
		internal static extern byte IsItemDeactivatedAfterEditNative();

		public static bool IsItemDeactivatedAfterEdit()
		{
			byte ret = IsItemDeactivatedAfterEditNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemToggledOpen")]
		internal static extern byte IsItemToggledOpenNative();

		public static bool IsItemToggledOpen()
		{
			byte ret = IsItemToggledOpenNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAnyItemHovered")]
		internal static extern byte IsAnyItemHoveredNative();

		public static bool IsAnyItemHovered()
		{
			byte ret = IsAnyItemHoveredNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAnyItemActive")]
		internal static extern byte IsAnyItemActiveNative();

		public static bool IsAnyItemActive()
		{
			byte ret = IsAnyItemActiveNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAnyItemFocused")]
		internal static extern byte IsAnyItemFocusedNative();

		public static bool IsAnyItemFocused()
		{
			byte ret = IsAnyItemFocusedNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemID")]
		internal static extern int GetItemIDNative();

		public static int GetItemID()
		{
			int ret = GetItemIDNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemRectMin")]
		internal static extern void GetItemRectMinNative(Vector2* output);

		public static Vector2 GetItemRectMin()
		{
			Vector2 ret;
			GetItemRectMinNative(&ret);
			return ret;
		}

		public static void GetItemRectMin(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetItemRectMinNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemRectMax")]
		internal static extern void GetItemRectMaxNative(Vector2* output);

		public static Vector2 GetItemRectMax()
		{
			Vector2 ret;
			GetItemRectMaxNative(&ret);
			return ret;
		}

		public static void GetItemRectMax(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetItemRectMaxNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemRectSize")]
		internal static extern void GetItemRectSizeNative(Vector2* output);

		public static Vector2 GetItemRectSize()
		{
			Vector2 ret;
			GetItemRectSizeNative(&ret);
			return ret;
		}

		public static void GetItemRectSize(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetItemRectSizeNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetItemAllowOverlap")]
		internal static extern void SetItemAllowOverlapNative();

		public static void SetItemAllowOverlap()
		{
			SetItemAllowOverlapNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMainViewport")]
		internal static extern ImGuiViewport* GetMainViewportNative();

		public static ImGuiViewportPtr GetMainViewport()
		{
			ImGuiViewportPtr ret = GetMainViewportNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetBackgroundDrawList_Nil")]
		internal static extern ImDrawList* GetBackgroundDrawListNative();

		public static ImDrawListPtr GetBackgroundDrawList()
		{
			ImDrawListPtr ret = GetBackgroundDrawListNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetForegroundDrawList_Nil")]
		internal static extern ImDrawList* GetForegroundDrawListNative();

		public static ImDrawListPtr GetForegroundDrawList()
		{
			ImDrawListPtr ret = GetForegroundDrawListNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetBackgroundDrawList_ViewportPtr")]
		internal static extern ImDrawList* GetBackgroundDrawListNative(ImGuiViewport* viewport);

		public static ImDrawListPtr GetBackgroundDrawList(ImGuiViewport* viewport)
		{
			ImDrawListPtr ret = GetBackgroundDrawListNative(viewport);
			return ret;
		}

		public static ImDrawListPtr GetBackgroundDrawList(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawListPtr ret = GetBackgroundDrawListNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetForegroundDrawList_ViewportPtr")]
		internal static extern ImDrawList* GetForegroundDrawListNative(ImGuiViewport* viewport);

		public static ImDrawListPtr GetForegroundDrawList(ImGuiViewport* viewport)
		{
			ImDrawListPtr ret = GetForegroundDrawListNative(viewport);
			return ret;
		}

		public static ImDrawListPtr GetForegroundDrawList(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawListPtr ret = GetForegroundDrawListNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsRectVisible_Nil")]
		internal static extern byte IsRectVisibleNative(Vector2 size);

		public static bool IsRectVisible(Vector2 size)
		{
			byte ret = IsRectVisibleNative(size);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsRectVisible_Vec2")]
		internal static extern byte IsRectVisibleNative(Vector2 rectMin, Vector2 rectMax);

		public static bool IsRectVisible(Vector2 rectMin, Vector2 rectMax)
		{
			byte ret = IsRectVisibleNative(rectMin, rectMax);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTime")]
		internal static extern double GetTimeNative();

		public static double GetTime()
		{
			double ret = GetTimeNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFrameCount")]
		internal static extern int GetFrameCountNative();

		public static int GetFrameCount()
		{
			int ret = GetFrameCountNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetDrawListSharedData")]
		internal static extern ImDrawListSharedData* GetDrawListSharedDataNative();

		public static ImDrawListSharedDataPtr GetDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = GetDrawListSharedDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStyleColorName")]
		internal static extern byte* GetStyleColorNameNative(ImGuiCol idx);

		public static byte* GetStyleColorName(ImGuiCol idx)
		{
			byte* ret = GetStyleColorNameNative(idx);
			return ret;
		}

		public static string GetStyleColorNameS(ImGuiCol idx)
		{
			string ret = Utils.DecodeStringUTF8(GetStyleColorNameNative(idx));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetStateStorage")]
		internal static extern void SetStateStorageNative(ImGuiStorage* storage);

		public static void SetStateStorage(ImGuiStorage* storage)
		{
			SetStateStorageNative(storage);
		}

		public static void SetStateStorage(ref ImGuiStorage storage)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				SetStateStorageNative((ImGuiStorage*)pstorage);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStateStorage")]
		internal static extern ImGuiStorage* GetStateStorageNative();

		public static ImGuiStoragePtr GetStateStorage()
		{
			ImGuiStoragePtr ret = GetStateStorageNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginChildFrame")]
		internal static extern byte BeginChildFrameNative(int id, Vector2 size, ImGuiWindowFlags flags);

		public static bool BeginChildFrame(int id, Vector2 size, ImGuiWindowFlags flags)
		{
			byte ret = BeginChildFrameNative(id, size, flags);
			return ret != 0;
		}

		public static bool BeginChildFrame(int id, Vector2 size)
		{
			byte ret = BeginChildFrameNative(id, size, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndChildFrame")]
		internal static extern void EndChildFrameNative();

		public static void EndChildFrame()
		{
			EndChildFrameNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcTextSize")]
		internal static extern void CalcTextSizeNative(Vector2* output, byte* text, byte* textEnd, byte hideTextAfterDoubleHash, float wrapWidth);

		public static Vector2 CalcTextSize(byte* text)
		{
			Vector2 ret;
			CalcTextSizeNative(&ret, text, (byte*)(default), (byte)(0), (float)(-1.0f));
			return ret;
		}

		public static Vector2 CalcTextSize(byte* text, byte* textEnd)
		{
			Vector2 ret;
			CalcTextSizeNative(&ret, text, textEnd, (byte)(0), (float)(-1.0f));
			return ret;
		}

		public static Vector2 CalcTextSize(byte* text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			Vector2 ret;
			CalcTextSizeNative(&ret, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			return ret;
		}

		public static Vector2 CalcTextSize(byte* text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			Vector2 ret;
			CalcTextSizeNative(&ret, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			return ret;
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeNative((Vector2*)poutput, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeNative((Vector2*)poutput, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeNative((Vector2*)poutput, text, textEnd, (byte)(0), (float)(-1.0f));
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeNative((Vector2*)poutput, text, (byte*)(default), (byte)(0), (float)(-1.0f));
			}
		}

		public static Vector2 CalcTextSize(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				Vector2 ret;
				CalcTextSizeNative(&ret, (byte*)ptext, (byte*)(default), (byte)(0), (float)(-1.0f));
				return ret;
			}
		}

		public static Vector2 CalcTextSize(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				Vector2 ret;
				CalcTextSizeNative(&ret, (byte*)ptext, textEnd, (byte)(0), (float)(-1.0f));
				return ret;
			}
		}

		public static Vector2 CalcTextSize(ref byte text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				Vector2 ret;
				CalcTextSizeNative(&ret, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				return ret;
			}
		}

		public static Vector2 CalcTextSize(ref byte text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				Vector2 ret;
				CalcTextSizeNative(&ret, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				return ret;
			}
		}

		public static Vector2 CalcTextSize(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, pStr0, (byte*)(default), (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSize(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, pStr0, textEnd, (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSize(string text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSize(string text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)poutput, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)poutput, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)poutput, (byte*)ptext, textEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)poutput, (byte*)ptext, (byte*)(default), (byte)(0), (float)(-1.0f));
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, pStr0, textEnd, (byte)(0), (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, pStr0, (byte*)(default), (byte)(0), (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static Vector2 CalcTextSize(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				Vector2 ret;
				CalcTextSizeNative(&ret, text, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
				return ret;
			}
		}

		public static Vector2 CalcTextSize(byte* text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				Vector2 ret;
				CalcTextSizeNative(&ret, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				return ret;
			}
		}

		public static Vector2 CalcTextSize(byte* text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				Vector2 ret;
				CalcTextSizeNative(&ret, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				return ret;
			}
		}

		public static Vector2 CalcTextSize(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, text, pStr0, (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSize(byte* text, string textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSize(byte* text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)poutput, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)poutput, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)poutput, text, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, string textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, byte* text, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, text, pStr0, (byte)(0), (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static Vector2 CalcTextSize(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					Vector2 ret;
					CalcTextSizeNative(&ret, (byte*)ptext, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSize(ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					Vector2 ret;
					CalcTextSizeNative(&ret, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSize(ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					Vector2 ret;
					CalcTextSizeNative(&ret, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSize(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, pStr0, pStr1, (byte)(0), (float)(-1.0f));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSize(string text, string textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSize(string text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Vector2 ret;
			CalcTextSizeNative(&ret, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeNative((Vector2*)poutput, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
					}
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeNative((Vector2*)poutput, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
					}
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, ref byte text, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeNative((Vector2*)poutput, (byte*)ptext, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
					}
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, string textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSize(ref Vector2 output, string text, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeNative((Vector2*)poutput, pStr0, pStr1, (byte)(0), (float)(-1.0f));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorConvertU32ToFloat4")]
		internal static extern void ColorConvertU32ToFloat4Native(Vector4* output, uint input);

		public static Vector4 ColorConvertU32ToFloat4(uint input)
		{
			Vector4 ret;
			ColorConvertU32ToFloat4Native(&ret, input);
			return ret;
		}

		public static void ColorConvertU32ToFloat4(ref Vector4 output, uint input)
		{
			fixed (Vector4* poutput = &output)
			{
				ColorConvertU32ToFloat4Native((Vector4*)poutput, input);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorConvertFloat4ToU32")]
		internal static extern uint ColorConvertFloat4ToU32Native(Vector4 input);

		public static uint ColorConvertFloat4ToU32(Vector4 input)
		{
			uint ret = ColorConvertFloat4ToU32Native(input);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorConvertRGBtoHSV")]
		internal static extern void ColorConvertRGBtoHSVNative(float r, float g, float b, float* outH, float* outS, float* outV);

		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, float* outS, float* outV)
		{
			ColorConvertRGBtoHSVNative(r, g, b, outH, outS, outV);
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, float* outS, float* outV)
		{
			fixed (float* poutH = &outH)
			{
				ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, outS, outV);
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, ref float outS, float* outV)
		{
			fixed (float* poutS = &outS)
			{
				ColorConvertRGBtoHSVNative(r, g, b, outH, (float*)poutS, outV);
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, ref float outS, float* outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, (float*)poutS, outV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, float* outS, ref float outV)
		{
			fixed (float* poutV = &outV)
			{
				ColorConvertRGBtoHSVNative(r, g, b, outH, outS, (float*)poutV);
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, float* outS, ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, outS, (float*)poutV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, ref float outS, ref float outV)
		{
			fixed (float* poutS = &outS)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSVNative(r, g, b, outH, (float*)poutS, (float*)poutV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, ref float outS, ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					fixed (float* poutV = &outV)
					{
						ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, (float*)poutS, (float*)poutV);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorConvertHSVtoRGB")]
		internal static extern void ColorConvertHSVtoRGBNative(float h, float s, float v, float* outR, float* outG, float* outB);

		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, float* outG, float* outB)
		{
			ColorConvertHSVtoRGBNative(h, s, v, outR, outG, outB);
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, float* outG, float* outB)
		{
			fixed (float* poutR = &outR)
			{
				ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, outG, outB);
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, ref float outG, float* outB)
		{
			fixed (float* poutG = &outG)
			{
				ColorConvertHSVtoRGBNative(h, s, v, outR, (float*)poutG, outB);
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, ref float outG, float* outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, (float*)poutG, outB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, float* outG, ref float outB)
		{
			fixed (float* poutB = &outB)
			{
				ColorConvertHSVtoRGBNative(h, s, v, outR, outG, (float*)poutB);
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, float* outG, ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, outG, (float*)poutB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, ref float outG, ref float outB)
		{
			fixed (float* poutG = &outG)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGBNative(h, s, v, outR, (float*)poutG, (float*)poutB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, ref float outG, ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					fixed (float* poutB = &outB)
					{
						ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, (float*)poutG, (float*)poutB);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyDown_Nil")]
		internal static extern byte IsKeyDownNative(ImGuiKey key);

		public static bool IsKeyDown(ImGuiKey key)
		{
			byte ret = IsKeyDownNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyPressed_Bool")]
		internal static extern byte IsKeyPressedNative(ImGuiKey key, byte repeat);

		public static bool IsKeyPressed(ImGuiKey key, bool repeat)
		{
			byte ret = IsKeyPressedNative(key, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool IsKeyPressed(ImGuiKey key)
		{
			byte ret = IsKeyPressedNative(key, (byte)(1));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyReleased_Nil")]
		internal static extern byte IsKeyReleasedNative(ImGuiKey key);

		public static bool IsKeyReleased(ImGuiKey key)
		{
			byte ret = IsKeyReleasedNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyPressedAmount")]
		internal static extern int GetKeyPressedAmountNative(ImGuiKey key, float repeatDelay, float rate);

		public static int GetKeyPressedAmount(ImGuiKey key, float repeatDelay, float rate)
		{
			int ret = GetKeyPressedAmountNative(key, repeatDelay, rate);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyName")]
		internal static extern byte* GetKeyNameNative(ImGuiKey key);

		public static byte* GetKeyName(ImGuiKey key)
		{
			byte* ret = GetKeyNameNative(key);
			return ret;
		}

		public static string GetKeyNameS(ImGuiKey key)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyNameNative(key));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextFrameWantCaptureKeyboard")]
		internal static extern void SetNextFrameWantCaptureKeyboardNative(byte wantCaptureKeyboard);

		public static void SetNextFrameWantCaptureKeyboard(bool wantCaptureKeyboard)
		{
			SetNextFrameWantCaptureKeyboardNative(wantCaptureKeyboard ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDown_Nil")]
		internal static extern byte IsMouseDownNative(ImGuiMouseButton button);

		public static bool IsMouseDown(ImGuiMouseButton button)
		{
			byte ret = IsMouseDownNative(button);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseClicked_Bool")]
		internal static extern byte IsMouseClickedNative(ImGuiMouseButton button, byte repeat);

		public static bool IsMouseClicked(ImGuiMouseButton button, bool repeat)
		{
			byte ret = IsMouseClickedNative(button, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool IsMouseClicked(ImGuiMouseButton button)
		{
			byte ret = IsMouseClickedNative(button, (byte)(0));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseReleased_Nil")]
		internal static extern byte IsMouseReleasedNative(ImGuiMouseButton button);

		public static bool IsMouseReleased(ImGuiMouseButton button)
		{
			byte ret = IsMouseReleasedNative(button);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDoubleClicked")]
		internal static extern byte IsMouseDoubleClickedNative(ImGuiMouseButton button);

		public static bool IsMouseDoubleClicked(ImGuiMouseButton button)
		{
			byte ret = IsMouseDoubleClickedNative(button);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMouseClickedCount")]
		internal static extern int GetMouseClickedCountNative(ImGuiMouseButton button);

		public static int GetMouseClickedCount(ImGuiMouseButton button)
		{
			int ret = GetMouseClickedCountNative(button);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseHoveringRect")]
		internal static extern byte IsMouseHoveringRectNative(Vector2 rMin, Vector2 rMax, byte clip);

		public static bool IsMouseHoveringRect(Vector2 rMin, Vector2 rMax, bool clip)
		{
			byte ret = IsMouseHoveringRectNative(rMin, rMax, clip ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool IsMouseHoveringRect(Vector2 rMin, Vector2 rMax)
		{
			byte ret = IsMouseHoveringRectNative(rMin, rMax, (byte)(1));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMousePosValid")]
		internal static extern byte IsMousePosValidNative(Vector2* mousePos);

		public static bool IsMousePosValid(Vector2* mousePos)
		{
			byte ret = IsMousePosValidNative(mousePos);
			return ret != 0;
		}

		public static bool IsMousePosValid()
		{
			byte ret = IsMousePosValidNative((Vector2*)(default));
			return ret != 0;
		}

		public static bool IsMousePosValid(ref Vector2 mousePos)
		{
			fixed (Vector2* pmousePos = &mousePos)
			{
				byte ret = IsMousePosValidNative((Vector2*)pmousePos);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAnyMouseDown")]
		internal static extern byte IsAnyMouseDownNative();

		public static bool IsAnyMouseDown()
		{
			byte ret = IsAnyMouseDownNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMousePos")]
		internal static extern void GetMousePosNative(Vector2* output);

		public static Vector2 GetMousePos()
		{
			Vector2 ret;
			GetMousePosNative(&ret);
			return ret;
		}

		public static void GetMousePos(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMousePosNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMousePosOnOpeningCurrentPopup")]
		internal static extern void GetMousePosOnOpeningCurrentPopupNative(Vector2* output);

		public static Vector2 GetMousePosOnOpeningCurrentPopup()
		{
			Vector2 ret;
			GetMousePosOnOpeningCurrentPopupNative(&ret);
			return ret;
		}

		public static void GetMousePosOnOpeningCurrentPopup(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMousePosOnOpeningCurrentPopupNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDragging")]
		internal static extern byte IsMouseDraggingNative(ImGuiMouseButton button, float lockThreshold);

		public static bool IsMouseDragging(ImGuiMouseButton button, float lockThreshold)
		{
			byte ret = IsMouseDraggingNative(button, lockThreshold);
			return ret != 0;
		}

		public static bool IsMouseDragging(ImGuiMouseButton button)
		{
			byte ret = IsMouseDraggingNative(button, (float)(-1.0f));
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMouseDragDelta")]
		internal static extern void GetMouseDragDeltaNative(Vector2* output, ImGuiMouseButton button, float lockThreshold);

		public static Vector2 GetMouseDragDelta()
		{
			Vector2 ret;
			GetMouseDragDeltaNative(&ret, (ImGuiMouseButton)(0), (float)(-1.0f));
			return ret;
		}

		public static Vector2 GetMouseDragDelta(ImGuiMouseButton button)
		{
			Vector2 ret;
			GetMouseDragDeltaNative(&ret, button, (float)(-1.0f));
			return ret;
		}

		public static Vector2 GetMouseDragDelta(ImGuiMouseButton button, float lockThreshold)
		{
			Vector2 ret;
			GetMouseDragDeltaNative(&ret, button, lockThreshold);
			return ret;
		}

		public static void GetMouseDragDelta(ref Vector2 output, ImGuiMouseButton button, float lockThreshold)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMouseDragDeltaNative((Vector2*)poutput, button, lockThreshold);
			}
		}

		public static void GetMouseDragDelta(ref Vector2 output, ImGuiMouseButton button)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMouseDragDeltaNative((Vector2*)poutput, button, (float)(-1.0f));
			}
		}

		public static void GetMouseDragDelta(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetMouseDragDeltaNative((Vector2*)poutput, (ImGuiMouseButton)(0), (float)(-1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igResetMouseDragDelta")]
		internal static extern void ResetMouseDragDeltaNative(ImGuiMouseButton button);

		public static void ResetMouseDragDelta(ImGuiMouseButton button)
		{
			ResetMouseDragDeltaNative(button);
		}

		public static void ResetMouseDragDelta()
		{
			ResetMouseDragDeltaNative((ImGuiMouseButton)(0));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetMouseCursor")]
		internal static extern ImGuiMouseCursor GetMouseCursorNative();

		public static ImGuiMouseCursor GetMouseCursor()
		{
			ImGuiMouseCursor ret = GetMouseCursorNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetMouseCursor")]
		internal static extern void SetMouseCursorNative(ImGuiMouseCursor cursorType);

		public static void SetMouseCursor(ImGuiMouseCursor cursorType)
		{
			SetMouseCursorNative(cursorType);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNextFrameWantCaptureMouse")]
		internal static extern void SetNextFrameWantCaptureMouseNative(byte wantCaptureMouse);

		public static void SetNextFrameWantCaptureMouse(bool wantCaptureMouse)
		{
			SetNextFrameWantCaptureMouseNative(wantCaptureMouse ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetClipboardText")]
		internal static extern byte* GetClipboardTextNative();

		public static byte* GetClipboardText()
		{
			byte* ret = GetClipboardTextNative();
			return ret;
		}

		public static string GetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardTextNative());
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetClipboardText")]
		internal static extern void SetClipboardTextNative(byte* text);

		public static void SetClipboardText(byte* text)
		{
			SetClipboardTextNative(text);
		}

		public static void SetClipboardText(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				SetClipboardTextNative((byte*)ptext);
			}
		}

		public static void SetClipboardText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetClipboardTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLoadIniSettingsFromDisk")]
		internal static extern void LoadIniSettingsFromDiskNative(byte* iniFilename);

		public static void LoadIniSettingsFromDisk(byte* iniFilename)
		{
			LoadIniSettingsFromDiskNative(iniFilename);
		}

		public static void LoadIniSettingsFromDisk(ref byte iniFilename)
		{
			fixed (byte* piniFilename = &iniFilename)
			{
				LoadIniSettingsFromDiskNative((byte*)piniFilename);
			}
		}

		public static void LoadIniSettingsFromDisk(string iniFilename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromDiskNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLoadIniSettingsFromMemory")]
		internal static extern void LoadIniSettingsFromMemoryNative(byte* iniData, nuint iniSize);

		public static void LoadIniSettingsFromMemory(byte* iniData, nuint iniSize)
		{
			LoadIniSettingsFromMemoryNative(iniData, iniSize);
		}

		public static void LoadIniSettingsFromMemory(byte* iniData)
		{
			LoadIniSettingsFromMemoryNative(iniData, (nuint)(0));
		}

		public static void LoadIniSettingsFromMemory(ref byte iniData, nuint iniSize)
		{
			fixed (byte* piniData = &iniData)
			{
				LoadIniSettingsFromMemoryNative((byte*)piniData, iniSize);
			}
		}

		public static void LoadIniSettingsFromMemory(ref byte iniData)
		{
			fixed (byte* piniData = &iniData)
			{
				LoadIniSettingsFromMemoryNative((byte*)piniData, (nuint)(0));
			}
		}

		public static void LoadIniSettingsFromMemory(string iniData, nuint iniSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromMemoryNative(pStr0, iniSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LoadIniSettingsFromMemory(string iniData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromMemoryNative(pStr0, (nuint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSaveIniSettingsToDisk")]
		internal static extern void SaveIniSettingsToDiskNative(byte* iniFilename);

		public static void SaveIniSettingsToDisk(byte* iniFilename)
		{
			SaveIniSettingsToDiskNative(iniFilename);
		}

		public static void SaveIniSettingsToDisk(ref byte iniFilename)
		{
			fixed (byte* piniFilename = &iniFilename)
			{
				SaveIniSettingsToDiskNative((byte*)piniFilename);
			}
		}

		public static void SaveIniSettingsToDisk(string iniFilename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SaveIniSettingsToDiskNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSaveIniSettingsToMemory")]
		internal static extern byte* SaveIniSettingsToMemoryNative(nuint* outIniSize);

		public static byte* SaveIniSettingsToMemory(nuint* outIniSize)
		{
			byte* ret = SaveIniSettingsToMemoryNative(outIniSize);
			return ret;
		}

		public static byte* SaveIniSettingsToMemory()
		{
			byte* ret = SaveIniSettingsToMemoryNative((nuint*)(default));
			return ret;
		}

		public static string SaveIniSettingsToMemoryS()
		{
			string ret = Utils.DecodeStringUTF8(SaveIniSettingsToMemoryNative((nuint*)(default)));
			return ret;
		}

		public static string SaveIniSettingsToMemoryS(nuint* outIniSize)
		{
			string ret = Utils.DecodeStringUTF8(SaveIniSettingsToMemoryNative(outIniSize));
			return ret;
		}

		public static byte* SaveIniSettingsToMemory(ref nuint outIniSize)
		{
			fixed (nuint* poutIniSize = &outIniSize)
			{
				byte* ret = SaveIniSettingsToMemoryNative((nuint*)poutIniSize);
				return ret;
			}
		}

		public static string SaveIniSettingsToMemoryS(ref nuint outIniSize)
		{
			fixed (nuint* poutIniSize = &outIniSize)
			{
				string ret = Utils.DecodeStringUTF8(SaveIniSettingsToMemoryNative((nuint*)poutIniSize));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugTextEncoding")]
		internal static extern void DebugTextEncodingNative(byte* text);

		public static void DebugTextEncoding(byte* text)
		{
			DebugTextEncodingNative(text);
		}

		public static void DebugTextEncoding(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				DebugTextEncodingNative((byte*)ptext);
			}
		}

		public static void DebugTextEncoding(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugTextEncodingNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugCheckVersionAndDataLayout")]
		internal static extern byte DebugCheckVersionAndDataLayoutNative(byte* versionStr, nuint szIo, nuint szStyle, nuint szVec2, nuint szVec4, nuint szDrawvert, nuint szDrawidx);

		public static bool DebugCheckVersionAndDataLayout(byte* versionStr, nuint szIo, nuint szStyle, nuint szVec2, nuint szVec4, nuint szDrawvert, nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szVec2, szVec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout(ref byte versionStr, nuint szIo, nuint szStyle, nuint szVec2, nuint szVec4, nuint szDrawvert, nuint szDrawidx)
		{
			fixed (byte* pversionStr = &versionStr)
			{
				byte ret = DebugCheckVersionAndDataLayoutNative((byte*)pversionStr, szIo, szStyle, szVec2, szVec4, szDrawvert, szDrawidx);
				return ret != 0;
			}
		}

		public static bool DebugCheckVersionAndDataLayout(string versionStr, nuint szIo, nuint szStyle, nuint szVec2, nuint szVec4, nuint szDrawvert, nuint szDrawidx)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (versionStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(versionStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(versionStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DebugCheckVersionAndDataLayoutNative(pStr0, szIo, szStyle, szVec2, szVec4, szDrawvert, szDrawidx);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetAllocatorFunctions")]
		internal static extern void SetAllocatorFunctionsNative(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc, void* userData);

		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc, void* userData)
		{
			SetAllocatorFunctionsNative(allocFunc, freeFunc, userData);
		}

		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc)
		{
			SetAllocatorFunctionsNative(allocFunc, freeFunc, (void*)(default));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetAllocatorFunctions")]
		internal static extern void GetAllocatorFunctionsNative(ImGuiMemAllocFunc pAllocFunc, ImGuiMemFreeFunc pFreeFunc, void** pUserData);

		public static void GetAllocatorFunctions(ImGuiMemAllocFunc pAllocFunc, ImGuiMemFreeFunc pFreeFunc, void** pUserData)
		{
			GetAllocatorFunctionsNative(pAllocFunc, pFreeFunc, pUserData);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMemAlloc")]
		internal static extern void* MemAllocNative(nuint size);

		public static void* MemAlloc(nuint size)
		{
			void* ret = MemAllocNative(size);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMemFree")]
		internal static extern void MemFreeNative(void* ptr);

		public static void MemFree(void* ptr)
		{
			MemFreeNative(ptr);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetPlatformIO")]
		internal static extern ImGuiPlatformIO* GetPlatformIONative();

		public static ImGuiPlatformIOPtr GetPlatformIO()
		{
			ImGuiPlatformIOPtr ret = GetPlatformIONative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdatePlatformWindows")]
		internal static extern void UpdatePlatformWindowsNative();

		public static void UpdatePlatformWindows()
		{
			UpdatePlatformWindowsNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderPlatformWindowsDefault")]
		internal static extern void RenderPlatformWindowsDefaultNative(void* platformRenderArg, void* rendererRenderArg);

		public static void RenderPlatformWindowsDefault(void* platformRenderArg, void* rendererRenderArg)
		{
			RenderPlatformWindowsDefaultNative(platformRenderArg, rendererRenderArg);
		}

		public static void RenderPlatformWindowsDefault(void* platformRenderArg)
		{
			RenderPlatformWindowsDefaultNative(platformRenderArg, (void*)(default));
		}

		public static void RenderPlatformWindowsDefault()
		{
			RenderPlatformWindowsDefaultNative((void*)(default), (void*)(default));
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDestroyPlatformWindows")]
		internal static extern void DestroyPlatformWindowsNative();

		public static void DestroyPlatformWindows()
		{
			DestroyPlatformWindowsNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindViewportByID")]
		internal static extern ImGuiViewport* FindViewportByIDNative(int id);

		public static ImGuiViewportPtr FindViewportByID(int id)
		{
			ImGuiViewportPtr ret = FindViewportByIDNative(id);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindViewportByPlatformHandle")]
		internal static extern ImGuiViewport* FindViewportByPlatformHandleNative(void* platformHandle);

		public static ImGuiViewportPtr FindViewportByPlatformHandle(void* platformHandle)
		{
			ImGuiViewportPtr ret = FindViewportByPlatformHandleNative(platformHandle);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyle_ImGuiStyle")]
		internal static extern ImGuiStyle* ImGuiStyleNative();

		public static ImGuiStylePtr ImGuiStyle()
		{
			ImGuiStylePtr ret = ImGuiStyleNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyle_destroy")]
		internal static extern void DestroyNative(ImGuiStyle* self);

		public static void Destroy(ImGuiStyle* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiStyle self)
		{
			fixed (ImGuiStyle* pself = &self)
			{
				DestroyNative((ImGuiStyle*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyle_ScaleAllSizes")]
		internal static extern void ScaleAllSizesNative(ImGuiStyle* self, float scaleFactor);

		public static void ScaleAllSizes(ImGuiStyle* self, float scaleFactor)
		{
			ScaleAllSizesNative(self, scaleFactor);
		}

		public static void ScaleAllSizes(ref ImGuiStyle self, float scaleFactor)
		{
			fixed (ImGuiStyle* pself = &self)
			{
				ScaleAllSizesNative((ImGuiStyle*)pself, scaleFactor);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddKeyEvent")]
		internal static extern void AddKeyEventNative(ImGuiIO* self, ImGuiKey key, byte down);

		public static void AddKeyEvent(ImGuiIO* self, ImGuiKey key, bool down)
		{
			AddKeyEventNative(self, key, down ? (byte)1 : (byte)0);
		}

		public static void AddKeyEvent(ref ImGuiIO self, ImGuiKey key, bool down)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddKeyEventNative((ImGuiIO*)pself, key, down ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddKeyAnalogEvent")]
		internal static extern void AddKeyAnalogEventNative(ImGuiIO* self, ImGuiKey key, byte down, float v);

		public static void AddKeyAnalogEvent(ImGuiIO* self, ImGuiKey key, bool down, float v)
		{
			AddKeyAnalogEventNative(self, key, down ? (byte)1 : (byte)0, v);
		}

		public static void AddKeyAnalogEvent(ref ImGuiIO self, ImGuiKey key, bool down, float v)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddKeyAnalogEventNative((ImGuiIO*)pself, key, down ? (byte)1 : (byte)0, v);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMousePosEvent")]
		internal static extern void AddMousePosEventNative(ImGuiIO* self, float x, float y);

		public static void AddMousePosEvent(ImGuiIO* self, float x, float y)
		{
			AddMousePosEventNative(self, x, y);
		}

		public static void AddMousePosEvent(ref ImGuiIO self, float x, float y)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMousePosEventNative((ImGuiIO*)pself, x, y);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMouseButtonEvent")]
		internal static extern void AddMouseButtonEventNative(ImGuiIO* self, int button, byte down);

		public static void AddMouseButtonEvent(ImGuiIO* self, int button, bool down)
		{
			AddMouseButtonEventNative(self, button, down ? (byte)1 : (byte)0);
		}

		public static void AddMouseButtonEvent(ref ImGuiIO self, int button, bool down)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseButtonEventNative((ImGuiIO*)pself, button, down ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMouseWheelEvent")]
		internal static extern void AddMouseWheelEventNative(ImGuiIO* self, float wheelX, float wheelY);

		public static void AddMouseWheelEvent(ImGuiIO* self, float wheelX, float wheelY)
		{
			AddMouseWheelEventNative(self, wheelX, wheelY);
		}

		public static void AddMouseWheelEvent(ref ImGuiIO self, float wheelX, float wheelY)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseWheelEventNative((ImGuiIO*)pself, wheelX, wheelY);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMouseSourceEvent")]
		internal static extern void AddMouseSourceEventNative(ImGuiIO* self, ImGuiMouseSource source);

		public static void AddMouseSourceEvent(ImGuiIO* self, ImGuiMouseSource source)
		{
			AddMouseSourceEventNative(self, source);
		}

		public static void AddMouseSourceEvent(ref ImGuiIO self, ImGuiMouseSource source)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseSourceEventNative((ImGuiIO*)pself, source);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddMouseViewportEvent")]
		internal static extern void AddMouseViewportEventNative(ImGuiIO* self, int id);

		public static void AddMouseViewportEvent(ImGuiIO* self, int id)
		{
			AddMouseViewportEventNative(self, id);
		}

		public static void AddMouseViewportEvent(ref ImGuiIO self, int id)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseViewportEventNative((ImGuiIO*)pself, id);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddFocusEvent")]
		internal static extern void AddFocusEventNative(ImGuiIO* self, byte focused);

		public static void AddFocusEvent(ImGuiIO* self, bool focused)
		{
			AddFocusEventNative(self, focused ? (byte)1 : (byte)0);
		}

		public static void AddFocusEvent(ref ImGuiIO self, bool focused)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddFocusEventNative((ImGuiIO*)pself, focused ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddInputCharacter")]
		internal static extern void AddInputCharacterNative(ImGuiIO* self, uint c);

		public static void AddInputCharacter(ImGuiIO* self, uint c)
		{
			AddInputCharacterNative(self, c);
		}

		public static void AddInputCharacter(ref ImGuiIO self, uint c)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharacterNative((ImGuiIO*)pself, c);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddInputCharacterUTF16")]
		internal static extern void AddInputCharacterUTF16Native(ImGuiIO* self, char c);

		public static void AddInputCharacterUTF16(ImGuiIO* self, char c)
		{
			AddInputCharacterUTF16Native(self, c);
		}

		public static void AddInputCharacterUTF16(ref ImGuiIO self, char c)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharacterUTF16Native((ImGuiIO*)pself, c);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_AddInputCharactersUTF8")]
		internal static extern void AddInputCharactersUTF8Native(ImGuiIO* self, byte* str);

		public static void AddInputCharactersUTF8(ImGuiIO* self, byte* str)
		{
			AddInputCharactersUTF8Native(self, str);
		}

		public static void AddInputCharactersUTF8(ref ImGuiIO self, byte* str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharactersUTF8Native((ImGuiIO*)pself, str);
			}
		}

		public static void AddInputCharactersUTF8(ImGuiIO* self, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				AddInputCharactersUTF8Native(self, (byte*)pstr);
			}
		}

		public static void AddInputCharactersUTF8(ImGuiIO* self, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddInputCharactersUTF8Native(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddInputCharactersUTF8(ref ImGuiIO self, ref byte str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					AddInputCharactersUTF8Native((ImGuiIO*)pself, (byte*)pstr);
				}
			}
		}

		public static void AddInputCharactersUTF8(ref ImGuiIO self, string str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddInputCharactersUTF8Native((ImGuiIO*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_SetKeyEventNativeData")]
		internal static extern void SetKeyEventNativeDataNative(ImGuiIO* self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex);

		public static void SetKeyEventNativeData(ImGuiIO* self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			SetKeyEventNativeDataNative(self, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
		}

		public static void SetKeyEventNativeData(ImGuiIO* self, ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			SetKeyEventNativeDataNative(self, key, nativeKeycode, nativeScancode, (int)(-1));
		}

		public static void SetKeyEventNativeData(ref ImGuiIO self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetKeyEventNativeDataNative((ImGuiIO*)pself, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			}
		}

		public static void SetKeyEventNativeData(ref ImGuiIO self, ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetKeyEventNativeDataNative((ImGuiIO*)pself, key, nativeKeycode, nativeScancode, (int)(-1));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_SetAppAcceptingEvents")]
		internal static extern void SetAppAcceptingEventsNative(ImGuiIO* self, byte acceptingEvents);

		public static void SetAppAcceptingEvents(ImGuiIO* self, bool acceptingEvents)
		{
			SetAppAcceptingEventsNative(self, acceptingEvents ? (byte)1 : (byte)0);
		}

		public static void SetAppAcceptingEvents(ref ImGuiIO self, bool acceptingEvents)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetAppAcceptingEventsNative((ImGuiIO*)pself, acceptingEvents ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_ClearInputCharacters")]
		internal static extern void ClearInputCharactersNative(ImGuiIO* self);

		public static void ClearInputCharacters(ImGuiIO* self)
		{
			ClearInputCharactersNative(self);
		}

		public static void ClearInputCharacters(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ClearInputCharactersNative((ImGuiIO*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_ClearInputKeys")]
		internal static extern void ClearInputKeysNative(ImGuiIO* self);

		public static void ClearInputKeys(ImGuiIO* self)
		{
			ClearInputKeysNative(self);
		}

		public static void ClearInputKeys(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ClearInputKeysNative((ImGuiIO*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_ImGuiIO")]
		internal static extern ImGuiIO* ImGuiIONative();

		public static ImGuiIOPtr ImGuiIO()
		{
			ImGuiIOPtr ret = ImGuiIONative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiIO_destroy")]
		internal static extern void DestroyNative(ImGuiIO* self);

		public static void Destroy(ImGuiIO* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				DestroyNative((ImGuiIO*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_ImGuiInputTextCallbackData")]
		internal static extern ImGuiInputTextCallbackData* ImGuiInputTextCallbackDataNative();

		public static ImGuiInputTextCallbackDataPtr ImGuiInputTextCallbackData()
		{
			ImGuiInputTextCallbackDataPtr ret = ImGuiInputTextCallbackDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_destroy")]
		internal static extern void DestroyNative(ImGuiInputTextCallbackData* self);

		public static void Destroy(ImGuiInputTextCallbackData* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				DestroyNative((ImGuiInputTextCallbackData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_DeleteChars")]
		internal static extern void DeleteCharsNative(ImGuiInputTextCallbackData* self, int pos, int bytesCount);

		public static void DeleteChars(ImGuiInputTextCallbackData* self, int pos, int bytesCount)
		{
			DeleteCharsNative(self, pos, bytesCount);
		}

		public static void DeleteChars(ref ImGuiInputTextCallbackData self, int pos, int bytesCount)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				DeleteCharsNative((ImGuiInputTextCallbackData*)pself, pos, bytesCount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_InsertChars")]
		internal static extern void InsertCharsNative(ImGuiInputTextCallbackData* self, int pos, byte* text, byte* textEnd);

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, byte* text, byte* textEnd)
		{
			InsertCharsNative(self, pos, text, textEnd);
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, byte* text)
		{
			InsertCharsNative(self, pos, text, (byte*)(default));
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, textEnd);
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, (byte*)(default));
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				InsertCharsNative(self, pos, (byte*)ptext, textEnd);
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				InsertCharsNative(self, pos, (byte*)ptext, (byte*)(default));
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, textEnd);
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, string text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, string text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				InsertCharsNative(self, pos, text, (byte*)ptextEnd);
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, (byte*)ptextEnd);
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					InsertCharsNative(self, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void InsertChars(ImGuiInputTextCallbackData* self, int pos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			InsertCharsNative(self, pos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, string text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_SelectAll")]
		internal static extern void SelectAllNative(ImGuiInputTextCallbackData* self);

		public static void SelectAll(ImGuiInputTextCallbackData* self)
		{
			SelectAllNative(self);
		}

		public static void SelectAll(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				SelectAllNative((ImGuiInputTextCallbackData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_ClearSelection")]
		internal static extern void ClearSelectionNative(ImGuiInputTextCallbackData* self);

		public static void ClearSelection(ImGuiInputTextCallbackData* self)
		{
			ClearSelectionNative(self);
		}

		public static void ClearSelection(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				ClearSelectionNative((ImGuiInputTextCallbackData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextCallbackData_HasSelection")]
		internal static extern byte HasSelectionNative(ImGuiInputTextCallbackData* self);

		public static bool HasSelection(ImGuiInputTextCallbackData* self)
		{
			byte ret = HasSelectionNative(self);
			return ret != 0;
		}

		public static bool HasSelection(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte ret = HasSelectionNative((ImGuiInputTextCallbackData*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowClass_ImGuiWindowClass")]
		internal static extern ImGuiWindowClass* ImGuiWindowClassNative();

		public static ImGuiWindowClassPtr ImGuiWindowClass()
		{
			ImGuiWindowClassPtr ret = ImGuiWindowClassNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowClass_destroy")]
		internal static extern void DestroyNative(ImGuiWindowClass* self);

		public static void Destroy(ImGuiWindowClass* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiWindowClass self)
		{
			fixed (ImGuiWindowClass* pself = &self)
			{
				DestroyNative((ImGuiWindowClass*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_ImGuiPayload")]
		internal static extern ImGuiPayload* ImGuiPayloadNative();

		public static ImGuiPayloadPtr ImGuiPayload()
		{
			ImGuiPayloadPtr ret = ImGuiPayloadNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_destroy")]
		internal static extern void DestroyNative(ImGuiPayload* self);

		public static void Destroy(ImGuiPayload* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				DestroyNative((ImGuiPayload*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_Clear")]
		internal static extern void ClearNative(ImGuiPayload* self);

		public static void Clear(ImGuiPayload* self)
		{
			ClearNative(self);
		}

		public static void Clear(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				ClearNative((ImGuiPayload*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_IsDataType")]
		internal static extern byte IsDataTypeNative(ImGuiPayload* self, byte* type);

		public static bool IsDataType(ImGuiPayload* self, byte* type)
		{
			byte ret = IsDataTypeNative(self, type);
			return ret != 0;
		}

		public static bool IsDataType(ref ImGuiPayload self, byte* type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte ret = IsDataTypeNative((ImGuiPayload*)pself, type);
				return ret != 0;
			}
		}

		public static bool IsDataType(ImGuiPayload* self, ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = IsDataTypeNative(self, (byte*)ptype);
				return ret != 0;
			}
		}

		public static bool IsDataType(ImGuiPayload* self, string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsDataTypeNative(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool IsDataType(ref ImGuiPayload self, ref byte type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				fixed (byte* ptype = &type)
				{
					byte ret = IsDataTypeNative((ImGuiPayload*)pself, (byte*)ptype);
					return ret != 0;
				}
			}
		}

		public static bool IsDataType(ref ImGuiPayload self, string type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = IsDataTypeNative((ImGuiPayload*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_IsPreview")]
		internal static extern byte IsPreviewNative(ImGuiPayload* self);

		public static bool IsPreview(ImGuiPayload* self)
		{
			byte ret = IsPreviewNative(self);
			return ret != 0;
		}

		public static bool IsPreview(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte ret = IsPreviewNative((ImGuiPayload*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPayload_IsDelivery")]
		internal static extern byte IsDeliveryNative(ImGuiPayload* self);

		public static bool IsDelivery(ImGuiPayload* self)
		{
			byte ret = IsDeliveryNative(self);
			return ret != 0;
		}

		public static bool IsDelivery(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte ret = IsDeliveryNative((ImGuiPayload*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs")]
		internal static extern ImGuiTableColumnSortSpecs* ImGuiTableColumnSortSpecsNative();

		public static ImGuiTableColumnSortSpecsPtr ImGuiTableColumnSortSpecs()
		{
			ImGuiTableColumnSortSpecsPtr ret = ImGuiTableColumnSortSpecsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumnSortSpecs_destroy")]
		internal static extern void DestroyNative(ImGuiTableColumnSortSpecs* self);

		public static void Destroy(ImGuiTableColumnSortSpecs* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiTableColumnSortSpecs self)
		{
			fixed (ImGuiTableColumnSortSpecs* pself = &self)
			{
				DestroyNative((ImGuiTableColumnSortSpecs*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSortSpecs_ImGuiTableSortSpecs")]
		internal static extern ImGuiTableSortSpecs* ImGuiTableSortSpecsNative();

		public static ImGuiTableSortSpecsPtr ImGuiTableSortSpecs()
		{
			ImGuiTableSortSpecsPtr ret = ImGuiTableSortSpecsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSortSpecs_destroy")]
		internal static extern void DestroyNative(ImGuiTableSortSpecs* self);

		public static void Destroy(ImGuiTableSortSpecs* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiTableSortSpecs self)
		{
			fixed (ImGuiTableSortSpecs* pself = &self)
			{
				DestroyNative((ImGuiTableSortSpecs*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOnceUponAFrame_ImGuiOnceUponAFrame")]
		internal static extern ImGuiOnceUponAFrame* ImGuiOnceUponAFrameNative();

		public static ImGuiOnceUponAFramePtr ImGuiOnceUponAFrame()
		{
			ImGuiOnceUponAFramePtr ret = ImGuiOnceUponAFrameNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOnceUponAFrame_destroy")]
		internal static extern void DestroyNative(ImGuiOnceUponAFrame* self);

		public static void Destroy(ImGuiOnceUponAFrame* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiOnceUponAFrame self)
		{
			fixed (ImGuiOnceUponAFrame* pself = &self)
			{
				DestroyNative((ImGuiOnceUponAFrame*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_ImGuiTextFilter")]
		internal static extern ImGuiTextFilter* ImGuiTextFilterNative(byte* defaultFilter);

		public static ImGuiTextFilterPtr ImGuiTextFilter(byte* defaultFilter)
		{
			ImGuiTextFilterPtr ret = ImGuiTextFilterNative(defaultFilter);
			return ret;
		}

		public static ImGuiTextFilterPtr ImGuiTextFilter()
		{
			ImGuiTextFilterPtr ret = ImGuiTextFilter((string)"");
			return ret;
		}

		public static ImGuiTextFilterPtr ImGuiTextFilter(ref byte defaultFilter)
		{
			fixed (byte* pdefaultFilter = &defaultFilter)
			{
				ImGuiTextFilterPtr ret = ImGuiTextFilterNative((byte*)pdefaultFilter);
				return ret;
			}
		}

		public static ImGuiTextFilterPtr ImGuiTextFilter(string defaultFilter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultFilter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultFilter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultFilter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextFilterPtr ret = ImGuiTextFilterNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_destroy")]
		internal static extern void DestroyNative(ImGuiTextFilter* self);

		public static void Destroy(ImGuiTextFilter* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				DestroyNative((ImGuiTextFilter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_Draw")]
		internal static extern byte DrawNative(ImGuiTextFilter* self, byte* label, float width);

		public static bool Draw(ImGuiTextFilter* self, byte* label, float width)
		{
			byte ret = DrawNative(self, label, width);
			return ret != 0;
		}

		public static bool Draw(ImGuiTextFilter* self, byte* label)
		{
			byte ret = DrawNative(self, label, (float)(0.0f));
			return ret != 0;
		}

		public static bool Draw(ImGuiTextFilter* self)
		{
			bool ret = Draw(self, (string)"Filter(inc,-exc)", (float)(0.0f));
			return ret;
		}

		public static bool Draw(ref ImGuiTextFilter self, byte* label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte ret = DrawNative((ImGuiTextFilter*)pself, label, width);
				return ret != 0;
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, byte* label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte ret = DrawNative((ImGuiTextFilter*)pself, label, (float)(0.0f));
				return ret != 0;
			}
		}

		public static bool Draw(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = Draw((ImGuiTextFilter*)pself, (string)"Filter(inc,-exc)", (float)(0.0f));
				return ret;
			}
		}

		public static bool Draw(ImGuiTextFilter* self, ref byte label, float width)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DrawNative(self, (byte*)plabel, width);
				return ret != 0;
			}
		}

		public static bool Draw(ImGuiTextFilter* self, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DrawNative(self, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}

		public static bool Draw(ImGuiTextFilter* self, string label, float width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DrawNative(self, pStr0, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Draw(ImGuiTextFilter* self, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DrawNative(self, pStr0, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Draw(ref ImGuiTextFilter self, ref byte label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = DrawNative((ImGuiTextFilter*)pself, (byte*)plabel, width);
					return ret != 0;
				}
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, ref byte label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = DrawNative((ImGuiTextFilter*)pself, (byte*)plabel, (float)(0.0f));
					return ret != 0;
				}
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, string label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DrawNative((ImGuiTextFilter*)pself, pStr0, width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Draw(ref ImGuiTextFilter self, string label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DrawNative((ImGuiTextFilter*)pself, pStr0, (float)(0.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_PassFilter")]
		internal static extern byte PassFilterNative(ImGuiTextFilter* self, byte* text, byte* textEnd);

		public static bool PassFilter(ImGuiTextFilter* self, byte* text, byte* textEnd)
		{
			byte ret = PassFilterNative(self, text, textEnd);
			return ret != 0;
		}

		public static bool PassFilter(ImGuiTextFilter* self, byte* text)
		{
			byte ret = PassFilterNative(self, text, (byte*)(default));
			return ret != 0;
		}

		public static bool PassFilter(ref ImGuiTextFilter self, byte* text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte ret = PassFilterNative((ImGuiTextFilter*)pself, text, textEnd);
				return ret != 0;
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, byte* text)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte ret = PassFilterNative((ImGuiTextFilter*)pself, text, (byte*)(default));
				return ret != 0;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = PassFilterNative(self, (byte*)ptext, textEnd);
				return ret != 0;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = PassFilterNative(self, (byte*)ptext, (byte*)(default));
				return ret != 0;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = PassFilterNative(self, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool PassFilter(ImGuiTextFilter* self, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = PassFilterNative(self, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool PassFilter(ref ImGuiTextFilter self, ref byte text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = PassFilterNative((ImGuiTextFilter*)pself, (byte*)ptext, textEnd);
					return ret != 0;
				}
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, ref byte text)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = PassFilterNative((ImGuiTextFilter*)pself, (byte*)ptext, (byte*)(default));
					return ret != 0;
				}
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, string text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = PassFilterNative((ImGuiTextFilter*)pself, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, string text)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = PassFilterNative((ImGuiTextFilter*)pself, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte ret = PassFilterNative(self, text, (byte*)ptextEnd);
				return ret != 0;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = PassFilterNative(self, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool PassFilter(ref ImGuiTextFilter self, byte* text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = PassFilterNative((ImGuiTextFilter*)pself, text, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, byte* text, string textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = PassFilterNative((ImGuiTextFilter*)pself, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = PassFilterNative(self, (byte*)ptext, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		public static bool PassFilter(ImGuiTextFilter* self, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = PassFilterNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool PassFilter(ref ImGuiTextFilter self, ref byte text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte ret = PassFilterNative((ImGuiTextFilter*)pself, (byte*)ptext, (byte*)ptextEnd);
						return ret != 0;
					}
				}
			}
		}

		public static bool PassFilter(ref ImGuiTextFilter self, string text, string textEnd)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = PassFilterNative((ImGuiTextFilter*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_Build")]
		internal static extern void BuildNative(ImGuiTextFilter* self);

		public static void Build(ImGuiTextFilter* self)
		{
			BuildNative(self);
		}

		public static void Build(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				BuildNative((ImGuiTextFilter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_Clear")]
		internal static extern void ClearNative(ImGuiTextFilter* self);

		public static void Clear(ImGuiTextFilter* self)
		{
			ClearNative(self);
		}

		public static void Clear(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				ClearNative((ImGuiTextFilter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextFilter_IsActive")]
		internal static extern byte IsActiveNative(ImGuiTextFilter* self);

		public static bool IsActive(ImGuiTextFilter* self)
		{
			byte ret = IsActiveNative(self);
			return ret != 0;
		}

		public static bool IsActive(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte ret = IsActiveNative((ImGuiTextFilter*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_ImGuiTextRange_Nil")]
		internal static extern ImGuiTextRange* ImGuiTextRangeNative();

		public static ImGuiTextRangePtr ImGuiTextRange()
		{
			ImGuiTextRangePtr ret = ImGuiTextRangeNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_destroy")]
		internal static extern void DestroyNative(ImGuiTextRange* self);

		public static void Destroy(ImGuiTextRange* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiTextRange self)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				DestroyNative((ImGuiTextRange*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_ImGuiTextRange_Str")]
		internal static extern ImGuiTextRange* ImGuiTextRangeNative(byte* b, byte* e);

		public static ImGuiTextRangePtr ImGuiTextRange(byte* b, byte* e)
		{
			ImGuiTextRangePtr ret = ImGuiTextRangeNative(b, e);
			return ret;
		}

		public static ImGuiTextRangePtr ImGuiTextRange(ref byte b, byte* e)
		{
			fixed (byte* pb = &b)
			{
				ImGuiTextRangePtr ret = ImGuiTextRangeNative((byte*)pb, e);
				return ret;
			}
		}

		public static ImGuiTextRangePtr ImGuiTextRange(string b, byte* e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (b != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(b);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(b, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextRangePtr ret = ImGuiTextRangeNative(pStr0, e);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImGuiTextRangePtr ImGuiTextRange(byte* b, ref byte e)
		{
			fixed (byte* pe = &e)
			{
				ImGuiTextRangePtr ret = ImGuiTextRangeNative(b, (byte*)pe);
				return ret;
			}
		}

		public static ImGuiTextRangePtr ImGuiTextRange(byte* b, string e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (e != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(e);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(e, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextRangePtr ret = ImGuiTextRangeNative(b, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImGuiTextRangePtr ImGuiTextRange(ref byte b, ref byte e)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pe = &e)
				{
					ImGuiTextRangePtr ret = ImGuiTextRangeNative((byte*)pb, (byte*)pe);
					return ret;
				}
			}
		}

		public static ImGuiTextRangePtr ImGuiTextRange(string b, string e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (b != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(b);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(b, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (e != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(e);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(e, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGuiTextRangePtr ret = ImGuiTextRangeNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_empty")]
		internal static extern byte emptyNative(ImGuiTextRange* self);

		public static bool empty(ImGuiTextRange* self)
		{
			byte ret = emptyNative(self);
			return ret != 0;
		}

		public static bool empty(ref ImGuiTextRange self)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				byte ret = emptyNative((ImGuiTextRange*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextRange_split")]
		internal static extern void splitNative(ImGuiTextRange* self, byte separator, ImVectorImGuiTextRange* output);

		public static void split(ImGuiTextRange* self, byte separator, ImVectorImGuiTextRange* output)
		{
			splitNative(self, separator, output);
		}

		public static void split(ref ImGuiTextRange self, byte separator, ImVectorImGuiTextRange* output)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				splitNative((ImGuiTextRange*)pself, separator, output);
			}
		}

		public static void split(ImGuiTextRange* self, byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImVectorImGuiTextRange* poutput = &output)
			{
				splitNative(self, separator, (ImVectorImGuiTextRange*)poutput);
			}
		}

		public static void split(ref ImGuiTextRange self, byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				fixed (ImVectorImGuiTextRange* poutput = &output)
				{
					splitNative((ImGuiTextRange*)pself, separator, (ImVectorImGuiTextRange*)poutput);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_ImGuiTextBuffer")]
		internal static extern ImGuiTextBuffer* ImGuiTextBufferNative();

		public static ImGuiTextBufferPtr ImGuiTextBuffer()
		{
			ImGuiTextBufferPtr ret = ImGuiTextBufferNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_destroy")]
		internal static extern void DestroyNative(ImGuiTextBuffer* self);

		public static void Destroy(ImGuiTextBuffer* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				DestroyNative((ImGuiTextBuffer*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_begin")]
		internal static extern byte* beginNative(ImGuiTextBuffer* self);

		public static byte* begin(ImGuiTextBuffer* self)
		{
			byte* ret = beginNative(self);
			return ret;
		}

		public static string beginS(ImGuiTextBuffer* self)
		{
			string ret = Utils.DecodeStringUTF8(beginNative(self));
			return ret;
		}

		public static byte* begin(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = beginNative((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		public static string beginS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(beginNative((ImGuiTextBuffer*)pself));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_end")]
		internal static extern byte* endNative(ImGuiTextBuffer* self);

		public static byte* end(ImGuiTextBuffer* self)
		{
			byte* ret = endNative(self);
			return ret;
		}

		public static string endS(ImGuiTextBuffer* self)
		{
			string ret = Utils.DecodeStringUTF8(endNative(self));
			return ret;
		}

		public static byte* end(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = endNative((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		public static string endS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(endNative((ImGuiTextBuffer*)pself));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_size")]
		internal static extern int sizeNative(ImGuiTextBuffer* self);

		public static int size(ImGuiTextBuffer* self)
		{
			int ret = sizeNative(self);
			return ret;
		}

		public static int size(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				int ret = sizeNative((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_empty")]
		internal static extern byte emptyNative(ImGuiTextBuffer* self);

		public static bool empty(ImGuiTextBuffer* self)
		{
			byte ret = emptyNative(self);
			return ret != 0;
		}

		public static bool empty(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte ret = emptyNative((ImGuiTextBuffer*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_clear")]
		internal static extern void clearNative(ImGuiTextBuffer* self);

		public static void clear(ImGuiTextBuffer* self)
		{
			clearNative(self);
		}

		public static void clear(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				clearNative((ImGuiTextBuffer*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_reserve")]
		internal static extern void reserveNative(ImGuiTextBuffer* self, int capacity);

		public static void reserve(ImGuiTextBuffer* self, int capacity)
		{
			reserveNative(self, capacity);
		}

		public static void reserve(ref ImGuiTextBuffer self, int capacity)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				reserveNative((ImGuiTextBuffer*)pself, capacity);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_c_str")]
		internal static extern byte* c_strNative(ImGuiTextBuffer* self);

		public static byte* c_str(ImGuiTextBuffer* self)
		{
			byte* ret = c_strNative(self);
			return ret;
		}

		public static string c_strS(ImGuiTextBuffer* self)
		{
			string ret = Utils.DecodeStringUTF8(c_strNative(self));
			return ret;
		}

		public static byte* c_str(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = c_strNative((ImGuiTextBuffer*)pself);
				return ret;
			}
		}

		public static string c_strS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(c_strNative((ImGuiTextBuffer*)pself));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_append")]
		internal static extern void appendNative(ImGuiTextBuffer* self, byte* str, byte* strEnd);

		public static void append(ImGuiTextBuffer* self, byte* str, byte* strEnd)
		{
			appendNative(self, str, strEnd);
		}

		public static void append(ImGuiTextBuffer* self, byte* str)
		{
			appendNative(self, str, (byte*)(default));
		}

		public static void append(ref ImGuiTextBuffer self, byte* str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				appendNative((ImGuiTextBuffer*)pself, str, strEnd);
			}
		}

		public static void append(ref ImGuiTextBuffer self, byte* str)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				appendNative((ImGuiTextBuffer*)pself, str, (byte*)(default));
			}
		}

		public static void append(ImGuiTextBuffer* self, ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				appendNative(self, (byte*)pstr, strEnd);
			}
		}

		public static void append(ImGuiTextBuffer* self, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				appendNative(self, (byte*)pstr, (byte*)(default));
			}
		}

		public static void append(ImGuiTextBuffer* self, string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendNative(self, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append(ImGuiTextBuffer* self, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendNative(self, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append(ref ImGuiTextBuffer self, ref byte str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					appendNative((ImGuiTextBuffer*)pself, (byte*)pstr, strEnd);
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, ref byte str)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					appendNative((ImGuiTextBuffer*)pself, (byte*)pstr, (byte*)(default));
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, string str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendNative((ImGuiTextBuffer*)pself, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, string str)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendNative((ImGuiTextBuffer*)pself, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void append(ImGuiTextBuffer* self, byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				appendNative(self, str, (byte*)pstrEnd);
			}
		}

		public static void append(ImGuiTextBuffer* self, byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendNative(self, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append(ref ImGuiTextBuffer self, byte* str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					appendNative((ImGuiTextBuffer*)pself, str, (byte*)pstrEnd);
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, byte* str, string strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendNative((ImGuiTextBuffer*)pself, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void append(ImGuiTextBuffer* self, ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					appendNative(self, (byte*)pstr, (byte*)pstrEnd);
				}
			}
		}

		public static void append(ImGuiTextBuffer* self, string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			appendNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append(ref ImGuiTextBuffer self, ref byte str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						appendNative((ImGuiTextBuffer*)pself, (byte*)pstr, (byte*)pstrEnd);
					}
				}
			}
		}

		public static void append(ref ImGuiTextBuffer self, string str, string strEnd)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				appendNative((ImGuiTextBuffer*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_appendfv")]
		internal static extern void appendfvNative(ImGuiTextBuffer* self, byte* fmt, nuint args);

		public static void appendfv(ImGuiTextBuffer* self, byte* fmt, nuint args)
		{
			appendfvNative(self, fmt, args);
		}

		public static void appendfv(ref ImGuiTextBuffer self, byte* fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				appendfvNative((ImGuiTextBuffer*)pself, fmt, args);
			}
		}

		public static void appendfv(ImGuiTextBuffer* self, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				appendfvNative(self, (byte*)pfmt, args);
			}
		}

		public static void appendfv(ImGuiTextBuffer* self, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendfvNative(self, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void appendfv(ref ImGuiTextBuffer self, ref byte fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				fixed (byte* pfmt = &fmt)
				{
					appendfvNative((ImGuiTextBuffer*)pself, (byte*)pfmt, args);
				}
			}
		}

		public static void appendfv(ref ImGuiTextBuffer self, string fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendfvNative((ImGuiTextBuffer*)pself, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Int")]
		internal static extern ImGuiStoragePair* ImGuiStoragePairNative(int key, int valI);

		public static ImGuiStoragePairPtr ImGuiStoragePair(int key, int valI)
		{
			ImGuiStoragePairPtr ret = ImGuiStoragePairNative(key, valI);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStoragePair_destroy")]
		internal static extern void DestroyNative(ImGuiStoragePair* self);

		public static void Destroy(ImGuiStoragePair* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiStoragePair self)
		{
			fixed (ImGuiStoragePair* pself = &self)
			{
				DestroyNative((ImGuiStoragePair*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Float")]
		internal static extern ImGuiStoragePair* ImGuiStoragePairNative(int key, float valF);

		public static ImGuiStoragePairPtr ImGuiStoragePair(int key, float valF)
		{
			ImGuiStoragePairPtr ret = ImGuiStoragePairNative(key, valF);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Ptr")]
		internal static extern ImGuiStoragePair* ImGuiStoragePairNative(int key, void* valP);

		public static ImGuiStoragePairPtr ImGuiStoragePair(int key, void* valP)
		{
			ImGuiStoragePairPtr ret = ImGuiStoragePairNative(key, valP);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_Clear")]
		internal static extern void ClearNative(ImGuiStorage* self);

		public static void Clear(ImGuiStorage* self)
		{
			ClearNative(self);
		}

		public static void Clear(ref ImGuiStorage self)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				ClearNative((ImGuiStorage*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetInt")]
		internal static extern int GetIntNative(ImGuiStorage* self, int key, int defaultVal);

		public static int GetInt(ImGuiStorage* self, int key, int defaultVal)
		{
			int ret = GetIntNative(self, key, defaultVal);
			return ret;
		}

		public static int GetInt(ImGuiStorage* self, int key)
		{
			int ret = GetIntNative(self, key, (int)(0));
			return ret;
		}

		public static int GetInt(ref ImGuiStorage self, int key, int defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int ret = GetIntNative((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		public static int GetInt(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int ret = GetIntNative((ImGuiStorage*)pself, key, (int)(0));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetInt")]
		internal static extern void SetIntNative(ImGuiStorage* self, int key, int val);

		public static void SetInt(ImGuiStorage* self, int key, int val)
		{
			SetIntNative(self, key, val);
		}

		public static void SetInt(ref ImGuiStorage self, int key, int val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetIntNative((ImGuiStorage*)pself, key, val);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetBool")]
		internal static extern byte GetBoolNative(ImGuiStorage* self, int key, byte defaultVal);

		public static bool GetBool(ImGuiStorage* self, int key, bool defaultVal)
		{
			byte ret = GetBoolNative(self, key, defaultVal ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool GetBool(ImGuiStorage* self, int key)
		{
			byte ret = GetBoolNative(self, key, (byte)(0));
			return ret != 0;
		}

		public static bool GetBool(ref ImGuiStorage self, int key, bool defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				byte ret = GetBoolNative((ImGuiStorage*)pself, key, defaultVal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool GetBool(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				byte ret = GetBoolNative((ImGuiStorage*)pself, key, (byte)(0));
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetBool")]
		internal static extern void SetBoolNative(ImGuiStorage* self, int key, byte val);

		public static void SetBool(ImGuiStorage* self, int key, bool val)
		{
			SetBoolNative(self, key, val ? (byte)1 : (byte)0);
		}

		public static void SetBool(ref ImGuiStorage self, int key, bool val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetBoolNative((ImGuiStorage*)pself, key, val ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetFloat")]
		internal static extern float GetFloatNative(ImGuiStorage* self, int key, float defaultVal);

		public static float GetFloat(ImGuiStorage* self, int key, float defaultVal)
		{
			float ret = GetFloatNative(self, key, defaultVal);
			return ret;
		}

		public static float GetFloat(ImGuiStorage* self, int key)
		{
			float ret = GetFloatNative(self, key, (float)(0.0f));
			return ret;
		}

		public static float GetFloat(ref ImGuiStorage self, int key, float defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float ret = GetFloatNative((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		public static float GetFloat(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float ret = GetFloatNative((ImGuiStorage*)pself, key, (float)(0.0f));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetFloat")]
		internal static extern void SetFloatNative(ImGuiStorage* self, int key, float val);

		public static void SetFloat(ImGuiStorage* self, int key, float val)
		{
			SetFloatNative(self, key, val);
		}

		public static void SetFloat(ref ImGuiStorage self, int key, float val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetFloatNative((ImGuiStorage*)pself, key, val);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetVoidPtr")]
		internal static extern void* GetVoidPtrNative(ImGuiStorage* self, int key);

		public static void* GetVoidPtr(ImGuiStorage* self, int key)
		{
			void* ret = GetVoidPtrNative(self, key);
			return ret;
		}

		public static void* GetVoidPtr(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				void* ret = GetVoidPtrNative((ImGuiStorage*)pself, key);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetVoidPtr")]
		internal static extern void SetVoidPtrNative(ImGuiStorage* self, int key, void* val);

		public static void SetVoidPtr(ImGuiStorage* self, int key, void* val)
		{
			SetVoidPtrNative(self, key, val);
		}

		public static void SetVoidPtr(ref ImGuiStorage self, int key, void* val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetVoidPtrNative((ImGuiStorage*)pself, key, val);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetIntRef")]
		internal static extern int* GetIntRefNative(ImGuiStorage* self, int key, int defaultVal);

		public static int* GetIntRef(ImGuiStorage* self, int key, int defaultVal)
		{
			int* ret = GetIntRefNative(self, key, defaultVal);
			return ret;
		}

		public static int* GetIntRef(ImGuiStorage* self, int key)
		{
			int* ret = GetIntRefNative(self, key, (int)(0));
			return ret;
		}

		public static int* GetIntRef(ref ImGuiStorage self, int key, int defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int* ret = GetIntRefNative((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		public static int* GetIntRef(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int* ret = GetIntRefNative((ImGuiStorage*)pself, key, (int)(0));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetBoolRef")]
		internal static extern bool* GetBoolRefNative(ImGuiStorage* self, int key, byte defaultVal);

		public static bool* GetBoolRef(ImGuiStorage* self, int key, bool defaultVal)
		{
			bool* ret = GetBoolRefNative(self, key, defaultVal ? (byte)1 : (byte)0);
			return ret;
		}

		public static bool* GetBoolRef(ImGuiStorage* self, int key)
		{
			bool* ret = GetBoolRefNative(self, key, (byte)(0));
			return ret;
		}

		public static bool* GetBoolRef(ref ImGuiStorage self, int key, bool defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				bool* ret = GetBoolRefNative((ImGuiStorage*)pself, key, defaultVal ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public static bool* GetBoolRef(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				bool* ret = GetBoolRefNative((ImGuiStorage*)pself, key, (byte)(0));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetFloatRef")]
		internal static extern float* GetFloatRefNative(ImGuiStorage* self, int key, float defaultVal);

		public static float* GetFloatRef(ImGuiStorage* self, int key, float defaultVal)
		{
			float* ret = GetFloatRefNative(self, key, defaultVal);
			return ret;
		}

		public static float* GetFloatRef(ImGuiStorage* self, int key)
		{
			float* ret = GetFloatRefNative(self, key, (float)(0.0f));
			return ret;
		}

		public static float* GetFloatRef(ref ImGuiStorage self, int key, float defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float* ret = GetFloatRefNative((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		public static float* GetFloatRef(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float* ret = GetFloatRefNative((ImGuiStorage*)pself, key, (float)(0.0f));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_GetVoidPtrRef")]
		internal static extern void** GetVoidPtrRefNative(ImGuiStorage* self, int key, void* defaultVal);

		public static void** GetVoidPtrRef(ImGuiStorage* self, int key, void* defaultVal)
		{
			void** ret = GetVoidPtrRefNative(self, key, defaultVal);
			return ret;
		}

		public static void** GetVoidPtrRef(ImGuiStorage* self, int key)
		{
			void** ret = GetVoidPtrRefNative(self, key, (void*)(default));
			return ret;
		}

		public static void** GetVoidPtrRef(ref ImGuiStorage self, int key, void* defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				void** ret = GetVoidPtrRefNative((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}

		public static void** GetVoidPtrRef(ref ImGuiStorage self, int key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				void** ret = GetVoidPtrRefNative((ImGuiStorage*)pself, key, (void*)(default));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_SetAllInt")]
		internal static extern void SetAllIntNative(ImGuiStorage* self, int val);

		public static void SetAllInt(ImGuiStorage* self, int val)
		{
			SetAllIntNative(self, val);
		}

		public static void SetAllInt(ref ImGuiStorage self, int val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				SetAllIntNative((ImGuiStorage*)pself, val);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStorage_BuildSortByKey")]
		internal static extern void BuildSortByKeyNative(ImGuiStorage* self);

		public static void BuildSortByKey(ImGuiStorage* self)
		{
			BuildSortByKeyNative(self);
		}

		public static void BuildSortByKey(ref ImGuiStorage self)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				BuildSortByKeyNative((ImGuiStorage*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_ImGuiListClipper")]
		internal static extern ImGuiListClipper* ImGuiListClipperNative();

		public static ImGuiListClipperPtr ImGuiListClipper()
		{
			ImGuiListClipperPtr ret = ImGuiListClipperNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_destroy")]
		internal static extern void DestroyNative(ImGuiListClipper* self);

		public static void Destroy(ImGuiListClipper* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				DestroyNative((ImGuiListClipper*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_Begin")]
		internal static extern void BeginNative(ImGuiListClipper* self, int itemsCount, float itemsHeight);

		public static void Begin(ImGuiListClipper* self, int itemsCount, float itemsHeight)
		{
			BeginNative(self, itemsCount, itemsHeight);
		}

		public static void Begin(ImGuiListClipper* self, int itemsCount)
		{
			BeginNative(self, itemsCount, (float)(-1.0f));
		}

		public static void Begin(ref ImGuiListClipper self, int itemsCount, float itemsHeight)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				BeginNative((ImGuiListClipper*)pself, itemsCount, itemsHeight);
			}
		}

		public static void Begin(ref ImGuiListClipper self, int itemsCount)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				BeginNative((ImGuiListClipper*)pself, itemsCount, (float)(-1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_End")]
		internal static extern void EndNative(ImGuiListClipper* self);

		public static void End(ImGuiListClipper* self)
		{
			EndNative(self);
		}

		public static void End(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				EndNative((ImGuiListClipper*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_Step")]
		internal static extern byte StepNative(ImGuiListClipper* self);

		public static bool Step(ImGuiListClipper* self)
		{
			byte ret = StepNative(self);
			return ret != 0;
		}

		public static bool Step(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				byte ret = StepNative((ImGuiListClipper*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipper_ForceDisplayRangeByIndices")]
		internal static extern void ForceDisplayRangeByIndicesNative(ImGuiListClipper* self, int itemMin, int itemMax);

		public static void ForceDisplayRangeByIndices(ImGuiListClipper* self, int itemMin, int itemMax)
		{
			ForceDisplayRangeByIndicesNative(self, itemMin, itemMax);
		}

		public static void ForceDisplayRangeByIndices(ref ImGuiListClipper self, int itemMin, int itemMax)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				ForceDisplayRangeByIndicesNative((ImGuiListClipper*)pself, itemMin, itemMax);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_Nil")]
		internal static extern ImColor* ImColorNative();

		public static ImColorPtr ImColor()
		{
			ImColorPtr ret = ImColorNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_destroy")]
		internal static extern void DestroyNative(ImColor* self);

		public static void Destroy(ImColor* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImColor self)
		{
			fixed (ImColor* pself = &self)
			{
				DestroyNative((ImColor*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_Float")]
		internal static extern ImColor* ImColorNative(float r, float g, float b, float a);

		public static ImColorPtr ImColor(float r, float g, float b, float a)
		{
			ImColorPtr ret = ImColorNative(r, g, b, a);
			return ret;
		}

		public static ImColorPtr ImColor(float r, float g, float b)
		{
			ImColorPtr ret = ImColorNative(r, g, b, (float)(1.0f));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_Vec4")]
		internal static extern ImColor* ImColorNative(Vector4 col);

		public static ImColorPtr ImColor(Vector4 col)
		{
			ImColorPtr ret = ImColorNative(col);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_Int")]
		internal static extern ImColor* ImColorNative(int r, int g, int b, int a);

		public static ImColorPtr ImColor(int r, int g, int b, int a)
		{
			ImColorPtr ret = ImColorNative(r, g, b, a);
			return ret;
		}

		public static ImColorPtr ImColor(int r, int g, int b)
		{
			ImColorPtr ret = ImColorNative(r, g, b, (int)(255));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_ImColor_U32")]
		internal static extern ImColor* ImColorNative(uint rgba);

		public static ImColorPtr ImColor(uint rgba)
		{
			ImColorPtr ret = ImColorNative(rgba);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_SetHSV")]
		internal static extern void SetHSVNative(ImColor* self, float h, float s, float v, float a);

		public static void SetHSV(ImColor* self, float h, float s, float v, float a)
		{
			SetHSVNative(self, h, s, v, a);
		}

		public static void SetHSV(ImColor* self, float h, float s, float v)
		{
			SetHSVNative(self, h, s, v, (float)(1.0f));
		}

		public static void SetHSV(ref ImColor self, float h, float s, float v, float a)
		{
			fixed (ImColor* pself = &self)
			{
				SetHSVNative((ImColor*)pself, h, s, v, a);
			}
		}

		public static void SetHSV(ref ImColor self, float h, float s, float v)
		{
			fixed (ImColor* pself = &self)
			{
				SetHSVNative((ImColor*)pself, h, s, v, (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImColor_HSV")]
		internal static extern void HSVNative(ImColor* output, float h, float s, float v, float a);

		public static ImColor HSV(float h, float s, float v)
		{
			ImColor ret;
			HSVNative(&ret, h, s, v, (float)(1.0f));
			return ret;
		}

		public static ImColor HSV(float h, float s, float v, float a)
		{
			ImColor ret;
			HSVNative(&ret, h, s, v, a);
			return ret;
		}

		public static void HSV(ref ImColor output, float h, float s, float v, float a)
		{
			fixed (ImColor* poutput = &output)
			{
				HSVNative((ImColor*)poutput, h, s, v, a);
			}
		}

		public static void HSV(ref ImColor output, float h, float s, float v)
		{
			fixed (ImColor* poutput = &output)
			{
				HSVNative((ImColor*)poutput, h, s, v, (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawCmd_ImDrawCmd")]
		internal static extern ImDrawCmd* ImDrawCmdNative();

		public static ImDrawCmdPtr ImDrawCmd()
		{
			ImDrawCmdPtr ret = ImDrawCmdNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawCmd_destroy")]
		internal static extern void DestroyNative(ImDrawCmd* self);

		public static void Destroy(ImDrawCmd* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImDrawCmd self)
		{
			fixed (ImDrawCmd* pself = &self)
			{
				DestroyNative((ImDrawCmd*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawCmd_GetTexID")]
		internal static extern ImTextureID GetTexIDNative(ImDrawCmd* self);

		public static ImTextureID GetTexID(ImDrawCmd* self)
		{
			ImTextureID ret = GetTexIDNative(self);
			return ret;
		}

		public static ImTextureID GetTexID(ref ImDrawCmd self)
		{
			fixed (ImDrawCmd* pself = &self)
			{
				ImTextureID ret = GetTexIDNative((ImDrawCmd*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_ImDrawListSplitter")]
		internal static extern ImDrawListSplitter* ImDrawListSplitterNative();

		public static ImDrawListSplitterPtr ImDrawListSplitter()
		{
			ImDrawListSplitterPtr ret = ImDrawListSplitterNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_destroy")]
		internal static extern void DestroyNative(ImDrawListSplitter* self);

		public static void Destroy(ImDrawListSplitter* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				DestroyNative((ImDrawListSplitter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_Clear")]
		internal static extern void ClearNative(ImDrawListSplitter* self);

		public static void Clear(ImDrawListSplitter* self)
		{
			ClearNative(self);
		}

		public static void Clear(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ClearNative((ImDrawListSplitter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_ClearFreeMemory")]
		internal static extern void ClearFreeMemoryNative(ImDrawListSplitter* self);

		public static void ClearFreeMemory(ImDrawListSplitter* self)
		{
			ClearFreeMemoryNative(self);
		}

		public static void ClearFreeMemory(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ClearFreeMemoryNative((ImDrawListSplitter*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_Split")]
		internal static extern void SplitNative(ImDrawListSplitter* self, ImDrawList* drawList, int count);

		public static void Split(ImDrawListSplitter* self, ImDrawList* drawList, int count)
		{
			SplitNative(self, drawList, count);
		}

		public static void Split(ref ImDrawListSplitter self, ImDrawList* drawList, int count)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				SplitNative((ImDrawListSplitter*)pself, drawList, count);
			}
		}

		public static void Split(ImDrawListSplitter* self, ref ImDrawList drawList, int count)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				SplitNative(self, (ImDrawList*)pdrawList, count);
			}
		}

		public static void Split(ref ImDrawListSplitter self, ref ImDrawList drawList, int count)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					SplitNative((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList, count);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_Merge")]
		internal static extern void MergeNative(ImDrawListSplitter* self, ImDrawList* drawList);

		public static void Merge(ImDrawListSplitter* self, ImDrawList* drawList)
		{
			MergeNative(self, drawList);
		}

		public static void Merge(ref ImDrawListSplitter self, ImDrawList* drawList)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				MergeNative((ImDrawListSplitter*)pself, drawList);
			}
		}

		public static void Merge(ImDrawListSplitter* self, ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				MergeNative(self, (ImDrawList*)pdrawList);
			}
		}

		public static void Merge(ref ImDrawListSplitter self, ref ImDrawList drawList)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					MergeNative((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSplitter_SetCurrentChannel")]
		internal static extern void SetCurrentChannelNative(ImDrawListSplitter* self, ImDrawList* drawList, int channelIdx);

		public static void SetCurrentChannel(ImDrawListSplitter* self, ImDrawList* drawList, int channelIdx)
		{
			SetCurrentChannelNative(self, drawList, channelIdx);
		}

		public static void SetCurrentChannel(ref ImDrawListSplitter self, ImDrawList* drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				SetCurrentChannelNative((ImDrawListSplitter*)pself, drawList, channelIdx);
			}
		}

		public static void SetCurrentChannel(ImDrawListSplitter* self, ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				SetCurrentChannelNative(self, (ImDrawList*)pdrawList, channelIdx);
			}
		}

		public static void SetCurrentChannel(ref ImDrawListSplitter self, ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					SetCurrentChannelNative((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList, channelIdx);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_ImDrawList")]
		internal static extern ImDrawList* ImDrawListNative(ImDrawListSharedData* sharedData);

		public static ImDrawListPtr ImDrawList(ImDrawListSharedData* sharedData)
		{
			ImDrawListPtr ret = ImDrawListNative(sharedData);
			return ret;
		}

		public static ImDrawListPtr ImDrawList(ref ImDrawListSharedData sharedData)
		{
			fixed (ImDrawListSharedData* psharedData = &sharedData)
			{
				ImDrawListPtr ret = ImDrawListNative((ImDrawListSharedData*)psharedData);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_destroy")]
		internal static extern void DestroyNative(ImDrawList* self);

		public static void Destroy(ImDrawList* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				DestroyNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PushClipRect")]
		internal static extern void PushClipRectNative(ImDrawList* self, Vector2 clipRectMin, Vector2 clipRectMax, byte intersectWithCurrentClipRect);

		public static void PushClipRect(ImDrawList* self, Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			PushClipRectNative(self, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		public static void PushClipRect(ImDrawList* self, Vector2 clipRectMin, Vector2 clipRectMax)
		{
			PushClipRectNative(self, clipRectMin, clipRectMax, (byte)(0));
		}

		public static void PushClipRect(ref ImDrawList self, Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				PushClipRectNative((ImDrawList*)pself, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
			}
		}

		public static void PushClipRect(ref ImDrawList self, Vector2 clipRectMin, Vector2 clipRectMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				PushClipRectNative((ImDrawList*)pself, clipRectMin, clipRectMax, (byte)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PushClipRectFullScreen")]
		internal static extern void PushClipRectFullScreenNative(ImDrawList* self);

		public static void PushClipRectFullScreen(ImDrawList* self)
		{
			PushClipRectFullScreenNative(self);
		}

		public static void PushClipRectFullScreen(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				PushClipRectFullScreenNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PopClipRect")]
		internal static extern void PopClipRectNative(ImDrawList* self);

		public static void PopClipRect(ImDrawList* self)
		{
			PopClipRectNative(self);
		}

		public static void PopClipRect(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				PopClipRectNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PushTextureID")]
		internal static extern void PushTextureIDNative(ImDrawList* self, ImTextureID textureId);

		public static void PushTextureID(ImDrawList* self, ImTextureID textureId)
		{
			PushTextureIDNative(self, textureId);
		}

		public static void PushTextureID(ref ImDrawList self, ImTextureID textureId)
		{
			fixed (ImDrawList* pself = &self)
			{
				PushTextureIDNative((ImDrawList*)pself, textureId);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PopTextureID")]
		internal static extern void PopTextureIDNative(ImDrawList* self);

		public static void PopTextureID(ImDrawList* self)
		{
			PopTextureIDNative(self);
		}

		public static void PopTextureID(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				PopTextureIDNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_GetClipRectMin")]
		internal static extern void GetClipRectMinNative(Vector2* output, ImDrawList* self);

		public static Vector2 GetClipRectMin(ImDrawList* self)
		{
			Vector2 ret;
			GetClipRectMinNative(&ret, self);
			return ret;
		}

		public static void GetClipRectMin(ref Vector2 output, ImDrawList* self)
		{
			fixed (Vector2* poutput = &output)
			{
				GetClipRectMinNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 GetClipRectMin(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				Vector2 ret;
				GetClipRectMinNative(&ret, (ImDrawList*)pself);
				return ret;
			}
		}

		public static void GetClipRectMin(ref Vector2 output, ref ImDrawList self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImDrawList* pself = &self)
				{
					GetClipRectMinNative((Vector2*)poutput, (ImDrawList*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_GetClipRectMax")]
		internal static extern void GetClipRectMaxNative(Vector2* output, ImDrawList* self);

		public static Vector2 GetClipRectMax(ImDrawList* self)
		{
			Vector2 ret;
			GetClipRectMaxNative(&ret, self);
			return ret;
		}

		public static void GetClipRectMax(ref Vector2 output, ImDrawList* self)
		{
			fixed (Vector2* poutput = &output)
			{
				GetClipRectMaxNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 GetClipRectMax(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				Vector2 ret;
				GetClipRectMaxNative(&ret, (ImDrawList*)pself);
				return ret;
			}
		}

		public static void GetClipRectMax(ref Vector2 output, ref ImDrawList self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImDrawList* pself = &self)
				{
					GetClipRectMaxNative((Vector2*)poutput, (ImDrawList*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddLine")]
		internal static extern void AddLineNative(ImDrawList* self, Vector2 p1, Vector2 p2, uint col, float thickness);

		public static void AddLine(ImDrawList* self, Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			AddLineNative(self, p1, p2, col, thickness);
		}

		public static void AddLine(ImDrawList* self, Vector2 p1, Vector2 p2, uint col)
		{
			AddLineNative(self, p1, p2, col, (float)(1.0f));
		}

		public static void AddLine(ref ImDrawList self, Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddLineNative((ImDrawList*)pself, p1, p2, col, thickness);
			}
		}

		public static void AddLine(ref ImDrawList self, Vector2 p1, Vector2 p2, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddLineNative((ImDrawList*)pself, p1, p2, col, (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddRect")]
		internal static extern void AddRectNative(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness);

		public static void AddRect(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			AddRectNative(self, pMin, pMax, col, rounding, flags, thickness);
		}

		public static void AddRect(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			AddRectNative(self, pMin, pMax, col, rounding, flags, (float)(1.0f));
		}

		public static void AddRect(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			AddRectNative(self, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
		}

		public static void AddRect(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col)
		{
			AddRectNative(self, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
		}

		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectNative((ImDrawList*)pself, pMin, pMax, col, rounding, flags, thickness);
			}
		}

		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectNative((ImDrawList*)pself, pMin, pMax, col, rounding, flags, (float)(1.0f));
			}
		}

		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectNative((ImDrawList*)pself, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectNative((ImDrawList*)pself, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddRectFilled")]
		internal static extern void AddRectFilledNative(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags);

		public static void AddRectFilled(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			AddRectFilledNative(self, pMin, pMax, col, rounding, flags);
		}

		public static void AddRectFilled(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			AddRectFilledNative(self, pMin, pMax, col, rounding, (ImDrawFlags)(0));
		}

		public static void AddRectFilled(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col)
		{
			AddRectFilledNative(self, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
		}

		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectFilledNative((ImDrawList*)pself, pMin, pMax, col, rounding, flags);
			}
		}

		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectFilledNative((ImDrawList*)pself, pMin, pMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectFilledNative((ImDrawList*)pself, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddRectFilledMultiColor")]
		internal static extern void AddRectFilledMultiColorNative(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft);

		public static void AddRectFilledMultiColor(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			AddRectFilledMultiColorNative(self, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
		}

		public static void AddRectFilledMultiColor(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddRectFilledMultiColorNative((ImDrawList*)pself, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddQuad")]
		internal static extern void AddQuadNative(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness);

		public static void AddQuad(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			AddQuadNative(self, p1, p2, p3, p4, col, thickness);
		}

		public static void AddQuad(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			AddQuadNative(self, p1, p2, p3, p4, col, (float)(1.0f));
		}

		public static void AddQuad(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddQuadNative((ImDrawList*)pself, p1, p2, p3, p4, col, thickness);
			}
		}

		public static void AddQuad(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddQuadNative((ImDrawList*)pself, p1, p2, p3, p4, col, (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddQuadFilled")]
		internal static extern void AddQuadFilledNative(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col);

		public static void AddQuadFilled(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			AddQuadFilledNative(self, p1, p2, p3, p4, col);
		}

		public static void AddQuadFilled(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddQuadFilledNative((ImDrawList*)pself, p1, p2, p3, p4, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddTriangle")]
		internal static extern void AddTriangleNative(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness);

		public static void AddTriangle(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			AddTriangleNative(self, p1, p2, p3, col, thickness);
		}

		public static void AddTriangle(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			AddTriangleNative(self, p1, p2, p3, col, (float)(1.0f));
		}

		public static void AddTriangle(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTriangleNative((ImDrawList*)pself, p1, p2, p3, col, thickness);
			}
		}

		public static void AddTriangle(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTriangleNative((ImDrawList*)pself, p1, p2, p3, col, (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddTriangleFilled")]
		internal static extern void AddTriangleFilledNative(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col);

		public static void AddTriangleFilled(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			AddTriangleFilledNative(self, p1, p2, p3, col);
		}

		public static void AddTriangleFilled(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTriangleFilledNative((ImDrawList*)pself, p1, p2, p3, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddCircle")]
		internal static extern void AddCircleNative(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments, float thickness);

		public static void AddCircle(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			AddCircleNative(self, center, radius, col, numSegments, thickness);
		}

		public static void AddCircle(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments)
		{
			AddCircleNative(self, center, radius, col, numSegments, (float)(1.0f));
		}

		public static void AddCircle(ImDrawList* self, Vector2 center, float radius, uint col)
		{
			AddCircleNative(self, center, radius, col, (int)(0), (float)(1.0f));
		}

		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircleNative((ImDrawList*)pself, center, radius, col, numSegments, thickness);
			}
		}

		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircleNative((ImDrawList*)pself, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircleNative((ImDrawList*)pself, center, radius, col, (int)(0), (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddCircleFilled")]
		internal static extern void AddCircleFilledNative(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments);

		public static void AddCircleFilled(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments)
		{
			AddCircleFilledNative(self, center, radius, col, numSegments);
		}

		public static void AddCircleFilled(ImDrawList* self, Vector2 center, float radius, uint col)
		{
			AddCircleFilledNative(self, center, radius, col, (int)(0));
		}

		public static void AddCircleFilled(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircleFilledNative((ImDrawList*)pself, center, radius, col, numSegments);
			}
		}

		public static void AddCircleFilled(ref ImDrawList self, Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCircleFilledNative((ImDrawList*)pself, center, radius, col, (int)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddNgon")]
		internal static extern void AddNgonNative(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments, float thickness);

		public static void AddNgon(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			AddNgonNative(self, center, radius, col, numSegments, thickness);
		}

		public static void AddNgon(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments)
		{
			AddNgonNative(self, center, radius, col, numSegments, (float)(1.0f));
		}

		public static void AddNgon(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddNgonNative((ImDrawList*)pself, center, radius, col, numSegments, thickness);
			}
		}

		public static void AddNgon(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddNgonNative((ImDrawList*)pself, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddNgonFilled")]
		internal static extern void AddNgonFilledNative(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments);

		public static void AddNgonFilled(ImDrawList* self, Vector2 center, float radius, uint col, int numSegments)
		{
			AddNgonFilledNative(self, center, radius, col, numSegments);
		}

		public static void AddNgonFilled(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddNgonFilledNative((ImDrawList*)pself, center, radius, col, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddText_Vec2")]
		internal static extern void AddTextNative(ImDrawList* self, Vector2 pos, uint col, byte* textBegin, byte* textEnd);

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			AddTextNative(self, pos, col, textBegin, textEnd);
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, byte* textBegin)
		{
			AddTextNative(self, pos, col, textBegin, (byte*)(default));
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTextNative((ImDrawList*)pself, pos, col, textBegin, textEnd);
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTextNative((ImDrawList*)pself, pos, col, textBegin, (byte*)(default));
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextNative(self, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextNative(self, pos, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, pos, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, pos, col, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative((ImDrawList*)pself, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative((ImDrawList*)pself, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, pos, col, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextNative(self, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, pos, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative((ImDrawList*)pself, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative(self, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		public static void AddText(ImDrawList* self, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddTextNative(self, pos, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative((ImDrawList*)pself, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextNative((ImDrawList*)pself, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddText_FontPtr")]
		internal static extern void AddTextNative(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect);

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			AddTextNative(self, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			AddTextNative(self, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			AddTextNative(self, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			AddTextNative(self, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextNative(self, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextNative(self, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextNative(self, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddTextNative(self, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				AddTextNative(self, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				AddTextNative(self, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative(self, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				AddTextNative(self, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative(self, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				AddTextNative(self, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative((ImDrawList*)pself, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public static void AddText(ImDrawList* self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					AddTextNative(self, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public static void AddText(ref ImDrawList self, ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						AddTextNative((ImDrawList*)pself, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddPolyline")]
		internal static extern void AddPolylineNative(ImDrawList* self, Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness);

		public static void AddPolyline(ImDrawList* self, Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			AddPolylineNative(self, points, numPoints, col, flags, thickness);
		}

		public static void AddPolyline(ref ImDrawList self, Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddPolylineNative((ImDrawList*)pself, points, numPoints, col, flags, thickness);
			}
		}

		public static void AddPolyline(ImDrawList* self, ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (Vector2* ppoints = &points)
			{
				AddPolylineNative(self, (Vector2*)ppoints, numPoints, col, flags, thickness);
			}
		}

		public static void AddPolyline(ref ImDrawList self, ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (Vector2* ppoints = &points)
				{
					AddPolylineNative((ImDrawList*)pself, (Vector2*)ppoints, numPoints, col, flags, thickness);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddConvexPolyFilled")]
		internal static extern void AddConvexPolyFilledNative(ImDrawList* self, Vector2* points, int numPoints, uint col);

		public static void AddConvexPolyFilled(ImDrawList* self, Vector2* points, int numPoints, uint col)
		{
			AddConvexPolyFilledNative(self, points, numPoints, col);
		}

		public static void AddConvexPolyFilled(ref ImDrawList self, Vector2* points, int numPoints, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddConvexPolyFilledNative((ImDrawList*)pself, points, numPoints, col);
			}
		}

		public static void AddConvexPolyFilled(ImDrawList* self, ref Vector2 points, int numPoints, uint col)
		{
			fixed (Vector2* ppoints = &points)
			{
				AddConvexPolyFilledNative(self, (Vector2*)ppoints, numPoints, col);
			}
		}

		public static void AddConvexPolyFilled(ref ImDrawList self, ref Vector2 points, int numPoints, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (Vector2* ppoints = &points)
				{
					AddConvexPolyFilledNative((ImDrawList*)pself, (Vector2*)ppoints, numPoints, col);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddBezierCubic")]
		internal static extern void AddBezierCubicNative(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments);

		public static void AddBezierCubic(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			AddBezierCubicNative(self, p1, p2, p3, p4, col, thickness, numSegments);
		}

		public static void AddBezierCubic(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			AddBezierCubicNative(self, p1, p2, p3, p4, col, thickness, (int)(0));
		}

		public static void AddBezierCubic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddBezierCubicNative((ImDrawList*)pself, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}

		public static void AddBezierCubic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddBezierCubicNative((ImDrawList*)pself, p1, p2, p3, p4, col, thickness, (int)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddBezierQuadratic")]
		internal static extern void AddBezierQuadraticNative(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments);

		public static void AddBezierQuadratic(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			AddBezierQuadraticNative(self, p1, p2, p3, col, thickness, numSegments);
		}

		public static void AddBezierQuadratic(ImDrawList* self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			AddBezierQuadraticNative(self, p1, p2, p3, col, thickness, (int)(0));
		}

		public static void AddBezierQuadratic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddBezierQuadraticNative((ImDrawList*)pself, p1, p2, p3, col, thickness, numSegments);
			}
		}

		public static void AddBezierQuadratic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddBezierQuadraticNative((ImDrawList*)pself, p1, p2, p3, col, thickness, (int)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddImage")]
		internal static extern void AddImageNative(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col);

		public static void AddImage(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			AddImageNative(self, userTextureId, pMin, pMax, uvMin, uvMax, col);
		}

		public static void AddImage(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			AddImageNative(self, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
		}

		public static void AddImage(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			AddImageNative(self, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}

		public static void AddImage(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			AddImageNative(self, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}

		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageNative((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}

		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageNative((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
			}
		}

		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageNative((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageNative((ImDrawList*)pself, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddImageQuad")]
		internal static extern void AddImageQuadNative(ImDrawList* self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col);

		public static void AddImageQuad(ImDrawList* self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			AddImageQuadNative(self, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
		}

		public static void AddImageQuad(ImDrawList* self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			AddImageQuadNative(self, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
		}

		public static void AddImageQuad(ImDrawList* self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			AddImageQuadNative(self, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public static void AddImageQuad(ImDrawList* self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			AddImageQuadNative(self, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public static void AddImageQuad(ImDrawList* self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			AddImageQuadNative(self, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public static void AddImageQuad(ImDrawList* self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			AddImageQuadNative(self, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuadNative((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuadNative((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuadNative((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuadNative((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuadNative((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageQuadNative((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddImageRounded")]
		internal static extern void AddImageRoundedNative(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags);

		public static void AddImageRounded(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			AddImageRoundedNative(self, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
		}

		public static void AddImageRounded(ImDrawList* self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			AddImageRoundedNative(self, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
		}

		public static void AddImageRounded(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageRoundedNative((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}

		public static void AddImageRounded(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddImageRoundedNative((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathClear")]
		internal static extern void PathClearNative(ImDrawList* self);

		public static void PathClear(ImDrawList* self)
		{
			PathClearNative(self);
		}

		public static void PathClear(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathClearNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathLineTo")]
		internal static extern void PathLineToNative(ImDrawList* self, Vector2 pos);

		public static void PathLineTo(ImDrawList* self, Vector2 pos)
		{
			PathLineToNative(self, pos);
		}

		public static void PathLineTo(ref ImDrawList self, Vector2 pos)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathLineToNative((ImDrawList*)pself, pos);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathLineToMergeDuplicate")]
		internal static extern void PathLineToMergeDuplicateNative(ImDrawList* self, Vector2 pos);

		public static void PathLineToMergeDuplicate(ImDrawList* self, Vector2 pos)
		{
			PathLineToMergeDuplicateNative(self, pos);
		}

		public static void PathLineToMergeDuplicate(ref ImDrawList self, Vector2 pos)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathLineToMergeDuplicateNative((ImDrawList*)pself, pos);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathFillConvex")]
		internal static extern void PathFillConvexNative(ImDrawList* self, uint col);

		public static void PathFillConvex(ImDrawList* self, uint col)
		{
			PathFillConvexNative(self, col);
		}

		public static void PathFillConvex(ref ImDrawList self, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathFillConvexNative((ImDrawList*)pself, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathStroke")]
		internal static extern void PathStrokeNative(ImDrawList* self, uint col, ImDrawFlags flags, float thickness);

		public static void PathStroke(ImDrawList* self, uint col, ImDrawFlags flags, float thickness)
		{
			PathStrokeNative(self, col, flags, thickness);
		}

		public static void PathStroke(ImDrawList* self, uint col, ImDrawFlags flags)
		{
			PathStrokeNative(self, col, flags, (float)(1.0f));
		}

		public static void PathStroke(ImDrawList* self, uint col)
		{
			PathStrokeNative(self, col, (ImDrawFlags)(0), (float)(1.0f));
		}

		public static void PathStroke(ref ImDrawList self, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathStrokeNative((ImDrawList*)pself, col, flags, thickness);
			}
		}

		public static void PathStroke(ref ImDrawList self, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathStrokeNative((ImDrawList*)pself, col, flags, (float)(1.0f));
			}
		}

		public static void PathStroke(ref ImDrawList self, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathStrokeNative((ImDrawList*)pself, col, (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathArcTo")]
		internal static extern void PathArcToNative(ImDrawList* self, Vector2 center, float radius, float aMin, float aMax, int numSegments);

		public static void PathArcTo(ImDrawList* self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			PathArcToNative(self, center, radius, aMin, aMax, numSegments);
		}

		public static void PathArcTo(ImDrawList* self, Vector2 center, float radius, float aMin, float aMax)
		{
			PathArcToNative(self, center, radius, aMin, aMax, (int)(0));
		}

		public static void PathArcTo(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathArcToNative((ImDrawList*)pself, center, radius, aMin, aMax, numSegments);
			}
		}

		public static void PathArcTo(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathArcToNative((ImDrawList*)pself, center, radius, aMin, aMax, (int)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathArcToFast")]
		internal static extern void PathArcToFastNative(ImDrawList* self, Vector2 center, float radius, int aMinOf12, int aMaxOf12);

		public static void PathArcToFast(ImDrawList* self, Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			PathArcToFastNative(self, center, radius, aMinOf12, aMaxOf12);
		}

		public static void PathArcToFast(ref ImDrawList self, Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathArcToFastNative((ImDrawList*)pself, center, radius, aMinOf12, aMaxOf12);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathBezierCubicCurveTo")]
		internal static extern void PathBezierCubicCurveToNative(ImDrawList* self, Vector2 p2, Vector2 p3, Vector2 p4, int numSegments);

		public static void PathBezierCubicCurveTo(ImDrawList* self, Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			PathBezierCubicCurveToNative(self, p2, p3, p4, numSegments);
		}

		public static void PathBezierCubicCurveTo(ImDrawList* self, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			PathBezierCubicCurveToNative(self, p2, p3, p4, (int)(0));
		}

		public static void PathBezierCubicCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathBezierCubicCurveToNative((ImDrawList*)pself, p2, p3, p4, numSegments);
			}
		}

		public static void PathBezierCubicCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathBezierCubicCurveToNative((ImDrawList*)pself, p2, p3, p4, (int)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathBezierQuadraticCurveTo")]
		internal static extern void PathBezierQuadraticCurveToNative(ImDrawList* self, Vector2 p2, Vector2 p3, int numSegments);

		public static void PathBezierQuadraticCurveTo(ImDrawList* self, Vector2 p2, Vector2 p3, int numSegments)
		{
			PathBezierQuadraticCurveToNative(self, p2, p3, numSegments);
		}

		public static void PathBezierQuadraticCurveTo(ImDrawList* self, Vector2 p2, Vector2 p3)
		{
			PathBezierQuadraticCurveToNative(self, p2, p3, (int)(0));
		}

		public static void PathBezierQuadraticCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathBezierQuadraticCurveToNative((ImDrawList*)pself, p2, p3, numSegments);
			}
		}

		public static void PathBezierQuadraticCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathBezierQuadraticCurveToNative((ImDrawList*)pself, p2, p3, (int)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PathRect")]
		internal static extern void PathRectNative(ImDrawList* self, Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags);

		public static void PathRect(ImDrawList* self, Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			PathRectNative(self, rectMin, rectMax, rounding, flags);
		}

		public static void PathRect(ImDrawList* self, Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			PathRectNative(self, rectMin, rectMax, rounding, (ImDrawFlags)(0));
		}

		public static void PathRect(ImDrawList* self, Vector2 rectMin, Vector2 rectMax)
		{
			PathRectNative(self, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
		}

		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathRectNative((ImDrawList*)pself, rectMin, rectMax, rounding, flags);
			}
		}

		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathRectNative((ImDrawList*)pself, rectMin, rectMax, rounding, (ImDrawFlags)(0));
			}
		}

		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				PathRectNative((ImDrawList*)pself, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddCallback")]
		internal static extern void AddCallbackNative(ImDrawList* self, ImDrawCallback callback, void* callbackData);

		public static void AddCallback(ImDrawList* self, ImDrawCallback callback, void* callbackData)
		{
			AddCallbackNative(self, callback, callbackData);
		}

		public static void AddCallback(ref ImDrawList self, ImDrawCallback callback, void* callbackData)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddCallbackNative((ImDrawList*)pself, callback, callbackData);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_AddDrawCmd")]
		internal static extern void AddDrawCmdNative(ImDrawList* self);

		public static void AddDrawCmd(ImDrawList* self)
		{
			AddDrawCmdNative(self);
		}

		public static void AddDrawCmd(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				AddDrawCmdNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_CloneOutput")]
		internal static extern ImDrawList* CloneOutputNative(ImDrawList* self);

		public static ImDrawListPtr CloneOutput(ImDrawList* self)
		{
			ImDrawListPtr ret = CloneOutputNative(self);
			return ret;
		}

		public static ImDrawListPtr CloneOutput(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImDrawListPtr ret = CloneOutputNative((ImDrawList*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_ChannelsSplit")]
		internal static extern void ChannelsSplitNative(ImDrawList* self, int count);

		public static void ChannelsSplit(ImDrawList* self, int count)
		{
			ChannelsSplitNative(self, count);
		}

		public static void ChannelsSplit(ref ImDrawList self, int count)
		{
			fixed (ImDrawList* pself = &self)
			{
				ChannelsSplitNative((ImDrawList*)pself, count);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_ChannelsMerge")]
		internal static extern void ChannelsMergeNative(ImDrawList* self);

		public static void ChannelsMerge(ImDrawList* self)
		{
			ChannelsMergeNative(self);
		}

		public static void ChannelsMerge(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ChannelsMergeNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_ChannelsSetCurrent")]
		internal static extern void ChannelsSetCurrentNative(ImDrawList* self, int n);

		public static void ChannelsSetCurrent(ImDrawList* self, int n)
		{
			ChannelsSetCurrentNative(self, n);
		}

		public static void ChannelsSetCurrent(ref ImDrawList self, int n)
		{
			fixed (ImDrawList* pself = &self)
			{
				ChannelsSetCurrentNative((ImDrawList*)pself, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimReserve")]
		internal static extern void PrimReserveNative(ImDrawList* self, int idxCount, int vtxCount);

		public static void PrimReserve(ImDrawList* self, int idxCount, int vtxCount)
		{
			PrimReserveNative(self, idxCount, vtxCount);
		}

		public static void PrimReserve(ref ImDrawList self, int idxCount, int vtxCount)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimReserveNative((ImDrawList*)pself, idxCount, vtxCount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimUnreserve")]
		internal static extern void PrimUnreserveNative(ImDrawList* self, int idxCount, int vtxCount);

		public static void PrimUnreserve(ImDrawList* self, int idxCount, int vtxCount)
		{
			PrimUnreserveNative(self, idxCount, vtxCount);
		}

		public static void PrimUnreserve(ref ImDrawList self, int idxCount, int vtxCount)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimUnreserveNative((ImDrawList*)pself, idxCount, vtxCount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimRect")]
		internal static extern void PrimRectNative(ImDrawList* self, Vector2 a, Vector2 b, uint col);

		public static void PrimRect(ImDrawList* self, Vector2 a, Vector2 b, uint col)
		{
			PrimRectNative(self, a, b, col);
		}

		public static void PrimRect(ref ImDrawList self, Vector2 a, Vector2 b, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimRectNative((ImDrawList*)pself, a, b, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimRectUV")]
		internal static extern void PrimRectUVNative(ImDrawList* self, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col);

		public static void PrimRectUV(ImDrawList* self, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			PrimRectUVNative(self, a, b, uvA, uvB, col);
		}

		public static void PrimRectUV(ref ImDrawList self, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimRectUVNative((ImDrawList*)pself, a, b, uvA, uvB, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimQuadUV")]
		internal static extern void PrimQuadUVNative(ImDrawList* self, Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col);

		public static void PrimQuadUV(ImDrawList* self, Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			PrimQuadUVNative(self, a, b, c, d, uvA, uvB, uvC, uvD, col);
		}

		public static void PrimQuadUV(ref ImDrawList self, Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimQuadUVNative((ImDrawList*)pself, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimWriteVtx")]
		internal static extern void PrimWriteVtxNative(ImDrawList* self, Vector2 pos, Vector2 uv, uint col);

		public static void PrimWriteVtx(ImDrawList* self, Vector2 pos, Vector2 uv, uint col)
		{
			PrimWriteVtxNative(self, pos, uv, col);
		}

		public static void PrimWriteVtx(ref ImDrawList self, Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimWriteVtxNative((ImDrawList*)pself, pos, uv, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimWriteIdx")]
		internal static extern void PrimWriteIdxNative(ImDrawList* self, ushort idx);

		public static void PrimWriteIdx(ImDrawList* self, ushort idx)
		{
			PrimWriteIdxNative(self, idx);
		}

		public static void PrimWriteIdx(ref ImDrawList self, ushort idx)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimWriteIdxNative((ImDrawList*)pself, idx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList_PrimVtx")]
		internal static extern void PrimVtxNative(ImDrawList* self, Vector2 pos, Vector2 uv, uint col);

		public static void PrimVtx(ImDrawList* self, Vector2 pos, Vector2 uv, uint col)
		{
			PrimVtxNative(self, pos, uv, col);
		}

		public static void PrimVtx(ref ImDrawList self, Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				PrimVtxNative((ImDrawList*)pself, pos, uv, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__ResetForNewFrame")]
		internal static extern void _ResetForNewFrameNative(ImDrawList* self);

		public static void _ResetForNewFrame(ImDrawList* self)
		{
			_ResetForNewFrameNative(self);
		}

		public static void _ResetForNewFrame(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_ResetForNewFrameNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__ClearFreeMemory")]
		internal static extern void _ClearFreeMemoryNative(ImDrawList* self);

		public static void _ClearFreeMemory(ImDrawList* self)
		{
			_ClearFreeMemoryNative(self);
		}

		public static void _ClearFreeMemory(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_ClearFreeMemoryNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__PopUnusedDrawCmd")]
		internal static extern void _PopUnusedDrawCmdNative(ImDrawList* self);

		public static void _PopUnusedDrawCmd(ImDrawList* self)
		{
			_PopUnusedDrawCmdNative(self);
		}

		public static void _PopUnusedDrawCmd(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_PopUnusedDrawCmdNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__TryMergeDrawCmds")]
		internal static extern void _TryMergeDrawCmdsNative(ImDrawList* self);

		public static void _TryMergeDrawCmds(ImDrawList* self)
		{
			_TryMergeDrawCmdsNative(self);
		}

		public static void _TryMergeDrawCmds(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_TryMergeDrawCmdsNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__OnChangedClipRect")]
		internal static extern void _OnChangedClipRectNative(ImDrawList* self);

		public static void _OnChangedClipRect(ImDrawList* self)
		{
			_OnChangedClipRectNative(self);
		}

		public static void _OnChangedClipRect(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_OnChangedClipRectNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__OnChangedTextureID")]
		internal static extern void _OnChangedTextureIDNative(ImDrawList* self);

		public static void _OnChangedTextureID(ImDrawList* self)
		{
			_OnChangedTextureIDNative(self);
		}

		public static void _OnChangedTextureID(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_OnChangedTextureIDNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__OnChangedVtxOffset")]
		internal static extern void _OnChangedVtxOffsetNative(ImDrawList* self);

		public static void _OnChangedVtxOffset(ImDrawList* self)
		{
			_OnChangedVtxOffsetNative(self);
		}

		public static void _OnChangedVtxOffset(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				_OnChangedVtxOffsetNative((ImDrawList*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__CalcCircleAutoSegmentCount")]
		internal static extern int _CalcCircleAutoSegmentCountNative(ImDrawList* self, float radius);

		public static int _CalcCircleAutoSegmentCount(ImDrawList* self, float radius)
		{
			int ret = _CalcCircleAutoSegmentCountNative(self, radius);
			return ret;
		}

		public static int _CalcCircleAutoSegmentCount(ref ImDrawList self, float radius)
		{
			fixed (ImDrawList* pself = &self)
			{
				int ret = _CalcCircleAutoSegmentCountNative((ImDrawList*)pself, radius);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__PathArcToFastEx")]
		internal static extern void _PathArcToFastExNative(ImDrawList* self, Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep);

		public static void _PathArcToFastEx(ImDrawList* self, Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			_PathArcToFastExNative(self, center, radius, aMinSample, aMaxSample, aStep);
		}

		public static void _PathArcToFastEx(ref ImDrawList self, Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			fixed (ImDrawList* pself = &self)
			{
				_PathArcToFastExNative((ImDrawList*)pself, center, radius, aMinSample, aMaxSample, aStep);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawList__PathArcToN")]
		internal static extern void _PathArcToNNative(ImDrawList* self, Vector2 center, float radius, float aMin, float aMax, int numSegments);

		public static void _PathArcToN(ImDrawList* self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			_PathArcToNNative(self, center, radius, aMin, aMax, numSegments);
		}

		public static void _PathArcToN(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				_PathArcToNNative((ImDrawList*)pself, center, radius, aMin, aMax, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_ImDrawData")]
		internal static extern ImDrawData* ImDrawDataNative();

		public static ImDrawDataPtr ImDrawData()
		{
			ImDrawDataPtr ret = ImDrawDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_destroy")]
		internal static extern void DestroyNative(ImDrawData* self);

		public static void Destroy(ImDrawData* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				DestroyNative((ImDrawData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_Clear")]
		internal static extern void ClearNative(ImDrawData* self);

		public static void Clear(ImDrawData* self)
		{
			ClearNative(self);
		}

		public static void Clear(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				ClearNative((ImDrawData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_DeIndexAllBuffers")]
		internal static extern void DeIndexAllBuffersNative(ImDrawData* self);

		public static void DeIndexAllBuffers(ImDrawData* self)
		{
			DeIndexAllBuffersNative(self);
		}

		public static void DeIndexAllBuffers(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				DeIndexAllBuffersNative((ImDrawData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawData_ScaleClipRects")]
		internal static extern void ScaleClipRectsNative(ImDrawData* self, Vector2 fbScale);

		public static void ScaleClipRects(ImDrawData* self, Vector2 fbScale)
		{
			ScaleClipRectsNative(self, fbScale);
		}

		public static void ScaleClipRects(ref ImDrawData self, Vector2 fbScale)
		{
			fixed (ImDrawData* pself = &self)
			{
				ScaleClipRectsNative((ImDrawData*)pself, fbScale);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontConfig_ImFontConfig")]
		internal static extern ImFontConfig* ImFontConfigNative();

		public static ImFontConfigPtr ImFontConfig()
		{
			ImFontConfigPtr ret = ImFontConfigNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontConfig_destroy")]
		internal static extern void DestroyNative(ImFontConfig* self);

		public static void Destroy(ImFontConfig* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImFontConfig self)
		{
			fixed (ImFontConfig* pself = &self)
			{
				DestroyNative((ImFontConfig*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder")]
		internal static extern ImFontGlyphRangesBuilder* ImFontGlyphRangesBuilderNative();

		public static ImFontGlyphRangesBuilderPtr ImFontGlyphRangesBuilder()
		{
			ImFontGlyphRangesBuilderPtr ret = ImFontGlyphRangesBuilderNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_destroy")]
		internal static extern void DestroyNative(ImFontGlyphRangesBuilder* self);

		public static void Destroy(ImFontGlyphRangesBuilder* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImFontGlyphRangesBuilder self)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				DestroyNative((ImFontGlyphRangesBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_Clear")]
		internal static extern void ClearNative(ImFontGlyphRangesBuilder* self);

		public static void Clear(ImFontGlyphRangesBuilder* self)
		{
			ClearNative(self);
		}

		public static void Clear(ref ImFontGlyphRangesBuilder self)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				ClearNative((ImFontGlyphRangesBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_GetBit")]
		internal static extern byte GetBitNative(ImFontGlyphRangesBuilder* self, nuint n);

		public static bool GetBit(ImFontGlyphRangesBuilder* self, nuint n)
		{
			byte ret = GetBitNative(self, n);
			return ret != 0;
		}

		public static bool GetBit(ref ImFontGlyphRangesBuilder self, nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte ret = GetBitNative((ImFontGlyphRangesBuilder*)pself, n);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_SetBit")]
		internal static extern void SetBitNative(ImFontGlyphRangesBuilder* self, nuint n);

		public static void SetBit(ImFontGlyphRangesBuilder* self, nuint n)
		{
			SetBitNative(self, n);
		}

		public static void SetBit(ref ImFontGlyphRangesBuilder self, nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				SetBitNative((ImFontGlyphRangesBuilder*)pself, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_AddChar")]
		internal static extern void AddCharNative(ImFontGlyphRangesBuilder* self, char c);

		public static void AddChar(ImFontGlyphRangesBuilder* self, char c)
		{
			AddCharNative(self, c);
		}

		public static void AddChar(ref ImFontGlyphRangesBuilder self, char c)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				AddCharNative((ImFontGlyphRangesBuilder*)pself, c);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_AddText")]
		internal static extern void AddTextNative(ImFontGlyphRangesBuilder* self, byte* text, byte* textEnd);

		public static void AddText(ImFontGlyphRangesBuilder* self, byte* text, byte* textEnd)
		{
			AddTextNative(self, text, textEnd);
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, byte* text)
		{
			AddTextNative(self, text, (byte*)(default));
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, byte* text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				AddTextNative((ImFontGlyphRangesBuilder*)pself, text, textEnd);
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, byte* text)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				AddTextNative((ImFontGlyphRangesBuilder*)pself, text, (byte*)(default));
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				AddTextNative(self, (byte*)ptext, textEnd);
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				AddTextNative(self, (byte*)ptext, (byte*)(default));
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, ref byte text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					AddTextNative((ImFontGlyphRangesBuilder*)pself, (byte*)ptext, textEnd);
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, ref byte text)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					AddTextNative((ImFontGlyphRangesBuilder*)pself, (byte*)ptext, (byte*)(default));
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, string text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImFontGlyphRangesBuilder*)pself, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, string text)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImFontGlyphRangesBuilder*)pself, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextNative(self, text, (byte*)ptextEnd);
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextNative(self, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, byte* text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative((ImFontGlyphRangesBuilder*)pself, text, (byte*)ptextEnd);
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, byte* text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextNative((ImFontGlyphRangesBuilder*)pself, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextNative(self, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void AddText(ImFontGlyphRangesBuilder* self, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddTextNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, ref byte text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextNative((ImFontGlyphRangesBuilder*)pself, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void AddText(ref ImFontGlyphRangesBuilder self, string text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextNative((ImFontGlyphRangesBuilder*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_AddRanges")]
		internal static extern void AddRangesNative(ImFontGlyphRangesBuilder* self, char* ranges);

		public static void AddRanges(ImFontGlyphRangesBuilder* self, char* ranges)
		{
			AddRangesNative(self, ranges);
		}

		public static void AddRanges(ref ImFontGlyphRangesBuilder self, char* ranges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				AddRangesNative((ImFontGlyphRangesBuilder*)pself, ranges);
			}
		}

		public static void AddRanges(ImFontGlyphRangesBuilder* self, ref char ranges)
		{
			fixed (char* pranges = &ranges)
			{
				AddRangesNative(self, (char*)pranges);
			}
		}

		public static void AddRanges(ref ImFontGlyphRangesBuilder self, ref char ranges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (char* pranges = &ranges)
				{
					AddRangesNative((ImFontGlyphRangesBuilder*)pself, (char*)pranges);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontGlyphRangesBuilder_BuildRanges")]
		internal static extern void BuildRangesNative(ImFontGlyphRangesBuilder* self, ImVectorImWchar* outRanges);

		public static void BuildRanges(ImFontGlyphRangesBuilder* self, ImVectorImWchar* outRanges)
		{
			BuildRangesNative(self, outRanges);
		}

		public static void BuildRanges(ref ImFontGlyphRangesBuilder self, ImVectorImWchar* outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				BuildRangesNative((ImFontGlyphRangesBuilder*)pself, outRanges);
			}
		}

		public static void BuildRanges(ImFontGlyphRangesBuilder* self, ref ImVectorImWchar outRanges)
		{
			fixed (ImVectorImWchar* poutRanges = &outRanges)
			{
				BuildRangesNative(self, (ImVectorImWchar*)poutRanges);
			}
		}

		public static void BuildRanges(ref ImFontGlyphRangesBuilder self, ref ImVectorImWchar outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (ImVectorImWchar* poutRanges = &outRanges)
				{
					BuildRangesNative((ImFontGlyphRangesBuilder*)pself, (ImVectorImWchar*)poutRanges);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlasCustomRect_ImFontAtlasCustomRect")]
		internal static extern ImFontAtlasCustomRect* ImFontAtlasCustomRectNative();

		public static ImFontAtlasCustomRectPtr ImFontAtlasCustomRect()
		{
			ImFontAtlasCustomRectPtr ret = ImFontAtlasCustomRectNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlasCustomRect_destroy")]
		internal static extern void DestroyNative(ImFontAtlasCustomRect* self);

		public static void Destroy(ImFontAtlasCustomRect* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImFontAtlasCustomRect self)
		{
			fixed (ImFontAtlasCustomRect* pself = &self)
			{
				DestroyNative((ImFontAtlasCustomRect*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlasCustomRect_IsPacked")]
		internal static extern byte IsPackedNative(ImFontAtlasCustomRect* self);

		public static bool IsPacked(ImFontAtlasCustomRect* self)
		{
			byte ret = IsPackedNative(self);
			return ret != 0;
		}

		public static bool IsPacked(ref ImFontAtlasCustomRect self)
		{
			fixed (ImFontAtlasCustomRect* pself = &self)
			{
				byte ret = IsPackedNative((ImFontAtlasCustomRect*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_ImFontAtlas")]
		internal static extern ImFontAtlas* ImFontAtlasNative();

		public static ImFontAtlasPtr ImFontAtlas()
		{
			ImFontAtlasPtr ret = ImFontAtlasNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_destroy")]
		internal static extern void DestroyNative(ImFontAtlas* self);

		public static void Destroy(ImFontAtlas* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				DestroyNative((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFont")]
		internal static extern ImFont* AddFontNative(ImFontAtlas* self, ImFontConfig* fontCfg);

		public static ImFontPtr AddFont(ImFontAtlas* self, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = AddFontNative(self, fontCfg);
			return ret;
		}

		public static ImFontPtr AddFont(ref ImFontAtlas self, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontNative((ImFontAtlas*)pself, fontCfg);
				return ret;
			}
		}

		public static ImFontPtr AddFont(ImFontAtlas* self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontNative(self, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}

		public static ImFontPtr AddFont(ref ImFontAtlas self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontNative((ImFontAtlas*)pself, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontDefault")]
		internal static extern ImFont* AddFontDefaultNative(ImFontAtlas* self, ImFontConfig* fontCfg);

		public static ImFontPtr AddFontDefault(ImFontAtlas* self, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = AddFontDefaultNative(self, fontCfg);
			return ret;
		}

		public static ImFontPtr AddFontDefault(ImFontAtlas* self)
		{
			ImFontPtr ret = AddFontDefaultNative(self, (ImFontConfig*)(default));
			return ret;
		}

		public static ImFontPtr AddFontDefault(ref ImFontAtlas self, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontDefaultNative((ImFontAtlas*)pself, fontCfg);
				return ret;
			}
		}

		public static ImFontPtr AddFontDefault(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontDefaultNative((ImFontAtlas*)pself, (ImFontConfig*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontDefault(ImFontAtlas* self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontDefaultNative(self, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}

		public static ImFontPtr AddFontDefault(ref ImFontAtlas self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontDefaultNative((ImFontAtlas*)pself, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontFromFileTTF")]
		internal static extern ImFont* AddFontFromFileTTFNative(ImFontAtlas* self, byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges);

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = AddFontFromFileTTFNative(self, filename, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = AddFontFromFileTTFNative(self, filename, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels)
		{
			ImFontPtr ret = AddFontFromFileTTFNative(self, filename, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, filename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, filename, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, filename, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, (byte*)pfilename, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = AddFontFromFileTTFNative(self, pStr0, sizePixels, fontCfg, glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ImFontConfig* fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = AddFontFromFileTTFNative(self, pStr0, sizePixels, fontCfg, (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = AddFontFromFileTTFNative(self, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromFileTTFNative(self, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromFileTTFNative(self, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, filename, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, filename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromFileTTFNative(self, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = AddFontFromFileTTFNative(self, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromFileTTFNative(self, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromFileTTFNative(self, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ImFontAtlas* self, string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromFileTTFNative(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public static ImFontPtr AddFontFromFileTTF(ref ImFontAtlas self, string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromFileTTFNative((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontFromMemoryTTF")]
		internal static extern ImFont* AddFontFromMemoryTTFNative(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges);

		public static ImFontPtr AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = AddFontFromMemoryTTFNative(self, fontData, fontSize, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = AddFontFromMemoryTTFNative(self, fontData, fontSize, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels)
		{
			ImFontPtr ret = AddFontFromMemoryTTFNative(self, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryTTFNative((ImFontAtlas*)pself, fontData, fontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryTTFNative((ImFontAtlas*)pself, fontData, fontSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryTTFNative((ImFontAtlas*)pself, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromMemoryTTFNative(self, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromMemoryTTFNative(self, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryTTFNative((ImFontAtlas*)pself, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryTTFNative((ImFontAtlas*)pself, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = AddFontFromMemoryTTFNative(self, fontData, fontSize, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryTTFNative((ImFontAtlas*)pself, fontData, fontSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ImFontAtlas* self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryTTFNative(self, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryTTF(ref ImFontAtlas self, void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromMemoryTTFNative((ImFontAtlas*)pself, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedTTF")]
		internal static extern ImFont* AddFontFromMemoryCompressedTTFNative(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges);

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = AddFontFromMemoryCompressedTTFNative(self, compressedFontData, compressedFontSize, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = AddFontFromMemoryCompressedTTFNative(self, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels)
		{
			ImFontPtr ret = AddFontFromMemoryCompressedTTFNative(self, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedTTFNative((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedTTFNative((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedTTFNative((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedTTFNative(self, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedTTFNative(self, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedTTFNative((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedTTFNative((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedTTFNative(self, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedTTFNative((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ImFontAtlas* self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedTTFNative(self, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedTTF(ref ImFontAtlas self, void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromMemoryCompressedTTFNative((ImFontAtlas*)pself, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedBase85TTF")]
		internal static extern ImFont* AddFontFromMemoryCompressedBase85TTFNative(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges);

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, compressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, compressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels)
		{
			ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, pStr0, sizePixels, fontCfg, glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, pStr0, sizePixels, fontCfg, (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, compressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ImFontAtlas* self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative(self, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public static ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref ImFontAtlas self, string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = AddFontFromMemoryCompressedBase85TTFNative((ImFontAtlas*)pself, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_ClearInputData")]
		internal static extern void ClearInputDataNative(ImFontAtlas* self);

		public static void ClearInputData(ImFontAtlas* self)
		{
			ClearInputDataNative(self);
		}

		public static void ClearInputData(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ClearInputDataNative((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_ClearTexData")]
		internal static extern void ClearTexDataNative(ImFontAtlas* self);

		public static void ClearTexData(ImFontAtlas* self)
		{
			ClearTexDataNative(self);
		}

		public static void ClearTexData(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ClearTexDataNative((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_ClearFonts")]
		internal static extern void ClearFontsNative(ImFontAtlas* self);

		public static void ClearFonts(ImFontAtlas* self)
		{
			ClearFontsNative(self);
		}

		public static void ClearFonts(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ClearFontsNative((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_Clear")]
		internal static extern void ClearNative(ImFontAtlas* self);

		public static void Clear(ImFontAtlas* self)
		{
			ClearNative(self);
		}

		public static void Clear(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ClearNative((ImFontAtlas*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_Build")]
		internal static extern byte BuildNative(ImFontAtlas* self);

		public static bool Build(ImFontAtlas* self)
		{
			byte ret = BuildNative(self);
			return ret != 0;
		}

		public static bool Build(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte ret = BuildNative((ImFontAtlas*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetTexDataAsAlpha8")]
		internal static extern void GetTexDataAsAlpha8Native(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel);

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			GetTexDataAsAlpha8Native(self, outPixels, outWidth, outHeight, outBytesPerPixel);
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight)
		{
			GetTexDataAsAlpha8Native(self, outPixels, outWidth, outHeight, (int*)(default));
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsAlpha8Native(self, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsAlpha8Native(self, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				GetTexDataAsAlpha8Native(self, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8Native(self, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								GetTexDataAsAlpha8Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetTexDataAsRGBA32")]
		internal static extern void GetTexDataAsRGBA32Native(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel);

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			GetTexDataAsRGBA32Native(self, outPixels, outWidth, outHeight, outBytesPerPixel);
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight)
		{
			GetTexDataAsRGBA32Native(self, outPixels, outWidth, outHeight, (int*)(default));
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsRGBA32Native(self, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsRGBA32Native(self, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				GetTexDataAsRGBA32Native(self, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32Native(self, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32Native((ImFontAtlas*)pself, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ImFontAtlas* self, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								GetTexDataAsRGBA32Native((ImFontAtlas*)pself, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_IsBuilt")]
		internal static extern byte IsBuiltNative(ImFontAtlas* self);

		public static bool IsBuilt(ImFontAtlas* self)
		{
			byte ret = IsBuiltNative(self);
			return ret != 0;
		}

		public static bool IsBuilt(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte ret = IsBuiltNative((ImFontAtlas*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_SetTexID")]
		internal static extern void SetTexIDNative(ImFontAtlas* self, ImTextureID id);

		public static void SetTexID(ImFontAtlas* self, ImTextureID id)
		{
			SetTexIDNative(self, id);
		}

		public static void SetTexID(ref ImFontAtlas self, ImTextureID id)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				SetTexIDNative((ImFontAtlas*)pself, id);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesDefault")]
		internal static extern char* GetGlyphRangesDefaultNative(ImFontAtlas* self);

		public static char* GetGlyphRangesDefault(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesDefaultNative(self);
			return ret;
		}

		public static char* GetGlyphRangesDefault(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesDefaultNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesGreek")]
		internal static extern char* GetGlyphRangesGreekNative(ImFontAtlas* self);

		public static char* GetGlyphRangesGreek(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesGreekNative(self);
			return ret;
		}

		public static char* GetGlyphRangesGreek(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesGreekNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesKorean")]
		internal static extern char* GetGlyphRangesKoreanNative(ImFontAtlas* self);

		public static char* GetGlyphRangesKorean(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesKoreanNative(self);
			return ret;
		}

		public static char* GetGlyphRangesKorean(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesKoreanNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesJapanese")]
		internal static extern char* GetGlyphRangesJapaneseNative(ImFontAtlas* self);

		public static char* GetGlyphRangesJapanese(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesJapaneseNative(self);
			return ret;
		}

		public static char* GetGlyphRangesJapanese(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesJapaneseNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesChineseFull")]
		internal static extern char* GetGlyphRangesChineseFullNative(ImFontAtlas* self);

		public static char* GetGlyphRangesChineseFull(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesChineseFullNative(self);
			return ret;
		}

		public static char* GetGlyphRangesChineseFull(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesChineseFullNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon")]
		internal static extern char* GetGlyphRangesChineseSimplifiedCommonNative(ImFontAtlas* self);

		public static char* GetGlyphRangesChineseSimplifiedCommon(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesChineseSimplifiedCommonNative(self);
			return ret;
		}

		public static char* GetGlyphRangesChineseSimplifiedCommon(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesChineseSimplifiedCommonNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesCyrillic")]
		internal static extern char* GetGlyphRangesCyrillicNative(ImFontAtlas* self);

		public static char* GetGlyphRangesCyrillic(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesCyrillicNative(self);
			return ret;
		}

		public static char* GetGlyphRangesCyrillic(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesCyrillicNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesThai")]
		internal static extern char* GetGlyphRangesThaiNative(ImFontAtlas* self);

		public static char* GetGlyphRangesThai(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesThaiNative(self);
			return ret;
		}

		public static char* GetGlyphRangesThai(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesThaiNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetGlyphRangesVietnamese")]
		internal static extern char* GetGlyphRangesVietnameseNative(ImFontAtlas* self);

		public static char* GetGlyphRangesVietnamese(ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesVietnameseNative(self);
			return ret;
		}

		public static char* GetGlyphRangesVietnamese(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				char* ret = GetGlyphRangesVietnameseNative((ImFontAtlas*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddCustomRectRegular")]
		internal static extern int AddCustomRectRegularNative(ImFontAtlas* self, int width, int height);

		public static int AddCustomRectRegular(ImFontAtlas* self, int width, int height)
		{
			int ret = AddCustomRectRegularNative(self, width, height);
			return ret;
		}

		public static int AddCustomRectRegular(ref ImFontAtlas self, int width, int height)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = AddCustomRectRegularNative((ImFontAtlas*)pself, width, height);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_AddCustomRectFontGlyph")]
		internal static extern int AddCustomRectFontGlyphNative(ImFontAtlas* self, ImFont* font, char id, int width, int height, float advanceX, Vector2 offset);

		public static int AddCustomRectFontGlyph(ImFontAtlas* self, ImFont* font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			int ret = AddCustomRectFontGlyphNative(self, font, id, width, height, advanceX, offset);
			return ret;
		}

		public static int AddCustomRectFontGlyph(ImFontAtlas* self, ImFont* font, char id, int width, int height, float advanceX)
		{
			int ret = AddCustomRectFontGlyphNative(self, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
			return ret;
		}

		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ImFont* font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = AddCustomRectFontGlyphNative((ImFontAtlas*)pself, font, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ImFont* font, char id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = AddCustomRectFontGlyphNative((ImFontAtlas*)pself, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph(ImFontAtlas* self, ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = AddCustomRectFontGlyphNative(self, (ImFont*)pfont, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph(ImFontAtlas* self, ref ImFont font, char id, int width, int height, float advanceX)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = AddCustomRectFontGlyphNative(self, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = AddCustomRectFontGlyphNative((ImFontAtlas*)pself, (ImFont*)pfont, id, width, height, advanceX, offset);
					return ret;
				}
			}
		}

		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ref ImFont font, char id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = AddCustomRectFontGlyphNative((ImFontAtlas*)pself, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetCustomRectByIndex")]
		internal static extern ImFontAtlasCustomRect* GetCustomRectByIndexNative(ImFontAtlas* self, int index);

		public static ImFontAtlasCustomRectPtr GetCustomRectByIndex(ImFontAtlas* self, int index)
		{
			ImFontAtlasCustomRectPtr ret = GetCustomRectByIndexNative(self, index);
			return ret;
		}

		public static ImFontAtlasCustomRectPtr GetCustomRectByIndex(ref ImFontAtlas self, int index)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontAtlasCustomRectPtr ret = GetCustomRectByIndexNative((ImFontAtlas*)pself, index);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_CalcCustomRectUV")]
		internal static extern void CalcCustomRectUVNative(ImFontAtlas* self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax);

		public static void CalcCustomRectUV(ImFontAtlas* self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			CalcCustomRectUVNative(self, rect, outUvMin, outUvMax);
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				CalcCustomRectUVNative((ImFontAtlas*)pself, rect, outUvMin, outUvMax);
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				CalcCustomRectUVNative(self, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					CalcCustomRectUVNative((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				CalcCustomRectUVNative(self, rect, (Vector2*)poutUvMin, outUvMax);
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					CalcCustomRectUVNative((ImFontAtlas*)pself, rect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					CalcCustomRectUVNative(self, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						CalcCustomRectUVNative((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
					}
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMax = &outUvMax)
			{
				CalcCustomRectUVNative(self, rect, outUvMin, (Vector2*)poutUvMax);
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					CalcCustomRectUVNative((ImFontAtlas*)pself, rect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					CalcCustomRectUVNative(self, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						CalcCustomRectUVNative((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					CalcCustomRectUVNative(self, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						CalcCustomRectUVNative((ImFontAtlas*)pself, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public static void CalcCustomRectUV(ImFontAtlas* self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						CalcCustomRectUVNative(self, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						fixed (Vector2* poutUvMax = &outUvMax)
						{
							CalcCustomRectUVNative((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFontAtlas_GetMouseCursorTexData")]
		internal static extern byte GetMouseCursorTexDataNative(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill);

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, outSize, outUvBorder, outUvFill);
			return ret != 0;
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvFill = &outUvFill)
			{
				byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ImFontAtlas* self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								byte ret = GetMouseCursorTexDataNative((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_ImFont")]
		internal static extern ImFont* ImFontNative();

		public static ImFontPtr ImFont()
		{
			ImFontPtr ret = ImFontNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_destroy")]
		internal static extern void DestroyNative(ImFont* self);

		public static void Destroy(ImFont* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				DestroyNative((ImFont*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_FindGlyph")]
		internal static extern ImFontGlyph* FindGlyphNative(ImFont* self, char c);

		public static ImFontGlyphPtr FindGlyph(ImFont* self, char c)
		{
			ImFontGlyphPtr ret = FindGlyphNative(self, c);
			return ret;
		}

		public static ImFontGlyphPtr FindGlyph(ref ImFont self, char c)
		{
			fixed (ImFont* pself = &self)
			{
				ImFontGlyphPtr ret = FindGlyphNative((ImFont*)pself, c);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_FindGlyphNoFallback")]
		internal static extern ImFontGlyph* FindGlyphNoFallbackNative(ImFont* self, char c);

		public static ImFontGlyphPtr FindGlyphNoFallback(ImFont* self, char c)
		{
			ImFontGlyphPtr ret = FindGlyphNoFallbackNative(self, c);
			return ret;
		}

		public static ImFontGlyphPtr FindGlyphNoFallback(ref ImFont self, char c)
		{
			fixed (ImFont* pself = &self)
			{
				ImFontGlyphPtr ret = FindGlyphNoFallbackNative((ImFont*)pself, c);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_GetCharAdvance")]
		internal static extern float GetCharAdvanceNative(ImFont* self, char c);

		public static float GetCharAdvance(ImFont* self, char c)
		{
			float ret = GetCharAdvanceNative(self, c);
			return ret;
		}

		public static float GetCharAdvance(ref ImFont self, char c)
		{
			fixed (ImFont* pself = &self)
			{
				float ret = GetCharAdvanceNative((ImFont*)pself, c);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_IsLoaded")]
		internal static extern byte IsLoadedNative(ImFont* self);

		public static bool IsLoaded(ImFont* self)
		{
			byte ret = IsLoadedNative(self);
			return ret != 0;
		}

		public static bool IsLoaded(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				byte ret = IsLoadedNative((ImFont*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_GetDebugName")]
		internal static extern byte* GetDebugNameNative(ImFont* self);

		public static byte* GetDebugName(ImFont* self)
		{
			byte* ret = GetDebugNameNative(self);
			return ret;
		}

		public static string GetDebugNameS(ImFont* self)
		{
			string ret = Utils.DecodeStringUTF8(GetDebugNameNative(self));
			return ret;
		}

		public static byte* GetDebugName(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				byte* ret = GetDebugNameNative((ImFont*)pself);
				return ret;
			}
		}

		public static string GetDebugNameS(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetDebugNameNative((ImFont*)pself));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_CalcTextSizeA")]
		internal static extern void CalcTextSizeANative(Vector2* output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining);

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin)
		{
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, (byte*)(default), (byte**)(default));
			return ret;
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd)
		{
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(default));
			return ret;
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
			return ret;
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(default));
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, (byte*)(default), (byte**)(default));
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)(default), (byte**)(default));
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(default));
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
				return ret;
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(default));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)(default), (byte**)(default));
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), (byte**)(default));
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(default));
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, pStr0, (byte*)(default), (byte**)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(default));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), (byte**)(default));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, (byte*)(default), (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), (byte**)(default));
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(default));
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, (byte*)(default), (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(default));
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), (byte**)(default));
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, (byte*)(default), (byte**)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(default));
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(default));
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(default));
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(default));
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(default));
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Vector2 ret;
			CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(default));
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						Vector2 ret;
						CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(default));
						return ret;
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						Vector2 ret;
						CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
						return ret;
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				Vector2 ret;
				CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(default));
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, byte** remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (byte** premaining = &remaining)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
				return ret;
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte** premaining = &remaining)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
					return ret;
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte** premaining = &remaining)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte** premaining = &remaining)
					{
						Vector2 ret;
						CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
						return ret;
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte** premaining = &remaining)
						{
							CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, byte* textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (byte** premaining = &remaining)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
					return ret;
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						Vector2 ret;
						CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
						return ret;
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, byte* textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						Vector2 ret;
						CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
						return ret;
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				Vector2 ret;
				CalcTextSizeANative(&ret, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ImFont* self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative((Vector2*)poutput, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							Vector2 ret;
							CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
							return ret;
						}
					}
				}
			}
		}

		public static Vector2 CalcTextSizeA(ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					Vector2 ret;
					CalcTextSizeANative(&ret, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, ref byte textBegin, ref byte textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (byte** premaining = &remaining)
							{
								CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
							}
						}
					}
				}
			}
		}

		public static void CalcTextSizeA(ref Vector2 output, ref ImFont self, float size, float maxWidth, float wrapWidth, string textBegin, string textEnd, ref byte* remaining)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImFont* pself = &self)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative((Vector2*)poutput, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_CalcWordWrapPositionA")]
		internal static extern byte* CalcWordWrapPositionANative(ImFont* self, float scale, byte* text, byte* textEnd, float wrapWidth);

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			byte* ret = CalcWordWrapPositionANative(self, scale, text, textEnd, wrapWidth);
			return ret;
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, text, textEnd, wrapWidth));
			return ret;
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* ret = CalcWordWrapPositionANative((ImFont*)pself, scale, text, textEnd, wrapWidth);
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative((ImFont*)pself, scale, text, textEnd, wrapWidth));
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = CalcWordWrapPositionANative(self, scale, (byte*)ptext, textEnd, wrapWidth);
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, (byte*)ptext, textEnd, wrapWidth));
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = CalcWordWrapPositionANative(self, scale, pStr0, textEnd, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, pStr0, textEnd, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					byte* ret = CalcWordWrapPositionANative((ImFont*)pself, scale, (byte*)ptext, textEnd, wrapWidth);
					return ret;
				}
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative((ImFont*)pself, scale, (byte*)ptext, textEnd, wrapWidth));
					return ret;
				}
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = CalcWordWrapPositionANative((ImFont*)pself, scale, pStr0, textEnd, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative((ImFont*)pself, scale, pStr0, textEnd, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte* ret = CalcWordWrapPositionANative(self, scale, text, (byte*)ptextEnd, wrapWidth);
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, text, (byte*)ptextEnd, wrapWidth));
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = CalcWordWrapPositionANative(self, scale, text, pStr0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, text, pStr0, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = CalcWordWrapPositionANative((ImFont*)pself, scale, text, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative((ImFont*)pself, scale, text, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = CalcWordWrapPositionANative((ImFont*)pself, scale, text, pStr0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative((ImFont*)pself, scale, text, pStr0, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = CalcWordWrapPositionANative(self, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public static byte* CalcWordWrapPositionA(ImFont* self, float scale, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = CalcWordWrapPositionANative(self, scale, pStr0, pStr1, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS(ImFont* self, float scale, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, pStr0, pStr1, wrapWidth));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte* ret = CalcWordWrapPositionANative((ImFont*)pself, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
						return ret;
					}
				}
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative((ImFont*)pself, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
						return ret;
					}
				}
			}
		}

		public static byte* CalcWordWrapPositionA(ref ImFont self, float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = CalcWordWrapPositionANative((ImFont*)pself, scale, pStr0, pStr1, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS(ref ImFont self, float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative((ImFont*)pself, scale, pStr0, pStr1, wrapWidth));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_RenderChar")]
		internal static extern void RenderCharNative(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, char c);

		public static void RenderChar(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, char c)
		{
			RenderCharNative(self, drawList, size, pos, col, c);
		}

		public static void RenderChar(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* pself = &self)
			{
				RenderCharNative((ImFont*)pself, drawList, size, pos, col, c);
			}
		}

		public static void RenderChar(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderCharNative(self, (ImDrawList*)pdrawList, size, pos, col, c);
			}
		}

		public static void RenderChar(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderCharNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, c);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_RenderText")]
		internal static extern void RenderTextNative(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, byte cpuFineClip);

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative((ImFont*)pself, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ImFont* self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
						}
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
						}
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderText(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					RenderTextNative((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_BuildLookupTable")]
		internal static extern void BuildLookupTableNative(ImFont* self);

		public static void BuildLookupTable(ImFont* self)
		{
			BuildLookupTableNative(self);
		}

		public static void BuildLookupTable(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				BuildLookupTableNative((ImFont*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_ClearOutputData")]
		internal static extern void ClearOutputDataNative(ImFont* self);

		public static void ClearOutputData(ImFont* self)
		{
			ClearOutputDataNative(self);
		}

		public static void ClearOutputData(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				ClearOutputDataNative((ImFont*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_GrowIndex")]
		internal static extern void GrowIndexNative(ImFont* self, int newSize);

		public static void GrowIndex(ImFont* self, int newSize)
		{
			GrowIndexNative(self, newSize);
		}

		public static void GrowIndex(ref ImFont self, int newSize)
		{
			fixed (ImFont* pself = &self)
			{
				GrowIndexNative((ImFont*)pself, newSize);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_AddGlyph")]
		internal static extern void AddGlyphNative(ImFont* self, ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX);

		public static void AddGlyph(ImFont* self, ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			AddGlyphNative(self, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
		}

		public static void AddGlyph(ref ImFont self, ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* pself = &self)
			{
				AddGlyphNative((ImFont*)pself, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public static void AddGlyph(ImFont* self, ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFontConfig* psrcCfg = &srcCfg)
			{
				AddGlyphNative(self, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public static void AddGlyph(ref ImFont self, ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImFontConfig* psrcCfg = &srcCfg)
				{
					AddGlyphNative((ImFont*)pself, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_AddRemapChar")]
		internal static extern void AddRemapCharNative(ImFont* self, char dst, char src, byte overwriteDst);

		public static void AddRemapChar(ImFont* self, char dst, char src, bool overwriteDst)
		{
			AddRemapCharNative(self, dst, src, overwriteDst ? (byte)1 : (byte)0);
		}

		public static void AddRemapChar(ImFont* self, char dst, char src)
		{
			AddRemapCharNative(self, dst, src, (byte)(1));
		}

		public static void AddRemapChar(ref ImFont self, char dst, char src, bool overwriteDst)
		{
			fixed (ImFont* pself = &self)
			{
				AddRemapCharNative((ImFont*)pself, dst, src, overwriteDst ? (byte)1 : (byte)0);
			}
		}

		public static void AddRemapChar(ref ImFont self, char dst, char src)
		{
			fixed (ImFont* pself = &self)
			{
				AddRemapCharNative((ImFont*)pself, dst, src, (byte)(1));
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_SetGlyphVisible")]
		internal static extern void SetGlyphVisibleNative(ImFont* self, char c, byte visible);

		public static void SetGlyphVisible(ImFont* self, char c, bool visible)
		{
			SetGlyphVisibleNative(self, c, visible ? (byte)1 : (byte)0);
		}

		public static void SetGlyphVisible(ref ImFont self, char c, bool visible)
		{
			fixed (ImFont* pself = &self)
			{
				SetGlyphVisibleNative((ImFont*)pself, c, visible ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImFont_IsGlyphRangeUnused")]
		internal static extern byte IsGlyphRangeUnusedNative(ImFont* self, uint cBegin, uint cLast);

		public static bool IsGlyphRangeUnused(ImFont* self, uint cBegin, uint cLast)
		{
			byte ret = IsGlyphRangeUnusedNative(self, cBegin, cLast);
			return ret != 0;
		}

		public static bool IsGlyphRangeUnused(ref ImFont self, uint cBegin, uint cLast)
		{
			fixed (ImFont* pself = &self)
			{
				byte ret = IsGlyphRangeUnusedNative((ImFont*)pself, cBegin, cLast);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewport_ImGuiViewport")]
		internal static extern ImGuiViewport* ImGuiViewportNative();

		public static ImGuiViewportPtr ImGuiViewport()
		{
			ImGuiViewportPtr ret = ImGuiViewportNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewport_destroy")]
		internal static extern void DestroyNative(ImGuiViewport* self);

		public static void Destroy(ImGuiViewport* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				DestroyNative((ImGuiViewport*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewport_GetCenter")]
		internal static extern void GetCenterNative(Vector2* output, ImGuiViewport* self);

		public static Vector2 GetCenter(ImGuiViewport* self)
		{
			Vector2 ret;
			GetCenterNative(&ret, self);
			return ret;
		}

		public static void GetCenter(ref Vector2 output, ImGuiViewport* self)
		{
			fixed (Vector2* poutput = &output)
			{
				GetCenterNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 GetCenter(ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				Vector2 ret;
				GetCenterNative(&ret, (ImGuiViewport*)pself);
				return ret;
			}
		}

		public static void GetCenter(ref Vector2 output, ref ImGuiViewport self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewport* pself = &self)
				{
					GetCenterNative((Vector2*)poutput, (ImGuiViewport*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewport_GetWorkCenter")]
		internal static extern void GetWorkCenterNative(Vector2* output, ImGuiViewport* self);

		public static Vector2 GetWorkCenter(ImGuiViewport* self)
		{
			Vector2 ret;
			GetWorkCenterNative(&ret, self);
			return ret;
		}

		public static void GetWorkCenter(ref Vector2 output, ImGuiViewport* self)
		{
			fixed (Vector2* poutput = &output)
			{
				GetWorkCenterNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 GetWorkCenter(ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				Vector2 ret;
				GetWorkCenterNative(&ret, (ImGuiViewport*)pself);
				return ret;
			}
		}

		public static void GetWorkCenter(ref Vector2 output, ref ImGuiViewport self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewport* pself = &self)
				{
					GetWorkCenterNative((Vector2*)poutput, (ImGuiViewport*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformIO_ImGuiPlatformIO")]
		internal static extern ImGuiPlatformIO* ImGuiPlatformIONative();

		public static ImGuiPlatformIOPtr ImGuiPlatformIO()
		{
			ImGuiPlatformIOPtr ret = ImGuiPlatformIONative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformIO_destroy")]
		internal static extern void DestroyNative(ImGuiPlatformIO* self);

		public static void Destroy(ImGuiPlatformIO* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiPlatformIO self)
		{
			fixed (ImGuiPlatformIO* pself = &self)
			{
				DestroyNative((ImGuiPlatformIO*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformMonitor_ImGuiPlatformMonitor")]
		internal static extern ImGuiPlatformMonitor* ImGuiPlatformMonitorNative();

		public static ImGuiPlatformMonitorPtr ImGuiPlatformMonitor()
		{
			ImGuiPlatformMonitorPtr ret = ImGuiPlatformMonitorNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformMonitor_destroy")]
		internal static extern void DestroyNative(ImGuiPlatformMonitor* self);

		public static void Destroy(ImGuiPlatformMonitor* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiPlatformMonitor self)
		{
			fixed (ImGuiPlatformMonitor* pself = &self)
			{
				DestroyNative((ImGuiPlatformMonitor*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformImeData_ImGuiPlatformImeData")]
		internal static extern ImGuiPlatformImeData* ImGuiPlatformImeDataNative();

		public static ImGuiPlatformImeDataPtr ImGuiPlatformImeData()
		{
			ImGuiPlatformImeDataPtr ret = ImGuiPlatformImeDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPlatformImeData_destroy")]
		internal static extern void DestroyNative(ImGuiPlatformImeData* self);

		public static void Destroy(ImGuiPlatformImeData* self)
		{
			DestroyNative(self);
		}

		public static void Destroy(ref ImGuiPlatformImeData self)
		{
			fixed (ImGuiPlatformImeData* pself = &self)
			{
				DestroyNative((ImGuiPlatformImeData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyIndex")]
		internal static extern ImGuiKey GetKeyIndexNative(ImGuiKey key);

		public static ImGuiKey GetKeyIndex(ImGuiKey key)
		{
			ImGuiKey ret = GetKeyIndexNative(key);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImHashData")]
		internal static extern int ImHashDataNative(void* data, nuint dataSize, int seed);

		public static int ImHashData(void* data, nuint dataSize, int seed)
		{
			int ret = ImHashDataNative(data, dataSize, seed);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImHashStr")]
		internal static extern int ImHashNative(byte* data, nuint dataSize, int seed);

		public static int ImHash(byte* data, nuint dataSize, int seed)
		{
			int ret = ImHashNative(data, dataSize, seed);
			return ret;
		}

		public static int ImHash(ref byte data, nuint dataSize, int seed)
		{
			fixed (byte* pdata = &data)
			{
				int ret = ImHashNative((byte*)pdata, dataSize, seed);
				return ret;
			}
		}

		public static int ImHash(string data, nuint dataSize, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImHashNative(pStr0, dataSize, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImQsort")]
		internal static extern void ImQsortNative(void* baseValue, nuint count, nuint sizeOfElement, delegate*<void*, nuint, nuint, delegate*<void*, void*>> compareFunc);

		public static void ImQsort(void* baseValue, nuint count, nuint sizeOfElement, delegate*<void*, nuint, nuint, delegate*<void*, void*>> compareFunc)
		{
			ImQsortNative(baseValue, count, sizeOfElement, compareFunc);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImAlphaBlendColors")]
		internal static extern uint ImAlphaBlendColorsNative(uint colA, uint colB);

		public static uint ImAlphaBlendColors(uint colA, uint colB)
		{
			uint ret = ImAlphaBlendColorsNative(colA, colB);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImIsPowerOfTwo_Int")]
		internal static extern byte ImIsPowerOfTwoIntNative(int v);

		public static bool ImIsPowerOfTwoInt(int v)
		{
			byte ret = ImIsPowerOfTwoIntNative(v);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImIsPowerOfTwo_U64")]
		internal static extern byte ImIsPowerOfTwoU64Native(ulong v);

		public static bool ImIsPowerOfTwoU64(ulong v)
		{
			byte ret = ImIsPowerOfTwoU64Native(v);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImUpperPowerOfTwo")]
		internal static extern int ImUpperPowerOfTwoNative(int v);

		public static int ImUpperPowerOfTwo(int v)
		{
			int ret = ImUpperPowerOfTwoNative(v);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStricmp")]
		internal static extern int ImStricmpNative(byte* str1, byte* str2);

		public static int ImStricmp(byte* str1, byte* str2)
		{
			int ret = ImStricmpNative(str1, str2);
			return ret;
		}

		public static int ImStricmp(ref byte str1, byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = ImStricmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		public static int ImStricmp(string str1, byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStricmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImStricmp(byte* str1, ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImStricmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		public static int ImStricmp(byte* str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStricmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImStricmp(ref byte str1, ref byte str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = ImStricmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		public static int ImStricmp(string str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImStricmpNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrnicmp")]
		internal static extern int ImStrnicmpNative(byte* str1, byte* str2, nuint count);

		public static int ImStrnicmp(byte* str1, byte* str2, nuint count)
		{
			int ret = ImStrnicmpNative(str1, str2, count);
			return ret;
		}

		public static int ImStrnicmp(ref byte str1, byte* str2, nuint count)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = ImStrnicmpNative((byte*)pstr1, str2, count);
				return ret;
			}
		}

		public static int ImStrnicmp(string str1, byte* str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStrnicmpNative(pStr0, str2, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImStrnicmp(byte* str1, ref byte str2, nuint count)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImStrnicmpNative(str1, (byte*)pstr2, count);
				return ret;
			}
		}

		public static int ImStrnicmp(byte* str1, string str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStrnicmpNative(str1, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImStrnicmp(ref byte str1, ref byte str2, nuint count)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = ImStrnicmpNative((byte*)pstr1, (byte*)pstr2, count);
					return ret;
				}
			}
		}

		public static int ImStrnicmp(string str1, string str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImStrnicmpNative(pStr0, pStr1, count);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrncpy")]
		internal static extern void ImStrncpyNative(byte* dst, byte* src, nuint count);

		public static void ImStrncpy(byte* dst, byte* src, nuint count)
		{
			ImStrncpyNative(dst, src, count);
		}

		public static void ImStrncpy(ref byte dst, byte* src, nuint count)
		{
			fixed (byte* pdst = &dst)
			{
				ImStrncpyNative((byte*)pdst, src, count);
			}
		}

		public static void ImStrncpy(ref string dst, byte* src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImStrncpyNative(pStr0, src, count);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImStrncpy(byte* dst, ref byte src, nuint count)
		{
			fixed (byte* psrc = &src)
			{
				ImStrncpyNative(dst, (byte*)psrc, count);
			}
		}

		public static void ImStrncpy(byte* dst, string src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImStrncpyNative(dst, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImStrncpy(ref byte dst, ref byte src, nuint count)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					ImStrncpyNative((byte*)pdst, (byte*)psrc, count);
				}
			}
		}

		public static void ImStrncpy(ref string dst, string src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImStrncpyNative(pStr0, pStr1, count);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrdup")]
		internal static extern byte* ImStrdupNative(byte* str);

		public static byte* ImStrdup(byte* str)
		{
			byte* ret = ImStrdupNative(str);
			return ret;
		}

		public static string ImStrdupS(byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImStrdupNative(str));
			return ret;
		}

		public static byte* ImStrdup(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImStrdupNative((byte*)pstr);
				return ret;
			}
		}

		public static string ImStrdupS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImStrdupNative((byte*)pstr));
				return ret;
			}
		}

		public static byte* ImStrdup(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrdupNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrdupS(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrdupNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrdupcpy")]
		internal static extern byte* ImStrdupcpyNative(byte* dst, nuint* pDstSize, byte* str);

		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, byte* str)
		{
			byte* ret = ImStrdupcpyNative(dst, pDstSize, str);
			return ret;
		}

		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, pDstSize, str));
			return ret;
		}

		public static byte* ImStrdupcpy(ref byte dst, nuint* pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				byte* ret = ImStrdupcpyNative((byte*)pdst, pDstSize, str);
				return ret;
			}
		}

		public static string ImStrdupcpyS(ref byte dst, nuint* pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative((byte*)pdst, pDstSize, str));
				return ret;
			}
		}

		public static byte* ImStrdupcpy(ref string dst, nuint* pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrdupcpyNative(pStr0, pDstSize, str);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrdupcpyS(ref string dst, nuint* pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(pStr0, pDstSize, str));
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrdupcpy(byte* dst, ref nuint pDstSize, byte* str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* ret = ImStrdupcpyNative(dst, (nuint*)ppDstSize, str);
				return ret;
			}
		}

		public static string ImStrdupcpyS(byte* dst, ref nuint pDstSize, byte* str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, (nuint*)ppDstSize, str));
				return ret;
			}
		}

		public static byte* ImStrdupcpy(ref byte dst, ref nuint pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (nuint* ppDstSize = &pDstSize)
				{
					byte* ret = ImStrdupcpyNative((byte*)pdst, (nuint*)ppDstSize, str);
					return ret;
				}
			}
		}

		public static string ImStrdupcpyS(ref byte dst, ref nuint pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (nuint* ppDstSize = &pDstSize)
				{
					string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative((byte*)pdst, (nuint*)ppDstSize, str));
					return ret;
				}
			}
		}

		public static byte* ImStrdupcpy(ref string dst, ref nuint pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* ret = ImStrdupcpyNative(pStr0, (nuint*)ppDstSize, str);
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string ImStrdupcpyS(ref string dst, ref nuint pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppDstSize = &pDstSize)
			{
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(pStr0, (nuint*)ppDstSize, str));
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImStrdupcpyNative(dst, pDstSize, (byte*)pstr);
				return ret;
			}
		}

		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, pDstSize, (byte*)pstr));
				return ret;
			}
		}

		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrdupcpyNative(dst, pDstSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, pDstSize, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrdupcpy(ref byte dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* pstr = &str)
				{
					byte* ret = ImStrdupcpyNative((byte*)pdst, pDstSize, (byte*)pstr);
					return ret;
				}
			}
		}

		public static string ImStrdupcpyS(ref byte dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* pstr = &str)
				{
					string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative((byte*)pdst, pDstSize, (byte*)pstr));
					return ret;
				}
			}
		}

		public static byte* ImStrdupcpy(ref string dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStrdupcpyNative(pStr0, pDstSize, pStr1);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrdupcpyS(ref string dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(pStr0, pDstSize, pStr1));
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrdupcpy(byte* dst, ref nuint pDstSize, ref byte str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				fixed (byte* pstr = &str)
				{
					byte* ret = ImStrdupcpyNative(dst, (nuint*)ppDstSize, (byte*)pstr);
					return ret;
				}
			}
		}

		public static string ImStrdupcpyS(byte* dst, ref nuint pDstSize, ref byte str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				fixed (byte* pstr = &str)
				{
					string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, (nuint*)ppDstSize, (byte*)pstr));
					return ret;
				}
			}
		}

		public static byte* ImStrdupcpy(byte* dst, ref nuint pDstSize, string str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImStrdupcpyNative(dst, (nuint*)ppDstSize, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string ImStrdupcpyS(byte* dst, ref nuint pDstSize, string str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, (nuint*)ppDstSize, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static byte* ImStrdupcpy(ref byte dst, ref nuint pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (nuint* ppDstSize = &pDstSize)
				{
					fixed (byte* pstr = &str)
					{
						byte* ret = ImStrdupcpyNative((byte*)pdst, (nuint*)ppDstSize, (byte*)pstr);
						return ret;
					}
				}
			}
		}

		public static string ImStrdupcpyS(ref byte dst, ref nuint pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (nuint* ppDstSize = &pDstSize)
				{
					fixed (byte* pstr = &str)
					{
						string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative((byte*)pdst, (nuint*)ppDstSize, (byte*)pstr));
						return ret;
					}
				}
			}
		}

		public static byte* ImStrdupcpy(ref string dst, ref nuint pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (str != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(str);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImStrdupcpyNative(pStr0, (nuint*)ppDstSize, pStr1);
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string ImStrdupcpyS(ref string dst, ref nuint pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (str != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(str);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(pStr0, (nuint*)ppDstSize, pStr1));
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrchrRange")]
		internal static extern byte* ImStrchrRangeNative(byte* strBegin, byte* strEnd, byte c);

		public static byte* ImStrchrRange(byte* strBegin, byte* strEnd, byte c)
		{
			byte* ret = ImStrchrRangeNative(strBegin, strEnd, c);
			return ret;
		}

		public static string ImStrchrRangeS(byte* strBegin, byte* strEnd, byte c)
		{
			string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative(strBegin, strEnd, c));
			return ret;
		}

		public static byte* ImStrchrRange(ref byte strBegin, byte* strEnd, byte c)
		{
			fixed (byte* pstrBegin = &strBegin)
			{
				byte* ret = ImStrchrRangeNative((byte*)pstrBegin, strEnd, c);
				return ret;
			}
		}

		public static string ImStrchrRangeS(ref byte strBegin, byte* strEnd, byte c)
		{
			fixed (byte* pstrBegin = &strBegin)
			{
				string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative((byte*)pstrBegin, strEnd, c));
				return ret;
			}
		}

		public static byte* ImStrchrRange(string strBegin, byte* strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrchrRangeNative(pStr0, strEnd, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrchrRangeS(string strBegin, byte* strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative(pStr0, strEnd, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrchrRange(byte* strBegin, ref byte strEnd, byte c)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				byte* ret = ImStrchrRangeNative(strBegin, (byte*)pstrEnd, c);
				return ret;
			}
		}

		public static string ImStrchrRangeS(byte* strBegin, ref byte strEnd, byte c)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative(strBegin, (byte*)pstrEnd, c));
				return ret;
			}
		}

		public static byte* ImStrchrRange(byte* strBegin, string strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrchrRangeNative(strBegin, pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrchrRangeS(byte* strBegin, string strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative(strBegin, pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStrchrRange(ref byte strBegin, ref byte strEnd, byte c)
		{
			fixed (byte* pstrBegin = &strBegin)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					byte* ret = ImStrchrRangeNative((byte*)pstrBegin, (byte*)pstrEnd, c);
					return ret;
				}
			}
		}

		public static string ImStrchrRangeS(ref byte strBegin, ref byte strEnd, byte c)
		{
			fixed (byte* pstrBegin = &strBegin)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative((byte*)pstrBegin, (byte*)pstrEnd, c));
					return ret;
				}
			}
		}

		public static byte* ImStrchrRange(string strBegin, string strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStrchrRangeNative(pStr0, pStr1, c);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStrchrRangeS(string strBegin, string strEnd, byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative(pStr0, pStr1, c));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrlenW")]
		internal static extern int ImStrlenWNative(char* str);

		public static int ImStrlenW(char* str)
		{
			int ret = ImStrlenWNative(str);
			return ret;
		}

		public static int ImStrlenW(ref char str)
		{
			fixed (char* pstr = &str)
			{
				int ret = ImStrlenWNative((char*)pstr);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStreolRange")]
		internal static extern byte* ImStreolRangeNative(byte* str, byte* strEnd);

		public static byte* ImStreolRange(byte* str, byte* strEnd)
		{
			byte* ret = ImStreolRangeNative(str, strEnd);
			return ret;
		}

		public static string ImStreolRangeS(byte* str, byte* strEnd)
		{
			string ret = Utils.DecodeStringUTF8(ImStreolRangeNative(str, strEnd));
			return ret;
		}

		public static byte* ImStreolRange(ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImStreolRangeNative((byte*)pstr, strEnd);
				return ret;
			}
		}

		public static string ImStreolRangeS(ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImStreolRangeNative((byte*)pstr, strEnd));
				return ret;
			}
		}

		public static byte* ImStreolRange(string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStreolRangeNative(pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStreolRangeS(string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStreolRangeNative(pStr0, strEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStreolRange(byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				byte* ret = ImStreolRangeNative(str, (byte*)pstrEnd);
				return ret;
			}
		}

		public static string ImStreolRangeS(byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImStreolRangeNative(str, (byte*)pstrEnd));
				return ret;
			}
		}

		public static byte* ImStreolRange(byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStreolRangeNative(str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStreolRangeS(byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStreolRangeNative(str, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStreolRange(ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					byte* ret = ImStreolRangeNative((byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		public static string ImStreolRangeS(ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImStreolRangeNative((byte*)pstr, (byte*)pstrEnd));
					return ret;
				}
			}
		}

		public static byte* ImStreolRange(string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStreolRangeNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStreolRangeS(string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStreolRangeNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrbolW")]
		internal static extern char* ImStrbolWNative(char* bufMidLine, char* bufBegin);

		public static char* ImStrbolW(char* bufMidLine, char* bufBegin)
		{
			char* ret = ImStrbolWNative(bufMidLine, bufBegin);
			return ret;
		}

		public static char* ImStrbolW(ref char bufMidLine, char* bufBegin)
		{
			fixed (char* pbufMidLine = &bufMidLine)
			{
				char* ret = ImStrbolWNative((char*)pbufMidLine, bufBegin);
				return ret;
			}
		}

		public static char* ImStrbolW(char* bufMidLine, ref char bufBegin)
		{
			fixed (char* pbufBegin = &bufBegin)
			{
				char* ret = ImStrbolWNative(bufMidLine, (char*)pbufBegin);
				return ret;
			}
		}

		public static char* ImStrbolW(ref char bufMidLine, ref char bufBegin)
		{
			fixed (char* pbufMidLine = &bufMidLine)
			{
				fixed (char* pbufBegin = &bufBegin)
				{
					char* ret = ImStrbolWNative((char*)pbufMidLine, (char*)pbufBegin);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStristr")]
		internal static extern byte* ImStristrNative(byte* haystack, byte* haystackEnd, byte* needle, byte* needleEnd);

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* ret = ImStristrNative(haystack, haystackEnd, needle, needleEnd);
			return ret;
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, needle, needleEnd));
			return ret;
		}

		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = ImStristrNative((byte*)phaystack, haystackEnd, needle, needleEnd);
				return ret;
			}
		}

		public static string ImStristrS(ref byte haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(ImStristrNative((byte*)phaystack, haystackEnd, needle, needleEnd));
				return ret;
			}
		}

		public static byte* ImStristr(string haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristrNative(pStr0, haystackEnd, needle, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(string haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(pStr0, haystackEnd, needle, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* ret = ImStristrNative(haystack, (byte*)phaystackEnd, needle, needleEnd);
				return ret;
			}
		}

		public static string ImStristrS(byte* haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, (byte*)phaystackEnd, needle, needleEnd));
				return ret;
			}
		}

		public static byte* ImStristr(byte* haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristrNative(haystack, pStr0, needle, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, pStr0, needle, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* ret = ImStristrNative((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(string haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(pStr0, pStr1, needle, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(string haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(pStr0, pStr1, needle, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = ImStristrNative(haystack, haystackEnd, (byte*)pneedle, needleEnd);
				return ret;
			}
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, (byte*)pneedle, needleEnd));
				return ret;
			}
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristrNative(haystack, haystackEnd, pStr0, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, pStr0, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImStristrNative((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(string haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(pStr0, haystackEnd, pStr1, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(string haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(pStr0, haystackEnd, pStr1, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImStristrNative(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(byte* haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(haystack, pStr0, pStr1, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, pStr0, pStr1, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* ret = ImStristrNative((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}

		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						string ret = Utils.DecodeStringUTF8(ImStristrNative((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}

		public static byte* ImStristr(string haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristrNative(pStr0, pStr1, pStr2, needleEnd);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(string haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(pStr0, pStr1, pStr2, needleEnd));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImStristrNative(haystack, haystackEnd, needle, (byte*)pneedleEnd);
				return ret;
			}
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, needle, (byte*)pneedleEnd));
				return ret;
			}
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needleEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristrNative(haystack, haystackEnd, needle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needleEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, needle, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImStristrNative((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(ref byte haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(string haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(pStr0, haystackEnd, needle, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(string haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(pStr0, haystackEnd, needle, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImStristrNative(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(byte* haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(byte* haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(haystack, pStr0, needle, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, pStr0, needle, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImStristrNative((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}

		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImStristrNative((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}

		public static byte* ImStristr(string haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristrNative(pStr0, pStr1, needle, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(string haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(pStr0, pStr1, needle, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImStristrNative(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}

		public static byte* ImStristr(byte* haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(haystack, haystackEnd, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImStristrNative((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}

		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImStristrNative((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}

		public static byte* ImStristr(string haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristrNative(pStr0, haystackEnd, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(string haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(pStr0, haystackEnd, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImStristrNative(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}

		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}

		public static byte* ImStristr(byte* haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristrNative(haystack, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(byte* haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, pStr0, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImStristrNative((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}

		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImStristrNative((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}

		public static byte* ImStristr(string haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* pStr3 = null;
			int pStrSize3 = 0;
			if (needleEnd != null)
			{
				pStrSize3 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize3 >= Utils.MaxStackallocSize)
				{
					pStr3 = Utils.Alloc<byte>(pStrSize3 + 1);
				}
				else
				{
					byte* pStrStack3 = stackalloc byte[pStrSize3 + 1];
					pStr3 = pStrStack3;
				}
				int pStrOffset3 = Utils.EncodeStringUTF8(needleEnd, pStr3, pStrSize3);
				pStr3[pStrOffset3] = 0;
			}
			byte* ret = ImStristrNative(pStr0, pStr1, pStr2, pStr3);
			if (pStrSize3 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr3);
			}
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImStristrS(string haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* pStr3 = null;
			int pStrSize3 = 0;
			if (needleEnd != null)
			{
				pStrSize3 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize3 >= Utils.MaxStackallocSize)
				{
					pStr3 = Utils.Alloc<byte>(pStrSize3 + 1);
				}
				else
				{
					byte* pStrStack3 = stackalloc byte[pStrSize3 + 1];
					pStr3 = pStrStack3;
				}
				int pStrOffset3 = Utils.EncodeStringUTF8(needleEnd, pStr3, pStrSize3);
				pStr3[pStrOffset3] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(pStr0, pStr1, pStr2, pStr3));
			if (pStrSize3 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr3);
			}
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrTrimBlanks")]
		internal static extern void ImTrimBlanksNative(byte* str);

		public static void ImTrimBlanks(byte* str)
		{
			ImTrimBlanksNative(str);
		}

		public static void ImTrimBlanks(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				ImTrimBlanksNative((byte*)pstr);
			}
		}

		public static void ImTrimBlanks(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImTrimBlanksNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImStrSkipBlank")]
		internal static extern byte* ImSkipBlankNative(byte* str);

		public static byte* ImSkipBlank(byte* str)
		{
			byte* ret = ImSkipBlankNative(str);
			return ret;
		}

		public static string ImSkipBlankS(byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImSkipBlankNative(str));
			return ret;
		}

		public static byte* ImSkipBlank(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImSkipBlankNative((byte*)pstr);
				return ret;
			}
		}

		public static string ImSkipBlankS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImSkipBlankNative((byte*)pstr));
				return ret;
			}
		}

		public static byte* ImSkipBlank(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImSkipBlankNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImSkipBlankS(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImSkipBlankNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImToUpper")]
		internal static extern byte ImToUpperNative(byte c);

		public static byte ImToUpper(byte c)
		{
			byte ret = ImToUpperNative(c);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImCharIsBlankA")]
		internal static extern byte ImCharIsBlankANative(byte c);

		public static bool ImCharIsBlankA(byte c)
		{
			byte ret = ImCharIsBlankANative(c);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImCharIsBlankW")]
		internal static extern byte ImCharIsBlankWNative(uint c);

		public static bool ImCharIsBlankW(uint c)
		{
			byte ret = ImCharIsBlankWNative(c);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFormatString")]
		internal static extern int ImFormatStringNative(byte* buf, nuint bufSize, byte* fmt);

		public static int ImFormatString(byte* buf, nuint bufSize, byte* fmt)
		{
			int ret = ImFormatStringNative(buf, bufSize, fmt);
			return ret;
		}

		public static int ImFormatString(ref byte buf, nuint bufSize, byte* fmt)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = ImFormatStringNative((byte*)pbuf, bufSize, fmt);
				return ret;
			}
		}

		public static int ImFormatString(ref string buf, nuint bufSize, byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImFormatStringNative(pStr0, bufSize, fmt);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImFormatString(byte* buf, nuint bufSize, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = ImFormatStringNative(buf, bufSize, (byte*)pfmt);
				return ret;
			}
		}

		public static int ImFormatString(byte* buf, nuint bufSize, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImFormatStringNative(buf, bufSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImFormatString(ref byte buf, nuint bufSize, ref byte fmt)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = ImFormatStringNative((byte*)pbuf, bufSize, (byte*)pfmt);
					return ret;
				}
			}
		}

		public static int ImFormatString(ref string buf, nuint bufSize, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImFormatStringNative(pStr0, bufSize, pStr1);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFormatStringV")]
		internal static extern int ImFormatStringVNative(byte* buf, nuint bufSize, byte* fmt, nuint args);

		public static int ImFormatStringV(byte* buf, nuint bufSize, byte* fmt, nuint args)
		{
			int ret = ImFormatStringVNative(buf, bufSize, fmt, args);
			return ret;
		}

		public static int ImFormatStringV(ref byte buf, nuint bufSize, byte* fmt, nuint args)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = ImFormatStringVNative((byte*)pbuf, bufSize, fmt, args);
				return ret;
			}
		}

		public static int ImFormatStringV(ref string buf, nuint bufSize, byte* fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImFormatStringVNative(pStr0, bufSize, fmt, args);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImFormatStringV(byte* buf, nuint bufSize, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = ImFormatStringVNative(buf, bufSize, (byte*)pfmt, args);
				return ret;
			}
		}

		public static int ImFormatStringV(byte* buf, nuint bufSize, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImFormatStringVNative(buf, bufSize, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImFormatStringV(ref byte buf, nuint bufSize, ref byte fmt, nuint args)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = ImFormatStringVNative((byte*)pbuf, bufSize, (byte*)pfmt, args);
					return ret;
				}
			}
		}

		public static int ImFormatStringV(ref string buf, nuint bufSize, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImFormatStringVNative(pStr0, bufSize, pStr1, args);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFormatStringToTempBuffer")]
		internal static extern void ImFormatStringToTempBufferNative(byte** outBuf, byte** outBufEnd, byte* fmt);

		public static void ImFormatStringToTempBuffer(byte** outBuf, byte** outBufEnd, byte* fmt)
		{
			ImFormatStringToTempBufferNative(outBuf, outBufEnd, fmt);
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, byte** outBufEnd, byte* fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				ImFormatStringToTempBufferNative((byte**)poutBuf, outBufEnd, fmt);
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, ref byte* outBufEnd, byte* fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				ImFormatStringToTempBufferNative(outBuf, (byte**)poutBufEnd, fmt);
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, ref byte* outBufEnd, byte* fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					ImFormatStringToTempBufferNative((byte**)poutBuf, (byte**)poutBufEnd, fmt);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, byte** outBufEnd, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImFormatStringToTempBufferNative(outBuf, outBufEnd, (byte*)pfmt);
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, byte** outBufEnd, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFormatStringToTempBufferNative(outBuf, outBufEnd, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, byte** outBufEnd, ref byte fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBufferNative((byte**)poutBuf, outBufEnd, (byte*)pfmt);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, byte** outBufEnd, string fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBufferNative((byte**)poutBuf, outBufEnd, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, ref byte* outBufEnd, ref byte fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBufferNative(outBuf, (byte**)poutBufEnd, (byte*)pfmt);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(byte** outBuf, ref byte* outBufEnd, string fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBufferNative(outBuf, (byte**)poutBufEnd, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, ref byte* outBufEnd, ref byte fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					fixed (byte* pfmt = &fmt)
					{
						ImFormatStringToTempBufferNative((byte**)poutBuf, (byte**)poutBufEnd, (byte*)pfmt);
					}
				}
			}
		}

		public static void ImFormatStringToTempBuffer(ref byte* outBuf, ref byte* outBufEnd, string fmt)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (fmt != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(fmt);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImFormatStringToTempBufferNative((byte**)poutBuf, (byte**)poutBufEnd, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFormatStringToTempBufferV")]
		internal static extern void ImFormatStringToTempBufferVNative(byte** outBuf, byte** outBufEnd, byte* fmt, nuint args);

		public static void ImFormatStringToTempBufferV(byte** outBuf, byte** outBufEnd, byte* fmt, nuint args)
		{
			ImFormatStringToTempBufferVNative(outBuf, outBufEnd, fmt, args);
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, byte** outBufEnd, byte* fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				ImFormatStringToTempBufferVNative((byte**)poutBuf, outBufEnd, fmt, args);
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, ref byte* outBufEnd, byte* fmt, nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				ImFormatStringToTempBufferVNative(outBuf, (byte**)poutBufEnd, fmt, args);
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, ref byte* outBufEnd, byte* fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					ImFormatStringToTempBufferVNative((byte**)poutBuf, (byte**)poutBufEnd, fmt, args);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, byte** outBufEnd, ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImFormatStringToTempBufferVNative(outBuf, outBufEnd, (byte*)pfmt, args);
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, byte** outBufEnd, string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFormatStringToTempBufferVNative(outBuf, outBufEnd, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, byte** outBufEnd, ref byte fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBufferVNative((byte**)poutBuf, outBufEnd, (byte*)pfmt, args);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, byte** outBufEnd, string fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBufferVNative((byte**)poutBuf, outBufEnd, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, ref byte* outBufEnd, ref byte fmt, nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBufferVNative(outBuf, (byte**)poutBufEnd, (byte*)pfmt, args);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(byte** outBuf, ref byte* outBufEnd, string fmt, nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBufferVNative(outBuf, (byte**)poutBufEnd, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, ref byte* outBufEnd, ref byte fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					fixed (byte* pfmt = &fmt)
					{
						ImFormatStringToTempBufferVNative((byte**)poutBuf, (byte**)poutBufEnd, (byte*)pfmt, args);
					}
				}
			}
		}

		public static void ImFormatStringToTempBufferV(ref byte* outBuf, ref byte* outBufEnd, string fmt, nuint args)
		{
			fixed (byte** poutBuf = &outBuf)
			{
				fixed (byte** poutBufEnd = &outBufEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (fmt != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(fmt);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImFormatStringToTempBufferVNative((byte**)poutBuf, (byte**)poutBufEnd, pStr0, args);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatFindStart")]
		internal static extern byte* ImParseFormatFindStartNative(byte* format);

		public static byte* ImParseFormatFindStart(byte* format)
		{
			byte* ret = ImParseFormatFindStartNative(format);
			return ret;
		}

		public static string ImParseFormatFindStartS(byte* format)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatFindStartNative(format));
			return ret;
		}

		public static byte* ImParseFormatFindStart(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte* ret = ImParseFormatFindStartNative((byte*)pformat);
				return ret;
			}
		}

		public static string ImParseFormatFindStartS(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatFindStartNative((byte*)pformat));
				return ret;
			}
		}

		public static byte* ImParseFormatFindStart(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatFindStartNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatFindStartS(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatFindStartNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatFindEnd")]
		internal static extern byte* ImParseFormatFindEndNative(byte* format);

		public static byte* ImParseFormatFindEnd(byte* format)
		{
			byte* ret = ImParseFormatFindEndNative(format);
			return ret;
		}

		public static string ImParseFormatFindEndS(byte* format)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatFindEndNative(format));
			return ret;
		}

		public static byte* ImParseFormatFindEnd(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte* ret = ImParseFormatFindEndNative((byte*)pformat);
				return ret;
			}
		}

		public static string ImParseFormatFindEndS(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatFindEndNative((byte*)pformat));
				return ret;
			}
		}

		public static byte* ImParseFormatFindEnd(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatFindEndNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatFindEndS(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatFindEndNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatTrimDecorations")]
		internal static extern byte* ImParseFormatTrimDecorationsNative(byte* format, byte* buf, nuint bufSize);

		public static byte* ImParseFormatTrimDecorations(byte* format, byte* buf, nuint bufSize)
		{
			byte* ret = ImParseFormatTrimDecorationsNative(format, buf, bufSize);
			return ret;
		}

		public static string ImParseFormatTrimDecorationsS(byte* format, byte* buf, nuint bufSize)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatTrimDecorationsNative(format, buf, bufSize));
			return ret;
		}

		public static byte* ImParseFormatTrimDecorations(ref byte format, byte* buf, nuint bufSize)
		{
			fixed (byte* pformat = &format)
			{
				byte* ret = ImParseFormatTrimDecorationsNative((byte*)pformat, buf, bufSize);
				return ret;
			}
		}

		public static string ImParseFormatTrimDecorationsS(ref byte format, byte* buf, nuint bufSize)
		{
			fixed (byte* pformat = &format)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatTrimDecorationsNative((byte*)pformat, buf, bufSize));
				return ret;
			}
		}

		public static byte* ImParseFormatTrimDecorations(string format, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatTrimDecorationsNative(pStr0, buf, bufSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatTrimDecorationsS(string format, byte* buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatTrimDecorationsNative(pStr0, buf, bufSize));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatTrimDecorations(byte* format, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				byte* ret = ImParseFormatTrimDecorationsNative(format, (byte*)pbuf, bufSize);
				return ret;
			}
		}

		public static string ImParseFormatTrimDecorationsS(byte* format, ref byte buf, nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatTrimDecorationsNative(format, (byte*)pbuf, bufSize));
				return ret;
			}
		}

		public static byte* ImParseFormatTrimDecorations(byte* format, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatTrimDecorationsNative(format, pStr0, bufSize);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatTrimDecorationsS(byte* format, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatTrimDecorationsNative(format, pStr0, bufSize));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatTrimDecorations(ref byte format, ref byte buf, nuint bufSize)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pbuf = &buf)
				{
					byte* ret = ImParseFormatTrimDecorationsNative((byte*)pformat, (byte*)pbuf, bufSize);
					return ret;
				}
			}
		}

		public static string ImParseFormatTrimDecorationsS(ref byte format, ref byte buf, nuint bufSize)
		{
			fixed (byte* pformat = &format)
			{
				fixed (byte* pbuf = &buf)
				{
					string ret = Utils.DecodeStringUTF8(ImParseFormatTrimDecorationsNative((byte*)pformat, (byte*)pbuf, bufSize));
					return ret;
				}
			}
		}

		public static byte* ImParseFormatTrimDecorations(string format, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImParseFormatTrimDecorationsNative(pStr0, pStr1, bufSize);
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatTrimDecorationsS(string format, ref string buf, nuint bufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatTrimDecorationsNative(pStr0, pStr1, bufSize));
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatSanitizeForPrinting")]
		internal static extern void ImParseFormatSanitizeForPrintingNative(byte* fmtIn, byte* fmtOut, nuint fmtOutSize);

		public static void ImParseFormatSanitizeForPrinting(byte* fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			ImParseFormatSanitizeForPrintingNative(fmtIn, fmtOut, fmtOutSize);
		}

		public static void ImParseFormatSanitizeForPrinting(ref byte fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				ImParseFormatSanitizeForPrintingNative((byte*)pfmtIn, fmtOut, fmtOutSize);
			}
		}

		public static void ImParseFormatSanitizeForPrinting(string fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImParseFormatSanitizeForPrintingNative(pStr0, fmtOut, fmtOutSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImParseFormatSanitizeForPrinting(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				ImParseFormatSanitizeForPrintingNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
			}
		}

		public static void ImParseFormatSanitizeForPrinting(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImParseFormatSanitizeForPrintingNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImParseFormatSanitizeForPrinting(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					ImParseFormatSanitizeForPrintingNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
				}
			}
		}

		public static void ImParseFormatSanitizeForPrinting(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImParseFormatSanitizeForPrintingNative(pStr0, pStr1, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatSanitizeForScanning")]
		internal static extern byte* ImParseFormatSanitizeForScanningNative(byte* fmtIn, byte* fmtOut, nuint fmtOutSize);

		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize);
			return ret;
		}

		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize));
			return ret;
		}

		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize);
				return ret;
			}
		}

		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize));
				return ret;
			}
		}

		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(pStr0, fmtOut, fmtOutSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatSanitizeForScanningS(string fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(pStr0, fmtOut, fmtOutSize));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
				return ret;
			}
		}

		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize));
				return ret;
			}
		}

		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize));
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
					return ret;
				}
			}
		}

		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize));
					return ret;
				}
			}
		}

		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(pStr0, pStr1, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImParseFormatSanitizeForScanningS(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(pStr0, pStr1, fmtOutSize));
			fmtOut = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImParseFormatPrecision")]
		internal static extern int ImParseFormatPrecisionNative(byte* format, int defaultValue);

		public static int ImParseFormatPrecision(byte* format, int defaultValue)
		{
			int ret = ImParseFormatPrecisionNative(format, defaultValue);
			return ret;
		}

		public static int ImParseFormatPrecision(ref byte format, int defaultValue)
		{
			fixed (byte* pformat = &format)
			{
				int ret = ImParseFormatPrecisionNative((byte*)pformat, defaultValue);
				return ret;
			}
		}

		public static int ImParseFormatPrecision(string format, int defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImParseFormatPrecisionNative(pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCharToUtf8")]
		internal static extern byte* ImTextCharToUtf8Native(byte* outBuf, uint c);

		public static byte* ImTextCharToUtf8(byte* outBuf, uint c)
		{
			byte* ret = ImTextCharToUtf8Native(outBuf, c);
			return ret;
		}

		public static string ImTextCharToUtf8S(byte* outBuf, uint c)
		{
			string ret = Utils.DecodeStringUTF8(ImTextCharToUtf8Native(outBuf, c));
			return ret;
		}

		public static byte* ImTextCharToUtf8(ref byte outBuf, uint c)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				byte* ret = ImTextCharToUtf8Native((byte*)poutBuf, c);
				return ret;
			}
		}

		public static string ImTextCharToUtf8S(ref byte outBuf, uint c)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				string ret = Utils.DecodeStringUTF8(ImTextCharToUtf8Native((byte*)poutBuf, c));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextStrToUtf8")]
		internal static extern int ImTextToUtf8Native(byte* outBuf, int outBufSize, char* inText, char* inTextEnd);

		public static int ImTextToUtf8(byte* outBuf, int outBufSize, char* inText, char* inTextEnd)
		{
			int ret = ImTextToUtf8Native(outBuf, outBufSize, inText, inTextEnd);
			return ret;
		}

		public static int ImTextToUtf8(ref byte outBuf, int outBufSize, char* inText, char* inTextEnd)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				int ret = ImTextToUtf8Native((byte*)poutBuf, outBufSize, inText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextToUtf8(ref string outBuf, int outBufSize, char* inText, char* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextToUtf8Native(pStr0, outBufSize, inText, inTextEnd);
			outBuf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextToUtf8(byte* outBuf, int outBufSize, ref char inText, char* inTextEnd)
		{
			fixed (char* pinText = &inText)
			{
				int ret = ImTextToUtf8Native(outBuf, outBufSize, (char*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextToUtf8(ref byte outBuf, int outBufSize, ref char inText, char* inTextEnd)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				fixed (char* pinText = &inText)
				{
					int ret = ImTextToUtf8Native((byte*)poutBuf, outBufSize, (char*)pinText, inTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextToUtf8(ref string outBuf, int outBufSize, ref char inText, char* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pinText = &inText)
			{
				int ret = ImTextToUtf8Native(pStr0, outBufSize, (char*)pinText, inTextEnd);
				outBuf = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextToUtf8(byte* outBuf, int outBufSize, char* inText, ref char inTextEnd)
		{
			fixed (char* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextToUtf8Native(outBuf, outBufSize, inText, (char*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextToUtf8(ref byte outBuf, int outBufSize, char* inText, ref char inTextEnd)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				fixed (char* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextToUtf8Native((byte*)poutBuf, outBufSize, inText, (char*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextToUtf8(ref string outBuf, int outBufSize, char* inText, ref char inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextToUtf8Native(pStr0, outBufSize, inText, (char*)pinTextEnd);
				outBuf = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextToUtf8(byte* outBuf, int outBufSize, ref char inText, ref char inTextEnd)
		{
			fixed (char* pinText = &inText)
			{
				fixed (char* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextToUtf8Native(outBuf, outBufSize, (char*)pinText, (char*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextToUtf8(ref byte outBuf, int outBufSize, ref char inText, ref char inTextEnd)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				fixed (char* pinText = &inText)
				{
					fixed (char* pinTextEnd = &inTextEnd)
					{
						int ret = ImTextToUtf8Native((byte*)poutBuf, outBufSize, (char*)pinText, (char*)pinTextEnd);
						return ret;
					}
				}
			}
		}

		public static int ImTextToUtf8(ref string outBuf, int outBufSize, ref char inText, ref char inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pinText = &inText)
			{
				fixed (char* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextToUtf8Native(pStr0, outBufSize, (char*)pinText, (char*)pinTextEnd);
					outBuf = Utils.DecodeStringUTF8(pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCharFromUtf8")]
		internal static extern int ImTextCharFromUtf8Native(uint* outChar, byte* inText, byte* inTextEnd);

		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, byte* inTextEnd)
		{
			int ret = ImTextCharFromUtf8Native(outChar, inText, inTextEnd);
			return ret;
		}

		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				int ret = ImTextCharFromUtf8Native((uint*)poutChar, inText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, inTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCharFromUtf8(ref uint outChar, string inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCharFromUtf8Native((uint*)poutChar, pStr0, inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCharFromUtf8Native(outChar, inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, inText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCharFromUtf8Native((uint*)poutChar, inText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCharFromUtf8(uint* outChar, string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}

		public static int ImTextCharFromUtf8(ref uint outChar, string inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (inTextEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImTextCharFromUtf8Native((uint*)poutChar, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextStrFromUtf8")]
		internal static extern int ImTextFromUtf8Native(char* outBuf, int outBufSize, byte* inText, byte* inTextEnd, byte** inRemaining);

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, byte* inTextEnd, byte** inRemaining)
		{
			int ret = ImTextFromUtf8Native(outBuf, outBufSize, inText, inTextEnd, inRemaining);
			return ret;
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, byte* inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, inText, inTextEnd, inRemaining);
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, ref byte inText, byte* inTextEnd, byte** inRemaining)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextFromUtf8Native(outBuf, outBufSize, (byte*)pinText, inTextEnd, inRemaining);
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, string inText, byte* inTextEnd, byte** inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextFromUtf8Native(outBuf, outBufSize, pStr0, inTextEnd, inRemaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, ref byte inText, byte* inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinText = &inText)
				{
					int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, (byte*)pinText, inTextEnd, inRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, string inText, byte* inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, pStr0, inTextEnd, inRemaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, ref byte inTextEnd, byte** inRemaining)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextFromUtf8Native(outBuf, outBufSize, inText, (byte*)pinTextEnd, inRemaining);
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, string inTextEnd, byte** inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextFromUtf8Native(outBuf, outBufSize, inText, pStr0, inRemaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, ref byte inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, inText, (byte*)pinTextEnd, inRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, string inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, inText, pStr0, inRemaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, ref byte inText, ref byte inTextEnd, byte** inRemaining)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextFromUtf8Native(outBuf, outBufSize, (byte*)pinText, (byte*)pinTextEnd, inRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, string inText, string inTextEnd, byte** inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextFromUtf8Native(outBuf, outBufSize, pStr0, pStr1, inRemaining);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, ref byte inText, ref byte inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, (byte*)pinText, (byte*)pinTextEnd, inRemaining);
						return ret;
					}
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, string inText, string inTextEnd, byte** inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (inTextEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, pStr0, pStr1, inRemaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (byte** pinRemaining = &inRemaining)
			{
				int ret = ImTextFromUtf8Native(outBuf, outBufSize, inText, inTextEnd, (byte**)pinRemaining);
				return ret;
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, inText, inTextEnd, (byte**)pinRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, ref byte inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8Native(outBuf, outBufSize, (byte*)pinText, inTextEnd, (byte**)pinRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, string inText, byte* inTextEnd, ref byte* inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pinRemaining = &inRemaining)
			{
				int ret = ImTextFromUtf8Native(outBuf, outBufSize, pStr0, inTextEnd, (byte**)pinRemaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, ref byte inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte** pinRemaining = &inRemaining)
					{
						int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, (byte*)pinText, inTextEnd, (byte**)pinRemaining);
						return ret;
					}
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, string inText, byte* inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, pStr0, inTextEnd, (byte**)pinRemaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, ref byte inTextEnd, ref byte* inRemaining)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8Native(outBuf, outBufSize, inText, (byte*)pinTextEnd, (byte**)pinRemaining);
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, byte* inText, string inTextEnd, ref byte* inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pinRemaining = &inRemaining)
			{
				int ret = ImTextFromUtf8Native(outBuf, outBufSize, inText, pStr0, (byte**)pinRemaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, ref byte inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					fixed (byte** pinRemaining = &inRemaining)
					{
						int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, inText, (byte*)pinTextEnd, (byte**)pinRemaining);
						return ret;
					}
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, byte* inText, string inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, inText, pStr0, (byte**)pinRemaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, ref byte inText, ref byte inTextEnd, ref byte* inRemaining)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					fixed (byte** pinRemaining = &inRemaining)
					{
						int ret = ImTextFromUtf8Native(outBuf, outBufSize, (byte*)pinText, (byte*)pinTextEnd, (byte**)pinRemaining);
						return ret;
					}
				}
			}
		}

		public static int ImTextFromUtf8(char* outBuf, int outBufSize, string inText, string inTextEnd, ref byte* inRemaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** pinRemaining = &inRemaining)
			{
				int ret = ImTextFromUtf8Native(outBuf, outBufSize, pStr0, pStr1, (byte**)pinRemaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, ref byte inText, ref byte inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						fixed (byte** pinRemaining = &inRemaining)
						{
							int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, (byte*)pinText, (byte*)pinTextEnd, (byte**)pinRemaining);
							return ret;
						}
					}
				}
			}
		}

		public static int ImTextFromUtf8(ref char outBuf, int outBufSize, string inText, string inTextEnd, ref byte* inRemaining)
		{
			fixed (char* poutBuf = &outBuf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (inTextEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** pinRemaining = &inRemaining)
				{
					int ret = ImTextFromUtf8Native((char*)poutBuf, outBufSize, pStr0, pStr1, (byte**)pinRemaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCountCharsFromUtf8")]
		internal static extern int ImTextCountCharsFromUtf8Native(byte* inText, byte* inTextEnd);

		public static int ImTextCountCharsFromUtf8(byte* inText, byte* inTextEnd)
		{
			int ret = ImTextCountCharsFromUtf8Native(inText, inTextEnd);
			return ret;
		}

		public static int ImTextCountCharsFromUtf8(ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCountCharsFromUtf8(string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountCharsFromUtf8Native(pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCountCharsFromUtf8(byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountCharsFromUtf8Native(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextCountCharsFromUtf8(byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountCharsFromUtf8Native(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCountCharsFromUtf8(ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCountCharsFromUtf8(string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCountCharsFromUtf8Native(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCountUtf8BytesFromChar")]
		internal static extern int ImTextCountUtf8BytesFromCharNative(byte* inText, byte* inTextEnd);

		public static int ImTextCountUtf8BytesFromChar(byte* inText, byte* inTextEnd)
		{
			int ret = ImTextCountUtf8BytesFromCharNative(inText, inTextEnd);
			return ret;
		}

		public static int ImTextCountUtf8BytesFromChar(ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCountUtf8BytesFromChar(string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountUtf8BytesFromCharNative(pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCountUtf8BytesFromChar(byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromCharNative(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextCountUtf8BytesFromChar(byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountUtf8BytesFromCharNative(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImTextCountUtf8BytesFromChar(ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		public static int ImTextCountUtf8BytesFromChar(string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCountUtf8BytesFromCharNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTextCountUtf8BytesFromStr")]
		internal static extern int ImTextCountUtf8BytesFromNative(char* inText, char* inTextEnd);

		public static int ImTextCountUtf8BytesFrom(char* inText, char* inTextEnd)
		{
			int ret = ImTextCountUtf8BytesFromNative(inText, inTextEnd);
			return ret;
		}

		public static int ImTextCountUtf8BytesFrom(ref char inText, char* inTextEnd)
		{
			fixed (char* pinText = &inText)
			{
				int ret = ImTextCountUtf8BytesFromNative((char*)pinText, inTextEnd);
				return ret;
			}
		}

		public static int ImTextCountUtf8BytesFrom(char* inText, ref char inTextEnd)
		{
			fixed (char* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromNative(inText, (char*)pinTextEnd);
				return ret;
			}
		}

		public static int ImTextCountUtf8BytesFrom(ref char inText, ref char inTextEnd)
		{
			fixed (char* pinText = &inText)
			{
				fixed (char* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFromNative((char*)pinText, (char*)pinTextEnd);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileOpen")]
		internal static extern ImFileHandle ImFileOpenNative(byte* filename, byte* mode);

		public static ImFileHandle ImFileOpen(byte* filename, byte* mode)
		{
			ImFileHandle ret = ImFileOpenNative(filename, mode);
			return ret;
		}

		public static ImFileHandle ImFileOpen(ref byte filename, byte* mode)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFileHandle ret = ImFileOpenNative((byte*)pfilename, mode);
				return ret;
			}
		}

		public static ImFileHandle ImFileOpen(string filename, byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImFileOpenNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFileHandle ImFileOpen(byte* filename, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				ImFileHandle ret = ImFileOpenNative(filename, (byte*)pmode);
				return ret;
			}
		}

		public static ImFileHandle ImFileOpen(byte* filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImFileOpenNative(filename, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImFileHandle ImFileOpen(ref byte filename, ref byte mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					ImFileHandle ret = ImFileOpenNative((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}

		public static ImFileHandle ImFileOpen(string filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImFileHandle ret = ImFileOpenNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileClose")]
		internal static extern byte ImFileCloseNative(ImFileHandle file);

		public static bool ImFileClose(ImFileHandle file)
		{
			byte ret = ImFileCloseNative(file);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileGetSize")]
		internal static extern ulong ImFileGetSizeNative(ImFileHandle file);

		public static ulong ImFileGetSize(ImFileHandle file)
		{
			ulong ret = ImFileGetSizeNative(file);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileRead")]
		internal static extern ulong ImFileReadNative(void* data, ulong size, ulong count, ImFileHandle file);

		public static ulong ImFileRead(void* data, ulong size, ulong count, ImFileHandle file)
		{
			ulong ret = ImFileReadNative(data, size, count, file);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileWrite")]
		internal static extern ulong ImFileWriteNative(void* data, ulong size, ulong count, ImFileHandle file);

		public static ulong ImFileWrite(void* data, ulong size, ulong count, ImFileHandle file)
		{
			ulong ret = ImFileWriteNative(data, size, count, file);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFileLoadToMemory")]
		internal static extern void* ImFileLoadToMemoryNative(byte* filename, byte* mode, nuint* outFileSize, int paddingBytes);

		public static void* ImFileLoadToMemory(byte* filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			void* ret = ImFileLoadToMemoryNative(filename, mode, outFileSize, paddingBytes);
			return ret;
		}

		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, outFileSize, paddingBytes);
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(string filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, mode, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, outFileSize, paddingBytes);
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(byte* filename, string mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(filename, pStr0, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}

		public static void* ImFileLoadToMemory(string filename, string mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, pStr1, outFileSize, paddingBytes);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* ImFileLoadToMemory(byte* filename, byte* mode, ref nuint outFileSize, int paddingBytes)
		{
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemoryNative(filename, mode, (nuint*)poutFileSize, paddingBytes);
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, ref nuint outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (nuint* poutFileSize = &outFileSize)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, (nuint*)poutFileSize, paddingBytes);
					return ret;
				}
			}
		}

		public static void* ImFileLoadToMemory(string filename, byte* mode, ref nuint outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, mode, (nuint*)poutFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, ref nuint outFileSize, int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				fixed (nuint* poutFileSize = &outFileSize)
				{
					void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, (nuint*)poutFileSize, paddingBytes);
					return ret;
				}
			}
		}

		public static void* ImFileLoadToMemory(byte* filename, string mode, ref nuint outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemoryNative(filename, pStr0, (nuint*)poutFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, ref nuint outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					fixed (nuint* poutFileSize = &outFileSize)
					{
						void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (nuint*)poutFileSize, paddingBytes);
						return ret;
					}
				}
			}
		}

		public static void* ImFileLoadToMemory(string filename, string mode, ref nuint outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, pStr1, (nuint*)poutFileSize, paddingBytes);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImPow_Float")]
		internal static extern float ImPowFloatNative(float x, float y);

		public static float ImPowFloat(float x, float y)
		{
			float ret = ImPowFloatNative(x, y);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImPow_double")]
		internal static extern double ImPowDoubleNative(double x, double y);

		public static double ImPowDouble(double x, double y)
		{
			double ret = ImPowDoubleNative(x, y);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLog_Float")]
		internal static extern float ImLogFloatNative(float x);

		public static float ImLogFloat(float x)
		{
			float ret = ImLogFloatNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLog_double")]
		internal static extern double ImLogDoubleNative(double x);

		public static double ImLogDouble(double x)
		{
			double ret = ImLogDoubleNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImAbs_Int")]
		internal static extern int ImAbsIntNative(int x);

		public static int ImAbsInt(int x)
		{
			int ret = ImAbsIntNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImAbs_Float")]
		internal static extern float ImAbsFloatNative(float x);

		public static float ImAbsFloat(float x)
		{
			float ret = ImAbsFloatNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImAbs_double")]
		internal static extern double ImAbsDoubleNative(double x);

		public static double ImAbsDouble(double x)
		{
			double ret = ImAbsDoubleNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImSign_Float")]
		internal static extern float ImSignFloatNative(float x);

		public static float ImSignFloat(float x)
		{
			float ret = ImSignFloatNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImSign_double")]
		internal static extern double ImSignDoubleNative(double x);

		public static double ImSignDouble(double x)
		{
			double ret = ImSignDoubleNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImRsqrt_Float")]
		internal static extern float ImRsqrtFloatNative(float x);

		public static float ImRsqrtFloat(float x)
		{
			float ret = ImRsqrtFloatNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImRsqrt_double")]
		internal static extern double ImRsqrtDoubleNative(double x);

		public static double ImRsqrtDouble(double x)
		{
			double ret = ImRsqrtDoubleNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImMin")]
		internal static extern void ImMinNative(Vector2* output, Vector2 lhs, Vector2 rhs);

		public static Vector2 ImMin(Vector2 lhs, Vector2 rhs)
		{
			Vector2 ret;
			ImMinNative(&ret, lhs, rhs);
			return ret;
		}

		public static void ImMin(ref Vector2 output, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* poutput = &output)
			{
				ImMinNative((Vector2*)poutput, lhs, rhs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImMax")]
		internal static extern void ImMaxNative(Vector2* output, Vector2 lhs, Vector2 rhs);

		public static Vector2 ImMax(Vector2 lhs, Vector2 rhs)
		{
			Vector2 ret;
			ImMaxNative(&ret, lhs, rhs);
			return ret;
		}

		public static void ImMax(ref Vector2 output, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* poutput = &output)
			{
				ImMaxNative((Vector2*)poutput, lhs, rhs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImClamp")]
		internal static extern void ImClampNative(Vector2* output, Vector2 v, Vector2 mn, Vector2 mx);

		public static Vector2 ImClamp(Vector2 v, Vector2 mn, Vector2 mx)
		{
			Vector2 ret;
			ImClampNative(&ret, v, mn, mx);
			return ret;
		}

		public static void ImClamp(ref Vector2 output, Vector2 v, Vector2 mn, Vector2 mx)
		{
			fixed (Vector2* poutput = &output)
			{
				ImClampNative((Vector2*)poutput, v, mn, mx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLerp_Vec2Float")]
		internal static extern void ImLerpVec2FloatNative(Vector2* output, Vector2 a, Vector2 b, float t);

		public static Vector2 ImLerpVec2Float(Vector2 a, Vector2 b, float t)
		{
			Vector2 ret;
			ImLerpVec2FloatNative(&ret, a, b, t);
			return ret;
		}

		public static void ImLerpVec2Float(ref Vector2 output, Vector2 a, Vector2 b, float t)
		{
			fixed (Vector2* poutput = &output)
			{
				ImLerpVec2FloatNative((Vector2*)poutput, a, b, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLerp_Vec2Vec2")]
		internal static extern void ImLerpVec2Vec2Native(Vector2* output, Vector2 a, Vector2 b, Vector2 t);

		public static Vector2 ImLerpVec2Vec2(Vector2 a, Vector2 b, Vector2 t)
		{
			Vector2 ret;
			ImLerpVec2Vec2Native(&ret, a, b, t);
			return ret;
		}

		public static void ImLerpVec2Vec2(ref Vector2 output, Vector2 a, Vector2 b, Vector2 t)
		{
			fixed (Vector2* poutput = &output)
			{
				ImLerpVec2Vec2Native((Vector2*)poutput, a, b, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLerp_Vec4")]
		internal static extern void ImLerpVec4Native(Vector4* output, Vector4 a, Vector4 b, float t);

		public static Vector4 ImLerpVec4(Vector4 a, Vector4 b, float t)
		{
			Vector4 ret;
			ImLerpVec4Native(&ret, a, b, t);
			return ret;
		}

		public static void ImLerpVec4(ref Vector4 output, Vector4 a, Vector4 b, float t)
		{
			fixed (Vector4* poutput = &output)
			{
				ImLerpVec4Native((Vector4*)poutput, a, b, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImSaturate")]
		internal static extern float ImSaturateNative(float f);

		public static float ImSaturate(float f)
		{
			float ret = ImSaturateNative(f);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLengthSqr_Vec2")]
		internal static extern float ImLengthSqrVec2Native(Vector2 lhs);

		public static float ImLengthSqrVec2(Vector2 lhs)
		{
			float ret = ImLengthSqrVec2Native(lhs);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLengthSqr_Vec4")]
		internal static extern float ImLengthSqrVec4Native(Vector4 lhs);

		public static float ImLengthSqrVec4(Vector4 lhs)
		{
			float ret = ImLengthSqrVec4Native(lhs);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImInvLength")]
		internal static extern float ImInvLengthNative(Vector2 lhs, float failValue);

		public static float ImInvLength(Vector2 lhs, float failValue)
		{
			float ret = ImInvLengthNative(lhs, failValue);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFloor_Float")]
		internal static extern float ImFloorFloatNative(float f);

		public static float ImFloorFloat(float f)
		{
			float ret = ImFloorFloatNative(f);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFloorSigned_Float")]
		internal static extern float ImFloorSignedFloatNative(float f);

		public static float ImFloorSignedFloat(float f)
		{
			float ret = ImFloorSignedFloatNative(f);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFloor_Vec2")]
		internal static extern void ImFloorVec2Native(Vector2* output, Vector2 v);

		public static Vector2 ImFloorVec2(Vector2 v)
		{
			Vector2 ret;
			ImFloorVec2Native(&ret, v);
			return ret;
		}

		public static void ImFloorVec2(ref Vector2 output, Vector2 v)
		{
			fixed (Vector2* poutput = &output)
			{
				ImFloorVec2Native((Vector2*)poutput, v);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFloorSigned_Vec2")]
		internal static extern void ImFloorSignedVec2Native(Vector2* output, Vector2 v);

		public static Vector2 ImFloorSignedVec2(Vector2 v)
		{
			Vector2 ret;
			ImFloorSignedVec2Native(&ret, v);
			return ret;
		}

		public static void ImFloorSignedVec2(ref Vector2 output, Vector2 v)
		{
			fixed (Vector2* poutput = &output)
			{
				ImFloorSignedVec2Native((Vector2*)poutput, v);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImModPositive")]
		internal static extern int ImModPositiveNative(int a, int b);

		public static int ImModPositive(int a, int b)
		{
			int ret = ImModPositiveNative(a, b);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImDot")]
		internal static extern float ImDotNative(Vector2 a, Vector2 b);

		public static float ImDot(Vector2 a, Vector2 b)
		{
			float ret = ImDotNative(a, b);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImRotate")]
		internal static extern void ImRotateNative(Vector2* output, Vector2 v, float cosA, float sinA);

		public static Vector2 ImRotate(Vector2 v, float cosA, float sinA)
		{
			Vector2 ret;
			ImRotateNative(&ret, v, cosA, sinA);
			return ret;
		}

		public static void ImRotate(ref Vector2 output, Vector2 v, float cosA, float sinA)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRotateNative((Vector2*)poutput, v, cosA, sinA);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLinearSweep")]
		internal static extern float ImLinearSweepNative(float current, float target, float speed);

		public static float ImLinearSweep(float current, float target, float speed)
		{
			float ret = ImLinearSweepNative(current, target, speed);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImMul")]
		internal static extern void ImMulNative(Vector2* output, Vector2 lhs, Vector2 rhs);

		public static Vector2 ImMul(Vector2 lhs, Vector2 rhs)
		{
			Vector2 ret;
			ImMulNative(&ret, lhs, rhs);
			return ret;
		}

		public static void ImMul(ref Vector2 output, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* poutput = &output)
			{
				ImMulNative((Vector2*)poutput, lhs, rhs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImIsFloatAboveGuaranteedIntegerPrecision")]
		internal static extern byte ImIsFloatAboveGuaranteedIntegerPrecisionNative(float f);

		public static bool ImIsFloatAboveGuaranteedIntegerPrecision(float f)
		{
			byte ret = ImIsFloatAboveGuaranteedIntegerPrecisionNative(f);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImExponentialMovingAverage")]
		internal static extern float ImExponentialMovingAverageNative(float avg, float sample, int n);

		public static float ImExponentialMovingAverage(float avg, float sample, int n)
		{
			float ret = ImExponentialMovingAverageNative(avg, sample, n);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBezierCubicCalc")]
		internal static extern void ImBezierCubicCalcNative(Vector2* output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);

		public static Vector2 ImBezierCubicCalc(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			Vector2 ret;
			ImBezierCubicCalcNative(&ret, p1, p2, p3, p4, t);
			return ret;
		}

		public static void ImBezierCubicCalc(ref Vector2 output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			fixed (Vector2* poutput = &output)
			{
				ImBezierCubicCalcNative((Vector2*)poutput, p1, p2, p3, p4, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBezierCubicClosestPoint")]
		internal static extern void ImBezierCubicClosestPointNative(Vector2* output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments);

		public static Vector2 ImBezierCubicClosestPoint(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			Vector2 ret;
			ImBezierCubicClosestPointNative(&ret, p1, p2, p3, p4, p, numSegments);
			return ret;
		}

		public static void ImBezierCubicClosestPoint(ref Vector2 output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			fixed (Vector2* poutput = &output)
			{
				ImBezierCubicClosestPointNative((Vector2*)poutput, p1, p2, p3, p4, p, numSegments);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBezierCubicClosestPointCasteljau")]
		internal static extern void ImBezierCubicClosestPointCasteljauNative(Vector2* output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol);

		public static Vector2 ImBezierCubicClosestPointCasteljau(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			Vector2 ret;
			ImBezierCubicClosestPointCasteljauNative(&ret, p1, p2, p3, p4, p, tessTol);
			return ret;
		}

		public static void ImBezierCubicClosestPointCasteljau(ref Vector2 output, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			fixed (Vector2* poutput = &output)
			{
				ImBezierCubicClosestPointCasteljauNative((Vector2*)poutput, p1, p2, p3, p4, p, tessTol);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBezierQuadraticCalc")]
		internal static extern void ImBezierQuadraticCalcNative(Vector2* output, Vector2 p1, Vector2 p2, Vector2 p3, float t);

		public static Vector2 ImBezierQuadraticCalc(Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			Vector2 ret;
			ImBezierQuadraticCalcNative(&ret, p1, p2, p3, t);
			return ret;
		}

		public static void ImBezierQuadraticCalc(ref Vector2 output, Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			fixed (Vector2* poutput = &output)
			{
				ImBezierQuadraticCalcNative((Vector2*)poutput, p1, p2, p3, t);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImLineClosestPoint")]
		internal static extern void ImLineClosestPointNative(Vector2* output, Vector2 a, Vector2 b, Vector2 p);

		public static Vector2 ImLineClosestPoint(Vector2 a, Vector2 b, Vector2 p)
		{
			Vector2 ret;
			ImLineClosestPointNative(&ret, a, b, p);
			return ret;
		}

		public static void ImLineClosestPoint(ref Vector2 output, Vector2 a, Vector2 b, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				ImLineClosestPointNative((Vector2*)poutput, a, b, p);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTriangleContainsPoint")]
		internal static extern byte ImTriangleContainsPointNative(Vector2 a, Vector2 b, Vector2 c, Vector2 p);

		public static bool ImTriangleContainsPoint(Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			byte ret = ImTriangleContainsPointNative(a, b, c, p);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTriangleClosestPoint")]
		internal static extern void ImTriangleClosestPointNative(Vector2* output, Vector2 a, Vector2 b, Vector2 c, Vector2 p);

		public static Vector2 ImTriangleClosestPoint(Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			Vector2 ret;
			ImTriangleClosestPointNative(&ret, a, b, c, p);
			return ret;
		}

		public static void ImTriangleClosestPoint(ref Vector2 output, Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				ImTriangleClosestPointNative((Vector2*)poutput, a, b, c, p);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTriangleBarycentricCoords")]
		internal static extern void ImTriangleBarycentricCoordsNative(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, float* outW);

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, float* outW)
		{
			ImTriangleBarycentricCoordsNative(a, b, c, p, outU, outV, outW);
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, float* outV, float* outW)
		{
			fixed (float* poutU = &outU)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, outV, outW);
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, ref float outV, float* outW)
		{
			fixed (float* poutV = &outV)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, outU, (float*)poutV, outW);
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, ref float outV, float* outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, (float*)poutV, outW);
				}
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, ref float outW)
		{
			fixed (float* poutW = &outW)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, outU, outV, (float*)poutW);
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, float* outV, ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutW = &outW)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, outV, (float*)poutW);
				}
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, ref float outV, ref float outW)
		{
			fixed (float* poutV = &outV)
			{
				fixed (float* poutW = &outW)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, outU, (float*)poutV, (float*)poutW);
				}
			}
		}

		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, ref float outV, ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					fixed (float* poutW = &outW)
					{
						ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, (float*)poutV, (float*)poutW);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImTriangleArea")]
		internal static extern float ImTriangleAreaNative(Vector2 a, Vector2 b, Vector2 c);

		public static float ImTriangleArea(Vector2 a, Vector2 b, Vector2 c)
		{
			float ret = ImTriangleAreaNative(a, b, c);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImGetDirQuadrantFromDelta")]
		internal static extern ImGuiDir ImGetDirQuadrantFromDeltaNative(float dx, float dy);

		public static ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)
		{
			ImGuiDir ret = ImGetDirQuadrantFromDeltaNative(dx, dy);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec1_ImVec1_Nil")]
		internal static extern ImVec1* ImVec1ImVec1NilNative();

		public static ImVec1Ptr ImVec1ImVec1Nil()
		{
			ImVec1Ptr ret = ImVec1ImVec1NilNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec1_destroy")]
		internal static extern void ImVec1DestroyNative(ImVec1* self);

		public static void ImVec1Destroy(ImVec1* self)
		{
			ImVec1DestroyNative(self);
		}

		public static void ImVec1Destroy(ref ImVec1 self)
		{
			fixed (ImVec1* pself = &self)
			{
				ImVec1DestroyNative((ImVec1*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec1_ImVec1_Float")]
		internal static extern ImVec1* ImVec1ImVec1FloatNative(float x);

		public static ImVec1Ptr ImVec1ImVec1Float(float x)
		{
			ImVec1Ptr ret = ImVec1ImVec1FloatNative(x);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2ih_ImVec2ih_Nil")]
		internal static extern ImVec2ih* ImVec2ihImVec2ihNilNative();

		public static ImVec2ihPtr ImVec2ihImVec2ihNil()
		{
			ImVec2ihPtr ret = ImVec2ihImVec2ihNilNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2ih_destroy")]
		internal static extern void ImVec2ihDestroyNative(ImVec2ih* self);

		public static void ImVec2ihDestroy(ImVec2ih* self)
		{
			ImVec2ihDestroyNative(self);
		}

		public static void ImVec2ihDestroy(ref ImVec2ih self)
		{
			fixed (ImVec2ih* pself = &self)
			{
				ImVec2ihDestroyNative((ImVec2ih*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2ih_ImVec2ih_short")]
		internal static extern ImVec2ih* ImVec2ihImVec2ihShortNative(short x, short y);

		public static ImVec2ihPtr ImVec2ihImVec2ihShort(short x, short y)
		{
			ImVec2ihPtr ret = ImVec2ihImVec2ihShortNative(x, y);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVec2ih_ImVec2ih_Vec2")]
		internal static extern ImVec2ih* ImVec2ihImVec2ihVec2Native(Vector2 rhs);

		public static ImVec2ihPtr ImVec2ihImVec2ihVec2(Vector2 rhs)
		{
			ImVec2ihPtr ret = ImVec2ihImVec2ihVec2Native(rhs);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ImRect_Nil")]
		internal static extern ImRect* ImRectImRectNilNative();

		public static ImRectPtr ImRectImRectNil()
		{
			ImRectPtr ret = ImRectImRectNilNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_destroy")]
		internal static extern void ImRectDestroyNative(ImRect* self);

		public static void ImRectDestroy(ImRect* self)
		{
			ImRectDestroyNative(self);
		}

		public static void ImRectDestroy(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectDestroyNative((ImRect*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ImRect_Vec2")]
		internal static extern ImRect* ImRectImRectVec2Native(Vector2 min, Vector2 max);

		public static ImRectPtr ImRectImRectVec2(Vector2 min, Vector2 max)
		{
			ImRectPtr ret = ImRectImRectVec2Native(min, max);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ImRect_Vec4")]
		internal static extern ImRect* ImRectImRectVec4Native(Vector4 v);

		public static ImRectPtr ImRectImRectVec4(Vector4 v)
		{
			ImRectPtr ret = ImRectImRectVec4Native(v);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ImRect_Float")]
		internal static extern ImRect* ImRectImRectFloatNative(float x1, float y1, float x2, float y2);

		public static ImRectPtr ImRectImRectFloat(float x1, float y1, float x2, float y2)
		{
			ImRectPtr ret = ImRectImRectFloatNative(x1, y1, x2, y2);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetCenter")]
		internal static extern void ImRectGetCenterNative(Vector2* output, ImRect* self);

		public static Vector2 ImRectGetCenter(ImRect* self)
		{
			Vector2 ret;
			ImRectGetCenterNative(&ret, self);
			return ret;
		}

		public static void ImRectGetCenter(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetCenterNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 ImRectGetCenter(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImRectGetCenterNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		public static void ImRectGetCenter(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetCenterNative((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetSize")]
		internal static extern void ImRectGetSizeNative(Vector2* output, ImRect* self);

		public static Vector2 ImRectGetSize(ImRect* self)
		{
			Vector2 ret;
			ImRectGetSizeNative(&ret, self);
			return ret;
		}

		public static void ImRectGetSize(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetSizeNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 ImRectGetSize(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImRectGetSizeNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		public static void ImRectGetSize(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetSizeNative((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetWidth")]
		internal static extern float ImRectGetWidthNative(ImRect* self);

		public static float ImRectGetWidth(ImRect* self)
		{
			float ret = ImRectGetWidthNative(self);
			return ret;
		}

		public static float ImRectGetWidth(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImRectGetWidthNative((ImRect*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetHeight")]
		internal static extern float ImRectGetHeightNative(ImRect* self);

		public static float ImRectGetHeight(ImRect* self)
		{
			float ret = ImRectGetHeightNative(self);
			return ret;
		}

		public static float ImRectGetHeight(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImRectGetHeightNative((ImRect*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetArea")]
		internal static extern float ImRectGetAreaNative(ImRect* self);

		public static float ImRectGetArea(ImRect* self)
		{
			float ret = ImRectGetAreaNative(self);
			return ret;
		}

		public static float ImRectGetArea(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImRectGetAreaNative((ImRect*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetTL")]
		internal static extern void ImRectGetTLNative(Vector2* output, ImRect* self);

		public static Vector2 ImRectGetTL(ImRect* self)
		{
			Vector2 ret;
			ImRectGetTLNative(&ret, self);
			return ret;
		}

		public static void ImRectGetTL(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetTLNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 ImRectGetTL(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImRectGetTLNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		public static void ImRectGetTL(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetTLNative((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetTR")]
		internal static extern void ImRectGetTRNative(Vector2* output, ImRect* self);

		public static Vector2 ImRectGetTR(ImRect* self)
		{
			Vector2 ret;
			ImRectGetTRNative(&ret, self);
			return ret;
		}

		public static void ImRectGetTR(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetTRNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 ImRectGetTR(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImRectGetTRNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		public static void ImRectGetTR(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetTRNative((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetBL")]
		internal static extern void ImRectGetBLNative(Vector2* output, ImRect* self);

		public static Vector2 ImRectGetBL(ImRect* self)
		{
			Vector2 ret;
			ImRectGetBLNative(&ret, self);
			return ret;
		}

		public static void ImRectGetBL(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetBLNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 ImRectGetBL(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImRectGetBLNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		public static void ImRectGetBL(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetBLNative((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_GetBR")]
		internal static extern void ImRectGetBRNative(Vector2* output, ImRect* self);

		public static Vector2 ImRectGetBR(ImRect* self)
		{
			Vector2 ret;
			ImRectGetBRNative(&ret, self);
			return ret;
		}

		public static void ImRectGetBR(ref Vector2 output, ImRect* self)
		{
			fixed (Vector2* poutput = &output)
			{
				ImRectGetBRNative((Vector2*)poutput, self);
			}
		}

		public static Vector2 ImRectGetBR(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImRectGetBRNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		public static void ImRectGetBR(ref Vector2 output, ref ImRect self)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectGetBRNative((Vector2*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Contains_Vec2")]
		internal static extern byte ImRectContainsVec2Native(ImRect* self, Vector2 p);

		public static bool ImRectContainsVec2(ImRect* self, Vector2 p)
		{
			byte ret = ImRectContainsVec2Native(self, p);
			return ret != 0;
		}

		public static bool ImRectContainsVec2(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ImRectContainsVec2Native((ImRect*)pself, p);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Contains_Rect")]
		internal static extern byte ImRectContainsRectNative(ImRect* self, ImRect r);

		public static bool ImRectContainsRect(ImRect* self, ImRect r)
		{
			byte ret = ImRectContainsRectNative(self, r);
			return ret != 0;
		}

		public static bool ImRectContainsRect(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ImRectContainsRectNative((ImRect*)pself, r);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Overlaps")]
		internal static extern byte ImRectOverlapsNative(ImRect* self, ImRect r);

		public static bool ImRectOverlaps(ImRect* self, ImRect r)
		{
			byte ret = ImRectOverlapsNative(self, r);
			return ret != 0;
		}

		public static bool ImRectOverlaps(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ImRectOverlapsNative((ImRect*)pself, r);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Add_Vec2")]
		internal static extern void ImRectAddVec2Native(ImRect* self, Vector2 p);

		public static void ImRectAddVec2(ImRect* self, Vector2 p)
		{
			ImRectAddVec2Native(self, p);
		}

		public static void ImRectAddVec2(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectAddVec2Native((ImRect*)pself, p);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Add_Rect")]
		internal static extern void ImRectAddRectNative(ImRect* self, ImRect r);

		public static void ImRectAddRect(ImRect* self, ImRect r)
		{
			ImRectAddRectNative(self, r);
		}

		public static void ImRectAddRect(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectAddRectNative((ImRect*)pself, r);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Expand_Float")]
		internal static extern void ImRectExpandFloatNative(ImRect* self, float amount);

		public static void ImRectExpandFloat(ImRect* self, float amount)
		{
			ImRectExpandFloatNative(self, amount);
		}

		public static void ImRectExpandFloat(ref ImRect self, float amount)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectExpandFloatNative((ImRect*)pself, amount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Expand_Vec2")]
		internal static extern void ImRectExpandVec2Native(ImRect* self, Vector2 amount);

		public static void ImRectExpandVec2(ImRect* self, Vector2 amount)
		{
			ImRectExpandVec2Native(self, amount);
		}

		public static void ImRectExpandVec2(ref ImRect self, Vector2 amount)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectExpandVec2Native((ImRect*)pself, amount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Translate")]
		internal static extern void ImRectTranslateNative(ImRect* self, Vector2 d);

		public static void ImRectTranslate(ImRect* self, Vector2 d)
		{
			ImRectTranslateNative(self, d);
		}

		public static void ImRectTranslate(ref ImRect self, Vector2 d)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectTranslateNative((ImRect*)pself, d);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_TranslateX")]
		internal static extern void ImRectTranslateXNative(ImRect* self, float dx);

		public static void ImRectTranslateX(ImRect* self, float dx)
		{
			ImRectTranslateXNative(self, dx);
		}

		public static void ImRectTranslateX(ref ImRect self, float dx)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectTranslateXNative((ImRect*)pself, dx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_TranslateY")]
		internal static extern void ImRectTranslateYNative(ImRect* self, float dy);

		public static void ImRectTranslateY(ImRect* self, float dy)
		{
			ImRectTranslateYNative(self, dy);
		}

		public static void ImRectTranslateY(ref ImRect self, float dy)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectTranslateYNative((ImRect*)pself, dy);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ClipWith")]
		internal static extern void ImRectClipWithNative(ImRect* self, ImRect r);

		public static void ImRectClipWith(ImRect* self, ImRect r)
		{
			ImRectClipWithNative(self, r);
		}

		public static void ImRectClipWith(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectClipWithNative((ImRect*)pself, r);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ClipWithFull")]
		internal static extern void ImRectClipWithFullNative(ImRect* self, ImRect r);

		public static void ImRectClipWithFull(ImRect* self, ImRect r)
		{
			ImRectClipWithFullNative(self, r);
		}

		public static void ImRectClipWithFull(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectClipWithFullNative((ImRect*)pself, r);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_Floor")]
		internal static extern void ImRectFloorNative(ImRect* self);

		public static void ImRectFloor(ImRect* self)
		{
			ImRectFloorNative(self);
		}

		public static void ImRectFloor(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectFloorNative((ImRect*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_IsInverted")]
		internal static extern byte ImRectIsInvertedNative(ImRect* self);

		public static bool ImRectIsInverted(ImRect* self)
		{
			byte ret = ImRectIsInvertedNative(self);
			return ret != 0;
		}

		public static bool ImRectIsInverted(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ImRectIsInvertedNative((ImRect*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImRect_ToVec4")]
		internal static extern void ImRectToVec4Native(Vector4* output, ImRect* self);

		public static Vector4 ImRectToVec4(ImRect* self)
		{
			Vector4 ret;
			ImRectToVec4Native(&ret, self);
			return ret;
		}

		public static void ImRectToVec4(ref Vector4 output, ImRect* self)
		{
			fixed (Vector4* poutput = &output)
			{
				ImRectToVec4Native((Vector4*)poutput, self);
			}
		}

		public static Vector4 ImRectToVec4(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector4 ret;
				ImRectToVec4Native(&ret, (ImRect*)pself);
				return ret;
			}
		}

		public static void ImRectToVec4(ref Vector4 output, ref ImRect self)
		{
			fixed (Vector4* poutput = &output)
			{
				fixed (ImRect* pself = &self)
				{
					ImRectToVec4Native((Vector4*)poutput, (ImRect*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArrayGetStorageSizeInBytes")]
		internal static extern nuint ImBitArrayGetStorageSizeInBytesNative(int bitcount);

		public static nuint ImBitArrayGetStorageSizeInBytes(int bitcount)
		{
			nuint ret = ImBitArrayGetStorageSizeInBytesNative(bitcount);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArrayClearAllBits")]
		internal static extern void ImBitArrayClearAllBitsNative(uint* arr, int bitcount);

		public static void ImBitArrayClearAllBits(uint* arr, int bitcount)
		{
			ImBitArrayClearAllBitsNative(arr, bitcount);
		}

		public static void ImBitArrayClearAllBits(ref uint arr, int bitcount)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArrayClearAllBitsNative((uint*)parr, bitcount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArrayTestBit")]
		internal static extern byte ImBitArrayTestBitNative(uint* arr, int n);

		public static bool ImBitArrayTestBit(uint* arr, int n)
		{
			byte ret = ImBitArrayTestBitNative(arr, n);
			return ret != 0;
		}

		public static bool ImBitArrayTestBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				byte ret = ImBitArrayTestBitNative((uint*)parr, n);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArrayClearBit")]
		internal static extern void ImBitArrayClearBitNative(uint* arr, int n);

		public static void ImBitArrayClearBit(uint* arr, int n)
		{
			ImBitArrayClearBitNative(arr, n);
		}

		public static void ImBitArrayClearBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArrayClearBitNative((uint*)parr, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArraySetBit")]
		internal static extern void ImBitArraySetBitNative(uint* arr, int n);

		public static void ImBitArraySetBit(uint* arr, int n)
		{
			ImBitArraySetBitNative(arr, n);
		}

		public static void ImBitArraySetBit(ref uint arr, int n)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArraySetBitNative((uint*)parr, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImBitArraySetBitRange")]
		internal static extern void ImBitArraySetBitRangeNative(uint* arr, int n, int n2);

		public static void ImBitArraySetBitRange(uint* arr, int n, int n2)
		{
			ImBitArraySetBitRangeNative(arr, n, n2);
		}

		public static void ImBitArraySetBitRange(ref uint arr, int n, int n2)
		{
			fixed (uint* parr = &arr)
			{
				ImBitArraySetBitRangeNative((uint*)parr, n, n2);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_Create")]
		internal static extern void ImBitVectorCreateNative(ImBitVector* self, int sz);

		public static void ImBitVectorCreate(ImBitVector* self, int sz)
		{
			ImBitVectorCreateNative(self, sz);
		}

		public static void ImBitVectorCreate(ref ImBitVector self, int sz)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImBitVectorCreateNative((ImBitVector*)pself, sz);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_Clear")]
		internal static extern void ImBitVectorClearNative(ImBitVector* self);

		public static void ImBitVectorClear(ImBitVector* self)
		{
			ImBitVectorClearNative(self);
		}

		public static void ImBitVectorClear(ref ImBitVector self)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImBitVectorClearNative((ImBitVector*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_TestBit")]
		internal static extern byte ImBitVectorTestBitNative(ImBitVector* self, int n);

		public static bool ImBitVectorTestBit(ImBitVector* self, int n)
		{
			byte ret = ImBitVectorTestBitNative(self, n);
			return ret != 0;
		}

		public static bool ImBitVectorTestBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				byte ret = ImBitVectorTestBitNative((ImBitVector*)pself, n);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_SetBit")]
		internal static extern void ImBitVectorSetBitNative(ImBitVector* self, int n);

		public static void ImBitVectorSetBit(ImBitVector* self, int n)
		{
			ImBitVectorSetBitNative(self, n);
		}

		public static void ImBitVectorSetBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImBitVectorSetBitNative((ImBitVector*)pself, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImBitVector_ClearBit")]
		internal static extern void ImBitVectorClearBitNative(ImBitVector* self, int n);

		public static void ImBitVectorClearBit(ImBitVector* self, int n)
		{
			ImBitVectorClearBitNative(self, n);
		}

		public static void ImBitVectorClearBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImBitVectorClearBitNative((ImBitVector*)pself, n);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_clear")]
		internal static extern void ImGuiTextIndexClearNative(ImGuiTextIndex* self);

		public static void ImGuiTextIndexClear(ImGuiTextIndex* self)
		{
			ImGuiTextIndexClearNative(self);
		}

		public static void ImGuiTextIndexClear(ref ImGuiTextIndex self)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				ImGuiTextIndexClearNative((ImGuiTextIndex*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_size")]
		internal static extern int ImGuiTextIndexSizeNative(ImGuiTextIndex* self);

		public static int ImGuiTextIndexSize(ImGuiTextIndex* self)
		{
			int ret = ImGuiTextIndexSizeNative(self);
			return ret;
		}

		public static int ImGuiTextIndexSize(ref ImGuiTextIndex self)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				int ret = ImGuiTextIndexSizeNative((ImGuiTextIndex*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_get_line_begin")]
		internal static extern byte* ImGuiTextIndexGetLineBeginNative(ImGuiTextIndex* self, byte* baseValue, int n);

		public static byte* ImGuiTextIndexGetLineBegin(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			byte* ret = ImGuiTextIndexGetLineBeginNative(self, baseValue, n);
			return ret;
		}

		public static string ImGuiTextIndexGetLineBeginS(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative(self, baseValue, n));
			return ret;
		}

		public static byte* ImGuiTextIndexGetLineBegin(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* ret = ImGuiTextIndexGetLineBeginNative((ImGuiTextIndex*)pself, baseValue, n);
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineBeginS(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative((ImGuiTextIndex*)pself, baseValue, n));
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineBegin(ImGuiTextIndex* self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = ImGuiTextIndexGetLineBeginNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineBeginS(ImGuiTextIndex* self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineBegin(ImGuiTextIndex* self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiTextIndexGetLineBeginNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImGuiTextIndexGetLineBeginS(ImGuiTextIndex* self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImGuiTextIndexGetLineBegin(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = ImGuiTextIndexGetLineBeginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		public static string ImGuiTextIndexGetLineBeginS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		public static byte* ImGuiTextIndexGetLineBegin(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiTextIndexGetLineBeginNative((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineBeginS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_get_line_end")]
		internal static extern byte* ImGuiTextIndexGetLineEndNative(ImGuiTextIndex* self, byte* baseValue, int n);

		public static byte* ImGuiTextIndexGetLineEnd(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			byte* ret = ImGuiTextIndexGetLineEndNative(self, baseValue, n);
			return ret;
		}

		public static string ImGuiTextIndexGetLineEndS(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative(self, baseValue, n));
			return ret;
		}

		public static byte* ImGuiTextIndexGetLineEnd(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* ret = ImGuiTextIndexGetLineEndNative((ImGuiTextIndex*)pself, baseValue, n);
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineEndS(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative((ImGuiTextIndex*)pself, baseValue, n));
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineEnd(ImGuiTextIndex* self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = ImGuiTextIndexGetLineEndNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineEndS(ImGuiTextIndex* self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		public static byte* ImGuiTextIndexGetLineEnd(ImGuiTextIndex* self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiTextIndexGetLineEndNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string ImGuiTextIndexGetLineEndS(ImGuiTextIndex* self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* ImGuiTextIndexGetLineEnd(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = ImGuiTextIndexGetLineEndNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		public static string ImGuiTextIndexGetLineEndS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		public static byte* ImGuiTextIndexGetLineEnd(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiTextIndexGetLineEndNative((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static string ImGuiTextIndexGetLineEndS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextIndex_append")]
		internal static extern void ImGuiTextIndexAppendNative(ImGuiTextIndex* self, byte* baseValue, int oldSize, int newSize);

		public static void ImGuiTextIndexAppend(ImGuiTextIndex* self, byte* baseValue, int oldSize, int newSize)
		{
			ImGuiTextIndexAppendNative(self, baseValue, oldSize, newSize);
		}

		public static void ImGuiTextIndexAppend(ref ImGuiTextIndex self, byte* baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				ImGuiTextIndexAppendNative((ImGuiTextIndex*)pself, baseValue, oldSize, newSize);
			}
		}

		public static void ImGuiTextIndexAppend(ImGuiTextIndex* self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				ImGuiTextIndexAppendNative(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		public static void ImGuiTextIndexAppend(ImGuiTextIndex* self, string baseValue, int oldSize, int newSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextIndexAppendNative(self, pStr0, oldSize, newSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImGuiTextIndexAppend(ref ImGuiTextIndex self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					ImGuiTextIndexAppendNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		public static void ImGuiTextIndexAppend(ref ImGuiTextIndex self, string baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiTextIndexAppendNative((ImGuiTextIndex*)pself, pStr0, oldSize, newSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSharedData_ImDrawListSharedData")]
		internal static extern ImDrawListSharedData* ImDrawListSharedDataImDrawListSharedDataNative();

		public static ImDrawListSharedDataPtr ImDrawListSharedDataImDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = ImDrawListSharedDataImDrawListSharedDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSharedData_destroy")]
		internal static extern void ImDrawListSharedDataDestroyNative(ImDrawListSharedData* self);

		public static void ImDrawListSharedDataDestroy(ImDrawListSharedData* self)
		{
			ImDrawListSharedDataDestroyNative(self);
		}

		public static void ImDrawListSharedDataDestroy(ref ImDrawListSharedData self)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				ImDrawListSharedDataDestroyNative((ImDrawListSharedData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawListSharedData_SetCircleTessellationMaxError")]
		internal static extern void ImDrawListSharedDataSetCircleTessellationMaxErrorNative(ImDrawListSharedData* self, float maxError);

		public static void ImDrawListSharedDataSetCircleTessellationMaxError(ImDrawListSharedData* self, float maxError)
		{
			ImDrawListSharedDataSetCircleTessellationMaxErrorNative(self, maxError);
		}

		public static void ImDrawListSharedDataSetCircleTessellationMaxError(ref ImDrawListSharedData self, float maxError)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				ImDrawListSharedDataSetCircleTessellationMaxErrorNative((ImDrawListSharedData*)pself, maxError);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawDataBuilder_Clear")]
		internal static extern void ImDrawDataBuilderClearNative(ImDrawDataBuilder* self);

		public static void ImDrawDataBuilderClear(ImDrawDataBuilder* self)
		{
			ImDrawDataBuilderClearNative(self);
		}

		public static void ImDrawDataBuilderClear(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImDrawDataBuilderClearNative((ImDrawDataBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawDataBuilder_ClearFreeMemory")]
		internal static extern void ImDrawDataBuilderClearFreeMemoryNative(ImDrawDataBuilder* self);

		public static void ImDrawDataBuilderClearFreeMemory(ImDrawDataBuilder* self)
		{
			ImDrawDataBuilderClearFreeMemoryNative(self);
		}

		public static void ImDrawDataBuilderClearFreeMemory(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImDrawDataBuilderClearFreeMemoryNative((ImDrawDataBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawDataBuilder_GetDrawListCount")]
		internal static extern int ImDrawDataBuilderGetDrawListCountNative(ImDrawDataBuilder* self);

		public static int ImDrawDataBuilderGetDrawListCount(ImDrawDataBuilder* self)
		{
			int ret = ImDrawDataBuilderGetDrawListCountNative(self);
			return ret;
		}

		public static int ImDrawDataBuilderGetDrawListCount(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				int ret = ImDrawDataBuilderGetDrawListCountNative((ImDrawDataBuilder*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImDrawDataBuilder_FlattenIntoSingleLayer")]
		internal static extern void ImDrawDataBuilderFlattenIntoSingleLayerNative(ImDrawDataBuilder* self);

		public static void ImDrawDataBuilderFlattenIntoSingleLayer(ImDrawDataBuilder* self)
		{
			ImDrawDataBuilderFlattenIntoSingleLayerNative(self);
		}

		public static void ImDrawDataBuilderFlattenIntoSingleLayer(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImDrawDataBuilderFlattenIntoSingleLayerNative((ImDrawDataBuilder*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDataVarInfo_GetVarPtr")]
		internal static extern void* ImGuiDataVarInfoGetVarPtrNative(ImGuiDataVarInfo* self, void* parent);

		public static void* ImGuiDataVarInfoGetVarPtr(ImGuiDataVarInfo* self, void* parent)
		{
			void* ret = ImGuiDataVarInfoGetVarPtrNative(self, parent);
			return ret;
		}

		public static void* ImGuiDataVarInfoGetVarPtr(ref ImGuiDataVarInfo self, void* parent)
		{
			fixed (ImGuiDataVarInfo* pself = &self)
			{
				void* ret = ImGuiDataVarInfoGetVarPtrNative((ImGuiDataVarInfo*)pself, parent);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Int")]
		internal static extern ImGuiStyleMod* ImGuiStyleModImGuiStyleModIntNative(ImGuiStyleVar idx, int v);

		public static ImGuiStyleModPtr ImGuiStyleModImGuiStyleModInt(ImGuiStyleVar idx, int v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModImGuiStyleModIntNative(idx, v);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyleMod_destroy")]
		internal static extern void ImGuiStyleModDestroyNative(ImGuiStyleMod* self);

		public static void ImGuiStyleModDestroy(ImGuiStyleMod* self)
		{
			ImGuiStyleModDestroyNative(self);
		}

		public static void ImGuiStyleModDestroy(ref ImGuiStyleMod self)
		{
			fixed (ImGuiStyleMod* pself = &self)
			{
				ImGuiStyleModDestroyNative((ImGuiStyleMod*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Float")]
		internal static extern ImGuiStyleMod* ImGuiStyleModImGuiStyleModFloatNative(ImGuiStyleVar idx, float v);

		public static ImGuiStyleModPtr ImGuiStyleModImGuiStyleModFloat(ImGuiStyleVar idx, float v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModImGuiStyleModFloatNative(idx, v);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Vec2")]
		internal static extern ImGuiStyleMod* ImGuiStyleModImGuiStyleModVec2Native(ImGuiStyleVar idx, Vector2 v);

		public static ImGuiStyleModPtr ImGuiStyleModImGuiStyleModVec2(ImGuiStyleVar idx, Vector2 v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModImGuiStyleModVec2Native(idx, v);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiComboPreviewData_ImGuiComboPreviewData")]
		internal static extern ImGuiComboPreviewData* ImGuiComboPreviewDataImGuiComboPreviewDataNative();

		public static ImGuiComboPreviewDataPtr ImGuiComboPreviewDataImGuiComboPreviewData()
		{
			ImGuiComboPreviewDataPtr ret = ImGuiComboPreviewDataImGuiComboPreviewDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiComboPreviewData_destroy")]
		internal static extern void ImGuiComboPreviewDataDestroyNative(ImGuiComboPreviewData* self);

		public static void ImGuiComboPreviewDataDestroy(ImGuiComboPreviewData* self)
		{
			ImGuiComboPreviewDataDestroyNative(self);
		}

		public static void ImGuiComboPreviewDataDestroy(ref ImGuiComboPreviewData self)
		{
			fixed (ImGuiComboPreviewData* pself = &self)
			{
				ImGuiComboPreviewDataDestroyNative((ImGuiComboPreviewData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_ImGuiMenuColumns")]
		internal static extern ImGuiMenuColumns* ImGuiMenuColumnsImGuiMenuColumnsNative();

		public static ImGuiMenuColumnsPtr ImGuiMenuColumnsImGuiMenuColumns()
		{
			ImGuiMenuColumnsPtr ret = ImGuiMenuColumnsImGuiMenuColumnsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_destroy")]
		internal static extern void ImGuiMenuColumnsDestroyNative(ImGuiMenuColumns* self);

		public static void ImGuiMenuColumnsDestroy(ImGuiMenuColumns* self)
		{
			ImGuiMenuColumnsDestroyNative(self);
		}

		public static void ImGuiMenuColumnsDestroy(ref ImGuiMenuColumns self)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiMenuColumnsDestroyNative((ImGuiMenuColumns*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_Update")]
		internal static extern void ImGuiMenuColumnsUpdateNative(ImGuiMenuColumns* self, float spacing, byte windowReappearing);

		public static void ImGuiMenuColumnsUpdate(ImGuiMenuColumns* self, float spacing, bool windowReappearing)
		{
			ImGuiMenuColumnsUpdateNative(self, spacing, windowReappearing ? (byte)1 : (byte)0);
		}

		public static void ImGuiMenuColumnsUpdate(ref ImGuiMenuColumns self, float spacing, bool windowReappearing)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiMenuColumnsUpdateNative((ImGuiMenuColumns*)pself, spacing, windowReappearing ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_DeclColumns")]
		internal static extern float ImGuiMenuColumnsDeclColumnsNative(ImGuiMenuColumns* self, float wIcon, float wLabel, float wShortcut, float wMark);

		public static float ImGuiMenuColumnsDeclColumns(ImGuiMenuColumns* self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			float ret = ImGuiMenuColumnsDeclColumnsNative(self, wIcon, wLabel, wShortcut, wMark);
			return ret;
		}

		public static float ImGuiMenuColumnsDeclColumns(ref ImGuiMenuColumns self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				float ret = ImGuiMenuColumnsDeclColumnsNative((ImGuiMenuColumns*)pself, wIcon, wLabel, wShortcut, wMark);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiMenuColumns_CalcNextTotalWidth")]
		internal static extern void ImGuiMenuColumnsCalcNextTotalWidthNative(ImGuiMenuColumns* self, byte updateOffsets);

		public static void ImGuiMenuColumnsCalcNextTotalWidth(ImGuiMenuColumns* self, bool updateOffsets)
		{
			ImGuiMenuColumnsCalcNextTotalWidthNative(self, updateOffsets ? (byte)1 : (byte)0);
		}

		public static void ImGuiMenuColumnsCalcNextTotalWidth(ref ImGuiMenuColumns self, bool updateOffsets)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiMenuColumnsCalcNextTotalWidthNative((ImGuiMenuColumns*)pself, updateOffsets ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState")]
		internal static extern ImGuiInputTextDeactivatedState* ImGuiInputTextDeactivatedStateImGuiInputTextDeactivatedStateNative();

		public static ImGuiInputTextDeactivatedStatePtr ImGuiInputTextDeactivatedStateImGuiInputTextDeactivatedState()
		{
			ImGuiInputTextDeactivatedStatePtr ret = ImGuiInputTextDeactivatedStateImGuiInputTextDeactivatedStateNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextDeactivatedState_destroy")]
		internal static extern void ImGuiInputTextDeactivatedStateDestroyNative(ImGuiInputTextDeactivatedState* self);

		public static void ImGuiInputTextDeactivatedStateDestroy(ImGuiInputTextDeactivatedState* self)
		{
			ImGuiInputTextDeactivatedStateDestroyNative(self);
		}

		public static void ImGuiInputTextDeactivatedStateDestroy(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				ImGuiInputTextDeactivatedStateDestroyNative((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextDeactivatedState_ClearFreeMemory")]
		internal static extern void ImGuiInputTextDeactivatedStateClearFreeMemoryNative(ImGuiInputTextDeactivatedState* self);

		public static void ImGuiInputTextDeactivatedStateClearFreeMemory(ImGuiInputTextDeactivatedState* self)
		{
			ImGuiInputTextDeactivatedStateClearFreeMemoryNative(self);
		}

		public static void ImGuiInputTextDeactivatedStateClearFreeMemory(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				ImGuiInputTextDeactivatedStateClearFreeMemoryNative((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_ImGuiInputTextState")]
		internal static extern ImGuiInputTextState* ImGuiInputTextStateImGuiInputTextStateNative();

		public static ImGuiInputTextStatePtr ImGuiInputTextStateImGuiInputTextState()
		{
			ImGuiInputTextStatePtr ret = ImGuiInputTextStateImGuiInputTextStateNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_destroy")]
		internal static extern void ImGuiInputTextStateDestroyNative(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateDestroy(ImGuiInputTextState* self)
		{
			ImGuiInputTextStateDestroyNative(self);
		}

		public static void ImGuiInputTextStateDestroy(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateDestroyNative((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_ClearText")]
		internal static extern void ImGuiInputTextStateClearTextNative(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateClearText(ImGuiInputTextState* self)
		{
			ImGuiInputTextStateClearTextNative(self);
		}

		public static void ImGuiInputTextStateClearText(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateClearTextNative((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_ClearFreeMemory")]
		internal static extern void ImGuiInputTextStateClearFreeMemoryNative(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateClearFreeMemory(ImGuiInputTextState* self)
		{
			ImGuiInputTextStateClearFreeMemoryNative(self);
		}

		public static void ImGuiInputTextStateClearFreeMemory(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateClearFreeMemoryNative((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetUndoAvailCount")]
		internal static extern int ImGuiInputTextStateGetUndoAvailCountNative(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetUndoAvailCount(ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetUndoAvailCountNative(self);
			return ret;
		}

		public static int ImGuiInputTextStateGetUndoAvailCount(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetUndoAvailCountNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetRedoAvailCount")]
		internal static extern int ImGuiInputTextStateGetRedoAvailCountNative(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetRedoAvailCount(ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetRedoAvailCountNative(self);
			return ret;
		}

		public static int ImGuiInputTextStateGetRedoAvailCount(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetRedoAvailCountNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_OnKeyPressed")]
		internal static extern void ImGuiInputTextStateOnKeyPressedNative(ImGuiInputTextState* self, int key);

		public static void ImGuiInputTextStateOnKeyPressed(ImGuiInputTextState* self, int key)
		{
			ImGuiInputTextStateOnKeyPressedNative(self, key);
		}

		public static void ImGuiInputTextStateOnKeyPressed(ref ImGuiInputTextState self, int key)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateOnKeyPressedNative((ImGuiInputTextState*)pself, key);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_CursorAnimReset")]
		internal static extern void ImGuiInputTextStateCursorAnimResetNative(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateCursorAnimReset(ImGuiInputTextState* self)
		{
			ImGuiInputTextStateCursorAnimResetNative(self);
		}

		public static void ImGuiInputTextStateCursorAnimReset(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateCursorAnimResetNative((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_CursorClamp")]
		internal static extern void ImGuiInputTextStateCursorClampNative(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateCursorClamp(ImGuiInputTextState* self)
		{
			ImGuiInputTextStateCursorClampNative(self);
		}

		public static void ImGuiInputTextStateCursorClamp(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateCursorClampNative((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_HasSelection")]
		internal static extern byte ImGuiInputTextStateHasSelectionNative(ImGuiInputTextState* self);

		public static bool ImGuiInputTextStateHasSelection(ImGuiInputTextState* self)
		{
			byte ret = ImGuiInputTextStateHasSelectionNative(self);
			return ret != 0;
		}

		public static bool ImGuiInputTextStateHasSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				byte ret = ImGuiInputTextStateHasSelectionNative((ImGuiInputTextState*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_ClearSelection")]
		internal static extern void ImGuiInputTextStateClearSelectionNative(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateClearSelection(ImGuiInputTextState* self)
		{
			ImGuiInputTextStateClearSelectionNative(self);
		}

		public static void ImGuiInputTextStateClearSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateClearSelectionNative((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetCursorPos")]
		internal static extern int ImGuiInputTextStateGetCursorPosNative(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetCursorPos(ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetCursorPosNative(self);
			return ret;
		}

		public static int ImGuiInputTextStateGetCursorPos(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetCursorPosNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetSelectionStart")]
		internal static extern int ImGuiInputTextStateGetSelectionStartNative(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetSelectionStart(ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetSelectionStartNative(self);
			return ret;
		}

		public static int ImGuiInputTextStateGetSelectionStart(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetSelectionStartNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_GetSelectionEnd")]
		internal static extern int ImGuiInputTextStateGetSelectionEndNative(ImGuiInputTextState* self);

		public static int ImGuiInputTextStateGetSelectionEnd(ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetSelectionEndNative(self);
			return ret;
		}

		public static int ImGuiInputTextStateGetSelectionEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiInputTextStateGetSelectionEndNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputTextState_SelectAll")]
		internal static extern void ImGuiInputTextStateSelectAllNative(ImGuiInputTextState* self);

		public static void ImGuiInputTextStateSelectAll(ImGuiInputTextState* self)
		{
			ImGuiInputTextStateSelectAllNative(self);
		}

		public static void ImGuiInputTextStateSelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiInputTextStateSelectAllNative((ImGuiInputTextState*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPopupData_ImGuiPopupData")]
		internal static extern ImGuiPopupData* ImGuiPopupDataImGuiPopupDataNative();

		public static ImGuiPopupDataPtr ImGuiPopupDataImGuiPopupData()
		{
			ImGuiPopupDataPtr ret = ImGuiPopupDataImGuiPopupDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPopupData_destroy")]
		internal static extern void ImGuiPopupDataDestroyNative(ImGuiPopupData* self);

		public static void ImGuiPopupDataDestroy(ImGuiPopupData* self)
		{
			ImGuiPopupDataDestroyNative(self);
		}

		public static void ImGuiPopupDataDestroy(ref ImGuiPopupData self)
		{
			fixed (ImGuiPopupData* pself = &self)
			{
				ImGuiPopupDataDestroyNative((ImGuiPopupData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextWindowData_ImGuiNextWindowData")]
		internal static extern ImGuiNextWindowData* ImGuiNextWindowDataImGuiNextWindowDataNative();

		public static ImGuiNextWindowDataPtr ImGuiNextWindowDataImGuiNextWindowData()
		{
			ImGuiNextWindowDataPtr ret = ImGuiNextWindowDataImGuiNextWindowDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextWindowData_destroy")]
		internal static extern void ImGuiNextWindowDataDestroyNative(ImGuiNextWindowData* self);

		public static void ImGuiNextWindowDataDestroy(ImGuiNextWindowData* self)
		{
			ImGuiNextWindowDataDestroyNative(self);
		}

		public static void ImGuiNextWindowDataDestroy(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ImGuiNextWindowDataDestroyNative((ImGuiNextWindowData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextWindowData_ClearFlags")]
		internal static extern void ImGuiNextWindowDataClearFlagsNative(ImGuiNextWindowData* self);

		public static void ImGuiNextWindowDataClearFlags(ImGuiNextWindowData* self)
		{
			ImGuiNextWindowDataClearFlagsNative(self);
		}

		public static void ImGuiNextWindowDataClearFlags(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ImGuiNextWindowDataClearFlagsNative((ImGuiNextWindowData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextItemData_ImGuiNextItemData")]
		internal static extern ImGuiNextItemData* ImGuiNextItemDataImGuiNextItemDataNative();

		public static ImGuiNextItemDataPtr ImGuiNextItemDataImGuiNextItemData()
		{
			ImGuiNextItemDataPtr ret = ImGuiNextItemDataImGuiNextItemDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextItemData_destroy")]
		internal static extern void ImGuiNextItemDataDestroyNative(ImGuiNextItemData* self);

		public static void ImGuiNextItemDataDestroy(ImGuiNextItemData* self)
		{
			ImGuiNextItemDataDestroyNative(self);
		}

		public static void ImGuiNextItemDataDestroy(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ImGuiNextItemDataDestroyNative((ImGuiNextItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNextItemData_ClearFlags")]
		internal static extern void ImGuiNextItemDataClearFlagsNative(ImGuiNextItemData* self);

		public static void ImGuiNextItemDataClearFlags(ImGuiNextItemData* self)
		{
			ImGuiNextItemDataClearFlagsNative(self);
		}

		public static void ImGuiNextItemDataClearFlags(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ImGuiNextItemDataClearFlagsNative((ImGuiNextItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiLastItemData_ImGuiLastItemData")]
		internal static extern ImGuiLastItemData* ImGuiLastItemDataImGuiLastItemDataNative();

		public static ImGuiLastItemDataPtr ImGuiLastItemDataImGuiLastItemData()
		{
			ImGuiLastItemDataPtr ret = ImGuiLastItemDataImGuiLastItemDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiLastItemData_destroy")]
		internal static extern void ImGuiLastItemDataDestroyNative(ImGuiLastItemData* self);

		public static void ImGuiLastItemDataDestroy(ImGuiLastItemData* self)
		{
			ImGuiLastItemDataDestroyNative(self);
		}

		public static void ImGuiLastItemDataDestroy(ref ImGuiLastItemData self)
		{
			fixed (ImGuiLastItemData* pself = &self)
			{
				ImGuiLastItemDataDestroyNative((ImGuiLastItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackSizes_ImGuiStackSizes")]
		internal static extern ImGuiStackSizes* ImGuiStackSizesImGuiStackSizesNative();

		public static ImGuiStackSizesPtr ImGuiStackSizesImGuiStackSizes()
		{
			ImGuiStackSizesPtr ret = ImGuiStackSizesImGuiStackSizesNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackSizes_destroy")]
		internal static extern void ImGuiStackSizesDestroyNative(ImGuiStackSizes* self);

		public static void ImGuiStackSizesDestroy(ImGuiStackSizes* self)
		{
			ImGuiStackSizesDestroyNative(self);
		}

		public static void ImGuiStackSizesDestroy(ref ImGuiStackSizes self)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiStackSizesDestroyNative((ImGuiStackSizes*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackSizes_SetToContextState")]
		internal static extern void ImGuiStackSizesSetToContextStateNative(ImGuiStackSizes* self, ImGuiContext* ctx);

		public static void ImGuiStackSizesSetToContextState(ImGuiStackSizes* self, ImGuiContext* ctx)
		{
			ImGuiStackSizesSetToContextStateNative(self, ctx);
		}

		public static void ImGuiStackSizesSetToContextState(ref ImGuiStackSizes self, ImGuiContext* ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiStackSizesSetToContextStateNative((ImGuiStackSizes*)pself, ctx);
			}
		}

		public static void ImGuiStackSizesSetToContextState(ImGuiStackSizes* self, ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiStackSizesSetToContextStateNative(self, (ImGuiContext*)pctx);
			}
		}

		public static void ImGuiStackSizesSetToContextState(ref ImGuiStackSizes self, ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					ImGuiStackSizesSetToContextStateNative((ImGuiStackSizes*)pself, (ImGuiContext*)pctx);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackSizes_CompareWithContextState")]
		internal static extern void ImGuiStackSizesCompareWithContextStateNative(ImGuiStackSizes* self, ImGuiContext* ctx);

		public static void ImGuiStackSizesCompareWithContextState(ImGuiStackSizes* self, ImGuiContext* ctx)
		{
			ImGuiStackSizesCompareWithContextStateNative(self, ctx);
		}

		public static void ImGuiStackSizesCompareWithContextState(ref ImGuiStackSizes self, ImGuiContext* ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiStackSizesCompareWithContextStateNative((ImGuiStackSizes*)pself, ctx);
			}
		}

		public static void ImGuiStackSizesCompareWithContextState(ImGuiStackSizes* self, ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiStackSizesCompareWithContextStateNative(self, (ImGuiContext*)pctx);
			}
		}

		public static void ImGuiStackSizesCompareWithContextState(ref ImGuiStackSizes self, ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					ImGuiStackSizesCompareWithContextStateNative((ImGuiStackSizes*)pself, (ImGuiContext*)pctx);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr")]
		internal static extern ImGuiPtrOrIndex* ImGuiPtrOrIndexImGuiPtrOrIndexPtrNative(void* ptr);

		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndexImGuiPtrOrIndexPtr(void* ptr)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPtrOrIndexImGuiPtrOrIndexPtrNative(ptr);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPtrOrIndex_destroy")]
		internal static extern void ImGuiPtrOrIndexDestroyNative(ImGuiPtrOrIndex* self);

		public static void ImGuiPtrOrIndexDestroy(ImGuiPtrOrIndex* self)
		{
			ImGuiPtrOrIndexDestroyNative(self);
		}

		public static void ImGuiPtrOrIndexDestroy(ref ImGuiPtrOrIndex self)
		{
			fixed (ImGuiPtrOrIndex* pself = &self)
			{
				ImGuiPtrOrIndexDestroyNative((ImGuiPtrOrIndex*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int")]
		internal static extern ImGuiPtrOrIndex* ImGuiPtrOrIndexImGuiPtrOrIndexIntNative(int index);

		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndexImGuiPtrOrIndexInt(int index)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPtrOrIndexImGuiPtrOrIndexIntNative(index);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputEvent_ImGuiInputEvent")]
		internal static extern ImGuiInputEvent* ImGuiInputEventImGuiInputEventNative();

		public static ImGuiInputEventPtr ImGuiInputEventImGuiInputEvent()
		{
			ImGuiInputEventPtr ret = ImGuiInputEventImGuiInputEventNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiInputEvent_destroy")]
		internal static extern void ImGuiInputEventDestroyNative(ImGuiInputEvent* self);

		public static void ImGuiInputEventDestroy(ImGuiInputEvent* self)
		{
			ImGuiInputEventDestroyNative(self);
		}

		public static void ImGuiInputEventDestroy(ref ImGuiInputEvent self)
		{
			fixed (ImGuiInputEvent* pself = &self)
			{
				ImGuiInputEventDestroyNative((ImGuiInputEvent*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingData_ImGuiKeyRoutingData")]
		internal static extern ImGuiKeyRoutingData* ImGuiKeyRoutingDataImGuiKeyRoutingDataNative();

		public static ImGuiKeyRoutingDataPtr ImGuiKeyRoutingDataImGuiKeyRoutingData()
		{
			ImGuiKeyRoutingDataPtr ret = ImGuiKeyRoutingDataImGuiKeyRoutingDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingData_destroy")]
		internal static extern void ImGuiKeyRoutingDataDestroyNative(ImGuiKeyRoutingData* self);

		public static void ImGuiKeyRoutingDataDestroy(ImGuiKeyRoutingData* self)
		{
			ImGuiKeyRoutingDataDestroyNative(self);
		}

		public static void ImGuiKeyRoutingDataDestroy(ref ImGuiKeyRoutingData self)
		{
			fixed (ImGuiKeyRoutingData* pself = &self)
			{
				ImGuiKeyRoutingDataDestroyNative((ImGuiKeyRoutingData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingTable_ImGuiKeyRoutingTable")]
		internal static extern ImGuiKeyRoutingTable* ImGuiKeyRoutingTableImGuiKeyRoutingTableNative();

		public static ImGuiKeyRoutingTablePtr ImGuiKeyRoutingTableImGuiKeyRoutingTable()
		{
			ImGuiKeyRoutingTablePtr ret = ImGuiKeyRoutingTableImGuiKeyRoutingTableNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingTable_destroy")]
		internal static extern void ImGuiKeyRoutingTableDestroyNative(ImGuiKeyRoutingTable* self);

		public static void ImGuiKeyRoutingTableDestroy(ImGuiKeyRoutingTable* self)
		{
			ImGuiKeyRoutingTableDestroyNative(self);
		}

		public static void ImGuiKeyRoutingTableDestroy(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				ImGuiKeyRoutingTableDestroyNative((ImGuiKeyRoutingTable*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyRoutingTable_Clear")]
		internal static extern void ImGuiKeyRoutingTableClearNative(ImGuiKeyRoutingTable* self);

		public static void ImGuiKeyRoutingTableClear(ImGuiKeyRoutingTable* self)
		{
			ImGuiKeyRoutingTableClearNative(self);
		}

		public static void ImGuiKeyRoutingTableClear(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				ImGuiKeyRoutingTableClearNative((ImGuiKeyRoutingTable*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyOwnerData_ImGuiKeyOwnerData")]
		internal static extern ImGuiKeyOwnerData* ImGuiKeyOwnerDataImGuiKeyOwnerDataNative();

		public static ImGuiKeyOwnerDataPtr ImGuiKeyOwnerDataImGuiKeyOwnerData()
		{
			ImGuiKeyOwnerDataPtr ret = ImGuiKeyOwnerDataImGuiKeyOwnerDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiKeyOwnerData_destroy")]
		internal static extern void ImGuiKeyOwnerDataDestroyNative(ImGuiKeyOwnerData* self);

		public static void ImGuiKeyOwnerDataDestroy(ImGuiKeyOwnerData* self)
		{
			ImGuiKeyOwnerDataDestroyNative(self);
		}

		public static void ImGuiKeyOwnerDataDestroy(ref ImGuiKeyOwnerData self)
		{
			fixed (ImGuiKeyOwnerData* pself = &self)
			{
				ImGuiKeyOwnerDataDestroyNative((ImGuiKeyOwnerData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperRange_FromIndices")]
		internal static extern ImGuiListClipperRange ImGuiListClipperRangeFromIndicesNative(int min, int max);

		public static ImGuiListClipperRange ImGuiListClipperRangeFromIndices(int min, int max)
		{
			ImGuiListClipperRange ret = ImGuiListClipperRangeFromIndicesNative(min, max);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperRange_FromPositions")]
		internal static extern ImGuiListClipperRange ImGuiListClipperRangeFromPositionsNative(float y1, float y2, int offMin, int offMax);

		public static ImGuiListClipperRange ImGuiListClipperRangeFromPositions(float y1, float y2, int offMin, int offMax)
		{
			ImGuiListClipperRange ret = ImGuiListClipperRangeFromPositionsNative(y1, y2, offMin, offMax);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperData_ImGuiListClipperData")]
		internal static extern ImGuiListClipperData* ImGuiListClipperDataImGuiListClipperDataNative();

		public static ImGuiListClipperDataPtr ImGuiListClipperDataImGuiListClipperData()
		{
			ImGuiListClipperDataPtr ret = ImGuiListClipperDataImGuiListClipperDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperData_destroy")]
		internal static extern void ImGuiListClipperDataDestroyNative(ImGuiListClipperData* self);

		public static void ImGuiListClipperDataDestroy(ImGuiListClipperData* self)
		{
			ImGuiListClipperDataDestroyNative(self);
		}

		public static void ImGuiListClipperDataDestroy(ref ImGuiListClipperData self)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ImGuiListClipperDataDestroyNative((ImGuiListClipperData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiListClipperData_Reset")]
		internal static extern void ImGuiListClipperDataResetNative(ImGuiListClipperData* self, ImGuiListClipper* clipper);

		public static void ImGuiListClipperDataReset(ImGuiListClipperData* self, ImGuiListClipper* clipper)
		{
			ImGuiListClipperDataResetNative(self, clipper);
		}

		public static void ImGuiListClipperDataReset(ref ImGuiListClipperData self, ImGuiListClipper* clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ImGuiListClipperDataResetNative((ImGuiListClipperData*)pself, clipper);
			}
		}

		public static void ImGuiListClipperDataReset(ImGuiListClipperData* self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipper* pclipper = &clipper)
			{
				ImGuiListClipperDataResetNative(self, (ImGuiListClipper*)pclipper);
			}
		}

		public static void ImGuiListClipperDataReset(ref ImGuiListClipperData self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				fixed (ImGuiListClipper* pclipper = &clipper)
				{
					ImGuiListClipperDataResetNative((ImGuiListClipperData*)pself, (ImGuiListClipper*)pclipper);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNavItemData_ImGuiNavItemData")]
		internal static extern ImGuiNavItemData* ImGuiNavItemDataImGuiNavItemDataNative();

		public static ImGuiNavItemDataPtr ImGuiNavItemDataImGuiNavItemData()
		{
			ImGuiNavItemDataPtr ret = ImGuiNavItemDataImGuiNavItemDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNavItemData_destroy")]
		internal static extern void ImGuiNavItemDataDestroyNative(ImGuiNavItemData* self);

		public static void ImGuiNavItemDataDestroy(ImGuiNavItemData* self)
		{
			ImGuiNavItemDataDestroyNative(self);
		}

		public static void ImGuiNavItemDataDestroy(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ImGuiNavItemDataDestroyNative((ImGuiNavItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiNavItemData_Clear")]
		internal static extern void ImGuiNavItemDataClearNative(ImGuiNavItemData* self);

		public static void ImGuiNavItemDataClear(ImGuiNavItemData* self)
		{
			ImGuiNavItemDataClearNative(self);
		}

		public static void ImGuiNavItemDataClear(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ImGuiNavItemDataClearNative((ImGuiNavItemData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOldColumnData_ImGuiOldColumnData")]
		internal static extern ImGuiOldColumnData* ImGuiOldColumnDataImGuiOldColumnDataNative();

		public static ImGuiOldColumnDataPtr ImGuiOldColumnDataImGuiOldColumnData()
		{
			ImGuiOldColumnDataPtr ret = ImGuiOldColumnDataImGuiOldColumnDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOldColumnData_destroy")]
		internal static extern void ImGuiOldColumnDataDestroyNative(ImGuiOldColumnData* self);

		public static void ImGuiOldColumnDataDestroy(ImGuiOldColumnData* self)
		{
			ImGuiOldColumnDataDestroyNative(self);
		}

		public static void ImGuiOldColumnDataDestroy(ref ImGuiOldColumnData self)
		{
			fixed (ImGuiOldColumnData* pself = &self)
			{
				ImGuiOldColumnDataDestroyNative((ImGuiOldColumnData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOldColumns_ImGuiOldColumns")]
		internal static extern ImGuiOldColumns* ImGuiOldColumnsImGuiOldColumnsNative();

		public static ImGuiOldColumnsPtr ImGuiOldColumnsImGuiOldColumns()
		{
			ImGuiOldColumnsPtr ret = ImGuiOldColumnsImGuiOldColumnsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiOldColumns_destroy")]
		internal static extern void ImGuiOldColumnsDestroyNative(ImGuiOldColumns* self);

		public static void ImGuiOldColumnsDestroy(ImGuiOldColumns* self)
		{
			ImGuiOldColumnsDestroyNative(self);
		}

		public static void ImGuiOldColumnsDestroy(ref ImGuiOldColumns self)
		{
			fixed (ImGuiOldColumns* pself = &self)
			{
				ImGuiOldColumnsDestroyNative((ImGuiOldColumns*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_ImGuiDockNode")]
		internal static extern ImGuiDockNode* ImGuiDockNodeImGuiDockNodeNative(int id);

		public static ImGuiDockNodePtr ImGuiDockNodeImGuiDockNode(int id)
		{
			ImGuiDockNodePtr ret = ImGuiDockNodeImGuiDockNodeNative(id);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_destroy")]
		internal static extern void ImGuiDockNodeDestroyNative(ImGuiDockNode* self);

		public static void ImGuiDockNodeDestroy(ImGuiDockNode* self)
		{
			ImGuiDockNodeDestroyNative(self);
		}

		public static void ImGuiDockNodeDestroy(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiDockNodeDestroyNative((ImGuiDockNode*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsRootNode")]
		internal static extern byte ImGuiDockNodeIsRootNodeNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsRootNode(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsRootNodeNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsRootNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsRootNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsDockSpace")]
		internal static extern byte ImGuiDockNodeIsDockSpaceNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsDockSpace(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsDockSpaceNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsDockSpace(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsDockSpaceNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsFloatingNode")]
		internal static extern byte ImGuiDockNodeIsFloatingNodeNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsFloatingNode(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsFloatingNodeNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsFloatingNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsFloatingNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsCentralNode")]
		internal static extern byte ImGuiDockNodeIsCentralNodeNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsCentralNode(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsCentralNodeNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsCentralNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsCentralNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsHiddenTabBar")]
		internal static extern byte ImGuiDockNodeIsHiddenTabBarNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsHiddenTabBar(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsHiddenTabBarNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsHiddenTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsHiddenTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsNoTabBar")]
		internal static extern byte ImGuiDockNodeIsNoTabBarNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsNoTabBar(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsNoTabBarNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsNoTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsNoTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsSplitNode")]
		internal static extern byte ImGuiDockNodeIsSplitNodeNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsSplitNode(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsSplitNodeNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsSplitNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsSplitNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsLeafNode")]
		internal static extern byte ImGuiDockNodeIsLeafNodeNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsLeafNode(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsLeafNodeNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsLeafNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsLeafNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_IsEmpty")]
		internal static extern byte ImGuiDockNodeIsEmptyNative(ImGuiDockNode* self);

		public static bool ImGuiDockNodeIsEmpty(ImGuiDockNode* self)
		{
			byte ret = ImGuiDockNodeIsEmptyNative(self);
			return ret != 0;
		}

		public static bool ImGuiDockNodeIsEmpty(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiDockNodeIsEmptyNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_Rect")]
		internal static extern void ImGuiDockNodeRectNative(ImRect* output, ImGuiDockNode* self);

		public static ImRect ImGuiDockNodeRect(ImGuiDockNode* self)
		{
			ImRect ret;
			ImGuiDockNodeRectNative(&ret, self);
			return ret;
		}

		public static void ImGuiDockNodeRect(ref ImRect output, ImGuiDockNode* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiDockNodeRectNative((ImRect*)poutput, self);
			}
		}

		public static ImRect ImGuiDockNodeRect(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImRect ret;
				ImGuiDockNodeRectNative(&ret, (ImGuiDockNode*)pself);
				return ret;
			}
		}

		public static void ImGuiDockNodeRect(ref ImRect output, ref ImGuiDockNode self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiDockNode* pself = &self)
				{
					ImGuiDockNodeRectNative((ImRect*)poutput, (ImGuiDockNode*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_SetLocalFlags")]
		internal static extern void ImGuiDockNodeSetLocalFlagsNative(ImGuiDockNode* self, ImGuiDockNodeFlags flags);

		public static void ImGuiDockNodeSetLocalFlags(ImGuiDockNode* self, ImGuiDockNodeFlags flags)
		{
			ImGuiDockNodeSetLocalFlagsNative(self, flags);
		}

		public static void ImGuiDockNodeSetLocalFlags(ref ImGuiDockNode self, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiDockNodeSetLocalFlagsNative((ImGuiDockNode*)pself, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockNode_UpdateMergedFlags")]
		internal static extern void ImGuiDockNodeUpdateMergedFlagsNative(ImGuiDockNode* self);

		public static void ImGuiDockNodeUpdateMergedFlags(ImGuiDockNode* self)
		{
			ImGuiDockNodeUpdateMergedFlagsNative(self);
		}

		public static void ImGuiDockNodeUpdateMergedFlags(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiDockNodeUpdateMergedFlagsNative((ImGuiDockNode*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockContext_ImGuiDockContext")]
		internal static extern ImGuiDockContext* ImGuiDockContextImGuiDockContextNative();

		public static ImGuiDockContextPtr ImGuiDockContextImGuiDockContext()
		{
			ImGuiDockContextPtr ret = ImGuiDockContextImGuiDockContextNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiDockContext_destroy")]
		internal static extern void ImGuiDockContextDestroyNative(ImGuiDockContext* self);

		public static void ImGuiDockContextDestroy(ImGuiDockContext* self)
		{
			ImGuiDockContextDestroyNative(self);
		}

		public static void ImGuiDockContextDestroy(ref ImGuiDockContext self)
		{
			fixed (ImGuiDockContext* pself = &self)
			{
				ImGuiDockContextDestroyNative((ImGuiDockContext*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_ImGuiViewportP")]
		internal static extern ImGuiViewportP* ImGuiViewportPImGuiViewportPNative();

		public static ImGuiViewportPPtr ImGuiViewportPImGuiViewportP()
		{
			ImGuiViewportPPtr ret = ImGuiViewportPImGuiViewportPNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_destroy")]
		internal static extern void ImGuiViewportPDestroyNative(ImGuiViewportP* self);

		public static void ImGuiViewportPDestroy(ImGuiViewportP* self)
		{
			ImGuiViewportPDestroyNative(self);
		}

		public static void ImGuiViewportPDestroy(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPDestroyNative((ImGuiViewportP*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_ClearRequestFlags")]
		internal static extern void ImGuiViewportPClearRequestFlagsNative(ImGuiViewportP* self);

		public static void ImGuiViewportPClearRequestFlags(ImGuiViewportP* self)
		{
			ImGuiViewportPClearRequestFlagsNative(self);
		}

		public static void ImGuiViewportPClearRequestFlags(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPClearRequestFlagsNative((ImGuiViewportP*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_CalcWorkRectPos")]
		internal static extern void ImGuiViewportPCalcWorkRectPosNative(Vector2* output, ImGuiViewportP* self, Vector2 offMin);

		public static Vector2 ImGuiViewportPCalcWorkRectPos(ImGuiViewportP* self, Vector2 offMin)
		{
			Vector2 ret;
			ImGuiViewportPCalcWorkRectPosNative(&ret, self, offMin);
			return ret;
		}

		public static void ImGuiViewportPCalcWorkRectPos(ref Vector2 output, ImGuiViewportP* self, Vector2 offMin)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGuiViewportPCalcWorkRectPosNative((Vector2*)poutput, self, offMin);
			}
		}

		public static Vector2 ImGuiViewportPCalcWorkRectPos(ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				ImGuiViewportPCalcWorkRectPosNative(&ret, (ImGuiViewportP*)pself, offMin);
				return ret;
			}
		}

		public static void ImGuiViewportPCalcWorkRectPos(ref Vector2 output, ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPCalcWorkRectPosNative((Vector2*)poutput, (ImGuiViewportP*)pself, offMin);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_CalcWorkRectSize")]
		internal static extern void ImGuiViewportPCalcWorkRectSizeNative(Vector2* output, ImGuiViewportP* self, Vector2 offMin, Vector2 offMax);

		public static Vector2 ImGuiViewportPCalcWorkRectSize(ImGuiViewportP* self, Vector2 offMin, Vector2 offMax)
		{
			Vector2 ret;
			ImGuiViewportPCalcWorkRectSizeNative(&ret, self, offMin, offMax);
			return ret;
		}

		public static void ImGuiViewportPCalcWorkRectSize(ref Vector2 output, ImGuiViewportP* self, Vector2 offMin, Vector2 offMax)
		{
			fixed (Vector2* poutput = &output)
			{
				ImGuiViewportPCalcWorkRectSizeNative((Vector2*)poutput, self, offMin, offMax);
			}
		}

		public static Vector2 ImGuiViewportPCalcWorkRectSize(ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				ImGuiViewportPCalcWorkRectSizeNative(&ret, (ImGuiViewportP*)pself, offMin, offMax);
				return ret;
			}
		}

		public static void ImGuiViewportPCalcWorkRectSize(ref Vector2 output, ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPCalcWorkRectSizeNative((Vector2*)poutput, (ImGuiViewportP*)pself, offMin, offMax);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_UpdateWorkRect")]
		internal static extern void ImGuiViewportPUpdateWorkRectNative(ImGuiViewportP* self);

		public static void ImGuiViewportPUpdateWorkRect(ImGuiViewportP* self)
		{
			ImGuiViewportPUpdateWorkRectNative(self);
		}

		public static void ImGuiViewportPUpdateWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiViewportPUpdateWorkRectNative((ImGuiViewportP*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_GetMainRect")]
		internal static extern void ImGuiViewportPGetMainRectNative(ImRect* output, ImGuiViewportP* self);

		public static ImRect ImGuiViewportPGetMainRect(ImGuiViewportP* self)
		{
			ImRect ret;
			ImGuiViewportPGetMainRectNative(&ret, self);
			return ret;
		}

		public static void ImGuiViewportPGetMainRect(ref ImRect output, ImGuiViewportP* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiViewportPGetMainRectNative((ImRect*)poutput, self);
			}
		}

		public static ImRect ImGuiViewportPGetMainRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ImGuiViewportPGetMainRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		public static void ImGuiViewportPGetMainRect(ref ImRect output, ref ImGuiViewportP self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPGetMainRectNative((ImRect*)poutput, (ImGuiViewportP*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_GetWorkRect")]
		internal static extern void ImGuiViewportPGetWorkRectNative(ImRect* output, ImGuiViewportP* self);

		public static ImRect ImGuiViewportPGetWorkRect(ImGuiViewportP* self)
		{
			ImRect ret;
			ImGuiViewportPGetWorkRectNative(&ret, self);
			return ret;
		}

		public static void ImGuiViewportPGetWorkRect(ref ImRect output, ImGuiViewportP* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiViewportPGetWorkRectNative((ImRect*)poutput, self);
			}
		}

		public static ImRect ImGuiViewportPGetWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ImGuiViewportPGetWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		public static void ImGuiViewportPGetWorkRect(ref ImRect output, ref ImGuiViewportP self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPGetWorkRectNative((ImRect*)poutput, (ImGuiViewportP*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiViewportP_GetBuildWorkRect")]
		internal static extern void ImGuiViewportPGetBuildWorkRectNative(ImRect* output, ImGuiViewportP* self);

		public static ImRect ImGuiViewportPGetBuildWorkRect(ImGuiViewportP* self)
		{
			ImRect ret;
			ImGuiViewportPGetBuildWorkRectNative(&ret, self);
			return ret;
		}

		public static void ImGuiViewportPGetBuildWorkRect(ref ImRect output, ImGuiViewportP* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiViewportPGetBuildWorkRectNative((ImRect*)poutput, self);
			}
		}

		public static ImRect ImGuiViewportPGetBuildWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ImGuiViewportPGetBuildWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		public static void ImGuiViewportPGetBuildWorkRect(ref ImRect output, ref ImGuiViewportP self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiViewportPGetBuildWorkRectNative((ImRect*)poutput, (ImGuiViewportP*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowSettings_ImGuiWindowSettings")]
		internal static extern ImGuiWindowSettings* ImGuiWindowSettingsImGuiWindowSettingsNative();

		public static ImGuiWindowSettingsPtr ImGuiWindowSettingsImGuiWindowSettings()
		{
			ImGuiWindowSettingsPtr ret = ImGuiWindowSettingsImGuiWindowSettingsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowSettings_destroy")]
		internal static extern void ImGuiWindowSettingsDestroyNative(ImGuiWindowSettings* self);

		public static void ImGuiWindowSettingsDestroy(ImGuiWindowSettings* self)
		{
			ImGuiWindowSettingsDestroyNative(self);
		}

		public static void ImGuiWindowSettingsDestroy(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				ImGuiWindowSettingsDestroyNative((ImGuiWindowSettings*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindowSettings_GetName")]
		internal static extern byte* ImGuiWindowSettingsGetNameNative(ImGuiWindowSettings* self);

		public static byte* ImGuiWindowSettingsGetName(ImGuiWindowSettings* self)
		{
			byte* ret = ImGuiWindowSettingsGetNameNative(self);
			return ret;
		}

		public static string ImGuiWindowSettingsGetNameS(ImGuiWindowSettings* self)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiWindowSettingsGetNameNative(self));
			return ret;
		}

		public static byte* ImGuiWindowSettingsGetName(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				byte* ret = ImGuiWindowSettingsGetNameNative((ImGuiWindowSettings*)pself);
				return ret;
			}
		}

		public static string ImGuiWindowSettingsGetNameS(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiWindowSettingsGetNameNative((ImGuiWindowSettings*)pself));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiSettingsHandler_ImGuiSettingsHandler")]
		internal static extern ImGuiSettingsHandler* ImGuiSettingsHandlerImGuiSettingsHandlerNative();

		public static ImGuiSettingsHandlerPtr ImGuiSettingsHandlerImGuiSettingsHandler()
		{
			ImGuiSettingsHandlerPtr ret = ImGuiSettingsHandlerImGuiSettingsHandlerNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiSettingsHandler_destroy")]
		internal static extern void ImGuiSettingsHandlerDestroyNative(ImGuiSettingsHandler* self);

		public static void ImGuiSettingsHandlerDestroy(ImGuiSettingsHandler* self)
		{
			ImGuiSettingsHandlerDestroyNative(self);
		}

		public static void ImGuiSettingsHandlerDestroy(ref ImGuiSettingsHandler self)
		{
			fixed (ImGuiSettingsHandler* pself = &self)
			{
				ImGuiSettingsHandlerDestroyNative((ImGuiSettingsHandler*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackLevelInfo_ImGuiStackLevelInfo")]
		internal static extern ImGuiStackLevelInfo* ImGuiStackLevelInfoImGuiStackLevelInfoNative();

		public static ImGuiStackLevelInfoPtr ImGuiStackLevelInfoImGuiStackLevelInfo()
		{
			ImGuiStackLevelInfoPtr ret = ImGuiStackLevelInfoImGuiStackLevelInfoNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackLevelInfo_destroy")]
		internal static extern void ImGuiStackLevelInfoDestroyNative(ImGuiStackLevelInfo* self);

		public static void ImGuiStackLevelInfoDestroy(ImGuiStackLevelInfo* self)
		{
			ImGuiStackLevelInfoDestroyNative(self);
		}

		public static void ImGuiStackLevelInfoDestroy(ref ImGuiStackLevelInfo self)
		{
			fixed (ImGuiStackLevelInfo* pself = &self)
			{
				ImGuiStackLevelInfoDestroyNative((ImGuiStackLevelInfo*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackTool_ImGuiStackTool")]
		internal static extern ImGuiStackTool* ImGuiStackToolImGuiStackToolNative();

		public static ImGuiStackToolPtr ImGuiStackToolImGuiStackTool()
		{
			ImGuiStackToolPtr ret = ImGuiStackToolImGuiStackToolNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiStackTool_destroy")]
		internal static extern void ImGuiStackToolDestroyNative(ImGuiStackTool* self);

		public static void ImGuiStackToolDestroy(ImGuiStackTool* self)
		{
			ImGuiStackToolDestroyNative(self);
		}

		public static void ImGuiStackToolDestroy(ref ImGuiStackTool self)
		{
			fixed (ImGuiStackTool* pself = &self)
			{
				ImGuiStackToolDestroyNative((ImGuiStackTool*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiContextHook_ImGuiContextHook")]
		internal static extern ImGuiContextHook* ImGuiContextHookImGuiContextHookNative();

		public static ImGuiContextHookPtr ImGuiContextHookImGuiContextHook()
		{
			ImGuiContextHookPtr ret = ImGuiContextHookImGuiContextHookNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiContextHook_destroy")]
		internal static extern void ImGuiContextHookDestroyNative(ImGuiContextHook* self);

		public static void ImGuiContextHookDestroy(ImGuiContextHook* self)
		{
			ImGuiContextHookDestroyNative(self);
		}

		public static void ImGuiContextHookDestroy(ref ImGuiContextHook self)
		{
			fixed (ImGuiContextHook* pself = &self)
			{
				ImGuiContextHookDestroyNative((ImGuiContextHook*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiContext_ImGuiContext")]
		internal static extern ImGuiContext* ImGuiContextImGuiContextNative(ImFontAtlas* sharedFontAtlas);

		public static ImGuiContextPtr ImGuiContextImGuiContext(ImFontAtlas* sharedFontAtlas)
		{
			ImGuiContextPtr ret = ImGuiContextImGuiContextNative(sharedFontAtlas);
			return ret;
		}

		public static ImGuiContextPtr ImGuiContextImGuiContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = ImGuiContextImGuiContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiContext_destroy")]
		internal static extern void ImGuiContextDestroyNative(ImGuiContext* self);

		public static void ImGuiContextDestroy(ImGuiContext* self)
		{
			ImGuiContextDestroyNative(self);
		}

		public static void ImGuiContextDestroy(ref ImGuiContext self)
		{
			fixed (ImGuiContext* pself = &self)
			{
				ImGuiContextDestroyNative((ImGuiContext*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_ImGuiWindow")]
		internal static extern ImGuiWindow* ImGuiWindowImGuiWindowNative(ImGuiContext* context, byte* name);

		public static ImGuiWindowPtr ImGuiWindowImGuiWindow(ImGuiContext* context, byte* name)
		{
			ImGuiWindowPtr ret = ImGuiWindowImGuiWindowNative(context, name);
			return ret;
		}

		public static ImGuiWindowPtr ImGuiWindowImGuiWindow(ref ImGuiContext context, byte* name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				ImGuiWindowPtr ret = ImGuiWindowImGuiWindowNative((ImGuiContext*)pcontext, name);
				return ret;
			}
		}

		public static ImGuiWindowPtr ImGuiWindowImGuiWindow(ImGuiContext* context, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowPtr ret = ImGuiWindowImGuiWindowNative(context, (byte*)pname);
				return ret;
			}
		}

		public static ImGuiWindowPtr ImGuiWindowImGuiWindow(ImGuiContext* context, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowPtr ret = ImGuiWindowImGuiWindowNative(context, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static ImGuiWindowPtr ImGuiWindowImGuiWindow(ref ImGuiContext context, ref byte name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = &name)
				{
					ImGuiWindowPtr ret = ImGuiWindowImGuiWindowNative((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}

		public static ImGuiWindowPtr ImGuiWindowImGuiWindow(ref ImGuiContext context, string name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiWindowPtr ret = ImGuiWindowImGuiWindowNative((ImGuiContext*)pcontext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_destroy")]
		internal static extern void ImGuiWindowDestroyNative(ImGuiWindow* self);

		public static void ImGuiWindowDestroy(ImGuiWindow* self)
		{
			ImGuiWindowDestroyNative(self);
		}

		public static void ImGuiWindowDestroy(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiWindowDestroyNative((ImGuiWindow*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_GetID_Str")]
		internal static extern int ImGuiWindowGetIDNative(ImGuiWindow* self, byte* str, byte* strEnd);

		public static int ImGuiWindowGetID(ImGuiWindow* self, byte* str, byte* strEnd)
		{
			int ret = ImGuiWindowGetIDNative(self, str, strEnd);
			return ret;
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, byte* str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				int ret = ImGuiWindowGetIDNative((ImGuiWindow*)pself, str, strEnd);
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				int ret = ImGuiWindowGetIDNative(self, (byte*)pstr, strEnd);
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiWindowGetIDNative(self, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, ref byte str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					int ret = ImGuiWindowGetIDNative((ImGuiWindow*)pself, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, string str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiWindowGetIDNative((ImGuiWindow*)pself, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				int ret = ImGuiWindowGetIDNative(self, str, (byte*)pstrEnd);
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiWindowGetIDNative(self, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, byte* str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					int ret = ImGuiWindowGetIDNative((ImGuiWindow*)pself, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, byte* str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiWindowGetIDNative((ImGuiWindow*)pself, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					int ret = ImGuiWindowGetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		public static int ImGuiWindowGetID(ImGuiWindow* self, string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGuiWindowGetIDNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, ref byte str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						int ret = ImGuiWindowGetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		public static int ImGuiWindowGetID(ref ImGuiWindow self, string str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImGuiWindowGetIDNative((ImGuiWindow*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_GetID_Ptr")]
		internal static extern int ImGuiWindowGetIDPtrNative(ImGuiWindow* self, void* ptr);

		public static int ImGuiWindowGetIDPtr(ImGuiWindow* self, void* ptr)
		{
			int ret = ImGuiWindowGetIDPtrNative(self, ptr);
			return ret;
		}

		public static int ImGuiWindowGetIDPtr(ref ImGuiWindow self, void* ptr)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				int ret = ImGuiWindowGetIDPtrNative((ImGuiWindow*)pself, ptr);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_GetID_Int")]
		internal static extern int ImGuiWindowGetIDIntNative(ImGuiWindow* self, int n);

		public static int ImGuiWindowGetIDInt(ImGuiWindow* self, int n)
		{
			int ret = ImGuiWindowGetIDIntNative(self, n);
			return ret;
		}

		public static int ImGuiWindowGetIDInt(ref ImGuiWindow self, int n)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				int ret = ImGuiWindowGetIDIntNative((ImGuiWindow*)pself, n);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_GetIDFromRectangle")]
		internal static extern int ImGuiWindowGetIDFromRectangleNative(ImGuiWindow* self, ImRect rAbs);

		public static int ImGuiWindowGetIDFromRectangle(ImGuiWindow* self, ImRect rAbs)
		{
			int ret = ImGuiWindowGetIDFromRectangleNative(self, rAbs);
			return ret;
		}

		public static int ImGuiWindowGetIDFromRectangle(ref ImGuiWindow self, ImRect rAbs)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				int ret = ImGuiWindowGetIDFromRectangleNative((ImGuiWindow*)pself, rAbs);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_Rect")]
		internal static extern void ImGuiWindowRectNative(ImRect* output, ImGuiWindow* self);

		public static ImRect ImGuiWindowRect(ImGuiWindow* self)
		{
			ImRect ret;
			ImGuiWindowRectNative(&ret, self);
			return ret;
		}

		public static void ImGuiWindowRect(ref ImRect output, ImGuiWindow* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiWindowRectNative((ImRect*)poutput, self);
			}
		}

		public static ImRect ImGuiWindowRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				ImGuiWindowRectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		public static void ImGuiWindowRect(ref ImRect output, ref ImGuiWindow self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiWindowRectNative((ImRect*)poutput, (ImGuiWindow*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_CalcFontSize")]
		internal static extern float ImGuiWindowCalcFontSizeNative(ImGuiWindow* self);

		public static float ImGuiWindowCalcFontSize(ImGuiWindow* self)
		{
			float ret = ImGuiWindowCalcFontSizeNative(self);
			return ret;
		}

		public static float ImGuiWindowCalcFontSize(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiWindowCalcFontSizeNative((ImGuiWindow*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_TitleBarHeight")]
		internal static extern float ImGuiWindowTitleBarHeightNative(ImGuiWindow* self);

		public static float ImGuiWindowTitleBarHeight(ImGuiWindow* self)
		{
			float ret = ImGuiWindowTitleBarHeightNative(self);
			return ret;
		}

		public static float ImGuiWindowTitleBarHeight(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiWindowTitleBarHeightNative((ImGuiWindow*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_TitleBarRect")]
		internal static extern void ImGuiWindowTitleBarRectNative(ImRect* output, ImGuiWindow* self);

		public static ImRect ImGuiWindowTitleBarRect(ImGuiWindow* self)
		{
			ImRect ret;
			ImGuiWindowTitleBarRectNative(&ret, self);
			return ret;
		}

		public static void ImGuiWindowTitleBarRect(ref ImRect output, ImGuiWindow* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiWindowTitleBarRectNative((ImRect*)poutput, self);
			}
		}

		public static ImRect ImGuiWindowTitleBarRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				ImGuiWindowTitleBarRectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		public static void ImGuiWindowTitleBarRect(ref ImRect output, ref ImGuiWindow self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiWindowTitleBarRectNative((ImRect*)poutput, (ImGuiWindow*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_MenuBarHeight")]
		internal static extern float ImGuiWindowMenuBarHeightNative(ImGuiWindow* self);

		public static float ImGuiWindowMenuBarHeight(ImGuiWindow* self)
		{
			float ret = ImGuiWindowMenuBarHeightNative(self);
			return ret;
		}

		public static float ImGuiWindowMenuBarHeight(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiWindowMenuBarHeightNative((ImGuiWindow*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiWindow_MenuBarRect")]
		internal static extern void ImGuiWindowMenuBarRectNative(ImRect* output, ImGuiWindow* self);

		public static ImRect ImGuiWindowMenuBarRect(ImGuiWindow* self)
		{
			ImRect ret;
			ImGuiWindowMenuBarRectNative(&ret, self);
			return ret;
		}

		public static void ImGuiWindowMenuBarRect(ref ImRect output, ImGuiWindow* self)
		{
			fixed (ImRect* poutput = &output)
			{
				ImGuiWindowMenuBarRectNative((ImRect*)poutput, self);
			}
		}

		public static ImRect ImGuiWindowMenuBarRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				ImGuiWindowMenuBarRectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		public static void ImGuiWindowMenuBarRect(ref ImRect output, ref ImGuiWindow self)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiWindowMenuBarRectNative((ImRect*)poutput, (ImGuiWindow*)pself);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTabItem_ImGuiTabItem")]
		internal static extern ImGuiTabItem* ImGuiTabItemImGuiTabItemNative();

		public static ImGuiTabItemPtr ImGuiTabItemImGuiTabItem()
		{
			ImGuiTabItemPtr ret = ImGuiTabItemImGuiTabItemNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTabItem_destroy")]
		internal static extern void ImGuiTabItemDestroyNative(ImGuiTabItem* self);

		public static void ImGuiTabItemDestroy(ImGuiTabItem* self)
		{
			ImGuiTabItemDestroyNative(self);
		}

		public static void ImGuiTabItemDestroy(ref ImGuiTabItem self)
		{
			fixed (ImGuiTabItem* pself = &self)
			{
				ImGuiTabItemDestroyNative((ImGuiTabItem*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTabBar_ImGuiTabBar")]
		internal static extern ImGuiTabBar* ImGuiTabBarImGuiTabBarNative();

		public static ImGuiTabBarPtr ImGuiTabBarImGuiTabBar()
		{
			ImGuiTabBarPtr ret = ImGuiTabBarImGuiTabBarNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTabBar_destroy")]
		internal static extern void ImGuiTabBarDestroyNative(ImGuiTabBar* self);

		public static void ImGuiTabBarDestroy(ImGuiTabBar* self)
		{
			ImGuiTabBarDestroyNative(self);
		}

		public static void ImGuiTabBarDestroy(ref ImGuiTabBar self)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				ImGuiTabBarDestroyNative((ImGuiTabBar*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumn_ImGuiTableColumn")]
		internal static extern ImGuiTableColumn* ImGuiTableColumnImGuiTableColumnNative();

		public static ImGuiTableColumnPtr ImGuiTableColumnImGuiTableColumn()
		{
			ImGuiTableColumnPtr ret = ImGuiTableColumnImGuiTableColumnNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumn_destroy")]
		internal static extern void ImGuiTableColumnDestroyNative(ImGuiTableColumn* self);

		public static void ImGuiTableColumnDestroy(ImGuiTableColumn* self)
		{
			ImGuiTableColumnDestroyNative(self);
		}

		public static void ImGuiTableColumnDestroy(ref ImGuiTableColumn self)
		{
			fixed (ImGuiTableColumn* pself = &self)
			{
				ImGuiTableColumnDestroyNative((ImGuiTableColumn*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableInstanceData_ImGuiTableInstanceData")]
		internal static extern ImGuiTableInstanceData* ImGuiTableInstanceDataImGuiTableInstanceDataNative();

		public static ImGuiTableInstanceDataPtr ImGuiTableInstanceDataImGuiTableInstanceData()
		{
			ImGuiTableInstanceDataPtr ret = ImGuiTableInstanceDataImGuiTableInstanceDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableInstanceData_destroy")]
		internal static extern void ImGuiTableInstanceDataDestroyNative(ImGuiTableInstanceData* self);

		public static void ImGuiTableInstanceDataDestroy(ImGuiTableInstanceData* self)
		{
			ImGuiTableInstanceDataDestroyNative(self);
		}

		public static void ImGuiTableInstanceDataDestroy(ref ImGuiTableInstanceData self)
		{
			fixed (ImGuiTableInstanceData* pself = &self)
			{
				ImGuiTableInstanceDataDestroyNative((ImGuiTableInstanceData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTable_ImGuiTable")]
		internal static extern ImGuiTable* ImGuiTableImGuiTableNative();

		public static ImGuiTablePtr ImGuiTableImGuiTable()
		{
			ImGuiTablePtr ret = ImGuiTableImGuiTableNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTable_destroy")]
		internal static extern void ImGuiTableDestroyNative(ImGuiTable* self);

		public static void ImGuiTableDestroy(ImGuiTable* self)
		{
			ImGuiTableDestroyNative(self);
		}

		public static void ImGuiTableDestroy(ref ImGuiTable self)
		{
			fixed (ImGuiTable* pself = &self)
			{
				ImGuiTableDestroyNative((ImGuiTable*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableTempData_ImGuiTableTempData")]
		internal static extern ImGuiTableTempData* ImGuiTableTempDataImGuiTableTempDataNative();

		public static ImGuiTableTempDataPtr ImGuiTableTempDataImGuiTableTempData()
		{
			ImGuiTableTempDataPtr ret = ImGuiTableTempDataImGuiTableTempDataNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableTempData_destroy")]
		internal static extern void ImGuiTableTempDataDestroyNative(ImGuiTableTempData* self);

		public static void ImGuiTableTempDataDestroy(ImGuiTableTempData* self)
		{
			ImGuiTableTempDataDestroyNative(self);
		}

		public static void ImGuiTableTempDataDestroy(ref ImGuiTableTempData self)
		{
			fixed (ImGuiTableTempData* pself = &self)
			{
				ImGuiTableTempDataDestroyNative((ImGuiTableTempData*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumnSettings_ImGuiTableColumnSettings")]
		internal static extern ImGuiTableColumnSettings* ImGuiTableColumnSettingsImGuiTableColumnSettingsNative();

		public static ImGuiTableColumnSettingsPtr ImGuiTableColumnSettingsImGuiTableColumnSettings()
		{
			ImGuiTableColumnSettingsPtr ret = ImGuiTableColumnSettingsImGuiTableColumnSettingsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableColumnSettings_destroy")]
		internal static extern void ImGuiTableColumnSettingsDestroyNative(ImGuiTableColumnSettings* self);

		public static void ImGuiTableColumnSettingsDestroy(ImGuiTableColumnSettings* self)
		{
			ImGuiTableColumnSettingsDestroyNative(self);
		}

		public static void ImGuiTableColumnSettingsDestroy(ref ImGuiTableColumnSettings self)
		{
			fixed (ImGuiTableColumnSettings* pself = &self)
			{
				ImGuiTableColumnSettingsDestroyNative((ImGuiTableColumnSettings*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSettings_ImGuiTableSettings")]
		internal static extern ImGuiTableSettings* ImGuiTableSettingsImGuiTableSettingsNative();

		public static ImGuiTableSettingsPtr ImGuiTableSettingsImGuiTableSettings()
		{
			ImGuiTableSettingsPtr ret = ImGuiTableSettingsImGuiTableSettingsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSettings_destroy")]
		internal static extern void ImGuiTableSettingsDestroyNative(ImGuiTableSettings* self);

		public static void ImGuiTableSettingsDestroy(ImGuiTableSettings* self)
		{
			ImGuiTableSettingsDestroyNative(self);
		}

		public static void ImGuiTableSettingsDestroy(ref ImGuiTableSettings self)
		{
			fixed (ImGuiTableSettings* pself = &self)
			{
				ImGuiTableSettingsDestroyNative((ImGuiTableSettings*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTableSettings_GetColumnSettings")]
		internal static extern ImGuiTableColumnSettings* ImGuiTableSettingsGetColumnSettingsNative(ImGuiTableSettings* self);

		public static ImGuiTableColumnSettingsPtr ImGuiTableSettingsGetColumnSettings(ImGuiTableSettings* self)
		{
			ImGuiTableColumnSettingsPtr ret = ImGuiTableSettingsGetColumnSettingsNative(self);
			return ret;
		}

		public static ImGuiTableColumnSettingsPtr ImGuiTableSettingsGetColumnSettings(ref ImGuiTableSettings self)
		{
			fixed (ImGuiTableSettings* pself = &self)
			{
				ImGuiTableColumnSettingsPtr ret = ImGuiTableSettingsGetColumnSettingsNative((ImGuiTableSettings*)pself);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentWindowRead")]
		internal static extern ImGuiWindow* GetCurrentWindowReadNative();

		public static ImGuiWindowPtr GetCurrentWindowRead()
		{
			ImGuiWindowPtr ret = GetCurrentWindowReadNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentWindow")]
		internal static extern ImGuiWindow* GetCurrentWindowNative();

		public static ImGuiWindowPtr GetCurrentWindow()
		{
			ImGuiWindowPtr ret = GetCurrentWindowNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowByID")]
		internal static extern ImGuiWindow* FindWindowByIDNative(int id);

		public static ImGuiWindowPtr FindWindowByID(int id)
		{
			ImGuiWindowPtr ret = FindWindowByIDNative(id);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowByName")]
		internal static extern ImGuiWindow* FindWindowByNameNative(byte* name);

		public static ImGuiWindowPtr FindWindowByName(byte* name)
		{
			ImGuiWindowPtr ret = FindWindowByNameNative(name);
			return ret;
		}

		public static ImGuiWindowPtr FindWindowByName(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowPtr ret = FindWindowByNameNative((byte*)pname);
				return ret;
			}
		}

		public static ImGuiWindowPtr FindWindowByName(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowPtr ret = FindWindowByNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateWindowParentAndRootLinks")]
		internal static extern void UpdateWindowParentAndRootLinksNative(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parentWindow);

		public static void UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parentWindow)
		{
			UpdateWindowParentAndRootLinksNative(window, flags, parentWindow);
		}

		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ImGuiWindow* parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				UpdateWindowParentAndRootLinksNative((ImGuiWindow*)pwindow, flags, parentWindow);
			}
		}

		public static void UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pparentWindow = &parentWindow)
			{
				UpdateWindowParentAndRootLinksNative(window, flags, (ImGuiWindow*)pparentWindow);
			}
		}

		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* pparentWindow = &parentWindow)
				{
					UpdateWindowParentAndRootLinksNative((ImGuiWindow*)pwindow, flags, (ImGuiWindow*)pparentWindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcWindowNextAutoFitSize")]
		internal static extern void CalcWindowNextAutoFitSizeNative(Vector2* output, ImGuiWindow* window);

		public static Vector2 CalcWindowNextAutoFitSize(ImGuiWindow* window)
		{
			Vector2 ret;
			CalcWindowNextAutoFitSizeNative(&ret, window);
			return ret;
		}

		public static void CalcWindowNextAutoFitSize(ref Vector2 output, ImGuiWindow* window)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcWindowNextAutoFitSizeNative((Vector2*)poutput, window);
			}
		}

		public static Vector2 CalcWindowNextAutoFitSize(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				CalcWindowNextAutoFitSizeNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		public static void CalcWindowNextAutoFitSize(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					CalcWindowNextAutoFitSizeNative((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowChildOf")]
		internal static extern byte IsWindowChildOfNative(ImGuiWindow* window, ImGuiWindow* potentialParent, byte popupHierarchy, byte dockHierarchy);

		public static bool IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			byte ret = IsWindowChildOfNative(window, potentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool IsWindowChildOf(ref ImGuiWindow window, ImGuiWindow* potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowChildOfNative((ImGuiWindow*)pwindow, potentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool IsWindowChildOf(ImGuiWindow* window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				byte ret = IsWindowChildOfNative(window, (ImGuiWindow*)ppotentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool IsWindowChildOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					byte ret = IsWindowChildOfNative((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowWithinBeginStackOf")]
		internal static extern byte IsWindowWithinBeginStackOfNative(ImGuiWindow* window, ImGuiWindow* potentialParent);

		public static bool IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potentialParent)
		{
			byte ret = IsWindowWithinBeginStackOfNative(window, potentialParent);
			return ret != 0;
		}

		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ImGuiWindow* potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowWithinBeginStackOfNative((ImGuiWindow*)pwindow, potentialParent);
				return ret != 0;
			}
		}

		public static bool IsWindowWithinBeginStackOf(ImGuiWindow* window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				byte ret = IsWindowWithinBeginStackOfNative(window, (ImGuiWindow*)ppotentialParent);
				return ret != 0;
			}
		}

		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					byte ret = IsWindowWithinBeginStackOfNative((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent);
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowAbove")]
		internal static extern byte IsWindowAboveNative(ImGuiWindow* potentialAbove, ImGuiWindow* potentialBelow);

		public static bool IsWindowAbove(ImGuiWindow* potentialAbove, ImGuiWindow* potentialBelow)
		{
			byte ret = IsWindowAboveNative(potentialAbove, potentialBelow);
			return ret != 0;
		}

		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ImGuiWindow* potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				byte ret = IsWindowAboveNative((ImGuiWindow*)ppotentialAbove, potentialBelow);
				return ret != 0;
			}
		}

		public static bool IsWindowAbove(ImGuiWindow* potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
			{
				byte ret = IsWindowAboveNative(potentialAbove, (ImGuiWindow*)ppotentialBelow);
				return ret != 0;
			}
		}

		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
				{
					byte ret = IsWindowAboveNative((ImGuiWindow*)ppotentialAbove, (ImGuiWindow*)ppotentialBelow);
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowNavFocusable")]
		internal static extern byte IsWindowNavFocusableNative(ImGuiWindow* window);

		public static bool IsWindowNavFocusable(ImGuiWindow* window)
		{
			byte ret = IsWindowNavFocusableNative(window);
			return ret != 0;
		}

		public static bool IsWindowNavFocusable(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowNavFocusableNative((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowPos_WindowPtr")]
		internal static extern void SetWindowPosWindowPtrNative(ImGuiWindow* window, Vector2 pos, ImGuiCond cond);

		public static void SetWindowPosWindowPtr(ImGuiWindow* window, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosWindowPtrNative(window, pos, cond);
		}

		public static void SetWindowPosWindowPtr(ref ImGuiWindow window, Vector2 pos, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowPosWindowPtrNative((ImGuiWindow*)pwindow, pos, cond);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowSize_WindowPtr")]
		internal static extern void SetWindowSizeWindowPtrNative(ImGuiWindow* window, Vector2 size, ImGuiCond cond);

		public static void SetWindowSizeWindowPtr(ImGuiWindow* window, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeWindowPtrNative(window, size, cond);
		}

		public static void SetWindowSizeWindowPtr(ref ImGuiWindow window, Vector2 size, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowSizeWindowPtrNative((ImGuiWindow*)pwindow, size, cond);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowCollapsed_WindowPtr")]
		internal static extern void SetWindowCollapsedWindowPtrNative(ImGuiWindow* window, byte collapsed, ImGuiCond cond);

		public static void SetWindowCollapsedWindowPtr(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedWindowPtrNative(window, collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsedWindowPtr(ref ImGuiWindow window, bool collapsed, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowCollapsedWindowPtrNative((ImGuiWindow*)pwindow, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowHitTestHole")]
		internal static extern void SetWindowHitTestHoleNative(ImGuiWindow* window, Vector2 pos, Vector2 size);

		public static void SetWindowHitTestHole(ImGuiWindow* window, Vector2 pos, Vector2 size)
		{
			SetWindowHitTestHoleNative(window, pos, size);
		}

		public static void SetWindowHitTestHole(ref ImGuiWindow window, Vector2 pos, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHitTestHoleNative((ImGuiWindow*)pwindow, pos, size);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowHiddendAndSkipItemsForCurrentFrame")]
		internal static extern void SetWindowHiddendAndSkipItemsForCurrentFrameNative(ImGuiWindow* window);

		public static void SetWindowHiddendAndSkipItemsForCurrentFrame(ImGuiWindow* window)
		{
			SetWindowHiddendAndSkipItemsForCurrentFrameNative(window);
		}

		public static void SetWindowHiddendAndSkipItemsForCurrentFrame(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHiddendAndSkipItemsForCurrentFrameNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igWindowRectAbsToRel")]
		internal static extern void WindowRectAbsToRelNative(ImRect* output, ImGuiWindow* window, ImRect r);

		public static ImRect WindowRectAbsToRel(ImGuiWindow* window, ImRect r)
		{
			ImRect ret;
			WindowRectAbsToRelNative(&ret, window, r);
			return ret;
		}

		public static void WindowRectAbsToRel(ref ImRect output, ImGuiWindow* window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				WindowRectAbsToRelNative((ImRect*)poutput, window, r);
			}
		}

		public static ImRect WindowRectAbsToRel(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				WindowRectAbsToRelNative(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}

		public static void WindowRectAbsToRel(ref ImRect output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectAbsToRelNative((ImRect*)poutput, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igWindowRectRelToAbs")]
		internal static extern void WindowRectRelToAbsNative(ImRect* output, ImGuiWindow* window, ImRect r);

		public static ImRect WindowRectRelToAbs(ImGuiWindow* window, ImRect r)
		{
			ImRect ret;
			WindowRectRelToAbsNative(&ret, window, r);
			return ret;
		}

		public static void WindowRectRelToAbs(ref ImRect output, ImGuiWindow* window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				WindowRectRelToAbsNative((ImRect*)poutput, window, r);
			}
		}

		public static ImRect WindowRectRelToAbs(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				WindowRectRelToAbsNative(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}

		public static void WindowRectRelToAbs(ref ImRect output, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectRelToAbsNative((ImRect*)poutput, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igWindowPosRelToAbs")]
		internal static extern void WindowPosRelToAbsNative(Vector2* output, ImGuiWindow* window, Vector2 p);

		public static Vector2 WindowPosRelToAbs(ImGuiWindow* window, Vector2 p)
		{
			Vector2 ret;
			WindowPosRelToAbsNative(&ret, window, p);
			return ret;
		}

		public static void WindowPosRelToAbs(ref Vector2 output, ImGuiWindow* window, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				WindowPosRelToAbsNative((Vector2*)poutput, window, p);
			}
		}

		public static Vector2 WindowPosRelToAbs(ref ImGuiWindow window, Vector2 p)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				WindowPosRelToAbsNative(&ret, (ImGuiWindow*)pwindow, p);
				return ret;
			}
		}

		public static void WindowPosRelToAbs(ref Vector2 output, ref ImGuiWindow window, Vector2 p)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowPosRelToAbsNative((Vector2*)poutput, (ImGuiWindow*)pwindow, p);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFocusWindow")]
		internal static extern void FocusWindowNative(ImGuiWindow* window, ImGuiFocusRequestFlags flags);

		public static void FocusWindow(ImGuiWindow* window, ImGuiFocusRequestFlags flags)
		{
			FocusWindowNative(window, flags);
		}

		public static void FocusWindow(ref ImGuiWindow window, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				FocusWindowNative((ImGuiWindow*)pwindow, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFocusTopMostWindowUnderOne")]
		internal static extern void FocusTopMostWindowUnderOneNative(ImGuiWindow* underThisWindow, ImGuiWindow* ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags);

		public static void FocusTopMostWindowUnderOne(ImGuiWindow* underThisWindow, ImGuiWindow* ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags)
		{
			FocusTopMostWindowUnderOneNative(underThisWindow, ignoreWindow, filterViewport, flags);
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindow* ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, ignoreWindow, filterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindow* underThisWindow, ref ImGuiWindow ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				FocusTopMostWindowUnderOneNative(underThisWindow, (ImGuiWindow*)pignoreWindow, filterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow, filterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindow* underThisWindow, ImGuiWindow* ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiViewport* pfilterViewport = &filterViewport)
			{
				FocusTopMostWindowUnderOneNative(underThisWindow, ignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindow* ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiViewport* pfilterViewport = &filterViewport)
				{
					FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, ignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ImGuiWindow* underThisWindow, ref ImGuiWindow ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				fixed (ImGuiViewport* pfilterViewport = &filterViewport)
				{
					FocusTopMostWindowUnderOneNative(underThisWindow, (ImGuiWindow*)pignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
				}
			}
		}

		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					fixed (ImGuiViewport* pfilterViewport = &filterViewport)
					{
						FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBringWindowToFocusFront")]
		internal static extern void BringWindowToFocusFrontNative(ImGuiWindow* window);

		public static void BringWindowToFocusFront(ImGuiWindow* window)
		{
			BringWindowToFocusFrontNative(window);
		}

		public static void BringWindowToFocusFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToFocusFrontNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBringWindowToDisplayFront")]
		internal static extern void BringWindowToDisplayFrontNative(ImGuiWindow* window);

		public static void BringWindowToDisplayFront(ImGuiWindow* window)
		{
			BringWindowToDisplayFrontNative(window);
		}

		public static void BringWindowToDisplayFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayFrontNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBringWindowToDisplayBack")]
		internal static extern void BringWindowToDisplayBackNative(ImGuiWindow* window);

		public static void BringWindowToDisplayBack(ImGuiWindow* window)
		{
			BringWindowToDisplayBackNative(window);
		}

		public static void BringWindowToDisplayBack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayBackNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBringWindowToDisplayBehind")]
		internal static extern void BringWindowToDisplayBehindNative(ImGuiWindow* window, ImGuiWindow* aboveWindow);

		public static void BringWindowToDisplayBehind(ImGuiWindow* window, ImGuiWindow* aboveWindow)
		{
			BringWindowToDisplayBehindNative(window, aboveWindow);
		}

		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ImGuiWindow* aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayBehindNative((ImGuiWindow*)pwindow, aboveWindow);
			}
		}

		public static void BringWindowToDisplayBehind(ImGuiWindow* window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* paboveWindow = &aboveWindow)
			{
				BringWindowToDisplayBehindNative(window, (ImGuiWindow*)paboveWindow);
			}
		}

		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* paboveWindow = &aboveWindow)
				{
					BringWindowToDisplayBehindNative((ImGuiWindow*)pwindow, (ImGuiWindow*)paboveWindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowDisplayIndex")]
		internal static extern int FindWindowDisplayIndexNative(ImGuiWindow* window);

		public static int FindWindowDisplayIndex(ImGuiWindow* window)
		{
			int ret = FindWindowDisplayIndexNative(window);
			return ret;
		}

		public static int FindWindowDisplayIndex(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = FindWindowDisplayIndexNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindBottomMostVisibleWindowWithinBeginStack")]
		internal static extern ImGuiWindow* FindBottomMostVisibleWindowWithinBeginStackNative(ImGuiWindow* window);

		public static ImGuiWindowPtr FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* window)
		{
			ImGuiWindowPtr ret = FindBottomMostVisibleWindowWithinBeginStackNative(window);
			return ret;
		}

		public static ImGuiWindowPtr FindBottomMostVisibleWindowWithinBeginStack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowPtr ret = FindBottomMostVisibleWindowWithinBeginStackNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCurrentFont")]
		internal static extern void SetCurrentFontNative(ImFont* font);

		public static void SetCurrentFont(ImFont* font)
		{
			SetCurrentFontNative(font);
		}

		public static void SetCurrentFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				SetCurrentFontNative((ImFont*)pfont);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetDefaultFont")]
		internal static extern ImFont* GetDefaultFontNative();

		public static ImFontPtr GetDefaultFont()
		{
			ImFontPtr ret = GetDefaultFontNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetForegroundDrawList_WindowPtr")]
		internal static extern ImDrawList* GetForegroundDrawListWindowPtrNative(ImGuiWindow* window);

		public static ImDrawListPtr GetForegroundDrawListWindowPtr(ImGuiWindow* window)
		{
			ImDrawListPtr ret = GetForegroundDrawListWindowPtrNative(window);
			return ret;
		}

		public static ImDrawListPtr GetForegroundDrawListWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImDrawListPtr ret = GetForegroundDrawListWindowPtrNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInitialize")]
		internal static extern void InitializeNative();

		public static void Initialize()
		{
			InitializeNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShutdown")]
		internal static extern void ShutdownNative();

		public static void Shutdown()
		{
			ShutdownNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateInputEvents")]
		internal static extern void UpdateInputEventsNative(byte trickleFastInputs);

		public static void UpdateInputEvents(bool trickleFastInputs)
		{
			UpdateInputEventsNative(trickleFastInputs ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateHoveredWindowAndCaptureFlags")]
		internal static extern void UpdateHoveredWindowAndCaptureFlagsNative();

		public static void UpdateHoveredWindowAndCaptureFlags()
		{
			UpdateHoveredWindowAndCaptureFlagsNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStartMouseMovingWindow")]
		internal static extern void StartMouseMovingWindowNative(ImGuiWindow* window);

		public static void StartMouseMovingWindow(ImGuiWindow* window)
		{
			StartMouseMovingWindowNative(window);
		}

		public static void StartMouseMovingWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				StartMouseMovingWindowNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igStartMouseMovingWindowOrNode")]
		internal static extern void StartMouseMovingWindowOrNodeNative(ImGuiWindow* window, ImGuiDockNode* node, byte undockFloatingNode);

		public static void StartMouseMovingWindowOrNode(ImGuiWindow* window, ImGuiDockNode* node, bool undockFloatingNode)
		{
			StartMouseMovingWindowOrNodeNative(window, node, undockFloatingNode ? (byte)1 : (byte)0);
		}

		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ImGuiDockNode* node, bool undockFloatingNode)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				StartMouseMovingWindowOrNodeNative((ImGuiWindow*)pwindow, node, undockFloatingNode ? (byte)1 : (byte)0);
			}
		}

		public static void StartMouseMovingWindowOrNode(ImGuiWindow* window, ref ImGuiDockNode node, bool undockFloatingNode)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				StartMouseMovingWindowOrNodeNative(window, (ImGuiDockNode*)pnode, undockFloatingNode ? (byte)1 : (byte)0);
			}
		}

		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ref ImGuiDockNode node, bool undockFloatingNode)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					StartMouseMovingWindowOrNodeNative((ImGuiWindow*)pwindow, (ImGuiDockNode*)pnode, undockFloatingNode ? (byte)1 : (byte)0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateMouseMovingWindowNewFrame")]
		internal static extern void UpdateMouseMovingWindowNewFrameNative();

		public static void UpdateMouseMovingWindowNewFrame()
		{
			UpdateMouseMovingWindowNewFrameNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igUpdateMouseMovingWindowEndFrame")]
		internal static extern void UpdateMouseMovingWindowEndFrameNative();

		public static void UpdateMouseMovingWindowEndFrame()
		{
			UpdateMouseMovingWindowEndFrameNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igAddContextHook")]
		internal static extern int AddContextHookNative(ImGuiContext* context, ImGuiContextHook* hook);

		public static int AddContextHook(ImGuiContext* context, ImGuiContextHook* hook)
		{
			int ret = AddContextHookNative(context, hook);
			return ret;
		}

		public static int AddContextHook(ref ImGuiContext context, ImGuiContextHook* hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				int ret = AddContextHookNative((ImGuiContext*)pcontext, hook);
				return ret;
			}
		}

		public static int AddContextHook(ImGuiContext* context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContextHook* phook = &hook)
			{
				int ret = AddContextHookNative(context, (ImGuiContextHook*)phook);
				return ret;
			}
		}

		public static int AddContextHook(ref ImGuiContext context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (ImGuiContextHook* phook = &hook)
				{
					int ret = AddContextHookNative((ImGuiContext*)pcontext, (ImGuiContextHook*)phook);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRemoveContextHook")]
		internal static extern void RemoveContextHookNative(ImGuiContext* context, int hookToRemove);

		public static void RemoveContextHook(ImGuiContext* context, int hookToRemove)
		{
			RemoveContextHookNative(context, hookToRemove);
		}

		public static void RemoveContextHook(ref ImGuiContext context, int hookToRemove)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				RemoveContextHookNative((ImGuiContext*)pcontext, hookToRemove);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCallContextHooks")]
		internal static extern void CallContextHooksNative(ImGuiContext* context, ImGuiContextHookType type);

		public static void CallContextHooks(ImGuiContext* context, ImGuiContextHookType type)
		{
			CallContextHooksNative(context, type);
		}

		public static void CallContextHooks(ref ImGuiContext context, ImGuiContextHookType type)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				CallContextHooksNative((ImGuiContext*)pcontext, type);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTranslateWindowsInViewport")]
		internal static extern void TranslateWindowsInViewportNative(ImGuiViewportP* viewport, Vector2 oldPos, Vector2 newPos);

		public static void TranslateWindowsInViewport(ImGuiViewportP* viewport, Vector2 oldPos, Vector2 newPos)
		{
			TranslateWindowsInViewportNative(viewport, oldPos, newPos);
		}

		public static void TranslateWindowsInViewport(ref ImGuiViewportP viewport, Vector2 oldPos, Vector2 newPos)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				TranslateWindowsInViewportNative((ImGuiViewportP*)pviewport, oldPos, newPos);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScaleWindowsInViewport")]
		internal static extern void ScaleWindowsInViewportNative(ImGuiViewportP* viewport, float scale);

		public static void ScaleWindowsInViewport(ImGuiViewportP* viewport, float scale)
		{
			ScaleWindowsInViewportNative(viewport, scale);
		}

		public static void ScaleWindowsInViewport(ref ImGuiViewportP viewport, float scale)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ScaleWindowsInViewportNative((ImGuiViewportP*)pviewport, scale);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDestroyPlatformWindow")]
		internal static extern void DestroyPlatformWindowNative(ImGuiViewportP* viewport);

		public static void DestroyPlatformWindow(ImGuiViewportP* viewport)
		{
			DestroyPlatformWindowNative(viewport);
		}

		public static void DestroyPlatformWindow(ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DestroyPlatformWindowNative((ImGuiViewportP*)pviewport);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowViewport")]
		internal static extern void SetWindowViewportNative(ImGuiWindow* window, ImGuiViewportP* viewport);

		public static void SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
		{
			SetWindowViewportNative(window, viewport);
		}

		public static void SetWindowViewport(ref ImGuiWindow window, ImGuiViewportP* viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowViewportNative((ImGuiWindow*)pwindow, viewport);
			}
		}

		public static void SetWindowViewport(ImGuiWindow* window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				SetWindowViewportNative(window, (ImGuiViewportP*)pviewport);
			}
		}

		public static void SetWindowViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					SetWindowViewportNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetCurrentViewport")]
		internal static extern void SetCurrentViewportNative(ImGuiWindow* window, ImGuiViewportP* viewport);

		public static void SetCurrentViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
		{
			SetCurrentViewportNative(window, viewport);
		}

		public static void SetCurrentViewport(ref ImGuiWindow window, ImGuiViewportP* viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetCurrentViewportNative((ImGuiWindow*)pwindow, viewport);
			}
		}

		public static void SetCurrentViewport(ImGuiWindow* window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				SetCurrentViewportNative(window, (ImGuiViewportP*)pviewport);
			}
		}

		public static void SetCurrentViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					SetCurrentViewportNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetViewportPlatformMonitor")]
		internal static extern ImGuiPlatformMonitor* GetViewportPlatformMonitorNative(ImGuiViewport* viewport);

		public static ImGuiPlatformMonitorPtr GetViewportPlatformMonitor(ImGuiViewport* viewport)
		{
			ImGuiPlatformMonitorPtr ret = GetViewportPlatformMonitorNative(viewport);
			return ret;
		}

		public static ImGuiPlatformMonitorPtr GetViewportPlatformMonitor(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImGuiPlatformMonitorPtr ret = GetViewportPlatformMonitorNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindHoveredViewportFromPlatformWindowStack")]
		internal static extern ImGuiViewportP* FindHoveredViewportFromPlatformWindowStackNative(Vector2 mousePlatformPos);

		public static ImGuiViewportPPtr FindHoveredViewportFromPlatformWindowStack(Vector2 mousePlatformPos)
		{
			ImGuiViewportPPtr ret = FindHoveredViewportFromPlatformWindowStackNative(mousePlatformPos);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMarkIniSettingsDirty_Nil")]
		internal static extern void MarkIniSettingsDirtyNilNative();

		public static void MarkIniSettingsDirtyNil()
		{
			MarkIniSettingsDirtyNilNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMarkIniSettingsDirty_WindowPtr")]
		internal static extern void MarkIniSettingsDirtyWindowPtrNative(ImGuiWindow* window);

		public static void MarkIniSettingsDirtyWindowPtr(ImGuiWindow* window)
		{
			MarkIniSettingsDirtyWindowPtrNative(window);
		}

		public static void MarkIniSettingsDirtyWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				MarkIniSettingsDirtyWindowPtrNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClearIniSettings")]
		internal static extern void ClearIniSettingsNative();

		public static void ClearIniSettings()
		{
			ClearIniSettingsNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igAddSettingsHandler")]
		internal static extern void AddSettingsHandlerNative(ImGuiSettingsHandler* handler);

		public static void AddSettingsHandler(ImGuiSettingsHandler* handler)
		{
			AddSettingsHandlerNative(handler);
		}

		public static void AddSettingsHandler(ref ImGuiSettingsHandler handler)
		{
			fixed (ImGuiSettingsHandler* phandler = &handler)
			{
				AddSettingsHandlerNative((ImGuiSettingsHandler*)phandler);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRemoveSettingsHandler")]
		internal static extern void RemoveSettingsHandlerNative(byte* typeName);

		public static void RemoveSettingsHandler(byte* typeName)
		{
			RemoveSettingsHandlerNative(typeName);
		}

		public static void RemoveSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				RemoveSettingsHandlerNative((byte*)ptypeName);
			}
		}

		public static void RemoveSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RemoveSettingsHandlerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindSettingsHandler")]
		internal static extern ImGuiSettingsHandler* FindSettingsHandlerNative(byte* typeName);

		public static ImGuiSettingsHandlerPtr FindSettingsHandler(byte* typeName)
		{
			ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative(typeName);
			return ret;
		}

		public static ImGuiSettingsHandlerPtr FindSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative((byte*)ptypeName);
				return ret;
			}
		}

		public static ImGuiSettingsHandlerPtr FindSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCreateNewWindowSettings")]
		internal static extern ImGuiWindowSettings* CreateNewWindowSettingsNative(byte* name);

		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(byte* name)
		{
			ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative(name);
			return ret;
		}

		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative((byte*)pname);
				return ret;
			}
		}

		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowSettingsByID")]
		internal static extern ImGuiWindowSettings* FindWindowSettingsByIDNative(int id);

		public static ImGuiWindowSettingsPtr FindWindowSettingsByID(int id)
		{
			ImGuiWindowSettingsPtr ret = FindWindowSettingsByIDNative(id);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindWindowSettingsByWindow")]
		internal static extern ImGuiWindowSettings* FindWindowSettingsByWindowNative(ImGuiWindow* window);

		public static ImGuiWindowSettingsPtr FindWindowSettingsByWindow(ImGuiWindow* window)
		{
			ImGuiWindowSettingsPtr ret = FindWindowSettingsByWindowNative(window);
			return ret;
		}

		public static ImGuiWindowSettingsPtr FindWindowSettingsByWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowSettingsPtr ret = FindWindowSettingsByWindowNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClearWindowSettings")]
		internal static extern void ClearWindowSettingsNative(byte* name);

		public static void ClearWindowSettings(byte* name)
		{
			ClearWindowSettingsNative(name);
		}

		public static void ClearWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ClearWindowSettingsNative((byte*)pname);
			}
		}

		public static void ClearWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ClearWindowSettingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLocalizeRegisterEntries")]
		internal static extern void LocalizeRegisterEntriesNative(ImGuiLocEntry* entries, int count);

		public static void LocalizeRegisterEntries(ImGuiLocEntry* entries, int count)
		{
			LocalizeRegisterEntriesNative(entries, count);
		}

		public static void LocalizeRegisterEntries(ref ImGuiLocEntry entries, int count)
		{
			fixed (ImGuiLocEntry* pentries = &entries)
			{
				LocalizeRegisterEntriesNative((ImGuiLocEntry*)pentries, count);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLocalizeGetMsg")]
		internal static extern byte* LocalizeGetMsgNative(ImGuiLocKey key);

		public static byte* LocalizeGetMsg(ImGuiLocKey key)
		{
			byte* ret = LocalizeGetMsgNative(key);
			return ret;
		}

		public static string LocalizeGetMsgS(ImGuiLocKey key)
		{
			string ret = Utils.DecodeStringUTF8(LocalizeGetMsgNative(key));
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollX_WindowPtr")]
		internal static extern void SetScrollXWindowPtrNative(ImGuiWindow* window, float scrollX);

		public static void SetScrollXWindowPtr(ImGuiWindow* window, float scrollX)
		{
			SetScrollXWindowPtrNative(window, scrollX);
		}

		public static void SetScrollXWindowPtr(ref ImGuiWindow window, float scrollX)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollXWindowPtrNative((ImGuiWindow*)pwindow, scrollX);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollY_WindowPtr")]
		internal static extern void SetScrollYWindowPtrNative(ImGuiWindow* window, float scrollY);

		public static void SetScrollYWindowPtr(ImGuiWindow* window, float scrollY)
		{
			SetScrollYWindowPtrNative(window, scrollY);
		}

		public static void SetScrollYWindowPtr(ref ImGuiWindow window, float scrollY)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollYWindowPtrNative((ImGuiWindow*)pwindow, scrollY);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollFromPosX_WindowPtr")]
		internal static extern void SetScrollFromPosXWindowPtrNative(ImGuiWindow* window, float localX, float centerXRatio);

		public static void SetScrollFromPosXWindowPtr(ImGuiWindow* window, float localX, float centerXRatio)
		{
			SetScrollFromPosXWindowPtrNative(window, localX, centerXRatio);
		}

		public static void SetScrollFromPosXWindowPtr(ref ImGuiWindow window, float localX, float centerXRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollFromPosXWindowPtrNative((ImGuiWindow*)pwindow, localX, centerXRatio);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetScrollFromPosY_WindowPtr")]
		internal static extern void SetScrollFromPosYWindowPtrNative(ImGuiWindow* window, float localY, float centerYRatio);

		public static void SetScrollFromPosYWindowPtr(ImGuiWindow* window, float localY, float centerYRatio)
		{
			SetScrollFromPosYWindowPtrNative(window, localY, centerYRatio);
		}

		public static void SetScrollFromPosYWindowPtr(ref ImGuiWindow window, float localY, float centerYRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollFromPosYWindowPtrNative((ImGuiWindow*)pwindow, localY, centerYRatio);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollToItem")]
		internal static extern void ScrollToItemNative(ImGuiScrollFlags flags);

		public static void ScrollToItem(ImGuiScrollFlags flags)
		{
			ScrollToItemNative(flags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollToRect")]
		internal static extern void ScrollToRectNative(ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags);

		public static void ScrollToRect(ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags)
		{
			ScrollToRectNative(window, rect, flags);
		}

		public static void ScrollToRect(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRectNative((ImGuiWindow*)pwindow, rect, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollToRectEx")]
		internal static extern void ScrollToRectExNative(Vector2* output, ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags);

		public static Vector2 ScrollToRectEx(ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags)
		{
			Vector2 ret;
			ScrollToRectExNative(&ret, window, rect, flags);
			return ret;
		}

		public static void ScrollToRectEx(ref Vector2 output, ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* poutput = &output)
			{
				ScrollToRectExNative((Vector2*)poutput, window, rect, flags);
			}
		}

		public static Vector2 ScrollToRectEx(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				ScrollToRectExNative(&ret, (ImGuiWindow*)pwindow, rect, flags);
				return ret;
			}
		}

		public static void ScrollToRectEx(ref Vector2 output, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ScrollToRectExNative((Vector2*)poutput, (ImGuiWindow*)pwindow, rect, flags);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollToBringRectIntoView")]
		internal static extern void ScrollToBringRectIntoViewNative(ImGuiWindow* window, ImRect rect);

		public static void ScrollToBringRectIntoView(ImGuiWindow* window, ImRect rect)
		{
			ScrollToBringRectIntoViewNative(window, rect);
		}

		public static void ScrollToBringRectIntoView(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToBringRectIntoViewNative((ImGuiWindow*)pwindow, rect);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemStatusFlags")]
		internal static extern ImGuiItemStatusFlags GetItemStatusFlagsNative();

		public static ImGuiItemStatusFlags GetItemStatusFlags()
		{
			ImGuiItemStatusFlags ret = GetItemStatusFlagsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetItemFlags")]
		internal static extern ImGuiItemFlags GetItemFlagsNative();

		public static ImGuiItemFlags GetItemFlags()
		{
			ImGuiItemFlags ret = GetItemFlagsNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetActiveID")]
		internal static extern int GetActiveIDNative();

		public static int GetActiveID()
		{
			int ret = GetActiveIDNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetFocusID")]
		internal static extern int GetFocusIDNative();

		public static int GetFocusID()
		{
			int ret = GetFocusIDNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetActiveID")]
		internal static extern void SetActiveIDNative(int id, ImGuiWindow* window);

		public static void SetActiveID(int id, ImGuiWindow* window)
		{
			SetActiveIDNative(id, window);
		}

		public static void SetActiveID(int id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetActiveIDNative(id, (ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetFocusID")]
		internal static extern void SetFocusIDNative(int id, ImGuiWindow* window);

		public static void SetFocusID(int id, ImGuiWindow* window)
		{
			SetFocusIDNative(id, window);
		}

		public static void SetFocusID(int id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetFocusIDNative(id, (ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClearActiveID")]
		internal static extern void ClearActiveIDNative();

		public static void ClearActiveID()
		{
			ClearActiveIDNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetHoveredID")]
		internal static extern int GetHoveredIDNative();

		public static int GetHoveredID()
		{
			int ret = GetHoveredIDNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetHoveredID")]
		internal static extern void SetHoveredIDNative(int id);

		public static void SetHoveredID(int id)
		{
			SetHoveredIDNative(id);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igKeepAliveID")]
		internal static extern void KeepAliveIDNative(int id);

		public static void KeepAliveID(int id)
		{
			KeepAliveIDNative(id);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMarkItemEdited")]
		internal static extern void MarkItemEditedNative(int id);

		public static void MarkItemEdited(int id)
		{
			MarkItemEditedNative(id);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushOverrideID")]
		internal static extern void PushOverrideIDNative(int id);

		public static void PushOverrideID(int id)
		{
			PushOverrideIDNative(id);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetIDWithSeed_Str")]
		internal static extern int GetIDWithSeedNative(byte* strIdBegin, byte* strIdEnd, int seed);

		public static int GetIDWithSeed(byte* strIdBegin, byte* strIdEnd, int seed)
		{
			int ret = GetIDWithSeedNative(strIdBegin, strIdEnd, seed);
			return ret;
		}

		public static int GetIDWithSeed(ref byte strIdBegin, byte* strIdEnd, int seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				int ret = GetIDWithSeedNative((byte*)pstrIdBegin, strIdEnd, seed);
				return ret;
			}
		}

		public static int GetIDWithSeed(string strIdBegin, byte* strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDWithSeedNative(pStr0, strIdEnd, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetIDWithSeed(byte* strIdBegin, ref byte strIdEnd, int seed)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				int ret = GetIDWithSeedNative(strIdBegin, (byte*)pstrIdEnd, seed);
				return ret;
			}
		}

		public static int GetIDWithSeed(byte* strIdBegin, string strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetIDWithSeedNative(strIdBegin, pStr0, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetIDWithSeed(ref byte strIdBegin, ref byte strIdEnd, int seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					int ret = GetIDWithSeedNative((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		public static int GetIDWithSeed(string strIdBegin, string strIdEnd, int seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = GetIDWithSeedNative(pStr0, pStr1, seed);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetIDWithSeed_Int")]
		internal static extern int GetIDWithSeedIntNative(int n, int seed);

		public static int GetIDWithSeedInt(int n, int seed)
		{
			int ret = GetIDWithSeedIntNative(n, seed);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igItemSize_Vec2")]
		internal static extern void ItemSizeVec2Native(Vector2 size, float textBaselineY);

		public static void ItemSizeVec2(Vector2 size, float textBaselineY)
		{
			ItemSizeVec2Native(size, textBaselineY);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igItemSize_Rect")]
		internal static extern void ItemSizeRectNative(ImRect bb, float textBaselineY);

		public static void ItemSizeRect(ImRect bb, float textBaselineY)
		{
			ItemSizeRectNative(bb, textBaselineY);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igItemAdd")]
		internal static extern byte ItemAddNative(ImRect bb, int id, ImRect* navBb, ImGuiItemFlags extraFlags);

		public static bool ItemAdd(ImRect bb, int id, ImRect* navBb, ImGuiItemFlags extraFlags)
		{
			byte ret = ItemAddNative(bb, id, navBb, extraFlags);
			return ret != 0;
		}

		public static bool ItemAdd(ImRect bb, int id, ref ImRect navBb, ImGuiItemFlags extraFlags)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				byte ret = ItemAddNative(bb, id, (ImRect*)pnavBb, extraFlags);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igItemHoverable")]
		internal static extern byte ItemHoverableNative(ImRect bb, int id);

		public static bool ItemHoverable(ImRect bb, int id)
		{
			byte ret = ItemHoverableNative(bb, id);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsWindowContentHoverable")]
		internal static extern byte IsWindowContentHoverableNative(ImGuiWindow* window, ImGuiHoveredFlags flags);

		public static bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowContentHoverableNative(window, flags);
			return ret != 0;
		}

		public static bool IsWindowContentHoverable(ref ImGuiWindow window, ImGuiHoveredFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowContentHoverableNative((ImGuiWindow*)pwindow, flags);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsClippedEx")]
		internal static extern byte IsClippedExNative(ImRect bb, int id);

		public static bool IsClippedEx(ImRect bb, int id)
		{
			byte ret = IsClippedExNative(bb, id);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetLastItemData")]
		internal static extern void SetLastItemDataNative(int itemId, ImGuiItemFlags inFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect);

		public static void SetLastItemData(int itemId, ImGuiItemFlags inFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect)
		{
			SetLastItemDataNative(itemId, inFlags, statusFlags, itemRect);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcItemSize")]
		internal static extern void CalcItemSizeNative(Vector2* output, Vector2 size, float defaultW, float defaultH);

		public static Vector2 CalcItemSize(Vector2 size, float defaultW, float defaultH)
		{
			Vector2 ret;
			CalcItemSizeNative(&ret, size, defaultW, defaultH);
			return ret;
		}

		public static void CalcItemSize(ref Vector2 output, Vector2 size, float defaultW, float defaultH)
		{
			fixed (Vector2* poutput = &output)
			{
				CalcItemSizeNative((Vector2*)poutput, size, defaultW, defaultH);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcWrapWidthForPos")]
		internal static extern float CalcWrapWidthForPosNative(Vector2 pos, float wrapPosX);

		public static float CalcWrapWidthForPos(Vector2 pos, float wrapPosX)
		{
			float ret = CalcWrapWidthForPosNative(pos, wrapPosX);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushMultiItemsWidths")]
		internal static extern void PushMultiItemsWidthsNative(int components, float widthFull);

		public static void PushMultiItemsWidths(int components, float widthFull)
		{
			PushMultiItemsWidthsNative(components, widthFull);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsItemToggledSelection")]
		internal static extern byte IsItemToggledSelectionNative();

		public static bool IsItemToggledSelection()
		{
			byte ret = IsItemToggledSelectionNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetContentRegionMaxAbs")]
		internal static extern void GetContentRegionMaxAbsNative(Vector2* output);

		public static Vector2 GetContentRegionMaxAbs()
		{
			Vector2 ret;
			GetContentRegionMaxAbsNative(&ret);
			return ret;
		}

		public static void GetContentRegionMaxAbs(ref Vector2 output)
		{
			fixed (Vector2* poutput = &output)
			{
				GetContentRegionMaxAbsNative((Vector2*)poutput);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShrinkWidths")]
		internal static extern void ShrinkWidthsNative(ImGuiShrinkWidthItem* items, int count, float widthExcess);

		public static void ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float widthExcess)
		{
			ShrinkWidthsNative(items, count, widthExcess);
		}

		public static void ShrinkWidths(ref ImGuiShrinkWidthItem items, int count, float widthExcess)
		{
			fixed (ImGuiShrinkWidthItem* pitems = &items)
			{
				ShrinkWidthsNative((ImGuiShrinkWidthItem*)pitems, count, widthExcess);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushItemFlag")]
		internal static extern void PushItemFlagNative(ImGuiItemFlags option, byte enabled);

		public static void PushItemFlag(ImGuiItemFlags option, bool enabled)
		{
			PushItemFlagNative(option, enabled ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopItemFlag")]
		internal static extern void PopItemFlagNative();

		public static void PopItemFlag()
		{
			PopItemFlagNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetStyleVarInfo")]
		internal static extern ImGuiDataVarInfo* GetStyleVarInfoNative(ImGuiStyleVar idx);

		public static ImGuiDataVarInfoPtr GetStyleVarInfo(ImGuiStyleVar idx)
		{
			ImGuiDataVarInfoPtr ret = GetStyleVarInfoNative(idx);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogBegin")]
		internal static extern void LogBeginNative(ImGuiLogType type, int autoOpenDepth);

		public static void LogBegin(ImGuiLogType type, int autoOpenDepth)
		{
			LogBeginNative(type, autoOpenDepth);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogToBuffer")]
		internal static extern void LogToBufferNative(int autoOpenDepth);

		public static void LogToBuffer(int autoOpenDepth)
		{
			LogToBufferNative(autoOpenDepth);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogRenderedText")]
		internal static extern void LogRenderedTextNative(Vector2* refPos, byte* text, byte* textEnd);

		public static void LogRenderedText(Vector2* refPos, byte* text, byte* textEnd)
		{
			LogRenderedTextNative(refPos, text, textEnd);
		}

		public static void LogRenderedText(ref Vector2 refPos, byte* text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				LogRenderedTextNative((Vector2*)prefPos, text, textEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, textEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, ref byte text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, textEnd);
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, string text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				LogRenderedTextNative(refPos, text, (byte*)ptextEnd);
			}
		}

		public static void LogRenderedText(Vector2* refPos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, byte* text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative((Vector2*)prefPos, text, (byte*)ptextEnd);
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, byte* text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void LogRenderedText(Vector2* refPos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, ref byte text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public static void LogRenderedText(ref Vector2 refPos, string text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogSetNextTextDecoration")]
		internal static extern void LogSetNextTextDecorationNative(byte* prefix, byte* suffix);

		public static void LogSetNextTextDecoration(byte* prefix, byte* suffix)
		{
			LogSetNextTextDecorationNative(prefix, suffix);
		}

		public static void LogSetNextTextDecoration(ref byte prefix, byte* suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				LogSetNextTextDecorationNative((byte*)pprefix, suffix);
			}
		}

		public static void LogSetNextTextDecoration(string prefix, byte* suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogSetNextTextDecorationNative(pStr0, suffix);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogSetNextTextDecoration(byte* prefix, ref byte suffix)
		{
			fixed (byte* psuffix = &suffix)
			{
				LogSetNextTextDecorationNative(prefix, (byte*)psuffix);
			}
		}

		public static void LogSetNextTextDecoration(byte* prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (suffix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogSetNextTextDecorationNative(prefix, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LogSetNextTextDecoration(ref byte prefix, ref byte suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* psuffix = &suffix)
				{
					LogSetNextTextDecorationNative((byte*)pprefix, (byte*)psuffix);
				}
			}
		}

		public static void LogSetNextTextDecoration(string prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (suffix != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(suffix, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogSetNextTextDecorationNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginChildEx")]
		internal static extern byte BeginChildExNative(byte* name, int id, Vector2 sizeArg, byte border, ImGuiWindowFlags flags);

		public static bool BeginChildEx(byte* name, int id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			byte ret = BeginChildExNative(name, id, sizeArg, border ? (byte)1 : (byte)0, flags);
			return ret != 0;
		}

		public static bool BeginChildEx(ref byte name, int id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginChildExNative((byte*)pname, id, sizeArg, border ? (byte)1 : (byte)0, flags);
				return ret != 0;
			}
		}

		public static bool BeginChildEx(string name, int id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildExNative(pStr0, id, sizeArg, border ? (byte)1 : (byte)0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igOpenPopupEx")]
		internal static extern void OpenPopupExNative(int id, ImGuiPopupFlags popupFlags);

		public static void OpenPopupEx(int id, ImGuiPopupFlags popupFlags)
		{
			OpenPopupExNative(id, popupFlags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClosePopupToLevel")]
		internal static extern void ClosePopupToLevelNative(int remaining, byte restoreFocusToWindowUnderPopup);

		public static void ClosePopupToLevel(int remaining, bool restoreFocusToWindowUnderPopup)
		{
			ClosePopupToLevelNative(remaining, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClosePopupsOverWindow")]
		internal static extern void ClosePopupsOverWindowNative(ImGuiWindow* refWindow, byte restoreFocusToWindowUnderPopup);

		public static void ClosePopupsOverWindow(ImGuiWindow* refWindow, bool restoreFocusToWindowUnderPopup)
		{
			ClosePopupsOverWindowNative(refWindow, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
		}

		public static void ClosePopupsOverWindow(ref ImGuiWindow refWindow, bool restoreFocusToWindowUnderPopup)
		{
			fixed (ImGuiWindow* prefWindow = &refWindow)
			{
				ClosePopupsOverWindowNative((ImGuiWindow*)prefWindow, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClosePopupsExceptModals")]
		internal static extern void ClosePopupsExceptModalsNative();

		public static void ClosePopupsExceptModals()
		{
			ClosePopupsExceptModalsNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsPopupOpen_ID")]
		internal static extern byte IsPopupOpenIDNative(int id, ImGuiPopupFlags popupFlags);

		public static bool IsPopupOpenID(int id, ImGuiPopupFlags popupFlags)
		{
			byte ret = IsPopupOpenIDNative(id, popupFlags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginPopupEx")]
		internal static extern byte BeginPopupExNative(int id, ImGuiWindowFlags extraFlags);

		public static bool BeginPopupEx(int id, ImGuiWindowFlags extraFlags)
		{
			byte ret = BeginPopupExNative(id, extraFlags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTooltipEx")]
		internal static extern byte BeginTooltipExNative(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags);

		public static bool BeginTooltipEx(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags)
		{
			byte ret = BeginTooltipExNative(tooltipFlags, extraWindowFlags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetPopupAllowedExtentRect")]
		internal static extern void GetPopupAllowedExtentRectNative(ImRect* output, ImGuiWindow* window);

		public static ImRect GetPopupAllowedExtentRect(ImGuiWindow* window)
		{
			ImRect ret;
			GetPopupAllowedExtentRectNative(&ret, window);
			return ret;
		}

		public static void GetPopupAllowedExtentRect(ref ImRect output, ImGuiWindow* window)
		{
			fixed (ImRect* poutput = &output)
			{
				GetPopupAllowedExtentRectNative((ImRect*)poutput, window);
			}
		}

		public static ImRect GetPopupAllowedExtentRect(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				GetPopupAllowedExtentRectNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		public static void GetPopupAllowedExtentRect(ref ImRect output, ref ImGuiWindow window)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					GetPopupAllowedExtentRectNative((ImRect*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTopMostPopupModal")]
		internal static extern ImGuiWindow* GetTopMostPopupModalNative();

		public static ImGuiWindowPtr GetTopMostPopupModal()
		{
			ImGuiWindowPtr ret = GetTopMostPopupModalNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTopMostAndVisiblePopupModal")]
		internal static extern ImGuiWindow* GetTopMostAndVisiblePopupModalNative();

		public static ImGuiWindowPtr GetTopMostAndVisiblePopupModal()
		{
			ImGuiWindowPtr ret = GetTopMostAndVisiblePopupModalNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindBlockingModal")]
		internal static extern ImGuiWindow* FindBlockingModalNative(ImGuiWindow* window);

		public static ImGuiWindowPtr FindBlockingModal(ImGuiWindow* window)
		{
			ImGuiWindowPtr ret = FindBlockingModalNative(window);
			return ret;
		}

		public static ImGuiWindowPtr FindBlockingModal(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowPtr ret = FindBlockingModalNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindBestWindowPosForPopup")]
		internal static extern void FindBestWindowPosForPopupNative(Vector2* output, ImGuiWindow* window);

		public static Vector2 FindBestWindowPosForPopup(ImGuiWindow* window)
		{
			Vector2 ret;
			FindBestWindowPosForPopupNative(&ret, window);
			return ret;
		}

		public static void FindBestWindowPosForPopup(ref Vector2 output, ImGuiWindow* window)
		{
			fixed (Vector2* poutput = &output)
			{
				FindBestWindowPosForPopupNative((Vector2*)poutput, window);
			}
		}

		public static Vector2 FindBestWindowPosForPopup(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				FindBestWindowPosForPopupNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		public static void FindBestWindowPosForPopup(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					FindBestWindowPosForPopupNative((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindBestWindowPosForPopupEx")]
		internal static extern void FindBestWindowPosForPopupExNative(Vector2* output, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy);

		public static Vector2 FindBestWindowPosForPopupEx(Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			Vector2 ret;
			FindBestWindowPosForPopupExNative(&ret, refPos, size, lastDir, rOuter, rAvoid, policy);
			return ret;
		}

		public static void FindBestWindowPosForPopupEx(ref Vector2 output, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* poutput = &output)
			{
				FindBestWindowPosForPopupExNative((Vector2*)poutput, refPos, size, lastDir, rOuter, rAvoid, policy);
			}
		}

		public static Vector2 FindBestWindowPosForPopupEx(Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (ImGuiDir* plastDir = &lastDir)
			{
				Vector2 ret;
				FindBestWindowPosForPopupExNative(&ret, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				return ret;
			}
		}

		public static void FindBestWindowPosForPopupEx(ref Vector2 output, Vector2 refPos, Vector2 size, ref ImGuiDir lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiDir* plastDir = &lastDir)
				{
					FindBestWindowPosForPopupExNative((Vector2*)poutput, refPos, size, (ImGuiDir*)plastDir, rOuter, rAvoid, policy);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginViewportSideBar")]
		internal static extern byte BeginViewportSideBarNative(byte* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags);

		public static bool BeginViewportSideBar(byte* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginViewportSideBarNative(name, viewport, dir, size, windowFlags);
			return ret != 0;
		}

		public static bool BeginViewportSideBar(ref byte name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginViewportSideBarNative((byte*)pname, viewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginViewportSideBar(string name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginViewportSideBarNative(pStr0, viewport, dir, size, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginViewportSideBar(byte* name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = BeginViewportSideBarNative(name, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				return ret != 0;
			}
		}

		public static bool BeginViewportSideBar(ref byte name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					byte ret = BeginViewportSideBarNative((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret != 0;
				}
			}
		}

		public static bool BeginViewportSideBar(string name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = BeginViewportSideBarNative(pStr0, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginMenuEx")]
		internal static extern byte BeginMenuExNative(byte* label, byte* icon, byte enabled);

		public static bool BeginMenuEx(byte* label, byte* icon, bool enabled)
		{
			byte ret = BeginMenuExNative(label, icon, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool BeginMenuEx(ref byte label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginMenuExNative((byte*)plabel, icon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenuEx(string label, byte* icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, icon, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginMenuEx(byte* label, ref byte icon, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = BeginMenuExNative(label, (byte*)picon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool BeginMenuEx(byte* label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginMenuExNative(label, pStr0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginMenuEx(ref byte label, ref byte icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = BeginMenuExNative((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool BeginMenuEx(string label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = BeginMenuExNative(pStr0, pStr1, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMenuItemEx")]
		internal static extern byte MenuItemExNative(byte* label, byte* icon, byte* shortcut, byte selected, byte enabled);

		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte ret = MenuItemExNative(label, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = MenuItemExNative((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(string label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = MenuItemExNative(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(byte* label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(string label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemExNative(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItemEx(byte* label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemExNative(label, icon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(string label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(pStr0, icon, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = MenuItemExNative(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItemEx(byte* label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = MenuItemExNative(label, pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = MenuItemExNative((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		public static bool MenuItemEx(string label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = MenuItemExNative(pStr0, pStr1, pStr2, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginComboPopup")]
		internal static extern byte BeginComboPopupNative(int popupId, ImRect bb, ImGuiComboFlags flags);

		public static bool BeginComboPopup(int popupId, ImRect bb, ImGuiComboFlags flags)
		{
			byte ret = BeginComboPopupNative(popupId, bb, flags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginComboPreview")]
		internal static extern byte BeginComboPreviewNative();

		public static bool BeginComboPreview()
		{
			byte ret = BeginComboPreviewNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndComboPreview")]
		internal static extern void EndComboPreviewNative();

		public static void EndComboPreview()
		{
			EndComboPreviewNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavInitWindow")]
		internal static extern void NavInitWindowNative(ImGuiWindow* window, byte forceReinit);

		public static void NavInitWindow(ImGuiWindow* window, bool forceReinit)
		{
			NavInitWindowNative(window, forceReinit ? (byte)1 : (byte)0);
		}

		public static void NavInitWindow(ref ImGuiWindow window, bool forceReinit)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavInitWindowNative((ImGuiWindow*)pwindow, forceReinit ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavInitRequestApplyResult")]
		internal static extern void NavInitRequestApplyResultNative();

		public static void NavInitRequestApplyResult()
		{
			NavInitRequestApplyResultNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestButNoResultYet")]
		internal static extern byte NavMoveRequestButNoResultYetNative();

		public static bool NavMoveRequestButNoResultYet()
		{
			byte ret = NavMoveRequestButNoResultYetNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestSubmit")]
		internal static extern void NavMoveRequestSubmitNative(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags);

		public static void NavMoveRequestSubmit(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			NavMoveRequestSubmitNative(moveDir, clipDir, moveFlags, scrollFlags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestForward")]
		internal static extern void NavMoveRequestForwardNative(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags);

		public static void NavMoveRequestForward(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			NavMoveRequestForwardNative(moveDir, clipDir, moveFlags, scrollFlags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestResolveWithLastItem")]
		internal static extern void NavMoveRequestResolveWithLastItemNative(ImGuiNavItemData* result);

		public static void NavMoveRequestResolveWithLastItem(ImGuiNavItemData* result)
		{
			NavMoveRequestResolveWithLastItemNative(result);
		}

		public static void NavMoveRequestResolveWithLastItem(ref ImGuiNavItemData result)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				NavMoveRequestResolveWithLastItemNative((ImGuiNavItemData*)presult);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestCancel")]
		internal static extern void NavMoveRequestCancelNative();

		public static void NavMoveRequestCancel()
		{
			NavMoveRequestCancelNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestApplyResult")]
		internal static extern void NavMoveRequestApplyResultNative();

		public static void NavMoveRequestApplyResult()
		{
			NavMoveRequestApplyResultNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavMoveRequestTryWrapping")]
		internal static extern void NavMoveRequestTryWrappingNative(ImGuiWindow* window, ImGuiNavMoveFlags moveFlags);

		public static void NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags moveFlags)
		{
			NavMoveRequestTryWrappingNative(window, moveFlags);
		}

		public static void NavMoveRequestTryWrapping(ref ImGuiWindow window, ImGuiNavMoveFlags moveFlags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				NavMoveRequestTryWrappingNative((ImGuiWindow*)pwindow, moveFlags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavClearPreferredPosForAxis")]
		internal static extern void NavClearPreferredPosForAxisNative(ImGuiAxis axis);

		public static void NavClearPreferredPosForAxis(ImGuiAxis axis)
		{
			NavClearPreferredPosForAxisNative(axis);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igNavUpdateCurrentWindowIsScrollPushableX")]
		internal static extern void NavUpdateCurrentWindowIsScrollPushableXNative();

		public static void NavUpdateCurrentWindowIsScrollPushableX()
		{
			NavUpdateCurrentWindowIsScrollPushableXNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igActivateItem")]
		internal static extern void ActivateItemNative(int id);

		public static void ActivateItem(int id)
		{
			ActivateItemNative(id);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNavWindow")]
		internal static extern void SetNavWindowNative(ImGuiWindow* window);

		public static void SetNavWindow(ImGuiWindow* window)
		{
			SetNavWindowNative(window);
		}

		public static void SetNavWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetNavWindowNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetNavID")]
		internal static extern void SetNavIDNative(int id, ImGuiNavLayer navLayer, int focusScopeId, ImRect rectRel);

		public static void SetNavID(int id, ImGuiNavLayer navLayer, int focusScopeId, ImRect rectRel)
		{
			SetNavIDNative(id, navLayer, focusScopeId, rectRel);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsNamedKey")]
		internal static extern byte IsNamedKeyNative(ImGuiKey key);

		public static bool IsNamedKey(ImGuiKey key)
		{
			byte ret = IsNamedKeyNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsNamedKeyOrModKey")]
		internal static extern byte IsNamedKeyOrModKeyNative(ImGuiKey key);

		public static bool IsNamedKeyOrModKey(ImGuiKey key)
		{
			byte ret = IsNamedKeyOrModKeyNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsLegacyKey")]
		internal static extern byte IsLegacyKeyNative(ImGuiKey key);

		public static bool IsLegacyKey(ImGuiKey key)
		{
			byte ret = IsLegacyKeyNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyboardKey")]
		internal static extern byte IsKeyboardKeyNative(ImGuiKey key);

		public static bool IsKeyboardKey(ImGuiKey key)
		{
			byte ret = IsKeyboardKeyNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsGamepadKey")]
		internal static extern byte IsGamepadKeyNative(ImGuiKey key);

		public static bool IsGamepadKey(ImGuiKey key)
		{
			byte ret = IsGamepadKeyNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseKey")]
		internal static extern byte IsMouseKeyNative(ImGuiKey key);

		public static bool IsMouseKey(ImGuiKey key)
		{
			byte ret = IsMouseKeyNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsAliasKey")]
		internal static extern byte IsAliasKeyNative(ImGuiKey key);

		public static bool IsAliasKey(ImGuiKey key)
		{
			byte ret = IsAliasKeyNative(key);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igConvertShortcutMod")]
		internal static extern int ConvertShortcutModNative(int keyChord);

		public static int ConvertShortcutMod(int keyChord)
		{
			int ret = ConvertShortcutModNative(keyChord);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igConvertSingleModFlagToKey")]
		internal static extern ImGuiKey ConvertSingleModFlagToKeyNative(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKey ConvertSingleModFlagToKey(ImGuiContext* ctx, ImGuiKey key)
		{
			ImGuiKey ret = ConvertSingleModFlagToKeyNative(ctx, key);
			return ret;
		}

		public static ImGuiKey ConvertSingleModFlagToKey(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKey ret = ConvertSingleModFlagToKeyNative((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyData_ContextPtr")]
		internal static extern ImGuiKeyData* GetKeyDataContextPtrNative(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKeyDataPtr GetKeyDataContextPtr(ImGuiContext* ctx, ImGuiKey key)
		{
			ImGuiKeyDataPtr ret = GetKeyDataContextPtrNative(ctx, key);
			return ret;
		}

		public static ImGuiKeyDataPtr GetKeyDataContextPtr(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKeyDataPtr ret = GetKeyDataContextPtrNative((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyData_Key")]
		internal static extern ImGuiKeyData* GetKeyDataKeyNative(ImGuiKey key);

		public static ImGuiKeyDataPtr GetKeyDataKey(ImGuiKey key)
		{
			ImGuiKeyDataPtr ret = GetKeyDataKeyNative(key);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyChordName")]
		internal static extern void GetKeyChordNameNative(int keyChord, byte* outBuf, int outBufSize);

		public static void GetKeyChordName(int keyChord, byte* outBuf, int outBufSize)
		{
			GetKeyChordNameNative(keyChord, outBuf, outBufSize);
		}

		public static void GetKeyChordName(int keyChord, ref byte outBuf, int outBufSize)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				GetKeyChordNameNative(keyChord, (byte*)poutBuf, outBufSize);
			}
		}

		public static void GetKeyChordName(int keyChord, ref string outBuf, int outBufSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (outBuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(outBuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(outBuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetKeyChordNameNative(keyChord, pStr0, outBufSize);
			outBuf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igMouseButtonToKey")]
		internal static extern ImGuiKey MouseButtonToKeyNative(ImGuiMouseButton button);

		public static ImGuiKey MouseButtonToKey(ImGuiMouseButton button)
		{
			ImGuiKey ret = MouseButtonToKeyNative(button);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDragPastThreshold")]
		internal static extern byte IsMouseDragPastThresholdNative(ImGuiMouseButton button, float lockThreshold);

		public static bool IsMouseDragPastThreshold(ImGuiMouseButton button, float lockThreshold)
		{
			byte ret = IsMouseDragPastThresholdNative(button, lockThreshold);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyMagnitude2d")]
		internal static extern void GetKeyMagnitude2dNative(Vector2* output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown);

		public static Vector2 GetKeyMagnitude2d(ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			Vector2 ret;
			GetKeyMagnitude2dNative(&ret, keyLeft, keyRight, keyUp, keyDown);
			return ret;
		}

		public static void GetKeyMagnitude2d(ref Vector2 output, ImGuiKey keyLeft, ImGuiKey keyRight, ImGuiKey keyUp, ImGuiKey keyDown)
		{
			fixed (Vector2* poutput = &output)
			{
				GetKeyMagnitude2dNative((Vector2*)poutput, keyLeft, keyRight, keyUp, keyDown);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetNavTweakPressedAmount")]
		internal static extern float GetNavTweakPressedAmountNative(ImGuiAxis axis);

		public static float GetNavTweakPressedAmount(ImGuiAxis axis)
		{
			float ret = GetNavTweakPressedAmountNative(axis);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcTypematicRepeatAmount")]
		internal static extern int CalcTypematicRepeatAmountNative(float t0, float t1, float repeatDelay, float repeatRate);

		public static int CalcTypematicRepeatAmount(float t0, float t1, float repeatDelay, float repeatRate)
		{
			int ret = CalcTypematicRepeatAmountNative(t0, t1, repeatDelay, repeatRate);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetTypematicRepeatRate")]
		internal static extern void GetTypematicRepeatRateNative(ImGuiInputFlags flags, float* repeatDelay, float* repeatRate);

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeatDelay, float* repeatRate)
		{
			GetTypematicRepeatRateNative(flags, repeatDelay, repeatRate);
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, ref float repeatDelay, float* repeatRate)
		{
			fixed (float* prepeatDelay = &repeatDelay)
			{
				GetTypematicRepeatRateNative(flags, (float*)prepeatDelay, repeatRate);
			}
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeatDelay, ref float repeatRate)
		{
			fixed (float* prepeatRate = &repeatRate)
			{
				GetTypematicRepeatRateNative(flags, repeatDelay, (float*)prepeatRate);
			}
		}

		public static void GetTypematicRepeatRate(ImGuiInputFlags flags, ref float repeatDelay, ref float repeatRate)
		{
			fixed (float* prepeatDelay = &repeatDelay)
			{
				fixed (float* prepeatRate = &repeatRate)
				{
					GetTypematicRepeatRateNative(flags, (float*)prepeatDelay, (float*)prepeatRate);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetActiveIdUsingAllKeyboardKeys")]
		internal static extern void SetActiveIdUsingAllKeyboardKeysNative();

		public static void SetActiveIdUsingAllKeyboardKeys()
		{
			SetActiveIdUsingAllKeyboardKeysNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsActiveIdUsingNavDir")]
		internal static extern byte IsActiveIdUsingNavDirNative(ImGuiDir dir);

		public static bool IsActiveIdUsingNavDir(ImGuiDir dir)
		{
			byte ret = IsActiveIdUsingNavDirNative(dir);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyOwner")]
		internal static extern int GetKeyOwnerNative(ImGuiKey key);

		public static int GetKeyOwner(ImGuiKey key)
		{
			int ret = GetKeyOwnerNative(key);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetKeyOwner")]
		internal static extern void SetKeyOwnerNative(ImGuiKey key, int ownerId, ImGuiInputFlags flags);

		public static void SetKeyOwner(ImGuiKey key, int ownerId, ImGuiInputFlags flags)
		{
			SetKeyOwnerNative(key, ownerId, flags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetKeyOwnersForKeyChord")]
		internal static extern void SetKeyOwnersForKeyChordNative(int key, int ownerId, ImGuiInputFlags flags);

		public static void SetKeyOwnersForKeyChord(int key, int ownerId, ImGuiInputFlags flags)
		{
			SetKeyOwnersForKeyChordNative(key, ownerId, flags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetItemKeyOwner")]
		internal static extern void SetItemKeyOwnerNative(ImGuiKey key, ImGuiInputFlags flags);

		public static void SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags)
		{
			SetItemKeyOwnerNative(key, flags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTestKeyOwner")]
		internal static extern byte TestKeyOwnerNative(ImGuiKey key, int ownerId);

		public static bool TestKeyOwner(ImGuiKey key, int ownerId)
		{
			byte ret = TestKeyOwnerNative(key, ownerId);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetKeyOwnerData")]
		internal static extern ImGuiKeyOwnerData* GetKeyOwnerDataNative(ImGuiContext* ctx, ImGuiKey key);

		public static ImGuiKeyOwnerDataPtr GetKeyOwnerData(ImGuiContext* ctx, ImGuiKey key)
		{
			ImGuiKeyOwnerDataPtr ret = GetKeyOwnerDataNative(ctx, key);
			return ret;
		}

		public static ImGuiKeyOwnerDataPtr GetKeyOwnerData(ref ImGuiContext ctx, ImGuiKey key)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiKeyOwnerDataPtr ret = GetKeyOwnerDataNative((ImGuiContext*)pctx, key);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyDown_ID")]
		internal static extern byte IsKeyDownIDNative(ImGuiKey key, int ownerId);

		public static bool IsKeyDownID(ImGuiKey key, int ownerId)
		{
			byte ret = IsKeyDownIDNative(key, ownerId);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyPressed_ID")]
		internal static extern byte IsKeyPressedIDNative(ImGuiKey key, int ownerId, ImGuiInputFlags flags);

		public static bool IsKeyPressedID(ImGuiKey key, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = IsKeyPressedIDNative(key, ownerId, flags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyReleased_ID")]
		internal static extern byte IsKeyReleasedIDNative(ImGuiKey key, int ownerId);

		public static bool IsKeyReleasedID(ImGuiKey key, int ownerId)
		{
			byte ret = IsKeyReleasedIDNative(key, ownerId);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseDown_ID")]
		internal static extern byte IsMouseDownIDNative(ImGuiMouseButton button, int ownerId);

		public static bool IsMouseDownID(ImGuiMouseButton button, int ownerId)
		{
			byte ret = IsMouseDownIDNative(button, ownerId);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseClicked_ID")]
		internal static extern byte IsMouseClickedIDNative(ImGuiMouseButton button, int ownerId, ImGuiInputFlags flags);

		public static bool IsMouseClickedID(ImGuiMouseButton button, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = IsMouseClickedIDNative(button, ownerId, flags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsMouseReleased_ID")]
		internal static extern byte IsMouseReleasedIDNative(ImGuiMouseButton button, int ownerId);

		public static bool IsMouseReleasedID(ImGuiMouseButton button, int ownerId)
		{
			byte ret = IsMouseReleasedIDNative(button, ownerId);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShortcut")]
		internal static extern byte ShortcutNative(int keyChord, int ownerId, ImGuiInputFlags flags);

		public static bool Shortcut(int keyChord, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = ShortcutNative(keyChord, ownerId, flags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetShortcutRouting")]
		internal static extern byte SetShortcutRoutingNative(int keyChord, int ownerId, ImGuiInputFlags flags);

		public static bool SetShortcutRouting(int keyChord, int ownerId, ImGuiInputFlags flags)
		{
			byte ret = SetShortcutRoutingNative(keyChord, ownerId, flags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTestShortcutRouting")]
		internal static extern byte TestShortcutRoutingNative(int keyChord, int ownerId);

		public static bool TestShortcutRouting(int keyChord, int ownerId)
		{
			byte ret = TestShortcutRoutingNative(keyChord, ownerId);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetShortcutRoutingData")]
		internal static extern ImGuiKeyRoutingData* GetShortcutRoutingDataNative(int keyChord);

		public static ImGuiKeyRoutingDataPtr GetShortcutRoutingData(int keyChord)
		{
			ImGuiKeyRoutingDataPtr ret = GetShortcutRoutingDataNative(keyChord);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextInitialize")]
		internal static extern void DockContextInitializeNative(ImGuiContext* ctx);

		public static void DockContextInitialize(ImGuiContext* ctx)
		{
			DockContextInitializeNative(ctx);
		}

		public static void DockContextInitialize(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextInitializeNative((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextShutdown")]
		internal static extern void DockContextShutdownNative(ImGuiContext* ctx);

		public static void DockContextShutdown(ImGuiContext* ctx)
		{
			DockContextShutdownNative(ctx);
		}

		public static void DockContextShutdown(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextShutdownNative((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextClearNodes")]
		internal static extern void DockContextClearNodesNative(ImGuiContext* ctx, int rootId, byte clearSettingsRefs);

		public static void DockContextClearNodes(ImGuiContext* ctx, int rootId, bool clearSettingsRefs)
		{
			DockContextClearNodesNative(ctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
		}

		public static void DockContextClearNodes(ref ImGuiContext ctx, int rootId, bool clearSettingsRefs)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextClearNodesNative((ImGuiContext*)pctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextRebuildNodes")]
		internal static extern void DockContextRebuildNodesNative(ImGuiContext* ctx);

		public static void DockContextRebuildNodes(ImGuiContext* ctx)
		{
			DockContextRebuildNodesNative(ctx);
		}

		public static void DockContextRebuildNodes(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextRebuildNodesNative((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextNewFrameUpdateUndocking")]
		internal static extern void DockContextNewFrameUpdateUndockingNative(ImGuiContext* ctx);

		public static void DockContextNewFrameUpdateUndocking(ImGuiContext* ctx)
		{
			DockContextNewFrameUpdateUndockingNative(ctx);
		}

		public static void DockContextNewFrameUpdateUndocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateUndockingNative((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextNewFrameUpdateDocking")]
		internal static extern void DockContextNewFrameUpdateDockingNative(ImGuiContext* ctx);

		public static void DockContextNewFrameUpdateDocking(ImGuiContext* ctx)
		{
			DockContextNewFrameUpdateDockingNative(ctx);
		}

		public static void DockContextNewFrameUpdateDocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextNewFrameUpdateDockingNative((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextEndFrame")]
		internal static extern void DockContextEndFrameNative(ImGuiContext* ctx);

		public static void DockContextEndFrame(ImGuiContext* ctx)
		{
			DockContextEndFrameNative(ctx);
		}

		public static void DockContextEndFrame(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextEndFrameNative((ImGuiContext*)pctx);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextGenNodeID")]
		internal static extern int DockContextGenNodeIDNative(ImGuiContext* ctx);

		public static int DockContextGenNodeID(ImGuiContext* ctx)
		{
			int ret = DockContextGenNodeIDNative(ctx);
			return ret;
		}

		public static int DockContextGenNodeID(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				int ret = DockContextGenNodeIDNative((ImGuiContext*)pctx);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextQueueDock")]
		internal static extern void DockContextQueueDockNative(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, byte splitOuter);

		public static void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			DockContextQueueDockNative(ctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueDockNative((ImGuiContext*)pctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				DockContextQueueDockNative(ctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ppayload = &payload)
			{
				DockContextQueueDockNative(ctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative((ImGuiContext*)pctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					DockContextQueueDockNative(ctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ImGuiContext* ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						DockContextQueueDockNative(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						fixed (ImGuiWindow* ppayload = &payload)
						{
							DockContextQueueDockNative((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextQueueUndockWindow")]
		internal static extern void DockContextQueueUndockWindowNative(ImGuiContext* ctx, ImGuiWindow* window);

		public static void DockContextQueueUndockWindow(ImGuiContext* ctx, ImGuiWindow* window)
		{
			DockContextQueueUndockWindowNative(ctx, window);
		}

		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ImGuiWindow* window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockWindowNative((ImGuiContext*)pctx, window);
			}
		}

		public static void DockContextQueueUndockWindow(ImGuiContext* ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextQueueUndockWindowNative(ctx, (ImGuiWindow*)pwindow);
			}
		}

		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextQueueUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextQueueUndockNode")]
		internal static extern void DockContextQueueUndockNodeNative(ImGuiContext* ctx, ImGuiDockNode* node);

		public static void DockContextQueueUndockNode(ImGuiContext* ctx, ImGuiDockNode* node)
		{
			DockContextQueueUndockNodeNative(ctx, node);
		}

		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ImGuiDockNode* node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextQueueUndockNodeNative((ImGuiContext*)pctx, node);
			}
		}

		public static void DockContextQueueUndockNode(ImGuiContext* ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextQueueUndockNodeNative(ctx, (ImGuiDockNode*)pnode);
			}
		}

		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextQueueUndockNodeNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextProcessUndockWindow")]
		internal static extern void DockContextProcessUndockWindowNative(ImGuiContext* ctx, ImGuiWindow* window, byte clearPersistentDockingRef);

		public static void DockContextProcessUndockWindow(ImGuiContext* ctx, ImGuiWindow* window, bool clearPersistentDockingRef)
		{
			DockContextProcessUndockWindowNative(ctx, window, clearPersistentDockingRef ? (byte)1 : (byte)0);
		}

		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ImGuiWindow* window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockWindowNative((ImGuiContext*)pctx, window, clearPersistentDockingRef ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextProcessUndockWindow(ImGuiContext* ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DockContextProcessUndockWindowNative(ctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef ? (byte)1 : (byte)0);
			}
		}

		public static void DockContextProcessUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window, bool clearPersistentDockingRef)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					DockContextProcessUndockWindowNative((ImGuiContext*)pctx, (ImGuiWindow*)pwindow, clearPersistentDockingRef ? (byte)1 : (byte)0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextProcessUndockNode")]
		internal static extern void DockContextProcessUndockNodeNative(ImGuiContext* ctx, ImGuiDockNode* node);

		public static void DockContextProcessUndockNode(ImGuiContext* ctx, ImGuiDockNode* node)
		{
			DockContextProcessUndockNodeNative(ctx, node);
		}

		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ImGuiDockNode* node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockContextProcessUndockNodeNative((ImGuiContext*)pctx, node);
			}
		}

		public static void DockContextProcessUndockNode(ImGuiContext* ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockContextProcessUndockNodeNative(ctx, (ImGuiDockNode*)pnode);
			}
		}

		public static void DockContextProcessUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockContextProcessUndockNodeNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextCalcDropPosForDocking")]
		internal static extern byte DockContextCalcDropPosForDockingNative(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, byte splitOuter, Vector2* outPos);

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
			return ret != 0;
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (Vector2* poutPos = &outPos)
			{
				byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
				return ret != 0;
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ImGuiDockNode* payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, payloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindow* payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
			{
				fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = DockContextCalcDropPosForDockingNative(target, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNode* targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
				{
					fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = DockContextCalcDropPosForDockingNative(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payloadWindow, ref ImGuiDockNode payloadNode, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayloadWindow = &payloadWindow)
					{
						fixed (ImGuiDockNode* ppayloadNode = &payloadNode)
						{
							fixed (Vector2* poutPos = &outPos)
							{
								byte ret = DockContextCalcDropPosForDockingNative((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayloadWindow, (ImGuiDockNode*)ppayloadNode, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockContextFindNodeByID")]
		internal static extern ImGuiDockNode* DockContextFindNodeByIDNative(ImGuiContext* ctx, int id);

		public static ImGuiDockNodePtr DockContextFindNodeByID(ImGuiContext* ctx, int id)
		{
			ImGuiDockNodePtr ret = DockContextFindNodeByIDNative(ctx, id);
			return ret;
		}

		public static ImGuiDockNodePtr DockContextFindNodeByID(ref ImGuiContext ctx, int id)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiDockNodePtr ret = DockContextFindNodeByIDNative((ImGuiContext*)pctx, id);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeWindowMenuHandler_Default")]
		internal static extern void DockNodeWindowMenuHandlerDefaultNative(ImGuiContext* ctx, ImGuiDockNode* node, ImGuiTabBar* tabBar);

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContext* ctx, ImGuiDockNode* node, ImGuiTabBar* tabBar)
		{
			DockNodeWindowMenuHandlerDefaultNative(ctx, node, tabBar);
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ImGuiDockNode* node, ImGuiTabBar* tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, node, tabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContext* ctx, ref ImGuiDockNode node, ImGuiTabBar* tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DockNodeWindowMenuHandlerDefaultNative(ctx, (ImGuiDockNode*)pnode, tabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ref ImGuiDockNode node, ImGuiTabBar* tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, tabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContext* ctx, ImGuiDockNode* node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				DockNodeWindowMenuHandlerDefaultNative(ctx, node, (ImGuiTabBar*)ptabBar);
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ImGuiDockNode* node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, node, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ImGuiContext* ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiTabBar* ptabBar = &tabBar)
				{
					DockNodeWindowMenuHandlerDefaultNative(ctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
				}
			}
		}

		public static void DockNodeWindowMenuHandlerDefault(ref ImGuiContext ctx, ref ImGuiDockNode node, ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					fixed (ImGuiTabBar* ptabBar = &tabBar)
					{
						DockNodeWindowMenuHandlerDefaultNative((ImGuiContext*)pctx, (ImGuiDockNode*)pnode, (ImGuiTabBar*)ptabBar);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeBeginAmendTabBar")]
		internal static extern byte DockNodeBeginAmendTabBarNative(ImGuiDockNode* node);

		public static bool DockNodeBeginAmendTabBar(ImGuiDockNode* node)
		{
			byte ret = DockNodeBeginAmendTabBarNative(node);
			return ret != 0;
		}

		public static bool DockNodeBeginAmendTabBar(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = DockNodeBeginAmendTabBarNative((ImGuiDockNode*)pnode);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeEndAmendTabBar")]
		internal static extern void DockNodeEndAmendTabBarNative();

		public static void DockNodeEndAmendTabBar()
		{
			DockNodeEndAmendTabBarNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeGetRootNode")]
		internal static extern ImGuiDockNode* DockNodeGetRootNodeNative(ImGuiDockNode* node);

		public static ImGuiDockNodePtr DockNodeGetRootNode(ImGuiDockNode* node)
		{
			ImGuiDockNodePtr ret = DockNodeGetRootNodeNative(node);
			return ret;
		}

		public static ImGuiDockNodePtr DockNodeGetRootNode(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiDockNodePtr ret = DockNodeGetRootNodeNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeIsInHierarchyOf")]
		internal static extern byte DockNodeIsInHierarchyOfNative(ImGuiDockNode* node, ImGuiDockNode* parent);

		public static bool DockNodeIsInHierarchyOf(ImGuiDockNode* node, ImGuiDockNode* parent)
		{
			byte ret = DockNodeIsInHierarchyOfNative(node, parent);
			return ret != 0;
		}

		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ImGuiDockNode* parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = DockNodeIsInHierarchyOfNative((ImGuiDockNode*)pnode, parent);
				return ret != 0;
			}
		}

		public static bool DockNodeIsInHierarchyOf(ImGuiDockNode* node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pparent = &parent)
			{
				byte ret = DockNodeIsInHierarchyOfNative(node, (ImGuiDockNode*)pparent);
				return ret != 0;
			}
		}

		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiDockNode* pparent = &parent)
				{
					byte ret = DockNodeIsInHierarchyOfNative((ImGuiDockNode*)pnode, (ImGuiDockNode*)pparent);
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeGetDepth")]
		internal static extern int DockNodeGetDepthNative(ImGuiDockNode* node);

		public static int DockNodeGetDepth(ImGuiDockNode* node)
		{
			int ret = DockNodeGetDepthNative(node);
			return ret;
		}

		public static int DockNodeGetDepth(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetDepthNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockNodeGetWindowMenuButtonId")]
		internal static extern int DockNodeGetWindowMenuButtonIdNative(ImGuiDockNode* node);

		public static int DockNodeGetWindowMenuButtonId(ImGuiDockNode* node)
		{
			int ret = DockNodeGetWindowMenuButtonIdNative(node);
			return ret;
		}

		public static int DockNodeGetWindowMenuButtonId(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = DockNodeGetWindowMenuButtonIdNative((ImGuiDockNode*)pnode);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowDockNode")]
		internal static extern ImGuiDockNode* GetWindowDockNodeNative();

		public static ImGuiDockNodePtr GetWindowDockNode()
		{
			ImGuiDockNodePtr ret = GetWindowDockNodeNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowAlwaysWantOwnTabBar")]
		internal static extern byte GetWindowAlwaysWantOwnTabBarNative(ImGuiWindow* window);

		public static bool GetWindowAlwaysWantOwnTabBar(ImGuiWindow* window)
		{
			byte ret = GetWindowAlwaysWantOwnTabBarNative(window);
			return ret != 0;
		}

		public static bool GetWindowAlwaysWantOwnTabBar(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = GetWindowAlwaysWantOwnTabBarNative((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDocked")]
		internal static extern void BeginDockedNative(ImGuiWindow* window, bool* pOpen);

		public static void BeginDocked(ImGuiWindow* window, bool* pOpen)
		{
			BeginDockedNative(window, pOpen);
		}

		public static void BeginDocked(ref ImGuiWindow window, bool* pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockedNative((ImGuiWindow*)pwindow, pOpen);
			}
		}

		public static void BeginDocked(ImGuiWindow* window, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				BeginDockedNative(window, (bool*)ppOpen);
			}
		}

		public static void BeginDocked(ref ImGuiWindow window, ref bool pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					BeginDockedNative((ImGuiWindow*)pwindow, (bool*)ppOpen);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDockableDragDropSource")]
		internal static extern void BeginDockableDragDropSourceNative(ImGuiWindow* window);

		public static void BeginDockableDragDropSource(ImGuiWindow* window)
		{
			BeginDockableDragDropSourceNative(window);
		}

		public static void BeginDockableDragDropSource(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropSourceNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDockableDragDropTarget")]
		internal static extern void BeginDockableDragDropTargetNative(ImGuiWindow* window);

		public static void BeginDockableDragDropTarget(ImGuiWindow* window)
		{
			BeginDockableDragDropTargetNative(window);
		}

		public static void BeginDockableDragDropTarget(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BeginDockableDragDropTargetNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowDock")]
		internal static extern void SetWindowDockNative(ImGuiWindow* window, int dockId, ImGuiCond cond);

		public static void SetWindowDock(ImGuiWindow* window, int dockId, ImGuiCond cond)
		{
			SetWindowDockNative(window, dockId, cond);
		}

		public static void SetWindowDock(ref ImGuiWindow window, int dockId, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowDockNative((ImGuiWindow*)pwindow, dockId, cond);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderDockWindow")]
		internal static extern void DockBuilderDockWindowNative(byte* windowName, int nodeId);

		public static void DockBuilderDockWindow(byte* windowName, int nodeId)
		{
			DockBuilderDockWindowNative(windowName, nodeId);
		}

		public static void DockBuilderDockWindow(ref byte windowName, int nodeId)
		{
			fixed (byte* pwindowName = &windowName)
			{
				DockBuilderDockWindowNative((byte*)pwindowName, nodeId);
			}
		}

		public static void DockBuilderDockWindow(string windowName, int nodeId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (windowName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(windowName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(windowName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderDockWindowNative(pStr0, nodeId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderGetNode")]
		internal static extern ImGuiDockNode* DockBuilderGetNodeNative(int nodeId);

		public static ImGuiDockNodePtr DockBuilderGetNode(int nodeId)
		{
			ImGuiDockNodePtr ret = DockBuilderGetNodeNative(nodeId);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderGetCentralNode")]
		internal static extern ImGuiDockNode* DockBuilderGetCentralNodeNative(int nodeId);

		public static ImGuiDockNodePtr DockBuilderGetCentralNode(int nodeId)
		{
			ImGuiDockNodePtr ret = DockBuilderGetCentralNodeNative(nodeId);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderAddNode")]
		internal static extern int DockBuilderAddNodeNative(int nodeId, ImGuiDockNodeFlags flags);

		public static int DockBuilderAddNode(int nodeId, ImGuiDockNodeFlags flags)
		{
			int ret = DockBuilderAddNodeNative(nodeId, flags);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderRemoveNode")]
		internal static extern void DockBuilderRemoveNodeNative(int nodeId);

		public static void DockBuilderRemoveNode(int nodeId)
		{
			DockBuilderRemoveNodeNative(nodeId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderRemoveNodeDockedWindows")]
		internal static extern void DockBuilderRemoveNodeDockedWindowsNative(int nodeId, byte clearSettingsRefs);

		public static void DockBuilderRemoveNodeDockedWindows(int nodeId, bool clearSettingsRefs)
		{
			DockBuilderRemoveNodeDockedWindowsNative(nodeId, clearSettingsRefs ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderRemoveNodeChildNodes")]
		internal static extern void DockBuilderRemoveNodeChildNodesNative(int nodeId);

		public static void DockBuilderRemoveNodeChildNodes(int nodeId)
		{
			DockBuilderRemoveNodeChildNodesNative(nodeId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderSetNodePos")]
		internal static extern void DockBuilderSetNodePosNative(int nodeId, Vector2 pos);

		public static void DockBuilderSetNodePos(int nodeId, Vector2 pos)
		{
			DockBuilderSetNodePosNative(nodeId, pos);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderSetNodeSize")]
		internal static extern void DockBuilderSetNodeSizeNative(int nodeId, Vector2 size);

		public static void DockBuilderSetNodeSize(int nodeId, Vector2 size)
		{
			DockBuilderSetNodeSizeNative(nodeId, size);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderSplitNode")]
		internal static extern int DockBuilderSplitNodeNative(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, int* outIdAtOppositeDir);

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, int* outIdAtOppositeDir)
		{
			int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, outIdAtOppositeDir);
			return ret;
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, ref int outIdAtDir, int* outIdAtOppositeDir)
		{
			fixed (int* poutIdAtDir = &outIdAtDir)
			{
				int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, (int*)poutIdAtDir, outIdAtOppositeDir);
				return ret;
			}
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, int* outIdAtDir, ref int outIdAtOppositeDir)
		{
			fixed (int* poutIdAtOppositeDir = &outIdAtOppositeDir)
			{
				int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, (int*)poutIdAtOppositeDir);
				return ret;
			}
		}

		public static int DockBuilderSplitNode(int nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, ref int outIdAtDir, ref int outIdAtOppositeDir)
		{
			fixed (int* poutIdAtDir = &outIdAtDir)
			{
				fixed (int* poutIdAtOppositeDir = &outIdAtOppositeDir)
				{
					int ret = DockBuilderSplitNodeNative(nodeId, splitDir, sizeRatioForNodeAtDir, (int*)poutIdAtDir, (int*)poutIdAtOppositeDir);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderCopyDockSpace")]
		internal static extern void DockBuilderCopyDockSpaceNative(int srcDockspaceId, int dstDockspaceId, ImVectorConstCharPtr* inWindowRemapPairs);

		public static void DockBuilderCopyDockSpace(int srcDockspaceId, int dstDockspaceId, ImVectorConstCharPtr* inWindowRemapPairs)
		{
			DockBuilderCopyDockSpaceNative(srcDockspaceId, dstDockspaceId, inWindowRemapPairs);
		}

		public static void DockBuilderCopyDockSpace(int srcDockspaceId, int dstDockspaceId, ref ImVectorConstCharPtr inWindowRemapPairs)
		{
			fixed (ImVectorConstCharPtr* pinWindowRemapPairs = &inWindowRemapPairs)
			{
				DockBuilderCopyDockSpaceNative(srcDockspaceId, dstDockspaceId, (ImVectorConstCharPtr*)pinWindowRemapPairs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderCopyNode")]
		internal static extern void DockBuilderCopyNodeNative(int srcNodeId, int dstNodeId, ImVectorImGuiID* outNodeRemapPairs);

		public static void DockBuilderCopyNode(int srcNodeId, int dstNodeId, ImVectorImGuiID* outNodeRemapPairs)
		{
			DockBuilderCopyNodeNative(srcNodeId, dstNodeId, outNodeRemapPairs);
		}

		public static void DockBuilderCopyNode(int srcNodeId, int dstNodeId, ref ImVectorImGuiID outNodeRemapPairs)
		{
			fixed (ImVectorImGuiID* poutNodeRemapPairs = &outNodeRemapPairs)
			{
				DockBuilderCopyNodeNative(srcNodeId, dstNodeId, (ImVectorImGuiID*)poutNodeRemapPairs);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderCopyWindowSettings")]
		internal static extern void DockBuilderCopyWindowSettingsNative(byte* srcName, byte* dstName);

		public static void DockBuilderCopyWindowSettings(byte* srcName, byte* dstName)
		{
			DockBuilderCopyWindowSettingsNative(srcName, dstName);
		}

		public static void DockBuilderCopyWindowSettings(ref byte srcName, byte* dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, dstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(string srcName, byte* dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, dstName);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, ref byte dstName)
		{
			fixed (byte* pdstName = &dstName)
			{
				DockBuilderCopyWindowSettingsNative(srcName, (byte*)pdstName);
			}
		}

		public static void DockBuilderCopyWindowSettings(byte* srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dstName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(srcName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DockBuilderCopyWindowSettings(ref byte srcName, ref byte dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		public static void DockBuilderCopyWindowSettings(string srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (dstName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(dstName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDockBuilderFinish")]
		internal static extern void DockBuilderFinishNative(int nodeId);

		public static void DockBuilderFinish(int nodeId)
		{
			DockBuilderFinishNative(nodeId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushFocusScope")]
		internal static extern void PushFocusScopeNative(int id);

		public static void PushFocusScope(int id)
		{
			PushFocusScopeNative(id);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopFocusScope")]
		internal static extern void PopFocusScopeNative();

		public static void PopFocusScope()
		{
			PopFocusScopeNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentFocusScope")]
		internal static extern int GetCurrentFocusScopeNative();

		public static int GetCurrentFocusScope()
		{
			int ret = GetCurrentFocusScopeNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsDragDropActive")]
		internal static extern byte IsDragDropActiveNative();

		public static bool IsDragDropActive()
		{
			byte ret = IsDragDropActiveNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginDragDropTargetCustom")]
		internal static extern byte BeginDragDropTargetCustomNative(ImRect bb, int id);

		public static bool BeginDragDropTargetCustom(ImRect bb, int id)
		{
			byte ret = BeginDragDropTargetCustomNative(bb, id);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igClearDragDrop")]
		internal static extern void ClearDragDropNative();

		public static void ClearDragDrop()
		{
			ClearDragDropNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsDragDropPayloadBeingAccepted")]
		internal static extern byte IsDragDropPayloadBeingAcceptedNative();

		public static bool IsDragDropPayloadBeingAccepted()
		{
			byte ret = IsDragDropPayloadBeingAcceptedNative();
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderDragDropTargetRect")]
		internal static extern void RenderDragDropTargetRectNative(ImRect bb);

		public static void RenderDragDropTargetRect(ImRect bb)
		{
			RenderDragDropTargetRectNative(bb);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSetWindowClipRectBeforeSetChannel")]
		internal static extern void SetWindowClipRectBeforeSetChannelNative(ImGuiWindow* window, ImRect clipRect);

		public static void SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, ImRect clipRect)
		{
			SetWindowClipRectBeforeSetChannelNative(window, clipRect);
		}

		public static void SetWindowClipRectBeforeSetChannel(ref ImGuiWindow window, ImRect clipRect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowClipRectBeforeSetChannelNative((ImGuiWindow*)pwindow, clipRect);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginColumns")]
		internal static extern void BeginColumnsNative(byte* strId, int count, ImGuiOldColumnFlags flags);

		public static void BeginColumns(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			BeginColumnsNative(strId, count, flags);
		}

		public static void BeginColumns(ref byte strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				BeginColumnsNative((byte*)pstrId, count, flags);
			}
		}

		public static void BeginColumns(string strId, int count, ImGuiOldColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BeginColumnsNative(pStr0, count, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igEndColumns")]
		internal static extern void EndColumnsNative();

		public static void EndColumns()
		{
			EndColumnsNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushColumnClipRect")]
		internal static extern void PushColumnClipRectNative(int columnIndex);

		public static void PushColumnClipRect(int columnIndex)
		{
			PushColumnClipRectNative(columnIndex);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPushColumnsBackground")]
		internal static extern void PushColumnsBackgroundNative();

		public static void PushColumnsBackground()
		{
			PushColumnsBackgroundNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPopColumnsBackground")]
		internal static extern void PopColumnsBackgroundNative();

		public static void PopColumnsBackground()
		{
			PopColumnsBackgroundNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnsID")]
		internal static extern int GetColumnsIDNative(byte* strId, int count);

		public static int GetColumnsID(byte* strId, int count)
		{
			int ret = GetColumnsIDNative(strId, count);
			return ret;
		}

		public static int GetColumnsID(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				int ret = GetColumnsIDNative((byte*)pstrId, count);
				return ret;
			}
		}

		public static int GetColumnsID(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetColumnsIDNative(pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindOrCreateColumns")]
		internal static extern ImGuiOldColumns* FindOrCreateColumnsNative(ImGuiWindow* window, int id);

		public static ImGuiOldColumnsPtr FindOrCreateColumns(ImGuiWindow* window, int id)
		{
			ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative(window, id);
			return ret;
		}

		public static ImGuiOldColumnsPtr FindOrCreateColumns(ref ImGuiWindow window, int id)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative((ImGuiWindow*)pwindow, id);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnOffsetFromNorm")]
		internal static extern float GetColumnOffsetFromNormNative(ImGuiOldColumns* columns, float offsetNorm);

		public static float GetColumnOffsetFromNorm(ImGuiOldColumns* columns, float offsetNorm)
		{
			float ret = GetColumnOffsetFromNormNative(columns, offsetNorm);
			return ret;
		}

		public static float GetColumnOffsetFromNorm(ref ImGuiOldColumns columns, float offsetNorm)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnOffsetFromNormNative((ImGuiOldColumns*)pcolumns, offsetNorm);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetColumnNormFromOffset")]
		internal static extern float GetColumnNormFromOffsetNative(ImGuiOldColumns* columns, float offset);

		public static float GetColumnNormFromOffset(ImGuiOldColumns* columns, float offset)
		{
			float ret = GetColumnNormFromOffsetNative(columns, offset);
			return ret;
		}

		public static float GetColumnNormFromOffset(ref ImGuiOldColumns columns, float offset)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnNormFromOffsetNative((ImGuiOldColumns*)pcolumns, offset);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableOpenContextMenu")]
		internal static extern void TableOpenContextMenuNative(int columnN);

		public static void TableOpenContextMenu(int columnN)
		{
			TableOpenContextMenuNative(columnN);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnWidth")]
		internal static extern void TableSetColumnWidthNative(int columnN, float width);

		public static void TableSetColumnWidth(int columnN, float width)
		{
			TableSetColumnWidthNative(columnN, width);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnSortDirection")]
		internal static extern void TableSetColumnSortDirectionNative(int columnN, ImGuiSortDirection sortDirection, byte appendToSortSpecs);

		public static void TableSetColumnSortDirection(int columnN, ImGuiSortDirection sortDirection, bool appendToSortSpecs)
		{
			TableSetColumnSortDirectionNative(columnN, sortDirection, appendToSortSpecs ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetHoveredColumn")]
		internal static extern int TableGetHoveredColumnNative();

		public static int TableGetHoveredColumn()
		{
			int ret = TableGetHoveredColumnNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetHeaderRowHeight")]
		internal static extern float TableGetHeaderRowHeightNative();

		public static float TableGetHeaderRowHeight()
		{
			float ret = TableGetHeaderRowHeightNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTablePushBackgroundChannel")]
		internal static extern void TablePushBackgroundChannelNative();

		public static void TablePushBackgroundChannel()
		{
			TablePushBackgroundChannelNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTablePopBackgroundChannel")]
		internal static extern void TablePopBackgroundChannelNative();

		public static void TablePopBackgroundChannel()
		{
			TablePopBackgroundChannelNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentTable")]
		internal static extern ImGuiTable* GetCurrentTableNative();

		public static ImGuiTablePtr GetCurrentTable()
		{
			ImGuiTablePtr ret = GetCurrentTableNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableFindByID")]
		internal static extern ImGuiTable* TableFindByIDNative(int id);

		public static ImGuiTablePtr TableFindByID(int id)
		{
			ImGuiTablePtr ret = TableFindByIDNative(id);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTableEx")]
		internal static extern byte BeginTableExNative(byte* name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth);

		public static bool BeginTableEx(byte* name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, flags, outerSize, innerWidth);
			return ret != 0;
		}

		public static bool BeginTableEx(ref byte name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		public static bool BeginTableEx(string name, int id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginInitMemory")]
		internal static extern void TableBeginInitMemoryNative(ImGuiTable* table, int columnsCount);

		public static void TableBeginInitMemory(ImGuiTable* table, int columnsCount)
		{
			TableBeginInitMemoryNative(table, columnsCount);
		}

		public static void TableBeginInitMemory(ref ImGuiTable table, int columnsCount)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginInitMemoryNative((ImGuiTable*)ptable, columnsCount);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginApplyRequests")]
		internal static extern void TableBeginApplyRequestsNative(ImGuiTable* table);

		public static void TableBeginApplyRequests(ImGuiTable* table)
		{
			TableBeginApplyRequestsNative(table);
		}

		public static void TableBeginApplyRequests(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginApplyRequestsNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetupDrawChannels")]
		internal static extern void TableSetupDrawChannelsNative(ImGuiTable* table);

		public static void TableSetupDrawChannels(ImGuiTable* table)
		{
			TableSetupDrawChannelsNative(table);
		}

		public static void TableSetupDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetupDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableUpdateLayout")]
		internal static extern void TableUpdateLayoutNative(ImGuiTable* table);

		public static void TableUpdateLayout(ImGuiTable* table)
		{
			TableUpdateLayoutNative(table);
		}

		public static void TableUpdateLayout(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateLayoutNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableUpdateBorders")]
		internal static extern void TableUpdateBordersNative(ImGuiTable* table);

		public static void TableUpdateBorders(ImGuiTable* table)
		{
			TableUpdateBordersNative(table);
		}

		public static void TableUpdateBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateBordersNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableUpdateColumnsWeightFromWidth")]
		internal static extern void TableUpdateColumnsWeightFromWidthNative(ImGuiTable* table);

		public static void TableUpdateColumnsWeightFromWidth(ImGuiTable* table)
		{
			TableUpdateColumnsWeightFromWidthNative(table);
		}

		public static void TableUpdateColumnsWeightFromWidth(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateColumnsWeightFromWidthNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableDrawBorders")]
		internal static extern void TableDrawBordersNative(ImGuiTable* table);

		public static void TableDrawBorders(ImGuiTable* table)
		{
			TableDrawBordersNative(table);
		}

		public static void TableDrawBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawBordersNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableDrawContextMenu")]
		internal static extern void TableDrawContextMenuNative(ImGuiTable* table);

		public static void TableDrawContextMenu(ImGuiTable* table)
		{
			TableDrawContextMenuNative(table);
		}

		public static void TableDrawContextMenu(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawContextMenuNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginContextMenuPopup")]
		internal static extern byte TableBeginContextMenuPopupNative(ImGuiTable* table);

		public static bool TableBeginContextMenuPopup(ImGuiTable* table)
		{
			byte ret = TableBeginContextMenuPopupNative(table);
			return ret != 0;
		}

		public static bool TableBeginContextMenuPopup(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte ret = TableBeginContextMenuPopupNative((ImGuiTable*)ptable);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableMergeDrawChannels")]
		internal static extern void TableMergeDrawChannelsNative(ImGuiTable* table);

		public static void TableMergeDrawChannels(ImGuiTable* table)
		{
			TableMergeDrawChannelsNative(table);
		}

		public static void TableMergeDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableMergeDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetInstanceData")]
		internal static extern ImGuiTableInstanceData* TableGetInstanceDataNative(ImGuiTable* table, int instanceNo);

		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ImGuiTable* table, int instanceNo)
		{
			ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative(table, instanceNo);
			return ret;
		}

		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetInstanceID")]
		internal static extern int TableGetInstanceIDNative(ImGuiTable* table, int instanceNo);

		public static int TableGetInstanceID(ImGuiTable* table, int instanceNo)
		{
			int ret = TableGetInstanceIDNative(table, instanceNo);
			return ret;
		}

		public static int TableGetInstanceID(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				int ret = TableGetInstanceIDNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSortSpecsSanitize")]
		internal static extern void TableSortSpecsSanitizeNative(ImGuiTable* table);

		public static void TableSortSpecsSanitize(ImGuiTable* table)
		{
			TableSortSpecsSanitizeNative(table);
		}

		public static void TableSortSpecsSanitize(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsSanitizeNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSortSpecsBuild")]
		internal static extern void TableSortSpecsBuildNative(ImGuiTable* table);

		public static void TableSortSpecsBuild(ImGuiTable* table)
		{
			TableSortSpecsBuildNative(table);
		}

		public static void TableSortSpecsBuild(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsBuildNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnNextSortDirection")]
		internal static extern ImGuiSortDirection TableGetColumnNextSortDirectionNative(ImGuiTableColumn* column);

		public static ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumn* column)
		{
			ImGuiSortDirection ret = TableGetColumnNextSortDirectionNative(column);
			return ret;
		}

		public static ImGuiSortDirection TableGetColumnNextSortDirection(ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				ImGuiSortDirection ret = TableGetColumnNextSortDirectionNative((ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableFixColumnSortDirection")]
		internal static extern void TableFixColumnSortDirectionNative(ImGuiTable* table, ImGuiTableColumn* column);

		public static void TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column)
		{
			TableFixColumnSortDirectionNative(table, column);
		}

		public static void TableFixColumnSortDirection(ref ImGuiTable table, ImGuiTableColumn* column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableFixColumnSortDirectionNative((ImGuiTable*)ptable, column);
			}
		}

		public static void TableFixColumnSortDirection(ImGuiTable* table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				TableFixColumnSortDirectionNative(table, (ImGuiTableColumn*)pcolumn);
			}
		}

		public static void TableFixColumnSortDirection(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					TableFixColumnSortDirectionNative((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnWidthAuto")]
		internal static extern float TableGetColumnWidthAutoNative(ImGuiTable* table, ImGuiTableColumn* column);

		public static float TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column)
		{
			float ret = TableGetColumnWidthAutoNative(table, column);
			return ret;
		}

		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ImGuiTableColumn* column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetColumnWidthAutoNative((ImGuiTable*)ptable, column);
				return ret;
			}
		}

		public static float TableGetColumnWidthAuto(ImGuiTable* table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				float ret = TableGetColumnWidthAutoNative(table, (ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					float ret = TableGetColumnWidthAutoNative((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginRow")]
		internal static extern void TableBeginRowNative(ImGuiTable* table);

		public static void TableBeginRow(ImGuiTable* table)
		{
			TableBeginRowNative(table);
		}

		public static void TableBeginRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginRowNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableEndRow")]
		internal static extern void TableEndRowNative(ImGuiTable* table);

		public static void TableEndRow(ImGuiTable* table)
		{
			TableEndRowNative(table);
		}

		public static void TableEndRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableEndRowNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableBeginCell")]
		internal static extern void TableBeginCellNative(ImGuiTable* table, int columnN);

		public static void TableBeginCell(ImGuiTable* table, int columnN)
		{
			TableBeginCellNative(table, columnN);
		}

		public static void TableBeginCell(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginCellNative((ImGuiTable*)ptable, columnN);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableEndCell")]
		internal static extern void TableEndCellNative(ImGuiTable* table);

		public static void TableEndCell(ImGuiTable* table)
		{
			TableEndCellNative(table);
		}

		public static void TableEndCell(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableEndCellNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetCellBgRect")]
		internal static extern void TableGetCellBgRectNative(ImRect* output, ImGuiTable* table, int columnN);

		public static ImRect TableGetCellBgRect(ImGuiTable* table, int columnN)
		{
			ImRect ret;
			TableGetCellBgRectNative(&ret, table, columnN);
			return ret;
		}

		public static void TableGetCellBgRect(ref ImRect output, ImGuiTable* table, int columnN)
		{
			fixed (ImRect* poutput = &output)
			{
				TableGetCellBgRectNative((ImRect*)poutput, table, columnN);
			}
		}

		public static ImRect TableGetCellBgRect(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImRect ret;
				TableGetCellBgRectNative(&ret, (ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		public static void TableGetCellBgRect(ref ImRect output, ref ImGuiTable table, int columnN)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiTable* ptable = &table)
				{
					TableGetCellBgRectNative((ImRect*)poutput, (ImGuiTable*)ptable, columnN);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnName_TablePtr")]
		internal static extern byte* TableGetColumnNameTablePtrNative(ImGuiTable* table, int columnN);

		public static byte* TableGetColumnNameTablePtr(ImGuiTable* table, int columnN)
		{
			byte* ret = TableGetColumnNameTablePtrNative(table, columnN);
			return ret;
		}

		public static string TableGetColumnNameTablePtrS(ImGuiTable* table, int columnN)
		{
			string ret = Utils.DecodeStringUTF8(TableGetColumnNameTablePtrNative(table, columnN));
			return ret;
		}

		public static byte* TableGetColumnNameTablePtr(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte* ret = TableGetColumnNameTablePtrNative((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		public static string TableGetColumnNameTablePtrS(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				string ret = Utils.DecodeStringUTF8(TableGetColumnNameTablePtrNative((ImGuiTable*)ptable, columnN));
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetColumnResizeID")]
		internal static extern int TableGetColumnResizeIDNative(ImGuiTable* table, int columnN, int instanceNo);

		public static int TableGetColumnResizeID(ImGuiTable* table, int columnN, int instanceNo)
		{
			int ret = TableGetColumnResizeIDNative(table, columnN, instanceNo);
			return ret;
		}

		public static int TableGetColumnResizeID(ref ImGuiTable table, int columnN, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				int ret = TableGetColumnResizeIDNative((ImGuiTable*)ptable, columnN, instanceNo);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetMaxColumnWidth")]
		internal static extern float TableGetMaxColumnWidthNative(ImGuiTable* table, int columnN);

		public static float TableGetMaxColumnWidth(ImGuiTable* table, int columnN)
		{
			float ret = TableGetMaxColumnWidthNative(table, columnN);
			return ret;
		}

		public static float TableGetMaxColumnWidth(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetMaxColumnWidthNative((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnWidthAutoSingle")]
		internal static extern void TableSetColumnWidthAutoSingleNative(ImGuiTable* table, int columnN);

		public static void TableSetColumnWidthAutoSingle(ImGuiTable* table, int columnN)
		{
			TableSetColumnWidthAutoSingleNative(table, columnN);
		}

		public static void TableSetColumnWidthAutoSingle(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetColumnWidthAutoSingleNative((ImGuiTable*)ptable, columnN);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSetColumnWidthAutoAll")]
		internal static extern void TableSetColumnWidthAutoAllNative(ImGuiTable* table);

		public static void TableSetColumnWidthAutoAll(ImGuiTable* table)
		{
			TableSetColumnWidthAutoAllNative(table);
		}

		public static void TableSetColumnWidthAutoAll(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetColumnWidthAutoAllNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableRemove")]
		internal static extern void TableRemoveNative(ImGuiTable* table);

		public static void TableRemove(ImGuiTable* table)
		{
			TableRemoveNative(table);
		}

		public static void TableRemove(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableRemoveNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGcCompactTransientBuffers_TablePtr")]
		internal static extern void TableGcCompactTransientBuffersTablePtrNative(ImGuiTable* table);

		public static void TableGcCompactTransientBuffersTablePtr(ImGuiTable* table)
		{
			TableGcCompactTransientBuffersTablePtrNative(table);
		}

		public static void TableGcCompactTransientBuffersTablePtr(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableGcCompactTransientBuffersTablePtrNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGcCompactTransientBuffers_TableTempDataPtr")]
		internal static extern void TableGcCompactTransientBuffersTableTempDataPtrNative(ImGuiTableTempData* table);

		public static void TableGcCompactTransientBuffersTableTempDataPtr(ImGuiTableTempData* table)
		{
			TableGcCompactTransientBuffersTableTempDataPtrNative(table);
		}

		public static void TableGcCompactTransientBuffersTableTempDataPtr(ref ImGuiTableTempData table)
		{
			fixed (ImGuiTableTempData* ptable = &table)
			{
				TableGcCompactTransientBuffersTableTempDataPtrNative((ImGuiTableTempData*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGcCompactSettings")]
		internal static extern void TableGcCompactSettingsNative();

		public static void TableGcCompactSettings()
		{
			TableGcCompactSettingsNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableLoadSettings")]
		internal static extern void TableLoadSettingsNative(ImGuiTable* table);

		public static void TableLoadSettings(ImGuiTable* table)
		{
			TableLoadSettingsNative(table);
		}

		public static void TableLoadSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableLoadSettingsNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSaveSettings")]
		internal static extern void TableSaveSettingsNative(ImGuiTable* table);

		public static void TableSaveSettings(ImGuiTable* table)
		{
			TableSaveSettingsNative(table);
		}

		public static void TableSaveSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSaveSettingsNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableResetSettings")]
		internal static extern void TableResetSettingsNative(ImGuiTable* table);

		public static void TableResetSettings(ImGuiTable* table)
		{
			TableResetSettingsNative(table);
		}

		public static void TableResetSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableResetSettingsNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableGetBoundSettings")]
		internal static extern ImGuiTableSettings* TableGetBoundSettingsNative(ImGuiTable* table);

		public static ImGuiTableSettingsPtr TableGetBoundSettings(ImGuiTable* table)
		{
			ImGuiTableSettingsPtr ret = TableGetBoundSettingsNative(table);
			return ret;
		}

		public static ImGuiTableSettingsPtr TableGetBoundSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableSettingsPtr ret = TableGetBoundSettingsNative((ImGuiTable*)ptable);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSettingsAddSettingsHandler")]
		internal static extern void TableSettingsAddSettingsHandlerNative();

		public static void TableSettingsAddSettingsHandler()
		{
			TableSettingsAddSettingsHandlerNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSettingsCreate")]
		internal static extern ImGuiTableSettings* TableSettingsCreateNative(int id, int columnsCount);

		public static ImGuiTableSettingsPtr TableSettingsCreate(int id, int columnsCount)
		{
			ImGuiTableSettingsPtr ret = TableSettingsCreateNative(id, columnsCount);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTableSettingsFindByID")]
		internal static extern ImGuiTableSettings* TableSettingsFindByIDNative(int id);

		public static ImGuiTableSettingsPtr TableSettingsFindByID(int id)
		{
			ImGuiTableSettingsPtr ret = TableSettingsFindByIDNative(id);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetCurrentTabBar")]
		internal static extern ImGuiTabBar* GetCurrentTabBarNative();

		public static ImGuiTabBarPtr GetCurrentTabBar()
		{
			ImGuiTabBarPtr ret = GetCurrentTabBarNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igBeginTabBarEx")]
		internal static extern byte BeginTabBarExNative(ImGuiTabBar* tabBar, ImRect bb, ImGuiTabBarFlags flags, ImGuiDockNode* dockNode);

		public static bool BeginTabBarEx(ImGuiTabBar* tabBar, ImRect bb, ImGuiTabBarFlags flags, ImGuiDockNode* dockNode)
		{
			byte ret = BeginTabBarExNative(tabBar, bb, flags, dockNode);
			return ret != 0;
		}

		public static bool BeginTabBarEx(ref ImGuiTabBar tabBar, ImRect bb, ImGuiTabBarFlags flags, ImGuiDockNode* dockNode)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = BeginTabBarExNative((ImGuiTabBar*)ptabBar, bb, flags, dockNode);
				return ret != 0;
			}
		}

		public static bool BeginTabBarEx(ImGuiTabBar* tabBar, ImRect bb, ImGuiTabBarFlags flags, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiDockNode* pdockNode = &dockNode)
			{
				byte ret = BeginTabBarExNative(tabBar, bb, flags, (ImGuiDockNode*)pdockNode);
				return ret != 0;
			}
		}

		public static bool BeginTabBarEx(ref ImGuiTabBar tabBar, ImRect bb, ImGuiTabBarFlags flags, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiDockNode* pdockNode = &dockNode)
				{
					byte ret = BeginTabBarExNative((ImGuiTabBar*)ptabBar, bb, flags, (ImGuiDockNode*)pdockNode);
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarFindTabByID")]
		internal static extern ImGuiTabItem* TabBarFindTabByIDNative(ImGuiTabBar* tabBar, int tabId);

		public static ImGuiTabItemPtr TabBarFindTabByID(ImGuiTabBar* tabBar, int tabId)
		{
			ImGuiTabItemPtr ret = TabBarFindTabByIDNative(tabBar, tabId);
			return ret;
		}

		public static ImGuiTabItemPtr TabBarFindTabByID(ref ImGuiTabBar tabBar, int tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindTabByIDNative((ImGuiTabBar*)ptabBar, tabId);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarFindTabByOrder")]
		internal static extern ImGuiTabItem* TabBarFindTabByOrderNative(ImGuiTabBar* tabBar, int order);

		public static ImGuiTabItemPtr TabBarFindTabByOrder(ImGuiTabBar* tabBar, int order)
		{
			ImGuiTabItemPtr ret = TabBarFindTabByOrderNative(tabBar, order);
			return ret;
		}

		public static ImGuiTabItemPtr TabBarFindTabByOrder(ref ImGuiTabBar tabBar, int order)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindTabByOrderNative((ImGuiTabBar*)ptabBar, order);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarFindMostRecentlySelectedTabForActiveWindow")]
		internal static extern ImGuiTabItem* TabBarFindMostRecentlySelectedTabForActiveWindowNative(ImGuiTabBar* tabBar);

		public static ImGuiTabItemPtr TabBarFindMostRecentlySelectedTabForActiveWindow(ImGuiTabBar* tabBar)
		{
			ImGuiTabItemPtr ret = TabBarFindMostRecentlySelectedTabForActiveWindowNative(tabBar);
			return ret;
		}

		public static ImGuiTabItemPtr TabBarFindMostRecentlySelectedTabForActiveWindow(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindMostRecentlySelectedTabForActiveWindowNative((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarGetCurrentTab")]
		internal static extern ImGuiTabItem* TabBarGetCurrentTabNative(ImGuiTabBar* tabBar);

		public static ImGuiTabItemPtr TabBarGetCurrentTab(ImGuiTabBar* tabBar)
		{
			ImGuiTabItemPtr ret = TabBarGetCurrentTabNative(tabBar);
			return ret;
		}

		public static ImGuiTabItemPtr TabBarGetCurrentTab(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarGetCurrentTabNative((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarGetTabOrder")]
		internal static extern int TabBarGetTabOrderNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static int TabBarGetTabOrder(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			int ret = TabBarGetTabOrderNative(tabBar, tab);
			return ret;
		}

		public static int TabBarGetTabOrder(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				int ret = TabBarGetTabOrderNative((ImGuiTabBar*)ptabBar, tab);
				return ret;
			}
		}

		public static int TabBarGetTabOrder(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				int ret = TabBarGetTabOrderNative(tabBar, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		public static int TabBarGetTabOrder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					int ret = TabBarGetTabOrderNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarGetTabName")]
		internal static extern byte* TabBarGetTabNameNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static byte* TabBarGetTabName(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			byte* ret = TabBarGetTabNameNative(tabBar, tab);
			return ret;
		}

		public static string TabBarGetTabNameS(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative(tabBar, tab));
			return ret;
		}

		public static byte* TabBarGetTabName(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* ret = TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, tab);
				return ret;
			}
		}

		public static string TabBarGetTabNameS(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, tab));
				return ret;
			}
		}

		public static byte* TabBarGetTabName(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				byte* ret = TabBarGetTabNameNative(tabBar, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		public static string TabBarGetTabNameS(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative(tabBar, (ImGuiTabItem*)ptab));
				return ret;
			}
		}

		public static byte* TabBarGetTabName(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					byte* ret = TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		public static string TabBarGetTabNameS(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab));
					return ret;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarAddTab")]
		internal static extern void TabBarAddTabNative(ImGuiTabBar* tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindow* window);

		public static void TabBarAddTab(ImGuiTabBar* tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindow* window)
		{
			TabBarAddTabNative(tabBar, tabFlags, window);
		}

		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindow* window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarAddTabNative((ImGuiTabBar*)ptabBar, tabFlags, window);
			}
		}

		public static void TabBarAddTab(ImGuiTabBar* tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				TabBarAddTabNative(tabBar, tabFlags, (ImGuiWindow*)pwindow);
			}
		}

		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					TabBarAddTabNative((ImGuiTabBar*)ptabBar, tabFlags, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarRemoveTab")]
		internal static extern void TabBarRemoveTabNative(ImGuiTabBar* tabBar, int tabId);

		public static void TabBarRemoveTab(ImGuiTabBar* tabBar, int tabId)
		{
			TabBarRemoveTabNative(tabBar, tabId);
		}

		public static void TabBarRemoveTab(ref ImGuiTabBar tabBar, int tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarRemoveTabNative((ImGuiTabBar*)ptabBar, tabId);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarCloseTab")]
		internal static extern void TabBarCloseTabNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static void TabBarCloseTab(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			TabBarCloseTabNative(tabBar, tab);
		}

		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarCloseTabNative((ImGuiTabBar*)ptabBar, tab);
			}
		}

		public static void TabBarCloseTab(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarCloseTabNative(tabBar, (ImGuiTabItem*)ptab);
			}
		}

		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarCloseTabNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarQueueFocus")]
		internal static extern void TabBarQueueFocusNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab);

		public static void TabBarQueueFocus(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			TabBarQueueFocusNative(tabBar, tab);
		}

		public static void TabBarQueueFocus(ref ImGuiTabBar tabBar, ImGuiTabItem* tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueFocusNative((ImGuiTabBar*)ptabBar, tab);
			}
		}

		public static void TabBarQueueFocus(ImGuiTabBar* tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueFocusNative(tabBar, (ImGuiTabItem*)ptab);
			}
		}

		public static void TabBarQueueFocus(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueFocusNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarQueueReorder")]
		internal static extern void TabBarQueueReorderNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab, int offset);

		public static void TabBarQueueReorder(ImGuiTabBar* tabBar, ImGuiTabItem* tab, int offset)
		{
			TabBarQueueReorderNative(tabBar, tab, offset);
		}

		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ImGuiTabItem* tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueReorderNative((ImGuiTabBar*)ptabBar, tab, offset);
			}
		}

		public static void TabBarQueueReorder(ImGuiTabBar* tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueReorderNative(tabBar, (ImGuiTabItem*)ptab, offset);
			}
		}

		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueReorderNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, offset);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarQueueReorderFromMousePos")]
		internal static extern void TabBarQueueReorderFromMousePosNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab, Vector2 mousePos);

		public static void TabBarQueueReorderFromMousePos(ImGuiTabBar* tabBar, ImGuiTabItem* tab, Vector2 mousePos)
		{
			TabBarQueueReorderFromMousePosNative(tabBar, tab, mousePos);
		}

		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ImGuiTabItem* tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueReorderFromMousePosNative((ImGuiTabBar*)ptabBar, tab, mousePos);
			}
		}

		public static void TabBarQueueReorderFromMousePos(ImGuiTabBar* tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueReorderFromMousePosNative(tabBar, (ImGuiTabItem*)ptab, mousePos);
			}
		}

		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueReorderFromMousePosNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, mousePos);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabBarProcessReorder")]
		internal static extern byte TabBarProcessReorderNative(ImGuiTabBar* tabBar);

		public static bool TabBarProcessReorder(ImGuiTabBar* tabBar)
		{
			byte ret = TabBarProcessReorderNative(tabBar);
			return ret != 0;
		}

		public static bool TabBarProcessReorder(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = TabBarProcessReorderNative((ImGuiTabBar*)ptabBar);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemEx")]
		internal static extern byte TabItemExNative(ImGuiTabBar* tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow);

		public static bool TabItemEx(ImGuiTabBar* tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			byte ret = TabItemExNative(tabBar, label, pOpen, flags, dockedWindow);
			return ret != 0;
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TabItemExNative(tabBar, (byte*)plabel, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TabItemExNative(tabBar, pStr0, pOpen, flags, dockedWindow);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = TabItemExNative(tabBar, label, (bool*)ppOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative(tabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = TabItemExNative(tabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
						return ret != 0;
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				byte ret = TabItemExNative(tabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				return ret != 0;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				byte ret = TabItemExNative(tabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative(tabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		public static bool TabItemEx(ImGuiTabBar* tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
						{
							byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemCalcSize_Str")]
		internal static extern void TabItemCalcSizeNative(Vector2* output, byte* label, byte hasCloseButtonOrUnsavedMarker);

		public static Vector2 TabItemCalcSize(byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			Vector2 ret;
			TabItemCalcSizeNative(&ret, label, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			return ret;
		}

		public static void TabItemCalcSize(ref Vector2 output, byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				TabItemCalcSizeNative((Vector2*)poutput, label, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			}
		}

		public static Vector2 TabItemCalcSize(ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (byte* plabel = &label)
			{
				Vector2 ret;
				TabItemCalcSizeNative(&ret, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public static Vector2 TabItemCalcSize(string label, bool hasCloseButtonOrUnsavedMarker)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			TabItemCalcSizeNative(&ret, pStr0, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void TabItemCalcSize(ref Vector2 output, ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (byte* plabel = &label)
				{
					TabItemCalcSizeNative((Vector2*)poutput, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				}
			}
		}

		public static void TabItemCalcSize(ref Vector2 output, string label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* poutput = &output)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TabItemCalcSizeNative((Vector2*)poutput, pStr0, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemCalcSize_WindowPtr")]
		internal static extern void TabItemCalcSizeWindowPtrNative(Vector2* output, ImGuiWindow* window);

		public static Vector2 TabItemCalcSizeWindowPtr(ImGuiWindow* window)
		{
			Vector2 ret;
			TabItemCalcSizeWindowPtrNative(&ret, window);
			return ret;
		}

		public static void TabItemCalcSizeWindowPtr(ref Vector2 output, ImGuiWindow* window)
		{
			fixed (Vector2* poutput = &output)
			{
				TabItemCalcSizeWindowPtrNative((Vector2*)poutput, window);
			}
		}

		public static Vector2 TabItemCalcSizeWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				TabItemCalcSizeWindowPtrNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		public static void TabItemCalcSizeWindowPtr(ref Vector2 output, ref ImGuiWindow window)
		{
			fixed (Vector2* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					TabItemCalcSizeWindowPtrNative((Vector2*)poutput, (ImGuiWindow*)pwindow);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemBackground")]
		internal static extern void TabItemBackgroundNative(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, uint col);

		public static void TabItemBackground(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			TabItemBackgroundNative(drawList, bb, flags, col);
		}

		public static void TabItemBackground(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				TabItemBackgroundNative((ImDrawList*)pdrawList, bb, flags, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTabItemLabelAndCloseButton")]
		internal static extern void TabItemLabelAndCloseButtonNative(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, byte isContentsVisible, bool* outJustClosed, bool* outTextClipped);

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						fixed (bool* poutTextClipped = &outTextClipped)
						{
							TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						}
					}
				}
			}
		}

		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, int tabId, int closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderText")]
		internal static extern void RenderTextNative(Vector2 pos, byte* text, byte* textEnd, byte hideTextAfterHash);

		public static void RenderText(Vector2 pos, byte* text, byte* textEnd, bool hideTextAfterHash)
		{
			RenderTextNative(pos, text, textEnd, hideTextAfterHash ? (byte)1 : (byte)0);
		}

		public static void RenderText(Vector2 pos, ref byte text, byte* textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextNative(pos, (byte*)ptext, textEnd, hideTextAfterHash ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText(Vector2 pos, string text, byte* textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(pos, pStr0, textEnd, hideTextAfterHash ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(Vector2 pos, byte* text, ref byte textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(pos, text, (byte*)ptextEnd, hideTextAfterHash ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText(Vector2 pos, byte* text, string textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(pos, text, pStr0, hideTextAfterHash ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText(Vector2 pos, ref byte text, ref byte textEnd, bool hideTextAfterHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(pos, (byte*)ptext, (byte*)ptextEnd, hideTextAfterHash ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText(Vector2 pos, string text, string textEnd, bool hideTextAfterHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(pos, pStr0, pStr1, hideTextAfterHash ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderTextWrapped")]
		internal static extern void RenderTextWrappedNative(Vector2 pos, byte* text, byte* textEnd, float wrapWidth);

		public static void RenderTextWrapped(Vector2 pos, byte* text, byte* textEnd, float wrapWidth)
		{
			RenderTextWrappedNative(pos, text, textEnd, wrapWidth);
		}

		public static void RenderTextWrapped(Vector2 pos, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextWrappedNative(pos, (byte*)ptext, textEnd, wrapWidth);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextWrappedNative(pos, pStr0, textEnd, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextWrappedNative(pos, text, (byte*)ptextEnd, wrapWidth);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextWrappedNative(pos, text, pStr0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextWrapped(Vector2 pos, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextWrappedNative(pos, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
				}
			}
		}

		public static void RenderTextWrapped(Vector2 pos, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextWrappedNative(pos, pStr0, pStr1, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderTextClipped")]
		internal static extern void RenderTextClippedNative(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect);

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			RenderTextClippedNative(posMin, posMax, text, textEnd, textSizeIfKnown, align, clipRect);
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextClippedNative(posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedNative(posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextClippedNative(posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedNative(posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClippedNative(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextClippedNative(posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedNative(posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedNative(posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedNative(posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedNative(posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedNative(posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedNative(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedNative(posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedNative(posMin, posMax, text, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedNative(posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedNative(posMin, posMax, text, pStr0, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedNative(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedNative(posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedNative(posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedNative(posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedNative(posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClipped(Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedNative(posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderTextClippedEx")]
		internal static extern void RenderTextClippedExNative(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect);

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			RenderTextClippedExNative(drawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, clipRect);
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedExNative(drawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextClippedExNative(drawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextClippedExNative(drawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, clipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, clipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
						{
							RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, clipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ImRect* clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, clipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, textSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (ImRect* pclipRect = &clipRect)
			{
				RenderTextClippedExNative(drawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, (ImRect*)pclipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, Vector2* textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, textSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, byte* textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, textEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative(drawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, byte* text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, text, pStr0, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						fixed (ImRect* pclipRect = &clipRect)
						{
							RenderTextClippedExNative(drawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				fixed (ImRect* pclipRect = &clipRect)
				{
					RenderTextClippedExNative(drawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
						{
							fixed (ImRect* pclipRect = &clipRect)
							{
								RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
							}
						}
					}
				}
			}
		}

		public static void RenderTextClippedEx(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, string text, string textEnd, ref Vector2 textSizeIfKnown, Vector2 align, ref ImRect clipRect)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					fixed (ImRect* pclipRect = &clipRect)
					{
						RenderTextClippedExNative((ImDrawList*)pdrawList, posMin, posMax, pStr0, pStr1, (Vector2*)ptextSizeIfKnown, align, (ImRect*)pclipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderTextEllipsis")]
		internal static extern void RenderTextEllipsisNative(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, Vector2* textSizeIfKnown);

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, textEnd, textSizeIfKnown);
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, textEnd, textSizeIfKnown);
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			fixed (byte* ptext = &text)
			{
				RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, textEnd, textSizeIfKnown);
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, textEnd, textSizeIfKnown);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, textEnd, textSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, byte* textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, textEnd, textSizeIfKnown);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, ref byte textEnd, Vector2* textSizeIfKnown)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, (byte*)ptextEnd, textSizeIfKnown);
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, string textEnd, Vector2* textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, pStr0, textSizeIfKnown);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, ref byte textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, (byte*)ptextEnd, textSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, string textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, pStr0, textSizeIfKnown);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, string textEnd, Vector2* textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, pStr1, textSizeIfKnown);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, ref byte textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, (byte*)ptextEnd, textSizeIfKnown);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, string textEnd, Vector2* textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, pStr1, textSizeIfKnown);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, textEnd, (Vector2*)ptextSizeIfKnown);
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, textEnd, (Vector2*)ptextSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (byte* ptext = &text)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, textEnd, (Vector2*)ptextSizeIfKnown);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, textEnd, (Vector2*)ptextSizeIfKnown);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, byte* textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, textEnd, (Vector2*)ptextSizeIfKnown);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown);
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, string textEnd, ref Vector2 textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, pStr0, (Vector2*)ptextSizeIfKnown);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, ref byte textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, byte* text, string textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, text, pStr0, (Vector2*)ptextSizeIfKnown);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
					{
						RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown);
					}
				}
			}
		}

		public static void RenderTextEllipsis(ImDrawList* drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, string textEnd, ref Vector2 textSizeIfKnown)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
			{
				RenderTextEllipsisNative(drawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, pStr1, (Vector2*)ptextSizeIfKnown);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, ref byte text, ref byte textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
						{
							RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, (byte*)ptext, (byte*)ptextEnd, (Vector2*)ptextSizeIfKnown);
						}
					}
				}
			}
		}

		public static void RenderTextEllipsis(ref ImDrawList drawList, Vector2 posMin, Vector2 posMax, float clipMaxX, float ellipsisMaxX, string text, string textEnd, ref Vector2 textSizeIfKnown)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector2* ptextSizeIfKnown = &textSizeIfKnown)
				{
					RenderTextEllipsisNative((ImDrawList*)pdrawList, posMin, posMax, clipMaxX, ellipsisMaxX, pStr0, pStr1, (Vector2*)ptextSizeIfKnown);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderFrame")]
		internal static extern void RenderFrameNative(Vector2 pMin, Vector2 pMax, uint fillCol, byte border, float rounding);

		public static void RenderFrame(Vector2 pMin, Vector2 pMax, uint fillCol, bool border, float rounding)
		{
			RenderFrameNative(pMin, pMax, fillCol, border ? (byte)1 : (byte)0, rounding);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderFrameBorder")]
		internal static extern void RenderFrameBorderNative(Vector2 pMin, Vector2 pMax, float rounding);

		public static void RenderFrameBorder(Vector2 pMin, Vector2 pMax, float rounding)
		{
			RenderFrameBorderNative(pMin, pMax, rounding);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderColorRectWithAlphaCheckerboard")]
		internal static extern void RenderColorRectWithAlphaCheckerboardNative(ImDrawList* drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding, ImDrawFlags flags);

		public static void RenderColorRectWithAlphaCheckerboard(ImDrawList* drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding, ImDrawFlags flags)
		{
			RenderColorRectWithAlphaCheckerboardNative(drawList, pMin, pMax, fillCol, gridStep, gridOff, rounding, flags);
		}

		public static void RenderColorRectWithAlphaCheckerboard(ref ImDrawList drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderColorRectWithAlphaCheckerboardNative((ImDrawList*)pdrawList, pMin, pMax, fillCol, gridStep, gridOff, rounding, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderNavHighlight")]
		internal static extern void RenderNavHighlightNative(ImRect bb, int id, ImGuiNavHighlightFlags flags);

		public static void RenderNavHighlight(ImRect bb, int id, ImGuiNavHighlightFlags flags)
		{
			RenderNavHighlightNative(bb, id, flags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igFindRenderedTextEnd")]
		internal static extern byte* FindRenderedTextEndNative(byte* text, byte* textEnd);

		public static byte* FindRenderedTextEnd(byte* text, byte* textEnd)
		{
			byte* ret = FindRenderedTextEndNative(text, textEnd);
			return ret;
		}

		public static string FindRenderedTextEndS(byte* text, byte* textEnd)
		{
			string ret = Utils.DecodeStringUTF8(FindRenderedTextEndNative(text, textEnd));
			return ret;
		}

		public static byte* FindRenderedTextEnd(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = FindRenderedTextEndNative((byte*)ptext, textEnd);
				return ret;
			}
		}

		public static string FindRenderedTextEndS(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(FindRenderedTextEndNative((byte*)ptext, textEnd));
				return ret;
			}
		}

		public static byte* FindRenderedTextEnd(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = FindRenderedTextEndNative(pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string FindRenderedTextEndS(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(FindRenderedTextEndNative(pStr0, textEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* FindRenderedTextEnd(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte* ret = FindRenderedTextEndNative(text, (byte*)ptextEnd);
				return ret;
			}
		}

		public static string FindRenderedTextEndS(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				string ret = Utils.DecodeStringUTF8(FindRenderedTextEndNative(text, (byte*)ptextEnd));
				return ret;
			}
		}

		public static byte* FindRenderedTextEnd(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = FindRenderedTextEndNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string FindRenderedTextEndS(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(FindRenderedTextEndNative(text, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* FindRenderedTextEnd(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = FindRenderedTextEndNative((byte*)ptext, (byte*)ptextEnd);
					return ret;
				}
			}
		}

		public static string FindRenderedTextEndS(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(FindRenderedTextEndNative((byte*)ptext, (byte*)ptextEnd));
					return ret;
				}
			}
		}

		public static byte* FindRenderedTextEnd(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = FindRenderedTextEndNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string FindRenderedTextEndS(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(FindRenderedTextEndNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderMouseCursor")]
		internal static extern void RenderMouseCursorNative(Vector2 pos, float scale, ImGuiMouseCursor mouseCursor, uint colFill, uint colBorder, uint colShadow);

		public static void RenderMouseCursor(Vector2 pos, float scale, ImGuiMouseCursor mouseCursor, uint colFill, uint colBorder, uint colShadow)
		{
			RenderMouseCursorNative(pos, scale, mouseCursor, colFill, colBorder, colShadow);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderArrow")]
		internal static extern void RenderArrowNative(ImDrawList* drawList, Vector2 pos, uint col, ImGuiDir dir, float scale);

		public static void RenderArrow(ImDrawList* drawList, Vector2 pos, uint col, ImGuiDir dir, float scale)
		{
			RenderArrowNative(drawList, pos, col, dir, scale);
		}

		public static void RenderArrow(ref ImDrawList drawList, Vector2 pos, uint col, ImGuiDir dir, float scale)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderArrowNative((ImDrawList*)pdrawList, pos, col, dir, scale);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderBullet")]
		internal static extern void RenderBulletNative(ImDrawList* drawList, Vector2 pos, uint col);

		public static void RenderBullet(ImDrawList* drawList, Vector2 pos, uint col)
		{
			RenderBulletNative(drawList, pos, col);
		}

		public static void RenderBullet(ref ImDrawList drawList, Vector2 pos, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderBulletNative((ImDrawList*)pdrawList, pos, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderCheckMark")]
		internal static extern void RenderCheckMarkNative(ImDrawList* drawList, Vector2 pos, uint col, float sz);

		public static void RenderCheckMark(ImDrawList* drawList, Vector2 pos, uint col, float sz)
		{
			RenderCheckMarkNative(drawList, pos, col, sz);
		}

		public static void RenderCheckMark(ref ImDrawList drawList, Vector2 pos, uint col, float sz)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderCheckMarkNative((ImDrawList*)pdrawList, pos, col, sz);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderArrowPointingAt")]
		internal static extern void RenderArrowPointingAtNative(ImDrawList* drawList, Vector2 pos, Vector2 halfSz, ImGuiDir direction, uint col);

		public static void RenderArrowPointingAt(ImDrawList* drawList, Vector2 pos, Vector2 halfSz, ImGuiDir direction, uint col)
		{
			RenderArrowPointingAtNative(drawList, pos, halfSz, direction, col);
		}

		public static void RenderArrowPointingAt(ref ImDrawList drawList, Vector2 pos, Vector2 halfSz, ImGuiDir direction, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderArrowPointingAtNative((ImDrawList*)pdrawList, pos, halfSz, direction, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderArrowDockMenu")]
		internal static extern void RenderArrowDockMenuNative(ImDrawList* drawList, Vector2 pMin, float sz, uint col);

		public static void RenderArrowDockMenu(ImDrawList* drawList, Vector2 pMin, float sz, uint col)
		{
			RenderArrowDockMenuNative(drawList, pMin, sz, col);
		}

		public static void RenderArrowDockMenu(ref ImDrawList drawList, Vector2 pMin, float sz, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderArrowDockMenuNative((ImDrawList*)pdrawList, pMin, sz, col);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderRectFilledRangeH")]
		internal static extern void RenderRectFilledRangeHNative(ImDrawList* drawList, ImRect rect, uint col, float xStartNorm, float xEndNorm, float rounding);

		public static void RenderRectFilledRangeH(ImDrawList* drawList, ImRect rect, uint col, float xStartNorm, float xEndNorm, float rounding)
		{
			RenderRectFilledRangeHNative(drawList, rect, col, xStartNorm, xEndNorm, rounding);
		}

		public static void RenderRectFilledRangeH(ref ImDrawList drawList, ImRect rect, uint col, float xStartNorm, float xEndNorm, float rounding)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderRectFilledRangeHNative((ImDrawList*)pdrawList, rect, col, xStartNorm, xEndNorm, rounding);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igRenderRectFilledWithHole")]
		internal static extern void RenderRectFilledWithHoleNative(ImDrawList* drawList, ImRect outer, ImRect inner, uint col, float rounding);

		public static void RenderRectFilledWithHole(ImDrawList* drawList, ImRect outer, ImRect inner, uint col, float rounding)
		{
			RenderRectFilledWithHoleNative(drawList, outer, inner, col, rounding);
		}

		public static void RenderRectFilledWithHole(ref ImDrawList drawList, ImRect outer, ImRect inner, uint col, float rounding)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderRectFilledWithHoleNative((ImDrawList*)pdrawList, outer, inner, col, rounding);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCalcRoundingFlagsForRectInRect")]
		internal static extern ImDrawFlags CalcRoundingFlagsForRectInRectNative(ImRect rIn, ImRect rOuter, float threshold);

		public static ImDrawFlags CalcRoundingFlagsForRectInRect(ImRect rIn, ImRect rOuter, float threshold)
		{
			ImDrawFlags ret = CalcRoundingFlagsForRectInRectNative(rIn, rOuter, threshold);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTextEx")]
		internal static extern void TextExNative(byte* text, byte* textEnd, ImGuiTextFlags flags);

		public static void TextEx(byte* text, byte* textEnd, ImGuiTextFlags flags)
		{
			TextExNative(text, textEnd, flags);
		}

		public static void TextEx(ref byte text, byte* textEnd, ImGuiTextFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				TextExNative((byte*)ptext, textEnd, flags);
			}
		}

		public static void TextEx(string text, byte* textEnd, ImGuiTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextExNative(pStr0, textEnd, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextEx(byte* text, ref byte textEnd, ImGuiTextFlags flags)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				TextExNative(text, (byte*)ptextEnd, flags);
			}
		}

		public static void TextEx(byte* text, string textEnd, ImGuiTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextExNative(text, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void TextEx(ref byte text, ref byte textEnd, ImGuiTextFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					TextExNative((byte*)ptext, (byte*)ptextEnd, flags);
				}
			}
		}

		public static void TextEx(string text, string textEnd, ImGuiTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			TextExNative(pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igButtonEx")]
		internal static extern byte ButtonExNative(byte* label, Vector2 sizeArg, ImGuiButtonFlags flags);

		public static bool ButtonEx(byte* label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte ret = ButtonExNative(label, sizeArg, flags);
			return ret != 0;
		}

		public static bool ButtonEx(ref byte label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ButtonExNative((byte*)plabel, sizeArg, flags);
				return ret != 0;
			}
		}

		public static bool ButtonEx(string label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ButtonExNative(pStr0, sizeArg, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igArrowButtonEx")]
		internal static extern byte ArrowButtonExNative(byte* strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags);

		public static bool ArrowButtonEx(byte* strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte ret = ArrowButtonExNative(strId, dir, sizeArg, flags);
			return ret != 0;
		}

		public static bool ArrowButtonEx(ref byte strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ArrowButtonExNative((byte*)pstrId, dir, sizeArg, flags);
				return ret != 0;
			}
		}

		public static bool ArrowButtonEx(string strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ArrowButtonExNative(pStr0, dir, sizeArg, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImageButtonEx")]
		internal static extern byte ImageButtonExNative(int id, ImTextureID textureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol, ImGuiButtonFlags flags);

		public static bool ImageButtonEx(int id, ImTextureID textureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol, ImGuiButtonFlags flags)
		{
			byte ret = ImageButtonExNative(id, textureId, size, uv0, uv1, bgCol, tintCol, flags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSeparatorEx")]
		internal static extern void SeparatorExNative(ImGuiSeparatorFlags flags);

		public static void SeparatorEx(ImGuiSeparatorFlags flags)
		{
			SeparatorExNative(flags);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSeparatorTextEx")]
		internal static extern void SeparatorTextExNative(int id, byte* label, byte* labelEnd, float extraWidth);

		public static void SeparatorTextEx(int id, byte* label, byte* labelEnd, float extraWidth)
		{
			SeparatorTextExNative(id, label, labelEnd, extraWidth);
		}

		public static void SeparatorTextEx(int id, ref byte label, byte* labelEnd, float extraWidth)
		{
			fixed (byte* plabel = &label)
			{
				SeparatorTextExNative(id, (byte*)plabel, labelEnd, extraWidth);
			}
		}

		public static void SeparatorTextEx(int id, string label, byte* labelEnd, float extraWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SeparatorTextExNative(id, pStr0, labelEnd, extraWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SeparatorTextEx(int id, byte* label, ref byte labelEnd, float extraWidth)
		{
			fixed (byte* plabelEnd = &labelEnd)
			{
				SeparatorTextExNative(id, label, (byte*)plabelEnd, extraWidth);
			}
		}

		public static void SeparatorTextEx(int id, byte* label, string labelEnd, float extraWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SeparatorTextExNative(id, label, pStr0, extraWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SeparatorTextEx(int id, ref byte label, ref byte labelEnd, float extraWidth)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* plabelEnd = &labelEnd)
				{
					SeparatorTextExNative(id, (byte*)plabel, (byte*)plabelEnd, extraWidth);
				}
			}
		}

		public static void SeparatorTextEx(int id, string label, string labelEnd, float extraWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (labelEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(labelEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SeparatorTextExNative(id, pStr0, pStr1, extraWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckboxFlags_S64Ptr")]
		internal static extern byte CheckboxFlagsS64PtrNative(byte* label, long* flags, long flagsValue);

		public static bool CheckboxFlagsS64Ptr(byte* label, long* flags, long flagsValue)
		{
			byte ret = CheckboxFlagsS64PtrNative(label, flags, flagsValue);
			return ret != 0;
		}

		public static bool CheckboxFlagsS64Ptr(ref byte label, long* flags, long flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CheckboxFlagsS64PtrNative((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlagsS64Ptr(string label, long* flags, long flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CheckboxFlagsS64PtrNative(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CheckboxFlagsS64Ptr(byte* label, ref long flags, long flagsValue)
		{
			fixed (long* pflags = &flags)
			{
				byte ret = CheckboxFlagsS64PtrNative(label, (long*)pflags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlagsS64Ptr(ref byte label, ref long flags, long flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (long* pflags = &flags)
				{
					byte ret = CheckboxFlagsS64PtrNative((byte*)plabel, (long*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}

		public static bool CheckboxFlagsS64Ptr(string label, ref long flags, long flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (long* pflags = &flags)
			{
				byte ret = CheckboxFlagsS64PtrNative(pStr0, (long*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCheckboxFlags_U64Ptr")]
		internal static extern byte CheckboxFlagsU64PtrNative(byte* label, ulong* flags, ulong flagsValue);

		public static bool CheckboxFlagsU64Ptr(byte* label, ulong* flags, ulong flagsValue)
		{
			byte ret = CheckboxFlagsU64PtrNative(label, flags, flagsValue);
			return ret != 0;
		}

		public static bool CheckboxFlagsU64Ptr(ref byte label, ulong* flags, ulong flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CheckboxFlagsU64PtrNative((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlagsU64Ptr(string label, ulong* flags, ulong flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CheckboxFlagsU64PtrNative(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool CheckboxFlagsU64Ptr(byte* label, ref ulong flags, ulong flagsValue)
		{
			fixed (ulong* pflags = &flags)
			{
				byte ret = CheckboxFlagsU64PtrNative(label, (ulong*)pflags, flagsValue);
				return ret != 0;
			}
		}

		public static bool CheckboxFlagsU64Ptr(ref byte label, ref ulong flags, ulong flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (ulong* pflags = &flags)
				{
					byte ret = CheckboxFlagsU64PtrNative((byte*)plabel, (ulong*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}

		public static bool CheckboxFlagsU64Ptr(string label, ref ulong flags, ulong flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ulong* pflags = &flags)
			{
				byte ret = CheckboxFlagsU64PtrNative(pStr0, (ulong*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCloseButton")]
		internal static extern byte CloseButtonNative(int id, Vector2 pos);

		public static bool CloseButton(int id, Vector2 pos)
		{
			byte ret = CloseButtonNative(id, pos);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igCollapseButton")]
		internal static extern byte CollapseButtonNative(int id, Vector2 pos, ImGuiDockNode* dockNode);

		public static bool CollapseButton(int id, Vector2 pos, ImGuiDockNode* dockNode)
		{
			byte ret = CollapseButtonNative(id, pos, dockNode);
			return ret != 0;
		}

		public static bool CollapseButton(int id, Vector2 pos, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiDockNode* pdockNode = &dockNode)
			{
				byte ret = CollapseButtonNative(id, pos, (ImGuiDockNode*)pdockNode);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollbar")]
		internal static extern void ScrollbarNative(ImGuiAxis axis);

		public static void Scrollbar(ImGuiAxis axis)
		{
			ScrollbarNative(axis);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igScrollbarEx")]
		internal static extern byte ScrollbarExNative(ImRect bb, int id, ImGuiAxis axis, long* pScrollV, long availV, long contentsV, ImDrawFlags flags);

		public static bool ScrollbarEx(ImRect bb, int id, ImGuiAxis axis, long* pScrollV, long availV, long contentsV, ImDrawFlags flags)
		{
			byte ret = ScrollbarExNative(bb, id, axis, pScrollV, availV, contentsV, flags);
			return ret != 0;
		}

		public static bool ScrollbarEx(ImRect bb, int id, ImGuiAxis axis, ref long pScrollV, long availV, long contentsV, ImDrawFlags flags)
		{
			fixed (long* ppScrollV = &pScrollV)
			{
				byte ret = ScrollbarExNative(bb, id, axis, (long*)ppScrollV, availV, contentsV, flags);
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowScrollbarRect")]
		internal static extern void GetWindowScrollbarRectNative(ImRect* output, ImGuiWindow* window, ImGuiAxis axis);

		public static ImRect GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis)
		{
			ImRect ret;
			GetWindowScrollbarRectNative(&ret, window, axis);
			return ret;
		}

		public static void GetWindowScrollbarRect(ref ImRect output, ImGuiWindow* window, ImGuiAxis axis)
		{
			fixed (ImRect* poutput = &output)
			{
				GetWindowScrollbarRectNative((ImRect*)poutput, window, axis);
			}
		}

		public static ImRect GetWindowScrollbarRect(ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				GetWindowScrollbarRectNative(&ret, (ImGuiWindow*)pwindow, axis);
				return ret;
			}
		}

		public static void GetWindowScrollbarRect(ref ImRect output, ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImRect* poutput = &output)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					GetWindowScrollbarRectNative((ImRect*)poutput, (ImGuiWindow*)pwindow, axis);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowScrollbarID")]
		internal static extern int GetWindowScrollbarIDNative(ImGuiWindow* window, ImGuiAxis axis);

		public static int GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis)
		{
			int ret = GetWindowScrollbarIDNative(window, axis);
			return ret;
		}

		public static int GetWindowScrollbarID(ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = GetWindowScrollbarIDNative((ImGuiWindow*)pwindow, axis);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowResizeCornerID")]
		internal static extern int GetWindowResizeCornerIDNative(ImGuiWindow* window, int n);

		public static int GetWindowResizeCornerID(ImGuiWindow* window, int n)
		{
			int ret = GetWindowResizeCornerIDNative(window, n);
			return ret;
		}

		public static int GetWindowResizeCornerID(ref ImGuiWindow window, int n)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = GetWindowResizeCornerIDNative((ImGuiWindow*)pwindow, n);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetWindowResizeBorderID")]
		internal static extern int GetWindowResizeBorderIDNative(ImGuiWindow* window, ImGuiDir dir);

		public static int GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir)
		{
			int ret = GetWindowResizeBorderIDNative(window, dir);
			return ret;
		}

		public static int GetWindowResizeBorderID(ref ImGuiWindow window, ImGuiDir dir)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = GetWindowResizeBorderIDNative((ImGuiWindow*)pwindow, dir);
				return ret;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igButtonBehavior")]
		internal static extern byte ButtonBehaviorNative(ImRect bb, int id, bool* outHovered, bool* outHeld, ImGuiButtonFlags flags);

		public static bool ButtonBehavior(ImRect bb, int id, bool* outHovered, bool* outHeld, ImGuiButtonFlags flags)
		{
			byte ret = ButtonBehaviorNative(bb, id, outHovered, outHeld, flags);
			return ret != 0;
		}

		public static bool ButtonBehavior(ImRect bb, int id, ref bool outHovered, bool* outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHovered = &outHovered)
			{
				byte ret = ButtonBehaviorNative(bb, id, (bool*)poutHovered, outHeld, flags);
				return ret != 0;
			}
		}

		public static bool ButtonBehavior(ImRect bb, int id, bool* outHovered, ref bool outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHeld = &outHeld)
			{
				byte ret = ButtonBehaviorNative(bb, id, outHovered, (bool*)poutHeld, flags);
				return ret != 0;
			}
		}

		public static bool ButtonBehavior(ImRect bb, int id, ref bool outHovered, ref bool outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHovered = &outHovered)
			{
				fixed (bool* poutHeld = &outHeld)
				{
					byte ret = ButtonBehaviorNative(bb, id, (bool*)poutHovered, (bool*)poutHeld, flags);
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDragBehavior")]
		internal static extern byte DragBehaviorNative(int id, ImGuiDataType dataType, void* pV, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags);

		public static bool DragBehavior(int id, ImGuiDataType dataType, void* pV, float vSpeed, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags)
		{
			byte ret = DragBehaviorNative(id, dataType, pV, vSpeed, pMin, pMax, format, flags);
			return ret != 0;
		}

		public static bool DragBehavior(int id, ImGuiDataType dataType, void* pV, float vSpeed, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragBehaviorNative(id, dataType, pV, vSpeed, pMin, pMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragBehavior(int id, ImGuiDataType dataType, void* pV, float vSpeed, void* pMin, void* pMax, string format, ImGuiSliderFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragBehaviorNative(id, dataType, pV, vSpeed, pMin, pMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSliderBehavior")]
		internal static extern byte SliderBehaviorNative(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags, ImRect* outGrabBb);

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags, ImRect* outGrabBb)
		{
			byte ret = SliderBehaviorNative(bb, id, dataType, pV, pMin, pMax, format, flags, outGrabBb);
			return ret != 0;
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags, ImRect* outGrabBb)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = SliderBehaviorNative(bb, id, dataType, pV, pMin, pMax, (byte*)pformat, flags, outGrabBb);
				return ret != 0;
			}
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, string format, ImGuiSliderFlags flags, ImRect* outGrabBb)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SliderBehaviorNative(bb, id, dataType, pV, pMin, pMax, pStr0, flags, outGrabBb);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, byte* format, ImGuiSliderFlags flags, ref ImRect outGrabBb)
		{
			fixed (ImRect* poutGrabBb = &outGrabBb)
			{
				byte ret = SliderBehaviorNative(bb, id, dataType, pV, pMin, pMax, format, flags, (ImRect*)poutGrabBb);
				return ret != 0;
			}
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, ref byte format, ImGuiSliderFlags flags, ref ImRect outGrabBb)
		{
			fixed (byte* pformat = &format)
			{
				fixed (ImRect* poutGrabBb = &outGrabBb)
				{
					byte ret = SliderBehaviorNative(bb, id, dataType, pV, pMin, pMax, (byte*)pformat, flags, (ImRect*)poutGrabBb);
					return ret != 0;
				}
			}
		}

		public static bool SliderBehavior(ImRect bb, int id, ImGuiDataType dataType, void* pV, void* pMin, void* pMax, string format, ImGuiSliderFlags flags, ref ImRect outGrabBb)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImRect* poutGrabBb = &outGrabBb)
			{
				byte ret = SliderBehaviorNative(bb, id, dataType, pV, pMin, pMax, pStr0, flags, (ImRect*)poutGrabBb);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igSplitterBehavior")]
		internal static extern byte SplitterBehaviorNative(ImRect bb, int id, ImGuiAxis axis, float* size1, float* size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol);

		public static bool SplitterBehavior(ImRect bb, int id, ImGuiAxis axis, float* size1, float* size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			byte ret = SplitterBehaviorNative(bb, id, axis, size1, size2, minSize1, minSize2, hoverExtend, hoverVisibilityDelay, bgCol);
			return ret != 0;
		}

		public static bool SplitterBehavior(ImRect bb, int id, ImGuiAxis axis, ref float size1, float* size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				byte ret = SplitterBehaviorNative(bb, id, axis, (float*)psize1, size2, minSize1, minSize2, hoverExtend, hoverVisibilityDelay, bgCol);
				return ret != 0;
			}
		}

		public static bool SplitterBehavior(ImRect bb, int id, ImGuiAxis axis, float* size1, ref float size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize2 = &size2)
			{
				byte ret = SplitterBehaviorNative(bb, id, axis, size1, (float*)psize2, minSize1, minSize2, hoverExtend, hoverVisibilityDelay, bgCol);
				return ret != 0;
			}
		}

		public static bool SplitterBehavior(ImRect bb, int id, ImGuiAxis axis, ref float size1, ref float size2, float minSize1, float minSize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				fixed (float* psize2 = &size2)
				{
					byte ret = SplitterBehaviorNative(bb, id, axis, (float*)psize1, (float*)psize2, minSize1, minSize2, hoverExtend, hoverVisibilityDelay, bgCol);
					return ret != 0;
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeBehavior")]
		internal static extern byte TreeNodeBehaviorNative(int id, ImGuiTreeNodeFlags flags, byte* label, byte* labelEnd);

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, byte* label, byte* labelEnd)
		{
			byte ret = TreeNodeBehaviorNative(id, flags, label, labelEnd);
			return ret != 0;
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, ref byte label, byte* labelEnd)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TreeNodeBehaviorNative(id, flags, (byte*)plabel, labelEnd);
				return ret != 0;
			}
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, string label, byte* labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeBehaviorNative(id, flags, pStr0, labelEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, byte* label, ref byte labelEnd)
		{
			fixed (byte* plabelEnd = &labelEnd)
			{
				byte ret = TreeNodeBehaviorNative(id, flags, label, (byte*)plabelEnd);
				return ret != 0;
			}
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, byte* label, string labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeBehaviorNative(id, flags, label, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, ref byte label, ref byte labelEnd)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* plabelEnd = &labelEnd)
				{
					byte ret = TreeNodeBehaviorNative(id, flags, (byte*)plabel, (byte*)plabelEnd);
					return ret != 0;
				}
			}
		}

		public static bool TreeNodeBehavior(int id, ImGuiTreeNodeFlags flags, string label, string labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (labelEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(labelEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeBehaviorNative(id, flags, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreePushOverrideID")]
		internal static extern void TreePushOverrideIDNative(int id);

		public static void TreePushOverrideID(int id)
		{
			TreePushOverrideIDNative(id);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeSetOpen")]
		internal static extern void TreeNodeSetOpenNative(int id, byte open);

		public static void TreeNodeSetOpen(int id, bool open)
		{
			TreeNodeSetOpenNative(id, open ? (byte)1 : (byte)0);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTreeNodeUpdateNextOpen")]
		internal static extern byte TreeNodeUpdateNextOpenNative(int id, ImGuiTreeNodeFlags flags);

		public static bool TreeNodeUpdateNextOpen(int id, ImGuiTreeNodeFlags flags)
		{
			byte ret = TreeNodeUpdateNextOpenNative(id, flags);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeGetInfo")]
		internal static extern ImGuiDataTypeInfo* DataTypeGetInfoNative(ImGuiDataType dataType);

		public static ImGuiDataTypeInfoPtr DataTypeGetInfo(ImGuiDataType dataType)
		{
			ImGuiDataTypeInfoPtr ret = DataTypeGetInfoNative(dataType);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeFormatString")]
		internal static extern int DataTypeFormatStringNative(byte* buf, int bufSize, ImGuiDataType dataType, void* pData, byte* format);

		public static int DataTypeFormatString(byte* buf, int bufSize, ImGuiDataType dataType, void* pData, byte* format)
		{
			int ret = DataTypeFormatStringNative(buf, bufSize, dataType, pData, format);
			return ret;
		}

		public static int DataTypeFormatString(ref byte buf, int bufSize, ImGuiDataType dataType, void* pData, byte* format)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = DataTypeFormatStringNative((byte*)pbuf, bufSize, dataType, pData, format);
				return ret;
			}
		}

		public static int DataTypeFormatString(ref string buf, int bufSize, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = DataTypeFormatStringNative(pStr0, bufSize, dataType, pData, format);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int DataTypeFormatString(byte* buf, int bufSize, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				int ret = DataTypeFormatStringNative(buf, bufSize, dataType, pData, (byte*)pformat);
				return ret;
			}
		}

		public static int DataTypeFormatString(byte* buf, int bufSize, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = DataTypeFormatStringNative(buf, bufSize, dataType, pData, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int DataTypeFormatString(ref byte buf, int bufSize, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pformat = &format)
				{
					int ret = DataTypeFormatStringNative((byte*)pbuf, bufSize, dataType, pData, (byte*)pformat);
					return ret;
				}
			}
		}

		public static int DataTypeFormatString(ref string buf, int bufSize, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = DataTypeFormatStringNative(pStr0, bufSize, dataType, pData, pStr1);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeApplyOp")]
		internal static extern void DataTypeApplyOpNative(ImGuiDataType dataType, int op, void* output, void* arg1, void* arg2);

		public static void DataTypeApplyOp(ImGuiDataType dataType, int op, void* output, void* arg1, void* arg2)
		{
			DataTypeApplyOpNative(dataType, op, output, arg1, arg2);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeApplyFromText")]
		internal static extern byte DataTypeApplyFromTextNative(byte* buf, ImGuiDataType dataType, void* pData, byte* format);

		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte ret = DataTypeApplyFromTextNative(buf, dataType, pData, format);
			return ret != 0;
		}

		public static bool DataTypeApplyFromText(ref byte buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = DataTypeApplyFromTextNative((byte*)pbuf, dataType, pData, format);
				return ret != 0;
			}
		}

		public static bool DataTypeApplyFromText(string buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DataTypeApplyFromTextNative(pStr0, dataType, pData, format);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DataTypeApplyFromTextNative(buf, dataType, pData, (byte*)pformat);
				return ret != 0;
			}
		}

		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DataTypeApplyFromTextNative(buf, dataType, pData, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DataTypeApplyFromText(ref byte buf, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DataTypeApplyFromTextNative((byte*)pbuf, dataType, pData, (byte*)pformat);
					return ret != 0;
				}
			}
		}

		public static bool DataTypeApplyFromText(string buf, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = DataTypeApplyFromTextNative(pStr0, dataType, pData, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeCompare")]
		internal static extern int DataTypeCompareNative(ImGuiDataType dataType, void* arg1, void* arg2);

		public static int DataTypeCompare(ImGuiDataType dataType, void* arg1, void* arg2)
		{
			int ret = DataTypeCompareNative(dataType, arg1, arg2);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDataTypeClamp")]
		internal static extern byte DataTypeClampNative(ImGuiDataType dataType, void* pData, void* pMin, void* pMax);

		public static bool DataTypeClamp(ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			byte ret = DataTypeClampNative(dataType, pData, pMin, pMax);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputTextEx")]
		internal static extern byte InputTextExNative(byte* label, byte* hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData);

		public static bool InputTextEx(byte* label, byte* hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte ret = InputTextExNative(label, hint, buf, bufSize, sizeArg, flags, callback, userData);
			return ret != 0;
		}

		public static bool InputTextEx(ref byte label, byte* hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = InputTextExNative((byte*)plabel, hint, buf, bufSize, sizeArg, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputTextEx(string label, byte* hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextExNative(pStr0, hint, buf, bufSize, sizeArg, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextEx(byte* label, ref byte hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* phint = &hint)
			{
				byte ret = InputTextExNative(label, (byte*)phint, buf, bufSize, sizeArg, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputTextEx(byte* label, string hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextExNative(label, pStr0, buf, bufSize, sizeArg, flags, callback, userData);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextEx(ref byte label, ref byte hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					byte ret = InputTextExNative((byte*)plabel, (byte*)phint, buf, bufSize, sizeArg, flags, callback, userData);
					return ret != 0;
				}
			}
		}

		public static bool InputTextEx(string label, string hint, byte* buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextExNative(pStr0, pStr1, buf, bufSize, sizeArg, flags, callback, userData);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextEx(byte* label, byte* hint, ref byte buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = InputTextExNative(label, hint, (byte*)pbuf, bufSize, sizeArg, flags, callback, userData);
				return ret != 0;
			}
		}

		public static bool InputTextEx(byte* label, byte* hint, ref string buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputTextExNative(label, hint, pStr0, bufSize, sizeArg, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextEx(ref byte label, byte* hint, ref byte buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextExNative((byte*)plabel, hint, (byte*)pbuf, bufSize, sizeArg, flags, callback, userData);
					return ret != 0;
				}
			}
		}

		public static bool InputTextEx(string label, byte* hint, ref string buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextExNative(pStr0, hint, pStr1, bufSize, sizeArg, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextEx(byte* label, ref byte hint, ref byte buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* phint = &hint)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = InputTextExNative(label, (byte*)phint, (byte*)pbuf, bufSize, sizeArg, flags, callback, userData);
					return ret != 0;
				}
			}
		}

		public static bool InputTextEx(byte* label, string hint, ref string buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (hint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(hint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(hint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = InputTextExNative(label, pStr0, pStr1, bufSize, sizeArg, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputTextEx(ref byte label, ref byte hint, ref byte buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* phint = &hint)
				{
					fixed (byte* pbuf = &buf)
					{
						byte ret = InputTextExNative((byte*)plabel, (byte*)phint, (byte*)pbuf, bufSize, sizeArg, flags, callback, userData);
						return ret != 0;
					}
				}
			}
		}

		public static bool InputTextEx(string label, string hint, ref string buf, int bufSize, Vector2 sizeArg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* userData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (hint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(hint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(hint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (buf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(buf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(buf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = InputTextExNative(pStr0, pStr1, pStr2, bufSize, sizeArg, flags, callback, userData);
			buf = Utils.DecodeStringUTF8(pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igInputTextDeactivateHook")]
		internal static extern void InputTextDeactivateHookNative(int id);

		public static void InputTextDeactivateHook(int id)
		{
			InputTextDeactivateHookNative(id);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTempInputText")]
		internal static extern byte TempInputTextNative(ImRect bb, int id, byte* label, byte* buf, int bufSize, ImGuiInputTextFlags flags);

		public static bool TempInputText(ImRect bb, int id, byte* label, byte* buf, int bufSize, ImGuiInputTextFlags flags)
		{
			byte ret = TempInputTextNative(bb, id, label, buf, bufSize, flags);
			return ret != 0;
		}

		public static bool TempInputText(ImRect bb, int id, ref byte label, byte* buf, int bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TempInputTextNative(bb, id, (byte*)plabel, buf, bufSize, flags);
				return ret != 0;
			}
		}

		public static bool TempInputText(ImRect bb, int id, string label, byte* buf, int bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TempInputTextNative(bb, id, pStr0, buf, bufSize, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TempInputText(ImRect bb, int id, byte* label, ref byte buf, int bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = TempInputTextNative(bb, id, label, (byte*)pbuf, bufSize, flags);
				return ret != 0;
			}
		}

		public static bool TempInputText(ImRect bb, int id, byte* label, ref string buf, int bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TempInputTextNative(bb, id, label, pStr0, bufSize, flags);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TempInputText(ImRect bb, int id, ref byte label, ref byte buf, int bufSize, ImGuiInputTextFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pbuf = &buf)
				{
					byte ret = TempInputTextNative(bb, id, (byte*)plabel, (byte*)pbuf, bufSize, flags);
					return ret != 0;
				}
			}
		}

		public static bool TempInputText(ImRect bb, int id, string label, ref string buf, int bufSize, ImGuiInputTextFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (buf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(buf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(buf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TempInputTextNative(bb, id, pStr0, pStr1, bufSize, flags);
			buf = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTempInputScalar")]
		internal static extern byte TempInputScalarNative(ImRect bb, int id, byte* label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax);

		public static bool TempInputScalar(ImRect bb, int id, byte* label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			byte ret = TempInputScalarNative(bb, id, label, dataType, pData, format, pClampMin, pClampMax);
			return ret != 0;
		}

		public static bool TempInputScalar(ImRect bb, int id, ref byte label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TempInputScalarNative(bb, id, (byte*)plabel, dataType, pData, format, pClampMin, pClampMax);
				return ret != 0;
			}
		}

		public static bool TempInputScalar(ImRect bb, int id, string label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TempInputScalarNative(bb, id, pStr0, dataType, pData, format, pClampMin, pClampMax);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TempInputScalar(ImRect bb, int id, byte* label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = TempInputScalarNative(bb, id, label, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
				return ret != 0;
			}
		}

		public static bool TempInputScalar(ImRect bb, int id, byte* label, ImGuiDataType dataType, void* pData, string format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TempInputScalarNative(bb, id, label, dataType, pData, pStr0, pClampMin, pClampMax);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool TempInputScalar(ImRect bb, int id, ref byte label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = TempInputScalarNative(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
					return ret != 0;
				}
			}
		}

		public static bool TempInputScalar(ImRect bb, int id, string label, ImGuiDataType dataType, void* pData, string format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TempInputScalarNative(bb, id, pStr0, dataType, pData, pStr1, pClampMin, pClampMax);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igTempInputIsActive")]
		internal static extern byte TempInputIsActiveNative(int id);

		public static bool TempInputIsActive(int id)
		{
			byte ret = TempInputIsActiveNative(id);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGetInputTextState")]
		internal static extern ImGuiInputTextState* GetInputTextStateNative(int id);

		public static ImGuiInputTextStatePtr GetInputTextState(int id)
		{
			ImGuiInputTextStatePtr ret = GetInputTextStateNative(id);
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorTooltip")]
		internal static extern void ColorTooltipNative(byte* text, float* col, ImGuiColorEditFlags flags);

		public static void ColorTooltip(byte* text, float* col, ImGuiColorEditFlags flags)
		{
			ColorTooltipNative(text, col, flags);
		}

		public static void ColorTooltip(ref byte text, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				ColorTooltipNative((byte*)ptext, col, flags);
			}
		}

		public static void ColorTooltip(string text, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColorTooltipNative(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ColorTooltip(byte* text, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				ColorTooltipNative(text, (float*)pcol, flags);
			}
		}

		public static void ColorTooltip(ref byte text, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				fixed (float* pcol = &col)
				{
					ColorTooltipNative((byte*)ptext, (float*)pcol, flags);
				}
			}
		}

		public static void ColorTooltip(string text, ref float col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pcol = &col)
			{
				ColorTooltipNative(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorEditOptionsPopup")]
		internal static extern void ColorEditOptionsPopupNative(float* col, ImGuiColorEditFlags flags);

		public static void ColorEditOptionsPopup(float* col, ImGuiColorEditFlags flags)
		{
			ColorEditOptionsPopupNative(col, flags);
		}

		public static void ColorEditOptionsPopup(ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				ColorEditOptionsPopupNative((float*)pcol, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igColorPickerOptionsPopup")]
		internal static extern void ColorPickerOptionsPopupNative(float* refCol, ImGuiColorEditFlags flags);

		public static void ColorPickerOptionsPopup(float* refCol, ImGuiColorEditFlags flags)
		{
			ColorPickerOptionsPopupNative(refCol, flags);
		}

		public static void ColorPickerOptionsPopup(ref float refCol, ImGuiColorEditFlags flags)
		{
			fixed (float* prefCol = &refCol)
			{
				ColorPickerOptionsPopupNative((float*)prefCol, flags);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igPlotEx")]
		internal static extern int PlotExNative(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 sizeArg);

		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			int ret = PlotExNative(plotType, label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, sizeArg);
			return ret;
		}

		public static int PlotEx(ImGuiPlotType plotType, ref byte label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			fixed (byte* plabel = &label)
			{
				int ret = PlotExNative(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, sizeArg);
				return ret;
			}
		}

		public static int PlotEx(ImGuiPlotType plotType, string label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = PlotExNative(plotType, pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, sizeArg);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				int ret = PlotExNative(plotType, label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, sizeArg);
				return ret;
			}
		}

		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = PlotExNative(plotType, label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, sizeArg);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int PlotEx(ImGuiPlotType plotType, ref byte label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					int ret = PlotExNative(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, sizeArg);
					return ret;
				}
			}
		}

		public static int PlotEx(ImGuiPlotType plotType, string label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int>, void*, int, int, byte*, float, float, Vector2> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 sizeArg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = PlotExNative(plotType, pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, sizeArg);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShadeVertsLinearColorGradientKeepAlpha")]
		internal static extern void ShadeVertsLinearColorGradientKeepAlphaNative(ImDrawList* drawList, int vertStartIdx, int vertEndIdx, Vector2 gradientP0, Vector2 gradientP1, uint col0, uint col1);

		public static void ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* drawList, int vertStartIdx, int vertEndIdx, Vector2 gradientP0, Vector2 gradientP1, uint col0, uint col1)
		{
			ShadeVertsLinearColorGradientKeepAlphaNative(drawList, vertStartIdx, vertEndIdx, gradientP0, gradientP1, col0, col1);
		}

		public static void ShadeVertsLinearColorGradientKeepAlpha(ref ImDrawList drawList, int vertStartIdx, int vertEndIdx, Vector2 gradientP0, Vector2 gradientP1, uint col0, uint col1)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ShadeVertsLinearColorGradientKeepAlphaNative((ImDrawList*)pdrawList, vertStartIdx, vertEndIdx, gradientP0, gradientP1, col0, col1);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShadeVertsLinearUV")]
		internal static extern void ShadeVertsLinearUVNative(ImDrawList* drawList, int vertStartIdx, int vertEndIdx, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, byte clamp);

		public static void ShadeVertsLinearUV(ImDrawList* drawList, int vertStartIdx, int vertEndIdx, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, bool clamp)
		{
			ShadeVertsLinearUVNative(drawList, vertStartIdx, vertEndIdx, a, b, uvA, uvB, clamp ? (byte)1 : (byte)0);
		}

		public static void ShadeVertsLinearUV(ref ImDrawList drawList, int vertStartIdx, int vertEndIdx, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, bool clamp)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ShadeVertsLinearUVNative((ImDrawList*)pdrawList, vertStartIdx, vertEndIdx, a, b, uvA, uvB, clamp ? (byte)1 : (byte)0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGcCompactTransientMiscBuffers")]
		internal static extern void GcCompactTransientMiscBuffersNative();

		public static void GcCompactTransientMiscBuffers()
		{
			GcCompactTransientMiscBuffersNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGcCompactTransientWindowBuffers")]
		internal static extern void GcCompactTransientWindowBuffersNative(ImGuiWindow* window);

		public static void GcCompactTransientWindowBuffers(ImGuiWindow* window)
		{
			GcCompactTransientWindowBuffersNative(window);
		}

		public static void GcCompactTransientWindowBuffers(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				GcCompactTransientWindowBuffersNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGcAwakeTransientWindowBuffers")]
		internal static extern void GcAwakeTransientWindowBuffersNative(ImGuiWindow* window);

		public static void GcAwakeTransientWindowBuffers(ImGuiWindow* window)
		{
			GcAwakeTransientWindowBuffersNative(window);
		}

		public static void GcAwakeTransientWindowBuffers(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				GcAwakeTransientWindowBuffersNative((ImGuiWindow*)pwindow);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLog")]
		internal static extern void DebugLogNative(byte* fmt);

		public static void DebugLog(byte* fmt)
		{
			DebugLogNative(fmt);
		}

		public static void DebugLog(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				DebugLogNative((byte*)pfmt);
			}
		}

		public static void DebugLog(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugLogNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLogV")]
		internal static extern void DebugLogVNative(byte* fmt, nuint args);

		public static void DebugLogV(byte* fmt, nuint args)
		{
			DebugLogVNative(fmt, args);
		}

		public static void DebugLogV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				DebugLogVNative((byte*)pfmt, args);
			}
		}

		public static void DebugLogV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugLogVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igErrorCheckEndFrameRecover")]
		internal static extern void ErrorCheckEndFrameRecoverNative(ImGuiErrorLogCallback logCallback, void* userData);

		public static void ErrorCheckEndFrameRecover(ImGuiErrorLogCallback logCallback, void* userData)
		{
			ErrorCheckEndFrameRecoverNative(logCallback, userData);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igErrorCheckEndWindowRecover")]
		internal static extern void ErrorCheckEndWindowRecoverNative(ImGuiErrorLogCallback logCallback, void* userData);

		public static void ErrorCheckEndWindowRecover(ImGuiErrorLogCallback logCallback, void* userData)
		{
			ErrorCheckEndWindowRecoverNative(logCallback, userData);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igErrorCheckUsingSetCursorPosToExtendParentBoundaries")]
		internal static extern void ErrorCheckUsingSetCursorPosToExtendParentBoundariesNative();

		public static void ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
		{
			ErrorCheckUsingSetCursorPosToExtendParentBoundariesNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLocateItem")]
		internal static extern void DebugLocateItemNative(int targetId);

		public static void DebugLocateItem(int targetId)
		{
			DebugLocateItemNative(targetId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLocateItemOnHover")]
		internal static extern void DebugLocateItemOnHoverNative(int targetId);

		public static void DebugLocateItemOnHover(int targetId)
		{
			DebugLocateItemOnHoverNative(targetId);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugLocateItemResolveWithLastItem")]
		internal static extern void DebugLocateItemResolveWithLastItemNative();

		public static void DebugLocateItemResolveWithLastItem()
		{
			DebugLocateItemResolveWithLastItemNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugDrawItemRect")]
		internal static extern void DebugDrawItemRectNative(uint col);

		public static void DebugDrawItemRect(uint col)
		{
			DebugDrawItemRectNative(col);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugStartItemPicker")]
		internal static extern void DebugStartItemPickerNative();

		public static void DebugStartItemPicker()
		{
			DebugStartItemPickerNative();
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igShowFontAtlas")]
		internal static extern void ShowFontAtlasNative(ImFontAtlas* atlas);

		public static void ShowFontAtlas(ImFontAtlas* atlas)
		{
			ShowFontAtlasNative(atlas);
		}

		public static void ShowFontAtlas(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ShowFontAtlasNative((ImFontAtlas*)patlas);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugHookIdInfo")]
		internal static extern void DebugHookIdInfoNative(int id, ImGuiDataType dataType, void* dataId, void* dataIdEnd);

		public static void DebugHookIdInfo(int id, ImGuiDataType dataType, void* dataId, void* dataIdEnd)
		{
			DebugHookIdInfoNative(id, dataType, dataId, dataIdEnd);
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeColumns")]
		internal static extern void DebugNodeColumnsNative(ImGuiOldColumns* columns);

		public static void DebugNodeColumns(ImGuiOldColumns* columns)
		{
			DebugNodeColumnsNative(columns);
		}

		public static void DebugNodeColumns(ref ImGuiOldColumns columns)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				DebugNodeColumnsNative((ImGuiOldColumns*)pcolumns);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeDockNode")]
		internal static extern void DebugNodeDockNodeNative(ImGuiDockNode* node, byte* label);

		public static void DebugNodeDockNode(ImGuiDockNode* node, byte* label)
		{
			DebugNodeDockNodeNative(node, label);
		}

		public static void DebugNodeDockNode(ref ImGuiDockNode node, byte* label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				DebugNodeDockNodeNative((ImGuiDockNode*)pnode, label);
			}
		}

		public static void DebugNodeDockNode(ImGuiDockNode* node, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeDockNodeNative(node, (byte*)plabel);
			}
		}

		public static void DebugNodeDockNode(ImGuiDockNode* node, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeDockNodeNative(node, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeDockNode(ref ImGuiDockNode node, ref byte label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeDockNodeNative((ImGuiDockNode*)pnode, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeDockNode(ref ImGuiDockNode node, string label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeDockNodeNative((ImGuiDockNode*)pnode, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeDrawList")]
		internal static extern void DebugNodeDrawListNative(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* drawList, byte* label);

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* drawList, byte* label)
		{
			DebugNodeDrawListNative(window, viewport, drawList, label);
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ImDrawList* drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DebugNodeDrawListNative((ImGuiWindow*)pwindow, viewport, drawList, label);
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ImDrawList* drawList, byte* label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DebugNodeDrawListNative(window, (ImGuiViewportP*)pviewport, drawList, label);
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawList* drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					DebugNodeDrawListNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, label);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				DebugNodeDrawListNative(window, viewport, (ImDrawList*)pdrawList, label);
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					DebugNodeDrawListNative((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, label);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					DebugNodeDrawListNative(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, label);
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						DebugNodeDrawListNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, label);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* drawList, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeDrawListNative(window, viewport, drawList, (byte*)plabel);
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* drawList, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeDrawListNative(window, viewport, drawList, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ImDrawList* drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeDrawListNative((ImGuiWindow*)pwindow, viewport, drawList, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ImDrawList* drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeDrawListNative((ImGuiWindow*)pwindow, viewport, drawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ImDrawList* drawList, ref byte label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeDrawListNative(window, (ImGuiViewportP*)pviewport, drawList, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ImDrawList* drawList, string label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeDrawListNative(window, (ImGuiViewportP*)pviewport, drawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawList* drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (byte* plabel = &label)
					{
						DebugNodeDrawListNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, (byte*)plabel);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawList* drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					DebugNodeDrawListNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeDrawListNative(window, viewport, (ImDrawList*)pdrawList, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeDrawListNative(window, viewport, (ImDrawList*)pdrawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* plabel = &label)
					{
						DebugNodeDrawListNative((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, (byte*)plabel);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportP* viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					DebugNodeDrawListNative((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* plabel = &label)
					{
						DebugNodeDrawListNative(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, (byte*)plabel);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ImGuiWindow* window, ref ImGuiViewportP viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					DebugNodeDrawListNative(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						fixed (byte* plabel = &label)
						{
							DebugNodeDrawListNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, (byte*)plabel);
						}
					}
				}
			}
		}

		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (label != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(label);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						DebugNodeDrawListNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeDrawCmdShowMeshAndBoundingBox")]
		internal static extern void DebugNodeDrawCmdShowMeshAndBoundingBoxNative(ImDrawList* outDrawList, ImDrawList* drawList, ImDrawCmd* drawCmd, byte showMesh, byte showAabb);

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* outDrawList, ImDrawList* drawList, ImDrawCmd* drawCmd, bool showMesh, bool showAabb)
		{
			DebugNodeDrawCmdShowMeshAndBoundingBoxNative(outDrawList, drawList, drawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ImDrawList* drawList, ImDrawCmd* drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				DebugNodeDrawCmdShowMeshAndBoundingBoxNative((ImDrawList*)poutDrawList, drawList, drawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* outDrawList, ref ImDrawList drawList, ImDrawCmd* drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				DebugNodeDrawCmdShowMeshAndBoundingBoxNative(outDrawList, (ImDrawList*)pdrawList, drawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ref ImDrawList drawList, ImDrawCmd* drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					DebugNodeDrawCmdShowMeshAndBoundingBoxNative((ImDrawList*)poutDrawList, (ImDrawList*)pdrawList, drawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* outDrawList, ImDrawList* drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawCmd* pdrawCmd = &drawCmd)
			{
				DebugNodeDrawCmdShowMeshAndBoundingBoxNative(outDrawList, drawList, (ImDrawCmd*)pdrawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ImDrawList* drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawCmd* pdrawCmd = &drawCmd)
				{
					DebugNodeDrawCmdShowMeshAndBoundingBoxNative((ImDrawList*)poutDrawList, drawList, (ImDrawCmd*)pdrawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* outDrawList, ref ImDrawList drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (ImDrawCmd* pdrawCmd = &drawCmd)
				{
					DebugNodeDrawCmdShowMeshAndBoundingBoxNative(outDrawList, (ImDrawList*)pdrawList, (ImDrawCmd*)pdrawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
				}
			}
		}

		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ref ImDrawList drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (ImDrawCmd* pdrawCmd = &drawCmd)
					{
						DebugNodeDrawCmdShowMeshAndBoundingBoxNative((ImDrawList*)poutDrawList, (ImDrawList*)pdrawList, (ImDrawCmd*)pdrawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeFont")]
		internal static extern void DebugNodeFontNative(ImFont* font);

		public static void DebugNodeFont(ImFont* font)
		{
			DebugNodeFontNative(font);
		}

		public static void DebugNodeFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				DebugNodeFontNative((ImFont*)pfont);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeFontGlyph")]
		internal static extern void DebugNodeFontGlyphNative(ImFont* font, ImFontGlyph* glyph);

		public static void DebugNodeFontGlyph(ImFont* font, ImFontGlyph* glyph)
		{
			DebugNodeFontGlyphNative(font, glyph);
		}

		public static void DebugNodeFontGlyph(ref ImFont font, ImFontGlyph* glyph)
		{
			fixed (ImFont* pfont = &font)
			{
				DebugNodeFontGlyphNative((ImFont*)pfont, glyph);
			}
		}

		public static void DebugNodeFontGlyph(ImFont* font, ref ImFontGlyph glyph)
		{
			fixed (ImFontGlyph* pglyph = &glyph)
			{
				DebugNodeFontGlyphNative(font, (ImFontGlyph*)pglyph);
			}
		}

		public static void DebugNodeFontGlyph(ref ImFont font, ref ImFontGlyph glyph)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (ImFontGlyph* pglyph = &glyph)
				{
					DebugNodeFontGlyphNative((ImFont*)pfont, (ImFontGlyph*)pglyph);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeStorage")]
		internal static extern void DebugNodeStorageNative(ImGuiStorage* storage, byte* label);

		public static void DebugNodeStorage(ImGuiStorage* storage, byte* label)
		{
			DebugNodeStorageNative(storage, label);
		}

		public static void DebugNodeStorage(ref ImGuiStorage storage, byte* label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				DebugNodeStorageNative((ImGuiStorage*)pstorage, label);
			}
		}

		public static void DebugNodeStorage(ImGuiStorage* storage, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeStorageNative(storage, (byte*)plabel);
			}
		}

		public static void DebugNodeStorage(ImGuiStorage* storage, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeStorageNative(storage, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeStorage(ref ImGuiStorage storage, ref byte label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeStorageNative((ImGuiStorage*)pstorage, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeStorage(ref ImGuiStorage storage, string label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeStorageNative((ImGuiStorage*)pstorage, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeTabBar")]
		internal static extern void DebugNodeTabBarNative(ImGuiTabBar* tabBar, byte* label);

		public static void DebugNodeTabBar(ImGuiTabBar* tabBar, byte* label)
		{
			DebugNodeTabBarNative(tabBar, label);
		}

		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, byte* label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				DebugNodeTabBarNative((ImGuiTabBar*)ptabBar, label);
			}
		}

		public static void DebugNodeTabBar(ImGuiTabBar* tabBar, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeTabBarNative(tabBar, (byte*)plabel);
			}
		}

		public static void DebugNodeTabBar(ImGuiTabBar* tabBar, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeTabBarNative(tabBar, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, ref byte label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeTabBarNative((ImGuiTabBar*)ptabBar, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, string label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeTabBarNative((ImGuiTabBar*)ptabBar, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeTable")]
		internal static extern void DebugNodeTableNative(ImGuiTable* table);

		public static void DebugNodeTable(ImGuiTable* table)
		{
			DebugNodeTableNative(table);
		}

		public static void DebugNodeTable(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				DebugNodeTableNative((ImGuiTable*)ptable);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeTableSettings")]
		internal static extern void DebugNodeTableSettingsNative(ImGuiTableSettings* settings);

		public static void DebugNodeTableSettings(ImGuiTableSettings* settings)
		{
			DebugNodeTableSettingsNative(settings);
		}

		public static void DebugNodeTableSettings(ref ImGuiTableSettings settings)
		{
			fixed (ImGuiTableSettings* psettings = &settings)
			{
				DebugNodeTableSettingsNative((ImGuiTableSettings*)psettings);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeInputTextState")]
		internal static extern void DebugNodeInputTextStateNative(ImGuiInputTextState* state);

		public static void DebugNodeInputTextState(ImGuiInputTextState* state)
		{
			DebugNodeInputTextStateNative(state);
		}

		public static void DebugNodeInputTextState(ref ImGuiInputTextState state)
		{
			fixed (ImGuiInputTextState* pstate = &state)
			{
				DebugNodeInputTextStateNative((ImGuiInputTextState*)pstate);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeWindow")]
		internal static extern void DebugNodeWindowNative(ImGuiWindow* window, byte* label);

		public static void DebugNodeWindow(ImGuiWindow* window, byte* label)
		{
			DebugNodeWindowNative(window, label);
		}

		public static void DebugNodeWindow(ref ImGuiWindow window, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				DebugNodeWindowNative((ImGuiWindow*)pwindow, label);
			}
		}

		public static void DebugNodeWindow(ImGuiWindow* window, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeWindowNative(window, (byte*)plabel);
			}
		}

		public static void DebugNodeWindow(ImGuiWindow* window, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeWindowNative(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeWindow(ref ImGuiWindow window, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeWindowNative((ImGuiWindow*)pwindow, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeWindow(ref ImGuiWindow window, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeWindowNative((ImGuiWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeWindowSettings")]
		internal static extern void DebugNodeWindowSettingsNative(ImGuiWindowSettings* settings);

		public static void DebugNodeWindowSettings(ImGuiWindowSettings* settings)
		{
			DebugNodeWindowSettingsNative(settings);
		}

		public static void DebugNodeWindowSettings(ref ImGuiWindowSettings settings)
		{
			fixed (ImGuiWindowSettings* psettings = &settings)
			{
				DebugNodeWindowSettingsNative((ImGuiWindowSettings*)psettings);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeWindowsList")]
		internal static extern void DebugNodeWindowsListNative(ImVectorImGuiWindowPtr* windows, byte* label);

		public static void DebugNodeWindowsList(ImVectorImGuiWindowPtr* windows, byte* label)
		{
			DebugNodeWindowsListNative(windows, label);
		}

		public static void DebugNodeWindowsList(ref ImVectorImGuiWindowPtr windows, byte* label)
		{
			fixed (ImVectorImGuiWindowPtr* pwindows = &windows)
			{
				DebugNodeWindowsListNative((ImVectorImGuiWindowPtr*)pwindows, label);
			}
		}

		public static void DebugNodeWindowsList(ImVectorImGuiWindowPtr* windows, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				DebugNodeWindowsListNative(windows, (byte*)plabel);
			}
		}

		public static void DebugNodeWindowsList(ImVectorImGuiWindowPtr* windows, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugNodeWindowsListNative(windows, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugNodeWindowsList(ref ImVectorImGuiWindowPtr windows, ref byte label)
		{
			fixed (ImVectorImGuiWindowPtr* pwindows = &windows)
			{
				fixed (byte* plabel = &label)
				{
					DebugNodeWindowsListNative((ImVectorImGuiWindowPtr*)pwindows, (byte*)plabel);
				}
			}
		}

		public static void DebugNodeWindowsList(ref ImVectorImGuiWindowPtr windows, string label)
		{
			fixed (ImVectorImGuiWindowPtr* pwindows = &windows)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				DebugNodeWindowsListNative((ImVectorImGuiWindowPtr*)pwindows, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeWindowsListByBeginStackParent")]
		internal static extern void DebugNodeWindowsListByBeginStackParentNative(ImGuiWindow** windows, int windowsSize, ImGuiWindow* parentInBeginStack);

		public static void DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windowsSize, ImGuiWindow* parentInBeginStack)
		{
			DebugNodeWindowsListByBeginStackParentNative(windows, windowsSize, parentInBeginStack);
		}

		public static void DebugNodeWindowsListByBeginStackParent(ref ImGuiWindow* windows, int windowsSize, ImGuiWindow* parentInBeginStack)
		{
			fixed (ImGuiWindow** pwindows = &windows)
			{
				DebugNodeWindowsListByBeginStackParentNative((ImGuiWindow**)pwindows, windowsSize, parentInBeginStack);
			}
		}

		public static void DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windowsSize, ref ImGuiWindow parentInBeginStack)
		{
			fixed (ImGuiWindow* pparentInBeginStack = &parentInBeginStack)
			{
				DebugNodeWindowsListByBeginStackParentNative(windows, windowsSize, (ImGuiWindow*)pparentInBeginStack);
			}
		}

		public static void DebugNodeWindowsListByBeginStackParent(ref ImGuiWindow* windows, int windowsSize, ref ImGuiWindow parentInBeginStack)
		{
			fixed (ImGuiWindow** pwindows = &windows)
			{
				fixed (ImGuiWindow* pparentInBeginStack = &parentInBeginStack)
				{
					DebugNodeWindowsListByBeginStackParentNative((ImGuiWindow**)pwindows, windowsSize, (ImGuiWindow*)pparentInBeginStack);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugNodeViewport")]
		internal static extern void DebugNodeViewportNative(ImGuiViewportP* viewport);

		public static void DebugNodeViewport(ImGuiViewportP* viewport)
		{
			DebugNodeViewportNative(viewport);
		}

		public static void DebugNodeViewport(ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DebugNodeViewportNative((ImGuiViewportP*)pviewport);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugRenderKeyboardPreview")]
		internal static extern void DebugRenderKeyboardPreviewNative(ImDrawList* drawList);

		public static void DebugRenderKeyboardPreview(ImDrawList* drawList)
		{
			DebugRenderKeyboardPreviewNative(drawList);
		}

		public static void DebugRenderKeyboardPreview(ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				DebugRenderKeyboardPreviewNative((ImDrawList*)pdrawList);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igDebugRenderViewportThumbnail")]
		internal static extern void DebugRenderViewportThumbnailNative(ImDrawList* drawList, ImGuiViewportP* viewport, ImRect bb);

		public static void DebugRenderViewportThumbnail(ImDrawList* drawList, ImGuiViewportP* viewport, ImRect bb)
		{
			DebugRenderViewportThumbnailNative(drawList, viewport, bb);
		}

		public static void DebugRenderViewportThumbnail(ref ImDrawList drawList, ImGuiViewportP* viewport, ImRect bb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				DebugRenderViewportThumbnailNative((ImDrawList*)pdrawList, viewport, bb);
			}
		}

		public static void DebugRenderViewportThumbnail(ImDrawList* drawList, ref ImGuiViewportP viewport, ImRect bb)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DebugRenderViewportThumbnailNative(drawList, (ImGuiViewportP*)pviewport, bb);
			}
		}

		public static void DebugRenderViewportThumbnail(ref ImDrawList drawList, ref ImGuiViewportP viewport, ImRect bb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					DebugRenderViewportThumbnailNative((ImDrawList*)pdrawList, (ImGuiViewportP*)pviewport, bb);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igIsKeyPressedMap")]
		internal static extern byte IsKeyPressedMapNative(ImGuiKey key, byte repeat);

		public static bool IsKeyPressedMap(ImGuiKey key, bool repeat)
		{
			byte ret = IsKeyPressedMapNative(key, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasGetBuilderForStbTruetype")]
		internal static extern ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetypeNative();

		public static ImFontBuilderIOPtr ImFontAtlasGetBuilderForStbTruetype()
		{
			ImFontBuilderIOPtr ret = ImFontAtlasGetBuilderForStbTruetypeNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildInit")]
		internal static extern void ImFontAtlasBuildInitNative(ImFontAtlas* atlas);

		public static void ImFontAtlasBuildInit(ImFontAtlas* atlas)
		{
			ImFontAtlasBuildInitNative(atlas);
		}

		public static void ImFontAtlasBuildInit(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildInitNative((ImFontAtlas*)patlas);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildSetupFont")]
		internal static extern void ImFontAtlasBuildSetupFontNative(ImFontAtlas* atlas, ImFont* font, ImFontConfig* fontConfig, float ascent, float descent);

		public static void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* fontConfig, float ascent, float descent)
		{
			ImFontAtlasBuildSetupFontNative(atlas, font, fontConfig, ascent, descent);
		}

		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ImFont* font, ImFontConfig* fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildSetupFontNative((ImFontAtlas*)patlas, font, fontConfig, ascent, descent);
			}
		}

		public static void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ref ImFont font, ImFontConfig* fontConfig, float ascent, float descent)
		{
			fixed (ImFont* pfont = &font)
			{
				ImFontAtlasBuildSetupFontNative(atlas, (ImFont*)pfont, fontConfig, ascent, descent);
			}
		}

		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ref ImFont font, ImFontConfig* fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFont* pfont = &font)
				{
					ImFontAtlasBuildSetupFontNative((ImFontAtlas*)patlas, (ImFont*)pfont, fontConfig, ascent, descent);
				}
			}
		}

		public static void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontConfig* pfontConfig = &fontConfig)
			{
				ImFontAtlasBuildSetupFontNative(atlas, font, (ImFontConfig*)pfontConfig, ascent, descent);
			}
		}

		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ImFont* font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFontConfig* pfontConfig = &fontConfig)
				{
					ImFontAtlasBuildSetupFontNative((ImFontAtlas*)patlas, font, (ImFontConfig*)pfontConfig, ascent, descent);
				}
			}
		}

		public static void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ref ImFont font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (ImFontConfig* pfontConfig = &fontConfig)
				{
					ImFontAtlasBuildSetupFontNative(atlas, (ImFont*)pfont, (ImFontConfig*)pfontConfig, ascent, descent);
				}
			}
		}

		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ref ImFont font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (ImFontConfig* pfontConfig = &fontConfig)
					{
						ImFontAtlasBuildSetupFontNative((ImFontAtlas*)patlas, (ImFont*)pfont, (ImFontConfig*)pfontConfig, ascent, descent);
					}
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildPackCustomRects")]
		internal static extern void ImFontAtlasBuildPackCustomRectsNative(ImFontAtlas* atlas, void* stbrpContextOpaque);

		public static void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrpContextOpaque)
		{
			ImFontAtlasBuildPackCustomRectsNative(atlas, stbrpContextOpaque);
		}

		public static void ImFontAtlasBuildPackCustomRects(ref ImFontAtlas atlas, void* stbrpContextOpaque)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildPackCustomRectsNative((ImFontAtlas*)patlas, stbrpContextOpaque);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildFinish")]
		internal static extern void ImFontAtlasBuildFinishNative(ImFontAtlas* atlas);

		public static void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
		{
			ImFontAtlasBuildFinishNative(atlas);
		}

		public static void ImFontAtlasBuildFinish(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildFinishNative((ImFontAtlas*)patlas);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildRender8bppRectFromString")]
		internal static extern void ImFontAtlasBuildRender8bppRectFromStringNative(ImFontAtlas* atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, byte inMarkerPixelValue);

		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			ImFontAtlasBuildRender8bppRectFromStringNative(atlas, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildRender8bppRectFromStringNative((ImFontAtlas*)patlas, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
			}
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (byte* pinStr = &inStr)
			{
				ImFontAtlasBuildRender8bppRectFromStringNative(atlas, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
			}
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, string inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontAtlasBuildRender8bppRectFromStringNative(atlas, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (byte* pinStr = &inStr)
				{
					ImFontAtlasBuildRender8bppRectFromStringNative((ImFontAtlas*)patlas, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
				}
			}
		}

		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, string inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inStr != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inStr);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontAtlasBuildRender8bppRectFromStringNative((ImFontAtlas*)patlas, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildRender32bppRectFromString")]
		internal static extern void ImFontAtlasBuildRender32bppRectFromStringNative(ImFontAtlas* atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, uint inMarkerPixelValue);

		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			ImFontAtlasBuildRender32bppRectFromStringNative(atlas, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImFontAtlasBuildRender32bppRectFromStringNative((ImFontAtlas*)patlas, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
			}
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (byte* pinStr = &inStr)
			{
				ImFontAtlasBuildRender32bppRectFromStringNative(atlas, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
			}
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, string inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontAtlasBuildRender32bppRectFromStringNative(atlas, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (byte* pinStr = &inStr)
				{
					ImFontAtlasBuildRender32bppRectFromStringNative((ImFontAtlas*)patlas, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
				}
			}
		}

		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int x, int y, int w, int h, string inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inStr != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inStr);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontAtlasBuildRender32bppRectFromStringNative((ImFontAtlas*)patlas, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildMultiplyCalcLookupTable")]
		internal static extern void ImFontAtlasBuildMultiplyCalcLookupTableNative(byte* outTable, float inMultiplyFactor);

		public static void ImFontAtlasBuildMultiplyCalcLookupTable(byte* outTable, float inMultiplyFactor)
		{
			ImFontAtlasBuildMultiplyCalcLookupTableNative(outTable, inMultiplyFactor);
		}

		public static void ImFontAtlasBuildMultiplyCalcLookupTable(ref byte outTable, float inMultiplyFactor)
		{
			fixed (byte* poutTable = &outTable)
			{
				ImFontAtlasBuildMultiplyCalcLookupTableNative((byte*)poutTable, inMultiplyFactor);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igImFontAtlasBuildMultiplyRectAlpha8")]
		internal static extern void ImFontAtlasBuildMultiplyRectAlpha8Native(byte* table, byte* pixels, int x, int y, int w, int h, int stride);

		public static void ImFontAtlasBuildMultiplyRectAlpha8(byte* table, byte* pixels, int x, int y, int w, int h, int stride)
		{
			ImFontAtlasBuildMultiplyRectAlpha8Native(table, pixels, x, y, w, h, stride);
		}

		public static void ImFontAtlasBuildMultiplyRectAlpha8(ref byte table, byte* pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ptable = &table)
			{
				ImFontAtlasBuildMultiplyRectAlpha8Native((byte*)ptable, pixels, x, y, w, h, stride);
			}
		}

		public static void ImFontAtlasBuildMultiplyRectAlpha8(byte* table, ref byte pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ppixels = &pixels)
			{
				ImFontAtlasBuildMultiplyRectAlpha8Native(table, (byte*)ppixels, x, y, w, h, stride);
			}
		}

		public static void ImFontAtlasBuildMultiplyRectAlpha8(ref byte table, ref byte pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ptable = &table)
			{
				fixed (byte* ppixels = &pixels)
				{
					ImFontAtlasBuildMultiplyRectAlpha8Native((byte*)ptable, (byte*)ppixels, x, y, w, h, stride);
				}
			}
		}

		/// <summary>
		/// //////////////////////hand written functions
		/// no LogTextV
		/// </summary>
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igLogText")]
		internal static extern void LogTextNative(byte* fmt);

		/// <summary>
/// //////////////////////hand written functions
/// no LogTextV
/// </summary>
public static void LogText(byte* fmt)
		{
			LogTextNative(fmt);
		}

		/// <summary>
/// //////////////////////hand written functions
/// no LogTextV
/// </summary>
public static void LogText(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LogTextNative((byte*)pfmt);
			}
		}

		/// <summary>
/// //////////////////////hand written functions
/// no LogTextV
/// </summary>
public static void LogText(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// no appendfV
		/// </summary>
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImGuiTextBuffer_appendf")]
		internal static extern void appendfNative(ImGuiTextBuffer* buffer, byte* fmt);

		/// <summary>
/// no appendfV
/// </summary>
public static void appendf(ImGuiTextBuffer* buffer, byte* fmt)
		{
			appendfNative(buffer, fmt);
		}

		/// <summary>
/// no appendfV
/// </summary>
public static void appendf(ref ImGuiTextBuffer buffer, byte* fmt)
		{
			fixed (ImGuiTextBuffer* pbuffer = &buffer)
			{
				appendfNative((ImGuiTextBuffer*)pbuffer, fmt);
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public static void appendf(ImGuiTextBuffer* buffer, ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				appendfNative(buffer, (byte*)pfmt);
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public static void appendf(ImGuiTextBuffer* buffer, string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendfNative(buffer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public static void appendf(ref ImGuiTextBuffer buffer, ref byte fmt)
		{
			fixed (ImGuiTextBuffer* pbuffer = &buffer)
			{
				fixed (byte* pfmt = &fmt)
				{
					appendfNative((ImGuiTextBuffer*)pbuffer, (byte*)pfmt);
				}
			}
		}

		/// <summary>
/// no appendfV
/// </summary>
public static void appendf(ref ImGuiTextBuffer buffer, string fmt)
		{
			fixed (ImGuiTextBuffer* pbuffer = &buffer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendfNative((ImGuiTextBuffer*)pbuffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// for getting FLT_MAX in bindings
		/// </summary>
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGET_FLT_MAX")]
		internal static extern float GETFLTMAXNative();

		/// <summary>
/// for getting FLT_MAX in bindings
/// </summary>
public static float GETFLTMAX()
		{
			float ret = GETFLTMAXNative();
			return ret;
		}

		/// <summary>
		/// for getting FLT_MIN in bindings
		/// </summary>
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "igGET_FLT_MIN")]
		internal static extern float GETFLTMINNative();

		/// <summary>
/// for getting FLT_MIN in bindings
/// </summary>
public static float GETFLTMIN()
		{
			float ret = GETFLTMINNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVector_ImWchar_create")]
		internal static extern ImVectorImWchar* ImVectorImWcharCreateNative();

		public static ImVectorImWcharPtr ImVectorImWcharCreate()
		{
			ImVectorImWcharPtr ret = ImVectorImWcharCreateNative();
			return ret;
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVector_ImWchar_destroy")]
		internal static extern void ImVectorImWcharDestroyNative(ImVectorImWchar* self);

		public static void ImVectorImWcharDestroy(ImVectorImWchar* self)
		{
			ImVectorImWcharDestroyNative(self);
		}

		public static void ImVectorImWcharDestroy(ref ImVectorImWchar self)
		{
			fixed (ImVectorImWchar* pself = &self)
			{
				ImVectorImWcharDestroyNative((ImVectorImWchar*)pself);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVector_ImWchar_Init")]
		internal static extern void ImVectorImWcharInitNative(ImVectorImWchar* p);

		public static void ImVectorImWcharInit(ImVectorImWchar* p)
		{
			ImVectorImWcharInitNative(p);
		}

		public static void ImVectorImWcharInit(ref ImVectorImWchar p)
		{
			fixed (ImVectorImWchar* pp = &p)
			{
				ImVectorImWcharInitNative((ImVectorImWchar*)pp);
			}
		}

		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "ImVector_ImWchar_UnInit")]
		internal static extern void ImVectorImWcharUnInitNative(ImVectorImWchar* p);

		public static void ImVectorImWcharUnInit(ImVectorImWchar* p)
		{
			ImVectorImWcharUnInitNative(p);
		}

		public static void ImVectorImWcharUnInit(ref ImVectorImWchar p)
		{
			fixed (ImVectorImWchar* pp = &p)
			{
				ImVectorImWcharUnInitNative((ImVectorImWchar*)pp);
			}
		}

	}
}
